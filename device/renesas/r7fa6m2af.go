// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from R7FA6M2AF.svd, see https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas

//go:build renesas && r7fa6m2af

/*
// ARM 32-bit Cortex-M4F Microcontroller based device, CPU clock up to 120MHz, etc.
*/

package renesas

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "R7FA6M2AF"
	CPU          = "CM4"
	FPUPresent   = true
	NVICPrioBits = 4
)

// Interrupt numbers.
const (
	// Interrupt Controller
	IRQ_IEL0 = 0

	// Interrupt Controller
	IRQ_IEL1 = 1

	// Interrupt Controller
	IRQ_IEL2 = 2

	// Interrupt Controller
	IRQ_IEL3 = 3

	// Interrupt Controller
	IRQ_IEL4 = 4

	// Interrupt Controller
	IRQ_IEL5 = 5

	// Interrupt Controller
	IRQ_IEL6 = 6

	// Interrupt Controller
	IRQ_IEL7 = 7

	// Interrupt Controller
	IRQ_IEL8 = 8

	// Interrupt Controller
	IRQ_IEL9 = 9

	// Interrupt Controller
	IRQ_IEL10 = 10

	// Interrupt Controller
	IRQ_IEL11 = 11

	// Interrupt Controller
	IRQ_IEL12 = 12

	// Interrupt Controller
	IRQ_IEL13 = 13

	// Interrupt Controller
	IRQ_IEL14 = 14

	// Interrupt Controller
	IRQ_IEL15 = 15

	// Interrupt Controller
	IRQ_IEL16 = 16

	// Interrupt Controller
	IRQ_IEL17 = 17

	// Interrupt Controller
	IRQ_IEL18 = 18

	// Interrupt Controller
	IRQ_IEL19 = 19

	// Interrupt Controller
	IRQ_IEL20 = 20

	// Interrupt Controller
	IRQ_IEL21 = 21

	// Interrupt Controller
	IRQ_IEL22 = 22

	// Interrupt Controller
	IRQ_IEL23 = 23

	// Interrupt Controller
	IRQ_IEL24 = 24

	// Interrupt Controller
	IRQ_IEL25 = 25

	// Interrupt Controller
	IRQ_IEL26 = 26

	// Interrupt Controller
	IRQ_IEL27 = 27

	// Interrupt Controller
	IRQ_IEL28 = 28

	// Interrupt Controller
	IRQ_IEL29 = 29

	// Interrupt Controller
	IRQ_IEL30 = 30

	// Interrupt Controller
	IRQ_IEL31 = 31

	// Interrupt Controller
	IRQ_IEL32 = 32

	// Interrupt Controller
	IRQ_IEL33 = 33

	// Interrupt Controller
	IRQ_IEL34 = 34

	// Interrupt Controller
	IRQ_IEL35 = 35

	// Interrupt Controller
	IRQ_IEL36 = 36

	// Interrupt Controller
	IRQ_IEL37 = 37

	// Interrupt Controller
	IRQ_IEL38 = 38

	// Interrupt Controller
	IRQ_IEL39 = 39

	// Interrupt Controller
	IRQ_IEL40 = 40

	// Interrupt Controller
	IRQ_IEL41 = 41

	// Interrupt Controller
	IRQ_IEL42 = 42

	// Interrupt Controller
	IRQ_IEL43 = 43

	// Interrupt Controller
	IRQ_IEL44 = 44

	// Interrupt Controller
	IRQ_IEL45 = 45

	// Interrupt Controller
	IRQ_IEL46 = 46

	// Interrupt Controller
	IRQ_IEL47 = 47

	// Interrupt Controller
	IRQ_IEL48 = 48

	// Interrupt Controller
	IRQ_IEL49 = 49

	// Interrupt Controller
	IRQ_IEL50 = 50

	// Interrupt Controller
	IRQ_IEL51 = 51

	// Interrupt Controller
	IRQ_IEL52 = 52

	// Interrupt Controller
	IRQ_IEL53 = 53

	// Interrupt Controller
	IRQ_IEL54 = 54

	// Interrupt Controller
	IRQ_IEL55 = 55

	// Interrupt Controller
	IRQ_IEL56 = 56

	// Interrupt Controller
	IRQ_IEL57 = 57

	// Interrupt Controller
	IRQ_IEL58 = 58

	// Interrupt Controller
	IRQ_IEL59 = 59

	// Interrupt Controller
	IRQ_IEL60 = 60

	// Interrupt Controller
	IRQ_IEL61 = 61

	// Interrupt Controller
	IRQ_IEL62 = 62

	// Interrupt Controller
	IRQ_IEL63 = 63

	// Interrupt Controller
	IRQ_IEL64 = 64

	// Interrupt Controller
	IRQ_IEL65 = 65

	// Interrupt Controller
	IRQ_IEL66 = 66

	// Interrupt Controller
	IRQ_IEL67 = 67

	// Interrupt Controller
	IRQ_IEL68 = 68

	// Interrupt Controller
	IRQ_IEL69 = 69

	// Interrupt Controller
	IRQ_IEL70 = 70

	// Interrupt Controller
	IRQ_IEL71 = 71

	// Interrupt Controller
	IRQ_IEL72 = 72

	// Interrupt Controller
	IRQ_IEL73 = 73

	// Interrupt Controller
	IRQ_IEL74 = 74

	// Interrupt Controller
	IRQ_IEL75 = 75

	// Interrupt Controller
	IRQ_IEL76 = 76

	// Interrupt Controller
	IRQ_IEL77 = 77

	// Interrupt Controller
	IRQ_IEL78 = 78

	// Interrupt Controller
	IRQ_IEL79 = 79

	// Interrupt Controller
	IRQ_IEL80 = 80

	// Interrupt Controller
	IRQ_IEL81 = 81

	// Interrupt Controller
	IRQ_IEL82 = 82

	// Interrupt Controller
	IRQ_IEL83 = 83

	// Interrupt Controller
	IRQ_IEL84 = 84

	// Interrupt Controller
	IRQ_IEL85 = 85

	// Interrupt Controller
	IRQ_IEL86 = 86

	// Interrupt Controller
	IRQ_IEL87 = 87

	// Interrupt Controller
	IRQ_IEL88 = 88

	// Interrupt Controller
	IRQ_IEL89 = 89

	// Interrupt Controller
	IRQ_IEL90 = 90

	// Interrupt Controller
	IRQ_IEL91 = 91

	// Interrupt Controller
	IRQ_IEL92 = 92

	// Interrupt Controller
	IRQ_IEL93 = 93

	// Interrupt Controller
	IRQ_IEL94 = 94

	// Interrupt Controller
	IRQ_IEL95 = 95

	// Highest interrupt number on this device.
	IRQ_max = 95
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export IEL0_IRQHandler
func interruptIEL0() {
	callHandlers(IRQ_IEL0)
}

//export IEL1_IRQHandler
func interruptIEL1() {
	callHandlers(IRQ_IEL1)
}

//export IEL2_IRQHandler
func interruptIEL2() {
	callHandlers(IRQ_IEL2)
}

//export IEL3_IRQHandler
func interruptIEL3() {
	callHandlers(IRQ_IEL3)
}

//export IEL4_IRQHandler
func interruptIEL4() {
	callHandlers(IRQ_IEL4)
}

//export IEL5_IRQHandler
func interruptIEL5() {
	callHandlers(IRQ_IEL5)
}

//export IEL6_IRQHandler
func interruptIEL6() {
	callHandlers(IRQ_IEL6)
}

//export IEL7_IRQHandler
func interruptIEL7() {
	callHandlers(IRQ_IEL7)
}

//export IEL8_IRQHandler
func interruptIEL8() {
	callHandlers(IRQ_IEL8)
}

//export IEL9_IRQHandler
func interruptIEL9() {
	callHandlers(IRQ_IEL9)
}

//export IEL10_IRQHandler
func interruptIEL10() {
	callHandlers(IRQ_IEL10)
}

//export IEL11_IRQHandler
func interruptIEL11() {
	callHandlers(IRQ_IEL11)
}

//export IEL12_IRQHandler
func interruptIEL12() {
	callHandlers(IRQ_IEL12)
}

//export IEL13_IRQHandler
func interruptIEL13() {
	callHandlers(IRQ_IEL13)
}

//export IEL14_IRQHandler
func interruptIEL14() {
	callHandlers(IRQ_IEL14)
}

//export IEL15_IRQHandler
func interruptIEL15() {
	callHandlers(IRQ_IEL15)
}

//export IEL16_IRQHandler
func interruptIEL16() {
	callHandlers(IRQ_IEL16)
}

//export IEL17_IRQHandler
func interruptIEL17() {
	callHandlers(IRQ_IEL17)
}

//export IEL18_IRQHandler
func interruptIEL18() {
	callHandlers(IRQ_IEL18)
}

//export IEL19_IRQHandler
func interruptIEL19() {
	callHandlers(IRQ_IEL19)
}

//export IEL20_IRQHandler
func interruptIEL20() {
	callHandlers(IRQ_IEL20)
}

//export IEL21_IRQHandler
func interruptIEL21() {
	callHandlers(IRQ_IEL21)
}

//export IEL22_IRQHandler
func interruptIEL22() {
	callHandlers(IRQ_IEL22)
}

//export IEL23_IRQHandler
func interruptIEL23() {
	callHandlers(IRQ_IEL23)
}

//export IEL24_IRQHandler
func interruptIEL24() {
	callHandlers(IRQ_IEL24)
}

//export IEL25_IRQHandler
func interruptIEL25() {
	callHandlers(IRQ_IEL25)
}

//export IEL26_IRQHandler
func interruptIEL26() {
	callHandlers(IRQ_IEL26)
}

//export IEL27_IRQHandler
func interruptIEL27() {
	callHandlers(IRQ_IEL27)
}

//export IEL28_IRQHandler
func interruptIEL28() {
	callHandlers(IRQ_IEL28)
}

//export IEL29_IRQHandler
func interruptIEL29() {
	callHandlers(IRQ_IEL29)
}

//export IEL30_IRQHandler
func interruptIEL30() {
	callHandlers(IRQ_IEL30)
}

//export IEL31_IRQHandler
func interruptIEL31() {
	callHandlers(IRQ_IEL31)
}

//export IEL32_IRQHandler
func interruptIEL32() {
	callHandlers(IRQ_IEL32)
}

//export IEL33_IRQHandler
func interruptIEL33() {
	callHandlers(IRQ_IEL33)
}

//export IEL34_IRQHandler
func interruptIEL34() {
	callHandlers(IRQ_IEL34)
}

//export IEL35_IRQHandler
func interruptIEL35() {
	callHandlers(IRQ_IEL35)
}

//export IEL36_IRQHandler
func interruptIEL36() {
	callHandlers(IRQ_IEL36)
}

//export IEL37_IRQHandler
func interruptIEL37() {
	callHandlers(IRQ_IEL37)
}

//export IEL38_IRQHandler
func interruptIEL38() {
	callHandlers(IRQ_IEL38)
}

//export IEL39_IRQHandler
func interruptIEL39() {
	callHandlers(IRQ_IEL39)
}

//export IEL40_IRQHandler
func interruptIEL40() {
	callHandlers(IRQ_IEL40)
}

//export IEL41_IRQHandler
func interruptIEL41() {
	callHandlers(IRQ_IEL41)
}

//export IEL42_IRQHandler
func interruptIEL42() {
	callHandlers(IRQ_IEL42)
}

//export IEL43_IRQHandler
func interruptIEL43() {
	callHandlers(IRQ_IEL43)
}

//export IEL44_IRQHandler
func interruptIEL44() {
	callHandlers(IRQ_IEL44)
}

//export IEL45_IRQHandler
func interruptIEL45() {
	callHandlers(IRQ_IEL45)
}

//export IEL46_IRQHandler
func interruptIEL46() {
	callHandlers(IRQ_IEL46)
}

//export IEL47_IRQHandler
func interruptIEL47() {
	callHandlers(IRQ_IEL47)
}

//export IEL48_IRQHandler
func interruptIEL48() {
	callHandlers(IRQ_IEL48)
}

//export IEL49_IRQHandler
func interruptIEL49() {
	callHandlers(IRQ_IEL49)
}

//export IEL50_IRQHandler
func interruptIEL50() {
	callHandlers(IRQ_IEL50)
}

//export IEL51_IRQHandler
func interruptIEL51() {
	callHandlers(IRQ_IEL51)
}

//export IEL52_IRQHandler
func interruptIEL52() {
	callHandlers(IRQ_IEL52)
}

//export IEL53_IRQHandler
func interruptIEL53() {
	callHandlers(IRQ_IEL53)
}

//export IEL54_IRQHandler
func interruptIEL54() {
	callHandlers(IRQ_IEL54)
}

//export IEL55_IRQHandler
func interruptIEL55() {
	callHandlers(IRQ_IEL55)
}

//export IEL56_IRQHandler
func interruptIEL56() {
	callHandlers(IRQ_IEL56)
}

//export IEL57_IRQHandler
func interruptIEL57() {
	callHandlers(IRQ_IEL57)
}

//export IEL58_IRQHandler
func interruptIEL58() {
	callHandlers(IRQ_IEL58)
}

//export IEL59_IRQHandler
func interruptIEL59() {
	callHandlers(IRQ_IEL59)
}

//export IEL60_IRQHandler
func interruptIEL60() {
	callHandlers(IRQ_IEL60)
}

//export IEL61_IRQHandler
func interruptIEL61() {
	callHandlers(IRQ_IEL61)
}

//export IEL62_IRQHandler
func interruptIEL62() {
	callHandlers(IRQ_IEL62)
}

//export IEL63_IRQHandler
func interruptIEL63() {
	callHandlers(IRQ_IEL63)
}

//export IEL64_IRQHandler
func interruptIEL64() {
	callHandlers(IRQ_IEL64)
}

//export IEL65_IRQHandler
func interruptIEL65() {
	callHandlers(IRQ_IEL65)
}

//export IEL66_IRQHandler
func interruptIEL66() {
	callHandlers(IRQ_IEL66)
}

//export IEL67_IRQHandler
func interruptIEL67() {
	callHandlers(IRQ_IEL67)
}

//export IEL68_IRQHandler
func interruptIEL68() {
	callHandlers(IRQ_IEL68)
}

//export IEL69_IRQHandler
func interruptIEL69() {
	callHandlers(IRQ_IEL69)
}

//export IEL70_IRQHandler
func interruptIEL70() {
	callHandlers(IRQ_IEL70)
}

//export IEL71_IRQHandler
func interruptIEL71() {
	callHandlers(IRQ_IEL71)
}

//export IEL72_IRQHandler
func interruptIEL72() {
	callHandlers(IRQ_IEL72)
}

//export IEL73_IRQHandler
func interruptIEL73() {
	callHandlers(IRQ_IEL73)
}

//export IEL74_IRQHandler
func interruptIEL74() {
	callHandlers(IRQ_IEL74)
}

//export IEL75_IRQHandler
func interruptIEL75() {
	callHandlers(IRQ_IEL75)
}

//export IEL76_IRQHandler
func interruptIEL76() {
	callHandlers(IRQ_IEL76)
}

//export IEL77_IRQHandler
func interruptIEL77() {
	callHandlers(IRQ_IEL77)
}

//export IEL78_IRQHandler
func interruptIEL78() {
	callHandlers(IRQ_IEL78)
}

//export IEL79_IRQHandler
func interruptIEL79() {
	callHandlers(IRQ_IEL79)
}

//export IEL80_IRQHandler
func interruptIEL80() {
	callHandlers(IRQ_IEL80)
}

//export IEL81_IRQHandler
func interruptIEL81() {
	callHandlers(IRQ_IEL81)
}

//export IEL82_IRQHandler
func interruptIEL82() {
	callHandlers(IRQ_IEL82)
}

//export IEL83_IRQHandler
func interruptIEL83() {
	callHandlers(IRQ_IEL83)
}

//export IEL84_IRQHandler
func interruptIEL84() {
	callHandlers(IRQ_IEL84)
}

//export IEL85_IRQHandler
func interruptIEL85() {
	callHandlers(IRQ_IEL85)
}

//export IEL86_IRQHandler
func interruptIEL86() {
	callHandlers(IRQ_IEL86)
}

//export IEL87_IRQHandler
func interruptIEL87() {
	callHandlers(IRQ_IEL87)
}

//export IEL88_IRQHandler
func interruptIEL88() {
	callHandlers(IRQ_IEL88)
}

//export IEL89_IRQHandler
func interruptIEL89() {
	callHandlers(IRQ_IEL89)
}

//export IEL90_IRQHandler
func interruptIEL90() {
	callHandlers(IRQ_IEL90)
}

//export IEL91_IRQHandler
func interruptIEL91() {
	callHandlers(IRQ_IEL91)
}

//export IEL92_IRQHandler
func interruptIEL92() {
	callHandlers(IRQ_IEL92)
}

//export IEL93_IRQHandler
func interruptIEL93() {
	callHandlers(IRQ_IEL93)
}

//export IEL94_IRQHandler
func interruptIEL94() {
	callHandlers(IRQ_IEL94)
}

//export IEL95_IRQHandler
func interruptIEL95() {
	callHandlers(IRQ_IEL95)
}

// Peripherals.
var (
	// Port 0 Control Registers
	PORT0 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Port 1 Control Registers
	PORT1 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040020)))

	// Port 2 Control Registers
	PORT2 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040040)))

	// Port 3 Control Registers
	PORT3 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040060)))

	// Port 4 Control Registers
	PORT4 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040080)))

	// Port 5 Control Registers
	PORT5 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400a0)))

	// Port 6 Control Registers
	PORT6 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400c0)))

	// Port 7 Control Registers
	PORT7 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400e0)))

	// Port 8 Control Registers
	PORT8 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040100)))

	// Port 9 Control Registers
	PORT9 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040120)))

	// Port A Control Registers
	PORTA = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040140)))

	// Port B Control Registers
	PORTB = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040160)))

	// Pmn Pin Function Control Register
	PFS = (*PFS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// Miscellaneous Port Control Register
	PMISC = (*PMISC_Type)(unsafe.Pointer(uintptr(0x40040d00)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072100)))

	// Output Phase Switching Controller
	GPT_OPS = (*GPT_OPS_Type)(unsafe.Pointer(uintptr(0x40078ff0)))

	// General PWM Timer 0 (32-bit Enhanced High Resolution)
	GPT32EH0 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078000)))

	// General PWM Timer 1 (32-bit Enhanced High Resolution)
	GPT32EH1 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078100)))

	// General PWM Timer 2 (32-bit Enhanced High Resolution)
	GPT32EH2 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078200)))

	// General PWM Timer 3 (32-bit Enhanced High Resolution)
	GPT32EH3 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078300)))

	// General PWM Timer 4 (32-bit Enhanced)
	GPT32E4 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078400)))

	// General PWM Timer 5 (32-bit Enhanced)
	GPT32E5 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078500)))

	// General PWM Timer 6 (32-bit Enhanced)
	GPT32E6 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078600)))

	// General PWM Timer 7 (32-bit Enhanced)
	GPT32E7 = (*GPT32EH0_Type)(unsafe.Pointer(uintptr(0x40078700)))

	// USB 2.0 High-Speed Module
	USBHS = (*USBHS_Type)(unsafe.Pointer(uintptr(0x40060000)))

	// Serial Communication Interface 0
	SCI0 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070000)))

	// Serial Communication Interface 1
	SCI1 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070020)))

	// Serial Communication Interface 2
	SCI2 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070040)))

	// Serial Communication Interface 3
	SCI3 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070060)))

	// Serial Communication Interface 4
	SCI4 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070080)))

	// Serial Communication Interface 5
	SCI5 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x400700a0)))

	// Serial Communication Interface 6
	SCI6 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x400700c0)))

	// Serial Communication Interface 7
	SCI7 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x400700e0)))

	// Serial Communication Interface 8
	SCI8 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070100)))

	// Serial Communication Interface 9
	SCI9 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070120)))

	// Inter-Integrated Circuit 0
	IIC0 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x40053000)))

	// Inter-Integrated Circuit 1
	IIC1 = (*IIC1_Type)(unsafe.Pointer(uintptr(0x40053100)))

	// Inter-Integrated Circuit 2
	IIC2 = (*IIC1_Type)(unsafe.Pointer(uintptr(0x40053200)))

	// System Control
	SYSTEM = (*SYSTEM_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// DMA Controller for the Ethernet Controller Channel 0
	EDMAC0 = (*EDMAC0_Type)(unsafe.Pointer(uintptr(0x40064000)))

	// Ethernet Controller Channel 0
	ETHERC0 = (*ETHERC0_Type)(unsafe.Pointer(uintptr(0x40064100)))

	// SD Host Interface 0
	SDHI0 = (*SDHI0_Type)(unsafe.Pointer(uintptr(0x40062000)))

	// SD Host Interface 1
	SDHI1 = (*SDHI0_Type)(unsafe.Pointer(uintptr(0x40062400)))

	// CRC Calculator
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// Capacitive Touch Sensing Unit
	CTSU = (*CTSU_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// Bus Master MPU
	MMPU = (*MMPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Bus Slave MPU
	SMPU = (*SMPU_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// CPU Stack Pointer Monitor
	SPMON = (*SPMON_Type)(unsafe.Pointer(uintptr(0x40000d00)))

	// 12bit A/D Converter 0
	ADC120 = (*ADC120_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// 12bit A/D Converter 1
	ADC121 = (*ADC121_Type)(unsafe.Pointer(uintptr(0x4005c200)))

	// Module Stop Control B,C,D
	MSTP = (*MSTP_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// General PWM Timer 8 (32-bit Enhanced)
	GPT328 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078800)))

	// General PWM Timer 9 (32-bit Enhanced)
	GPT329 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078900)))

	// General PWM Timer 10 (32-bit Enhanced)
	GPT3210 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078a00)))

	// General PWM Timer 11 (32-bit Enhanced)
	GPT3211 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078b00)))

	// General PWM Timer 12 (32-bit Enhanced)
	GPT3212 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078c00)))

	// General PWM Timer 13 (32-bit Enhanced)
	GPT3213 = (*GPT328_Type)(unsafe.Pointer(uintptr(0x40078d00)))

	// Realtime Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Serial Sound Interface Enhanced (SSIE)
	SSIE0 = (*SSIE0_Type)(unsafe.Pointer(uintptr(0x4004e000)))

	// Serial Sound Interface Enhanced (SSIE)
	SSIE1 = (*SSIE0_Type)(unsafe.Pointer(uintptr(0x4004e100)))

	// USB 2.0 FS Module
	USBFS = (*USBFS_Type)(unsafe.Pointer(uintptr(0x40090000)))

	// Sampling Rate Converter RAM
	SRCRAM = (*SRCRAM_Type)(unsafe.Pointer(uintptr(0x40048000)))

	// Sampling Rate Converter
	SRC = (*SRC_Type)(unsafe.Pointer(uintptr(0x4004dff0)))

	// Interrupt Controller
	ICU = (*ICU_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// SRAM Control
	SRAM = (*SRAM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// PWM Delay Generation Circuit
	GPT_ODC = (*GPT_ODC_Type)(unsafe.Pointer(uintptr(0x4007b000)))

	// Asynchronous General purpose Timer 0
	AGT0 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// Asynchronous General purpose Timer 1
	AGT1 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084100)))

	// Flash Cache
	FCACHE = (*FCACHE_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// BUS Control
	BUS = (*BUS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// 12-bit D/A converter
	DAC12 = (*DAC12_Type)(unsafe.Pointer(uintptr(0x4005e000)))

	// ADC-DAC Interface
	AMI = (*AMI_Type)(unsafe.Pointer(uintptr(0x4005f000)))

	// Port Output Enable Module for GPT
	POEG = (*POEG_Type)(unsafe.Pointer(uintptr(0x40042000)))

	// Infrared Data Association
	IRDA = (*IRDA_Type)(unsafe.Pointer(uintptr(0x40070f00)))

	// CAN0 Module
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// CAN1 Module
	CAN1 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40051000)))

	// Parallel Data Capture Unit
	PDC = (*PDC_Type)(unsafe.Pointer(uintptr(0x40094000)))

	// Quad-SPI
	QSPI = (*QSPI_Type)(unsafe.Pointer(uintptr(0x64000000)))

	// Memory Mirror Function
	MMF = (*MMF_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Direct memory access controller 0
	DMAC0 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005000)))

	// Direct memory access controller 1
	DMAC1 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005040)))

	// Direct memory access controller 2
	DMAC2 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005080)))

	// Direct memory access controller 3
	DMAC3 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x400050c0)))

	// Direct memory access controller 4
	DMAC4 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005100)))

	// Direct memory access controller 5
	DMAC5 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005140)))

	// Direct memory access controller 6
	DMAC6 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x40005180)))

	// Direct memory access controller 7
	DMAC7 = (*DMAC0_Type)(unsafe.Pointer(uintptr(0x400051c0)))

	// DMAC Module Activation
	DMA = (*DMA_Type)(unsafe.Pointer(uintptr(0x40005200)))

	// Data Transfer Controller
	DTC = (*DTC_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Debug Function
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// Temperature Sensor
	TSN = (*TSN_Type)(unsafe.Pointer(uintptr(0x4005d000)))

	// High-Speed Analog Comparator 0
	ACMPHS0 = (*ACMPHS0_Type)(unsafe.Pointer(uintptr(0x40085000)))

	// High-Speed Analog Comparator 1
	ACMPHS1 = (*ACMPHS1_Type)(unsafe.Pointer(uintptr(0x40085100)))

	// High-Speed Analog Comparator 2
	ACMPHS2 = (*ACMPHS1_Type)(unsafe.Pointer(uintptr(0x40085200)))

	// High-Speed Analog Comparator 3
	ACMPHS3 = (*ACMPHS1_Type)(unsafe.Pointer(uintptr(0x40085300)))

	// High-Speed Analog Comparator 4
	ACMPHS4 = (*ACMPHS1_Type)(unsafe.Pointer(uintptr(0x40085400)))

	// High-Speed Analog Comparator 5
	ACMPHS5 = (*ACMPHS1_Type)(unsafe.Pointer(uintptr(0x40085500)))

	// Event Link Controller
	ELC = (*ELC_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40044200)))

	// Independent Watchdog Timer
	IWDT = (*IWDT_Type)(unsafe.Pointer(uintptr(0x40044400)))

	// Key Interrupt Function
	KINT = (*KINT_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// Data Operation Circuit
	DOC = (*DOC_Type)(unsafe.Pointer(uintptr(0x40054100)))

	// Clock Frequency Accuracy Measurement Circuit
	CAC = (*CAC_Type)(unsafe.Pointer(uintptr(0x40044600)))
)

// Port 0 Control Registers
type PORT0_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
}

// PORT0.PCNTR1: Port Control Register 1
func (o *PORT0_Type) SetPCNTR1_PODR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR1_PODR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR1_PDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR1_PDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff
}

// PORT0.PCNTR2: Port Control Register 2
func (o *PORT0_Type) SetPCNTR2_EIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR2_EIDR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR2_PIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR2_PIDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff
}

// PORT0.PCNTR3: Port Control Register 3
func (o *PORT0_Type) SetPCNTR3_PORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT0_Type) GetPCNTR3_PORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff0000) >> 16
}
func (o *PORT0_Type) SetPCNTR3_POSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff)|value)
}
func (o *PORT0_Type) GetPCNTR3_POSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff
}

// Port 1 Control Registers
type PORT1_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
	PCNTR4 volatile.Register32 // 0xC
}

// PORT1.PCNTR1: Port Control Register 1
func (o *PORT1_Type) SetPCNTR1_PODR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR1_PODR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR1_PDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR1.Reg, volatile.LoadUint32(&o.PCNTR1.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR1_PDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR1.Reg) & 0xffff
}

// PORT1.PCNTR2: Port Control Register 2
func (o *PORT1_Type) SetPCNTR2_EIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR2_EIDR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR2_PIDR(value uint32) {
	volatile.StoreUint32(&o.PCNTR2.Reg, volatile.LoadUint32(&o.PCNTR2.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR2_PIDR() uint32 {
	return volatile.LoadUint32(&o.PCNTR2.Reg) & 0xffff
}

// PORT1.PCNTR3: Port Control Register 3
func (o *PORT1_Type) SetPCNTR3_PORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR3_PORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR3_POSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR3.Reg, volatile.LoadUint32(&o.PCNTR3.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR3_POSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR3.Reg) & 0xffff
}

// PORT1.PCNTR4: Port Control Register 4
func (o *PORT1_Type) SetPCNTR4_EORR(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0xffff0000)|value<<16)
}
func (o *PORT1_Type) GetPCNTR4_EORR() uint32 {
	return (volatile.LoadUint32(&o.PCNTR4.Reg) & 0xffff0000) >> 16
}
func (o *PORT1_Type) SetPCNTR4_EOSR(value uint32) {
	volatile.StoreUint32(&o.PCNTR4.Reg, volatile.LoadUint32(&o.PCNTR4.Reg)&^(0xffff)|value)
}
func (o *PORT1_Type) GetPCNTR4_EOSR() uint32 {
	return volatile.LoadUint32(&o.PCNTR4.Reg) & 0xffff
}

// Pmn Pin Function Control Register
type PFS_Type struct {
	P000PFS volatile.Register32 // 0x0
	P001PFS volatile.Register32 // 0x4
	P002PFS volatile.Register32 // 0x8
	P003PFS volatile.Register32 // 0xC
	P004PFS volatile.Register32 // 0x10
	P005PFS volatile.Register32 // 0x14
	P006PFS volatile.Register32 // 0x18
	P007PFS volatile.Register32 // 0x1C
	P008PFS volatile.Register32 // 0x20
	P009PFS volatile.Register32 // 0x24
	_       [16]byte
	P014PFS volatile.Register32 // 0x38
	P015PFS volatile.Register32 // 0x3C
	P100PFS volatile.Register32 // 0x40
	P101PFS volatile.Register32 // 0x44
	P102PFS volatile.Register32 // 0x48
	P103PFS volatile.Register32 // 0x4C
	P104PFS volatile.Register32 // 0x50
	P105PFS volatile.Register32 // 0x54
	P106PFS volatile.Register32 // 0x58
	P107PFS volatile.Register32 // 0x5C
	P108PFS volatile.Register32 // 0x60
	P109PFS volatile.Register32 // 0x64
	P110PFS volatile.Register32 // 0x68
	P111PFS volatile.Register32 // 0x6C
	P112PFS volatile.Register32 // 0x70
	P113PFS volatile.Register32 // 0x74
	P114PFS volatile.Register32 // 0x78
	P115PFS volatile.Register32 // 0x7C
	P200PFS volatile.Register32 // 0x80
	P201PFS volatile.Register32 // 0x84
	P202PFS volatile.Register32 // 0x88
	P203PFS volatile.Register32 // 0x8C
	P204PFS volatile.Register32 // 0x90
	P205PFS volatile.Register32 // 0x94
	P206PFS volatile.Register32 // 0x98
	P207PFS volatile.Register32 // 0x9C
	P208PFS volatile.Register32 // 0xA0
	P209PFS volatile.Register32 // 0xA4
	P210PFS volatile.Register32 // 0xA8
	P211PFS volatile.Register32 // 0xAC
	P212PFS volatile.Register32 // 0xB0
	P213PFS volatile.Register32 // 0xB4
	P214PFS volatile.Register32 // 0xB8
	_       [4]byte
	P300PFS volatile.Register32 // 0xC0
	P301PFS volatile.Register32 // 0xC4
	P302PFS volatile.Register32 // 0xC8
	P303PFS volatile.Register32 // 0xCC
	P304PFS volatile.Register32 // 0xD0
	P305PFS volatile.Register32 // 0xD4
	P306PFS volatile.Register32 // 0xD8
	P307PFS volatile.Register32 // 0xDC
	P308PFS volatile.Register32 // 0xE0
	P309PFS volatile.Register32 // 0xE4
	P310PFS volatile.Register32 // 0xE8
	P311PFS volatile.Register32 // 0xEC
	P312PFS volatile.Register32 // 0xF0
	P313PFS volatile.Register32 // 0xF4
	P314PFS volatile.Register32 // 0xF8
	P315PFS volatile.Register32 // 0xFC
	P400PFS volatile.Register32 // 0x100
	P401PFS volatile.Register32 // 0x104
	P402PFS volatile.Register32 // 0x108
	P403PFS volatile.Register32 // 0x10C
	P404PFS volatile.Register32 // 0x110
	P405PFS volatile.Register32 // 0x114
	P406PFS volatile.Register32 // 0x118
	P407PFS volatile.Register32 // 0x11C
	P408PFS volatile.Register32 // 0x120
	P409PFS volatile.Register32 // 0x124
	P410PFS volatile.Register32 // 0x128
	P411PFS volatile.Register32 // 0x12C
	P412PFS volatile.Register32 // 0x130
	P413PFS volatile.Register32 // 0x134
	P414PFS volatile.Register32 // 0x138
	P415PFS volatile.Register32 // 0x13C
	P500PFS volatile.Register32 // 0x140
	P501PFS volatile.Register32 // 0x144
	P502PFS volatile.Register32 // 0x148
	P503PFS volatile.Register32 // 0x14C
	P504PFS volatile.Register32 // 0x150
	P505PFS volatile.Register32 // 0x154
	P506PFS volatile.Register32 // 0x158
	P507PFS volatile.Register32 // 0x15C
	P508PFS volatile.Register32 // 0x160
	_       [8]byte
	P511PFS volatile.Register32 // 0x16C
	P512PFS volatile.Register32 // 0x170
	P513PFS volatile.Register32 // 0x174
	P514PFS volatile.Register32 // 0x178
	P515PFS volatile.Register32 // 0x17C
	P600PFS volatile.Register32 // 0x180
	P601PFS volatile.Register32 // 0x184
	P602PFS volatile.Register32 // 0x188
	P603PFS volatile.Register32 // 0x18C
	P604PFS volatile.Register32 // 0x190
	P605PFS volatile.Register32 // 0x194
	P606PFS volatile.Register32 // 0x198
	P607PFS volatile.Register32 // 0x19C
	P608PFS volatile.Register32 // 0x1A0
	P609PFS volatile.Register32 // 0x1A4
	P610PFS volatile.Register32 // 0x1A8
	P611PFS volatile.Register32 // 0x1AC
	P612PFS volatile.Register32 // 0x1B0
	P613PFS volatile.Register32 // 0x1B4
	P614PFS volatile.Register32 // 0x1B8
	P615PFS volatile.Register32 // 0x1BC
	P700PFS volatile.Register32 // 0x1C0
	P701PFS volatile.Register32 // 0x1C4
	P702PFS volatile.Register32 // 0x1C8
	P703PFS volatile.Register32 // 0x1CC
	P704PFS volatile.Register32 // 0x1D0
	P705PFS volatile.Register32 // 0x1D4
	P706PFS volatile.Register32 // 0x1D8
	P707PFS volatile.Register32 // 0x1DC
	P708PFS volatile.Register32 // 0x1E0
	_       [28]byte
	P800PFS volatile.Register32 // 0x200
	P801PFS volatile.Register32 // 0x204
	P802PFS volatile.Register32 // 0x208
	P803PFS volatile.Register32 // 0x20C
	P804PFS volatile.Register32 // 0x210
	P805PFS volatile.Register32 // 0x214
	P806PFS volatile.Register32 // 0x218
	_       [36]byte
	P900PFS volatile.Register32 // 0x240
	P901PFS volatile.Register32 // 0x244
	_       [12]byte
	P905PFS volatile.Register32 // 0x254
	P906PFS volatile.Register32 // 0x258
	P907PFS volatile.Register32 // 0x25C
	P908PFS volatile.Register32 // 0x260
	_       [28]byte
	PA00PFS volatile.Register32 // 0x280
	PA01PFS volatile.Register32 // 0x284
	_       [24]byte
	PA08PFS volatile.Register32 // 0x2A0
	PA09PFS volatile.Register32 // 0x2A4
	PA10PFS volatile.Register32 // 0x2A8
	_       [20]byte
	PB00PFS volatile.Register32 // 0x2C0
	PB01PFS volatile.Register32 // 0x2C4
}

// PFS.P000PFS: P000 Pin Function Control Register
func (o *PFS_Type) SetP000PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP000PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP000PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP000PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP000PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP000PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP000PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP000PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP000PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0xc00)|value<<10)
}
func (o *PFS_Type) GetP000PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0xc00) >> 10
}
func (o *PFS_Type) SetP000PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP000PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP000PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP000PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP000PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP000PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP000PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP000PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP000PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP000PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P000PFS.Reg) & 0x1
}

// PFS.P100PFS: P100 Pin Function Control Register
func (o *PFS_Type) SetP100PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP100PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP100PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP100PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP100PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP100PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP100PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP100PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP100PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP100PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP100PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP100PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP100PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0xc00)|value<<10)
}
func (o *PFS_Type) GetP100PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0xc00) >> 10
}
func (o *PFS_Type) SetP100PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP100PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP100PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP100PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP100PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP100PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP100PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP100PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP100PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP100PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P100PFS.Reg) & 0x1
}

// PFS.P108PFS: P108 Pin Function Control Register
func (o *PFS_Type) SetP108PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP108PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP108PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP108PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP108PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP108PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP108PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP108PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP108PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP108PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP108PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP108PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP108PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0xc00)|value<<10)
}
func (o *PFS_Type) GetP108PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0xc00) >> 10
}
func (o *PFS_Type) SetP108PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP108PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP108PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP108PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP108PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP108PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP108PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP108PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P108PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP108PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P108PFS.Reg, volatile.LoadUint32(&o.P108PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP108PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P108PFS.Reg) & 0x1
}

// PFS.P110PFS: P110 Pin Function Control Register
func (o *PFS_Type) SetP110PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP110PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP110PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP110PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP110PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP110PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP110PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP110PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP110PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP110PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP110PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP110PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP110PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0xc00)|value<<10)
}
func (o *PFS_Type) GetP110PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0xc00) >> 10
}
func (o *PFS_Type) SetP110PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP110PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP110PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP110PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP110PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP110PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP110PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP110PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P110PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP110PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P110PFS.Reg, volatile.LoadUint32(&o.P110PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP110PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P110PFS.Reg) & 0x1
}

// PFS.P201PFS: P201 Pin Function Control Register
func (o *PFS_Type) SetP201PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP201PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP201PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP201PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP201PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP201PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP201PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP201PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP201PFS_EOF(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2000)|value<<13)
}
func (o *PFS_Type) GetP201PFS_EOF() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2000) >> 13
}
func (o *PFS_Type) SetP201PFS_EOR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1000)|value<<12)
}
func (o *PFS_Type) GetP201PFS_EOR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x1000) >> 12
}
func (o *PFS_Type) SetP201PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0xc00)|value<<10)
}
func (o *PFS_Type) GetP201PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0xc00) >> 10
}
func (o *PFS_Type) SetP201PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP201PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP201PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP201PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP201PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP201PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP201PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP201PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P201PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP201PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P201PFS.Reg, volatile.LoadUint32(&o.P201PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP201PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P201PFS.Reg) & 0x1
}

// Miscellaneous Port Control Register
type PMISC_Type struct {
	PFENET volatile.Register8 // 0x0
	_      [2]byte
	PWPR   volatile.Register8 // 0x3
}

// PMISC.PFENET: Ethernet Control Register
func (o *PMISC_Type) SetPFENET_PHYMODE0(value uint8) {
	volatile.StoreUint8(&o.PFENET.Reg, volatile.LoadUint8(&o.PFENET.Reg)&^(0x10)|value<<4)
}
func (o *PMISC_Type) GetPFENET_PHYMODE0() uint8 {
	return (volatile.LoadUint8(&o.PFENET.Reg) & 0x10) >> 4
}

// PMISC.PWPR: Write-Protect Register
func (o *PMISC_Type) SetPWPR_BOWI(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x80)|value<<7)
}
func (o *PMISC_Type) GetPWPR_BOWI() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x80) >> 7
}
func (o *PMISC_Type) SetPWPR_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x40)|value<<6)
}
func (o *PMISC_Type) GetPWPR_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x40) >> 6
}

// Serial Peripheral Interface 0
type SPI0_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	SPSCR  volatile.Register8  // 0x8
	SPSSR  volatile.Register8  // 0x9
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
	SPCMD1 volatile.Register16 // 0x12
	SPCMD2 volatile.Register16 // 0x14
	SPCMD3 volatile.Register16 // 0x16
	SPCMD4 volatile.Register16 // 0x18
	SPCMD5 volatile.Register16 // 0x1A
	SPCMD6 volatile.Register16 // 0x1C
	SPCMD7 volatile.Register16 // 0x1E
	SPDCR2 volatile.Register8  // 0x20
}

// SPI0.SPCR: SPI Control Register
func (o *SPI0_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}

// SPI0.SSLP: SPI Slave Select Polarity Register
func (o *SPI0_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}

// SPI0.SPPCR: RSPI Pin Control Register
func (o *SPI0_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}

// SPI0.SPSR: SPI Status Register
func (o *SPI0_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}

// SPI0.SPDR: SPI Data Register
func (o *SPI0_Type) SetSPDR(value uint32) {
	volatile.StoreUint32(&o.SPDR.Reg, value)
}
func (o *SPI0_Type) GetSPDR() uint32 {
	return volatile.LoadUint32(&o.SPDR.Reg)
}

// SPI0.SPSCR: SPI Sequence Control Register
func (o *SPI0_Type) SetSPSCR_SPSLN(value uint8) {
	volatile.StoreUint8(&o.SPSCR.Reg, volatile.LoadUint8(&o.SPSCR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSCR_SPSLN() uint8 {
	return volatile.LoadUint8(&o.SPSCR.Reg) & 0x7
}

// SPI0.SPSSR: SPI Sequence Status Register
func (o *SPI0_Type) SetSPSSR_SPECM(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPSSR_SPECM() uint8 {
	return (volatile.LoadUint8(&o.SPSSR.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPSSR_SPCP(value uint8) {
	volatile.StoreUint8(&o.SPSSR.Reg, volatile.LoadUint8(&o.SPSSR.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPSSR_SPCP() uint8 {
	return volatile.LoadUint8(&o.SPSSR.Reg) & 0x7
}

// SPI0.SPBR: SPI Bit Rate Register
func (o *SPI0_Type) SetSPBR(value uint8) {
	volatile.StoreUint8(&o.SPBR.Reg, value)
}
func (o *SPI0_Type) GetSPBR() uint8 {
	return volatile.LoadUint8(&o.SPBR.Reg)
}

// SPI0.SPDCR: SPI Data Control Register
func (o *SPI0_Type) SetSPDCR_SPBYT(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPDCR_SPBYT() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPDCR_SPFC(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x3)|value)
}
func (o *SPI0_Type) GetSPDCR_SPFC() uint8 {
	return volatile.LoadUint8(&o.SPDCR.Reg) & 0x3
}

// SPI0.SPCKD: SPI Clock Delay Register
func (o *SPI0_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI0.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI0_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI0.SPND: SPI Next-Access Delay Register
func (o *SPI0_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI0.SPCR2: SPI Control Register 2
func (o *SPI0_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}

// SPI0.SPCMD0: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD0_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD0_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}

// SPI0.SPCMD1: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD1_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD1_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD1_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD1_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD1_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD1_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD1_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD1_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD1_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD1_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD1_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD1_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD1_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD1_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD1_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD1_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD1_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD1_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD1.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD1_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD1.Reg, volatile.LoadUint16(&o.SPCMD1.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD1_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD1.Reg) & 0x1
}

// SPI0.SPCMD2: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD2_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD2_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD2_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD2_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD2_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD2_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD2_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD2_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD2_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD2_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD2_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD2_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD2_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD2_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD2_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD2_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD2_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD2_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD2_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD2.Reg, volatile.LoadUint16(&o.SPCMD2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD2_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD2.Reg) & 0x1
}

// SPI0.SPCMD3: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD3_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD3_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD3_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD3_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD3_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD3_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD3_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD3_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD3_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD3_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD3_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD3_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD3_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD3_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD3_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD3_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD3_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD3_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD3.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD3_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD3.Reg, volatile.LoadUint16(&o.SPCMD3.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD3_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD3.Reg) & 0x1
}

// SPI0.SPCMD4: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD4_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD4_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD4_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD4_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD4_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD4_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD4_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD4_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD4_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD4_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD4_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD4_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD4_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD4_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD4_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD4_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD4_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD4_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD4.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD4_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD4.Reg, volatile.LoadUint16(&o.SPCMD4.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD4_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD4.Reg) & 0x1
}

// SPI0.SPCMD5: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD5_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD5_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD5_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD5_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD5_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD5_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD5_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD5_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD5_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD5_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD5_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD5_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD5_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD5_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD5_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD5_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD5_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD5_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD5.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD5_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD5.Reg, volatile.LoadUint16(&o.SPCMD5.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD5_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD5.Reg) & 0x1
}

// SPI0.SPCMD6: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD6_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD6_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD6_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD6_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD6_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD6_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD6_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD6_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD6_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD6_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD6_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD6_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD6_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD6_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD6_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD6_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD6_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD6_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD6.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD6_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD6.Reg, volatile.LoadUint16(&o.SPCMD6.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD6_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD6.Reg) & 0x1
}

// SPI0.SPCMD7: SPI Command Register %s
func (o *SPI0_Type) SetSPCMD7_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD7_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD7_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD7_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD7_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD7_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD7_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD7_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD7_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD7_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD7_SSLKP(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD7_SSLKP() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD7_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD7_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD7_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD7_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD7_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD7_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD7.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD7_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD7.Reg, volatile.LoadUint16(&o.SPCMD7.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD7_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD7.Reg) & 0x1
}

// SPI0.SPDCR2: SPI Data Control Register 2
func (o *SPI0_Type) SetSPDCR2_BYSW(value uint8) {
	volatile.StoreUint8(&o.SPDCR2.Reg, volatile.LoadUint8(&o.SPDCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPDCR2_BYSW() uint8 {
	return volatile.LoadUint8(&o.SPDCR2.Reg) & 0x1
}

// Output Phase Switching Controller
type GPT_OPS_Type struct {
	OPSCR volatile.Register32 // 0x0
}

// GPT_OPS.OPSCR: Output Phase Switching Control Register
func (o *GPT_OPS_Type) SetOPSCR_NFCS(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT_OPS_Type) GetOPSCR_NFCS() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc0000000) >> 30
}
func (o *GPT_OPS_Type) SetOPSCR_NFEN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT_OPS_Type) GetOPSCR_NFEN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000000) >> 29
}
func (o *GPT_OPS_Type) SetOPSCR_GODF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT_OPS_Type) GetOPSCR_GODF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4000000) >> 26
}
func (o *GPT_OPS_Type) SetOPSCR_GRP(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT_OPS_Type) GetOPSCR_GRP() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x3000000) >> 24
}
func (o *GPT_OPS_Type) SetOPSCR_ALIGN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT_OPS_Type) GetOPSCR_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x200000) >> 21
}
func (o *GPT_OPS_Type) SetOPSCR_RV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT_OPS_Type) GetOPSCR_RV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100000) >> 20
}
func (o *GPT_OPS_Type) SetOPSCR_INV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT_OPS_Type) GetOPSCR_INV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80000) >> 19
}
func (o *GPT_OPS_Type) SetOPSCR_N(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT_OPS_Type) GetOPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40000) >> 18
}
func (o *GPT_OPS_Type) SetOPSCR_P(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT_OPS_Type) GetOPSCR_P() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000) >> 17
}
func (o *GPT_OPS_Type) SetOPSCR_FB(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT_OPS_Type) GetOPSCR_FB() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10000) >> 16
}
func (o *GPT_OPS_Type) SetOPSCR_EN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT_OPS_Type) GetOPSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100) >> 8
}
func (o *GPT_OPS_Type) SetOPSCR_W(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40)|value<<6)
}
func (o *GPT_OPS_Type) GetOPSCR_W() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40) >> 6
}
func (o *GPT_OPS_Type) SetOPSCR_V(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_OPS_Type) GetOPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20) >> 5
}
func (o *GPT_OPS_Type) SetOPSCR_U(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_OPS_Type) GetOPSCR_U() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10) >> 4
}
func (o *GPT_OPS_Type) SetOPSCR_WF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_OPS_Type) GetOPSCR_WF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4) >> 2
}
func (o *GPT_OPS_Type) SetOPSCR_VF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_OPS_Type) GetOPSCR_VF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x2) >> 1
}
func (o *GPT_OPS_Type) SetOPSCR_UF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x1)|value)
}
func (o *GPT_OPS_Type) GetOPSCR_UF() uint32 {
	return volatile.LoadUint32(&o.OPSCR.Reg) & 0x1
}

// General PWM Timer 0 (32-bit Enhanced High Resolution)
type GPT32EH0_Type struct {
	GTWP      volatile.Register32 // 0x0
	GTSTR     volatile.Register32 // 0x4
	GTSTP     volatile.Register32 // 0x8
	GTCLR     volatile.Register32 // 0xC
	GTSSR     volatile.Register32 // 0x10
	GTPSR     volatile.Register32 // 0x14
	GTCSR     volatile.Register32 // 0x18
	GTUPSR    volatile.Register32 // 0x1C
	GTDNSR    volatile.Register32 // 0x20
	GTICASR   volatile.Register32 // 0x24
	GTICBSR   volatile.Register32 // 0x28
	GTCR      volatile.Register32 // 0x2C
	GTUDDTYC  volatile.Register32 // 0x30
	GTIOR     volatile.Register32 // 0x34
	GTINTAD   volatile.Register32 // 0x38
	GTST      volatile.Register32 // 0x3C
	GTBER     volatile.Register32 // 0x40
	GTITC     volatile.Register32 // 0x44
	GTCNT     volatile.Register32 // 0x48
	GTCCRA    volatile.Register32 // 0x4C
	GTCCRB    volatile.Register32 // 0x50
	GTCCRC    volatile.Register32 // 0x54
	GTCCRE    volatile.Register32 // 0x58
	GTCCRD    volatile.Register32 // 0x5C
	GTCCRF    volatile.Register32 // 0x60
	GTPR      volatile.Register32 // 0x64
	GTPBR     volatile.Register32 // 0x68
	GTPDBR    volatile.Register32 // 0x6C
	GTADTRA   volatile.Register32 // 0x70
	GTADTBRA  volatile.Register32 // 0x74
	GTADTDBRA volatile.Register32 // 0x78
	GTADTRB   volatile.Register32 // 0x7C
	GTADTBRB  volatile.Register32 // 0x80
	GTADTDBRB volatile.Register32 // 0x84
	GTDTCR    volatile.Register32 // 0x88
	GTDVU     volatile.Register32 // 0x8C
	GTDVD     volatile.Register32 // 0x90
	GTDBU     volatile.Register32 // 0x94
	GTDBD     volatile.Register32 // 0x98
	GTSOS     volatile.Register32 // 0x9C
	GTSOTR    volatile.Register32 // 0xA0
}

// GPT32EH0.GTWP: General PWM Timer Write-Protection Register
func (o *GPT32EH0_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT32EH0_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT32EH0_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT32EH0.GTSTR: General PWM Timer Software Start Register
func (o *GPT32EH0_Type) SetGTSTR_CSTRT13(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT13() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT12(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT12() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT11(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT11() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT10(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT10() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT32EH0.GTSTP: General PWM Timer Software Stop Register
func (o *GPT32EH0_Type) SetGTSTP_CSTOP13(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP13() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP12(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP12() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP11(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP11() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP10(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP10() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT32EH0.GTCLR: General PWM Timer Software Clear Register
func (o *GPT32EH0_Type) SetGTCLR_CCLR13(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR13() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR12(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR12() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR11(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR11() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR10(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR10() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT32EH0.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT32EH0_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT32EH0_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT32EH0.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT32EH0_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT32EH0_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT32EH0.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT32EH0_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT32EH0_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT32EH0.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT32EH0_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT32EH0.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT32EH0_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT32EH0.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT32EH0_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT32EH0.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT32EH0_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT32EH0_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT32EH0.GTCR: General PWM Timer Control Register
func (o *GPT32EH0_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT32EH0_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT32EH0_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT32EH0.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT32EH0_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT32EH0_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT32EH0_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT32EH0_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT32EH0_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT32EH0.GTIOR: General PWM Timer I/O Control Register
func (o *GPT32EH0_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT32EH0_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT32EH0_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT32EH0_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT32EH0_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT32EH0_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT32EH0_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT32EH0_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT32EH0_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT32EH0_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT32EH0_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT32EH0_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT32EH0_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT32EH0_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT32EH0_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT32EH0_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT32EH0_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT32EH0.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT32EH0_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT32EH0_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT32EH0_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT32EH0_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT32EH0_Type) SetGTINTAD_GRPDTE(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x10000000)|value<<28)
}
func (o *GPT32EH0_Type) GetGTINTAD_GRPDTE() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x10000000) >> 28
}
func (o *GPT32EH0_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT32EH0_Type) SetGTINTAD_ADTRBDEN(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x80000)|value<<19)
}
func (o *GPT32EH0_Type) GetGTINTAD_ADTRBDEN() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x80000) >> 19
}
func (o *GPT32EH0_Type) SetGTINTAD_ADTRBUEN(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTINTAD_ADTRBUEN() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000) >> 18
}
func (o *GPT32EH0_Type) SetGTINTAD_ADTRADEN(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000)|value<<17)
}
func (o *GPT32EH0_Type) GetGTINTAD_ADTRADEN() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000) >> 17
}
func (o *GPT32EH0_Type) SetGTINTAD_ADTRAUEN(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x10000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTINTAD_ADTRAUEN() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x10000) >> 16
}

// GPT32EH0.GTST: General PWM Timer Status Register
func (o *GPT32EH0_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT32EH0_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT32EH0_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT32EH0_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT32EH0_Type) SetGTST_DTEF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10000000)|value<<28)
}
func (o *GPT32EH0_Type) GetGTST_DTEF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10000000) >> 28
}
func (o *GPT32EH0_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT32EH0_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT32EH0_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT32EH0_Type) SetGTST_ITCNT(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x700)|value<<8)
}
func (o *GPT32EH0_Type) GetGTST_ITCNT() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x700) >> 8
}
func (o *GPT32EH0_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT32EH0_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT32EH0_Type) SetGTST_TCFPO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT32EH0_Type) GetGTST_TCFPO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT32EH0_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT32EH0.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT32EH0_Type) SetGTBER_ADTDB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT32EH0_Type) GetGTBER_ADTDB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x40000000) >> 30
}
func (o *GPT32EH0_Type) SetGTBER_ADTTB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000000)|value<<28)
}
func (o *GPT32EH0_Type) GetGTBER_ADTTB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000000) >> 28
}
func (o *GPT32EH0_Type) SetGTBER_ADTDA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT32EH0_Type) GetGTBER_ADTDA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x4000000) >> 26
}
func (o *GPT32EH0_Type) SetGTBER_ADTTA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT32EH0_Type) GetGTBER_ADTTA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x3000000) >> 24
}
func (o *GPT32EH0_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT32EH0_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT32EH0_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT32EH0_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT32EH0_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT32EH0_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT32EH0_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT32EH0_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT32EH0_Type) SetGTBER_BD(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xf)|value)
}
func (o *GPT32EH0_Type) GetGTBER_BD() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0xf
}

// GPT32EH0.GTITC: General PWM Timer Interrupt and A/D Converter Start Request Skipping Setting Register
func (o *GPT32EH0_Type) SetGTITC_ADTBL(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x4000)|value<<14)
}
func (o *GPT32EH0_Type) GetGTITC_ADTBL() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x4000) >> 14
}
func (o *GPT32EH0_Type) SetGTITC_ADTAL(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x1000)|value<<12)
}
func (o *GPT32EH0_Type) GetGTITC_ADTAL() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x1000) >> 12
}
func (o *GPT32EH0_Type) SetGTITC_IVTT(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x700)|value<<8)
}
func (o *GPT32EH0_Type) GetGTITC_IVTT() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x700) >> 8
}
func (o *GPT32EH0_Type) SetGTITC_IVTC(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0xc0)|value<<6)
}
func (o *GPT32EH0_Type) GetGTITC_IVTC() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0xc0) >> 6
}
func (o *GPT32EH0_Type) SetGTITC_ITLF(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTITC_ITLF() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTITC_ITLE(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTITC_ITLE() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTITC_ITLD(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x8)|value<<3)
}
func (o *GPT32EH0_Type) GetGTITC_ITLD() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x8) >> 3
}
func (o *GPT32EH0_Type) SetGTITC_ITLC(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x4)|value<<2)
}
func (o *GPT32EH0_Type) GetGTITC_ITLC() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x4) >> 2
}
func (o *GPT32EH0_Type) SetGTITC_ITLB(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x2)|value<<1)
}
func (o *GPT32EH0_Type) GetGTITC_ITLB() uint32 {
	return (volatile.LoadUint32(&o.GTITC.Reg) & 0x2) >> 1
}
func (o *GPT32EH0_Type) SetGTITC_ITLA(value uint32) {
	volatile.StoreUint32(&o.GTITC.Reg, volatile.LoadUint32(&o.GTITC.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTITC_ITLA() uint32 {
	return volatile.LoadUint32(&o.GTITC.Reg) & 0x1
}

// GPT32EH0.GTCNT: General PWM Timer Counter
func (o *GPT32EH0_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT32EH0.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT32EH0_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg)
}

// GPT32EH0.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT32EH0_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg)
}

// GPT32EH0.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT32EH0_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg)
}

// GPT32EH0.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT32EH0_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg)
}

// GPT32EH0.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT32EH0_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg)
}

// GPT32EH0.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT32EH0_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, value)
}
func (o *GPT32EH0_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg)
}

// GPT32EH0.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT32EH0_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, value)
}
func (o *GPT32EH0_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg)
}

// GPT32EH0.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT32EH0_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, value)
}
func (o *GPT32EH0_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg)
}

// GPT32EH0.GTPDBR: General PWM Timer Cycle Setting Double-Buffer Register
func (o *GPT32EH0_Type) SetGTPDBR(value uint32) {
	volatile.StoreUint32(&o.GTPDBR.Reg, value)
}
func (o *GPT32EH0_Type) GetGTPDBR() uint32 {
	return volatile.LoadUint32(&o.GTPDBR.Reg)
}

// GPT32EH0.GTADTRA: A/D Converter Start Request Timing Register A
func (o *GPT32EH0_Type) SetGTADTRA(value uint32) {
	volatile.StoreUint32(&o.GTADTRA.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTRA() uint32 {
	return volatile.LoadUint32(&o.GTADTRA.Reg)
}

// GPT32EH0.GTADTBRA: A/D Converter Start Request Timing Buffer Register A
func (o *GPT32EH0_Type) SetGTADTBRA(value uint32) {
	volatile.StoreUint32(&o.GTADTBRA.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTBRA() uint32 {
	return volatile.LoadUint32(&o.GTADTBRA.Reg)
}

// GPT32EH0.GTADTDBRA: A/D Converter Start Request Timing Double-Buffer Register A
func (o *GPT32EH0_Type) SetGTADTDBRA(value uint32) {
	volatile.StoreUint32(&o.GTADTDBRA.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTDBRA() uint32 {
	return volatile.LoadUint32(&o.GTADTDBRA.Reg)
}

// GPT32EH0.GTADTRB: A/D Converter Start Request Timing Register B
func (o *GPT32EH0_Type) SetGTADTRB(value uint32) {
	volatile.StoreUint32(&o.GTADTRB.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTRB() uint32 {
	return volatile.LoadUint32(&o.GTADTRB.Reg)
}

// GPT32EH0.GTADTBRB: A/D Converter Start Request Timing Buffer Register B
func (o *GPT32EH0_Type) SetGTADTBRB(value uint32) {
	volatile.StoreUint32(&o.GTADTBRB.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTBRB() uint32 {
	return volatile.LoadUint32(&o.GTADTBRB.Reg)
}

// GPT32EH0.GTADTDBRB: A/D Converter Start Request Timing Double-Buffer Register B
func (o *GPT32EH0_Type) SetGTADTDBRB(value uint32) {
	volatile.StoreUint32(&o.GTADTDBRB.Reg, value)
}
func (o *GPT32EH0_Type) GetGTADTDBRB() uint32 {
	return volatile.LoadUint32(&o.GTADTDBRB.Reg)
}

// GPT32EH0.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT32EH0_Type) SetGTDTCR_TDFER(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT32EH0_Type) GetGTDTCR_TDFER() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x100) >> 8
}
func (o *GPT32EH0_Type) SetGTDTCR_TDBDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT32EH0_Type) GetGTDTCR_TDBDE() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x20) >> 5
}
func (o *GPT32EH0_Type) SetGTDTCR_TDBUE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT32EH0_Type) GetGTDTCR_TDBUE() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0x10) >> 4
}
func (o *GPT32EH0_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT32EH0.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT32EH0_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, value)
}
func (o *GPT32EH0_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg)
}

// GPT32EH0.GTDVD: General PWM Timer Dead Time Value Register D
func (o *GPT32EH0_Type) SetGTDVD(value uint32) {
	volatile.StoreUint32(&o.GTDVD.Reg, value)
}
func (o *GPT32EH0_Type) GetGTDVD() uint32 {
	return volatile.LoadUint32(&o.GTDVD.Reg)
}

// GPT32EH0.GTDBU: General PWM Timer Dead Time Buffer Register U
func (o *GPT32EH0_Type) SetGTDBU(value uint32) {
	volatile.StoreUint32(&o.GTDBU.Reg, value)
}
func (o *GPT32EH0_Type) GetGTDBU() uint32 {
	return volatile.LoadUint32(&o.GTDBU.Reg)
}

// GPT32EH0.GTDBD: General PWM Timer Dead Time Buffer Register D
func (o *GPT32EH0_Type) SetGTDBD(value uint32) {
	volatile.StoreUint32(&o.GTDBD.Reg, value)
}
func (o *GPT32EH0_Type) GetGTDBD() uint32 {
	return volatile.LoadUint32(&o.GTDBD.Reg)
}

// GPT32EH0.GTSOS: General PWM Timer Output Protection Function Status Register
func (o *GPT32EH0_Type) SetGTSOS_SOS(value uint32) {
	volatile.StoreUint32(&o.GTSOS.Reg, volatile.LoadUint32(&o.GTSOS.Reg)&^(0x3)|value)
}
func (o *GPT32EH0_Type) GetGTSOS_SOS() uint32 {
	return volatile.LoadUint32(&o.GTSOS.Reg) & 0x3
}

// GPT32EH0.GTSOTR: General PWM Timer Output Protection Function Temporary Release Register
func (o *GPT32EH0_Type) SetGTSOTR_SOTR(value uint32) {
	volatile.StoreUint32(&o.GTSOTR.Reg, volatile.LoadUint32(&o.GTSOTR.Reg)&^(0x1)|value)
}
func (o *GPT32EH0_Type) GetGTSOTR_SOTR() uint32 {
	return volatile.LoadUint32(&o.GTSOTR.Reg) & 0x1
}

// USB 2.0 High-Speed Module
type USBHS_Type struct {
	SYSCFG    volatile.Register16 // 0x0
	BUSWAIT   volatile.Register16 // 0x2
	SYSSTS0   volatile.Register16 // 0x4
	PLLSTA    volatile.Register16 // 0x6
	DVSTCTR0  volatile.Register16 // 0x8
	_         [2]byte
	TESTMODE  volatile.Register16 // 0xC
	_         [6]byte
	CFIFO     volatile.Register32 // 0x14
	D0FIFO    volatile.Register32 // 0x18
	D1FIFO    volatile.Register32 // 0x1C
	CFIFOSEL  volatile.Register16 // 0x20
	CFIFOCTR  volatile.Register16 // 0x22
	_         [4]byte
	D0FIFOSEL volatile.Register16 // 0x28
	D0FIFOCTR volatile.Register16 // 0x2A
	D1FIFOSEL volatile.Register16 // 0x2C
	D1FIFOCTR volatile.Register16 // 0x2E
	INTENB0   volatile.Register16 // 0x30
	INTENB1   volatile.Register16 // 0x32
	_         [2]byte
	BRDYENB   volatile.Register16 // 0x36
	NRDYENB   volatile.Register16 // 0x38
	BEMPENB   volatile.Register16 // 0x3A
	SOFCFG    volatile.Register16 // 0x3C
	PHYSET    volatile.Register16 // 0x3E
	INTSTS0   volatile.Register16 // 0x40
	INTSTS1   volatile.Register16 // 0x42
	_         [2]byte
	BRDYSTS   volatile.Register16 // 0x46
	NRDYSTS   volatile.Register16 // 0x48
	BEMPSTS   volatile.Register16 // 0x4A
	FRMNUM    volatile.Register16 // 0x4C
	UFRMNUM   volatile.Register16 // 0x4E
	USBADDR   volatile.Register16 // 0x50
	_         [2]byte
	USBREQ    volatile.Register16 // 0x54
	USBVAL    volatile.Register16 // 0x56
	USBINDX   volatile.Register16 // 0x58
	USBLENG   volatile.Register16 // 0x5A
	DCPCFG    volatile.Register16 // 0x5C
	DCPMAXP   volatile.Register16 // 0x5E
	DCPCTR    volatile.Register16 // 0x60
	_         [2]byte
	PIPESEL   volatile.Register16 // 0x64
	_         [2]byte
	PIPECFG   volatile.Register16 // 0x68
	PIPEBUF   volatile.Register16 // 0x6A
	PIPEMAXP  volatile.Register16 // 0x6C
	PIPEPERI  volatile.Register16 // 0x6E
	PIPE1CTR  volatile.Register16 // 0x70
	PIPE2CTR  volatile.Register16 // 0x72
	PIPE3CTR  volatile.Register16 // 0x74
	PIPE4CTR  volatile.Register16 // 0x76
	PIPE5CTR  volatile.Register16 // 0x78
	PIPE6CTR  volatile.Register16 // 0x7A
	PIPE7CTR  volatile.Register16 // 0x7C
	PIPE8CTR  volatile.Register16 // 0x7E
	PIPE9CTR  volatile.Register16 // 0x80
	_         [14]byte
	PIPE1TRE  volatile.Register16 // 0x90
	PIPE1TRN  volatile.Register16 // 0x92
	PIPE2TRE  volatile.Register16 // 0x94
	PIPE2TRN  volatile.Register16 // 0x96
	PIPE3TRE  volatile.Register16 // 0x98
	PIPE3TRN  volatile.Register16 // 0x9A
	PIPE4TRE  volatile.Register16 // 0x9C
	PIPE4TRN  volatile.Register16 // 0x9E
	PIPE5TRE  volatile.Register16 // 0xA0
	PIPE5TRN  volatile.Register16 // 0xA2
	_         [44]byte
	DEVADD0   volatile.Register16 // 0xD0
	DEVADD1   volatile.Register16 // 0xD2
	DEVADD2   volatile.Register16 // 0xD4
	DEVADD3   volatile.Register16 // 0xD6
	DEVADD4   volatile.Register16 // 0xD8
	DEVADD5   volatile.Register16 // 0xDA
	DEVADD6   volatile.Register16 // 0xDC
	DEVADD7   volatile.Register16 // 0xDE
	DEVADD8   volatile.Register16 // 0xE0
	DEVADD9   volatile.Register16 // 0xE2
	DEVADDA   volatile.Register16 // 0xE4
	_         [26]byte
	LPCTRL    volatile.Register16 // 0x100
	LPSTS     volatile.Register16 // 0x102
	_         [60]byte
	BCCTRL    volatile.Register16 // 0x140
	_         [2]byte
	PL1CTRL1  volatile.Register16 // 0x144
	PL1CTRL2  volatile.Register16 // 0x146
	HL1CTRL1  volatile.Register16 // 0x148
	HL1CTRL2  volatile.Register16 // 0x14A
	_         [20]byte
	DPUSR0R   volatile.Register32 // 0x160
	DPUSR1R   volatile.Register32 // 0x164
	DPUSR2R   volatile.Register16 // 0x168
	DPUSRCR   volatile.Register16 // 0x16A
}

// USBHS.SYSCFG: System Configuration Control Register
func (o *USBHS_Type) SetSYSCFG_CNEN(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetSYSCFG_CNEN() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetSYSCFG_HSE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetSYSCFG_HSE() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetSYSCFG_DCFM(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetSYSCFG_DCFM() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetSYSCFG_DRPD(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetSYSCFG_DRPD() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetSYSCFG_DPRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetSYSCFG_DPRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetSYSCFG_USBE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetSYSCFG_USBE() uint16 {
	return volatile.LoadUint16(&o.SYSCFG.Reg) & 0x1
}

// USBHS.BUSWAIT: CPU Bus Wait Register
func (o *USBHS_Type) SetBUSWAIT_BWAIT(value uint16) {
	volatile.StoreUint16(&o.BUSWAIT.Reg, volatile.LoadUint16(&o.BUSWAIT.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetBUSWAIT_BWAIT() uint16 {
	return volatile.LoadUint16(&o.BUSWAIT.Reg) & 0xf
}

// USBHS.SYSSTS0: System Configuration Status Register
func (o *USBHS_Type) SetSYSSTS0_OVCMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0xc000)|value<<14)
}
func (o *USBHS_Type) GetSYSSTS0_OVCMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0xc000) >> 14
}
func (o *USBHS_Type) SetSYSSTS0_HTACT(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetSYSSTS0_HTACT() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetSYSSTS0_SOFEA(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetSYSSTS0_SOFEA() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetSYSSTS0_IDMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetSYSSTS0_IDMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetSYSSTS0_LNST(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetSYSSTS0_LNST() uint16 {
	return volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3
}

// USBHS.PLLSTA: PLL Status Register
func (o *USBHS_Type) SetPLLSTA_PLLLOCK(value uint16) {
	volatile.StoreUint16(&o.PLLSTA.Reg, volatile.LoadUint16(&o.PLLSTA.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetPLLSTA_PLLLOCK() uint16 {
	return volatile.LoadUint16(&o.PLLSTA.Reg) & 0x1
}

// USBHS.DVSTCTR0: Device State Control Register 0
func (o *USBHS_Type) SetDVSTCTR0_HNPBTOA(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetDVSTCTR0_HNPBTOA() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetDVSTCTR0_EXICEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetDVSTCTR0_EXICEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetDVSTCTR0_VBUSEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetDVSTCTR0_VBUSEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetDVSTCTR0_WKUP(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDVSTCTR0_WKUP() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDVSTCTR0_RWUPE(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDVSTCTR0_RWUPE() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDVSTCTR0_USBRST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDVSTCTR0_USBRST() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDVSTCTR0_RESUME(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDVSTCTR0_RESUME() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDVSTCTR0_UACT(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDVSTCTR0_UACT() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDVSTCTR0_RHST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetDVSTCTR0_RHST() uint16 {
	return volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x7
}

// USBHS.TESTMODE: USB Test Mode Register
func (o *USBHS_Type) SetTESTMODE_UTST(value uint16) {
	volatile.StoreUint16(&o.TESTMODE.Reg, volatile.LoadUint16(&o.TESTMODE.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetTESTMODE_UTST() uint16 {
	return volatile.LoadUint16(&o.TESTMODE.Reg) & 0xf
}

// USBHS.CFIFO: CFIFO Port Register
func (o *USBHS_Type) SetCFIFO(value uint32) {
	volatile.StoreUint32(&o.CFIFO.Reg, value)
}
func (o *USBHS_Type) GetCFIFO() uint32 {
	return volatile.LoadUint32(&o.CFIFO.Reg)
}

// USBHS.D0FIFO: D0FIFO Port Register
func (o *USBHS_Type) SetD0FIFO(value uint32) {
	volatile.StoreUint32(&o.D0FIFO.Reg, value)
}
func (o *USBHS_Type) GetD0FIFO() uint32 {
	return volatile.LoadUint32(&o.D0FIFO.Reg)
}

// USBHS.D1FIFO: D1FIFO Port Register
func (o *USBHS_Type) SetD1FIFO(value uint32) {
	volatile.StoreUint32(&o.D1FIFO.Reg, value)
}
func (o *USBHS_Type) GetD1FIFO() uint32 {
	return volatile.LoadUint32(&o.D1FIFO.Reg)
}

// USBHS.CFIFOSEL: CFIFO Port Select Register
func (o *USBHS_Type) SetCFIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetCFIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetCFIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetCFIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetCFIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xc00)|value<<10)
}
func (o *USBHS_Type) GetCFIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xc00) >> 10
}
func (o *USBHS_Type) SetCFIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetCFIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetCFIFOSEL_ISEL(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetCFIFOSEL_ISEL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetCFIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetCFIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xf
}

// USBHS.CFIFOCTR: CFIFO Port Control Register
func (o *USBHS_Type) SetCFIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetCFIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetCFIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetCFIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetCFIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetCFIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetCFIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0xfff)|value)
}
func (o *USBHS_Type) GetCFIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0xfff
}

// USBHS.D0FIFOSEL: D0FIFO Port Select Register
func (o *USBHS_Type) SetD0FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetD0FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetD0FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetD0FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetD0FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetD0FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetD0FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetD0FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetD0FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xc00)|value<<10)
}
func (o *USBHS_Type) GetD0FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xc00) >> 10
}
func (o *USBHS_Type) SetD0FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetD0FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetD0FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetD0FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xf
}

// USBHS.D0FIFOCTR: D0FIFO Port Control Register
func (o *USBHS_Type) SetD0FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetD0FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetD0FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetD0FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetD0FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetD0FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetD0FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0xfff)|value)
}
func (o *USBHS_Type) GetD0FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0xfff
}

// USBHS.D1FIFOSEL: D1FIFO Port Select Register
func (o *USBHS_Type) SetD1FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetD1FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetD1FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetD1FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetD1FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetD1FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetD1FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetD1FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetD1FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xc00)|value<<10)
}
func (o *USBHS_Type) GetD1FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xc00) >> 10
}
func (o *USBHS_Type) SetD1FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetD1FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetD1FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetD1FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xf
}

// USBHS.D1FIFOCTR: D1FIFO Port Control Register
func (o *USBHS_Type) SetD1FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetD1FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetD1FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetD1FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetD1FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetD1FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetD1FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0xfff)|value)
}
func (o *USBHS_Type) GetD1FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0xfff
}

// USBHS.INTENB0: Interrupt Enable Register 0
func (o *USBHS_Type) SetINTENB0_VBSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetINTENB0_VBSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetINTENB0_RSME(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetINTENB0_RSME() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetINTENB0_SOFE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetINTENB0_SOFE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetINTENB0_DVSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetINTENB0_DVSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetINTENB0_CTRE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetINTENB0_CTRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetINTENB0_BEMPE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetINTENB0_BEMPE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetINTENB0_NRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetINTENB0_NRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetINTENB0_BRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetINTENB0_BRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x100) >> 8
}

// USBHS.INTENB1: Interrupt Enable Register 1
func (o *USBHS_Type) SetINTENB1_OVRCRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetINTENB1_OVRCRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetINTENB1_BCHGE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetINTENB1_BCHGE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetINTENB1_DTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetINTENB1_DTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetINTENB1_ATTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetINTENB1_ATTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetINTENB1_L1RSMENDE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetINTENB1_L1RSMENDE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetINTENB1_LPMENDE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetINTENB1_LPMENDE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetINTENB1_EOFERRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetINTENB1_EOFERRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetINTENB1_SIGNE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetINTENB1_SIGNE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetINTENB1_SACKE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetINTENB1_SACKE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetINTENB1_PDDETINTE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetINTENB1_PDDETINTE() uint16 {
	return volatile.LoadUint16(&o.INTENB1.Reg) & 0x1
}

// USBHS.BRDYENB: BRDY Interrupt Enable Register
func (o *USBHS_Type) SetBRDYENB_PIPEBRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetBRDYENB_PIPEBRDYE() uint16 {
	return volatile.LoadUint16(&o.BRDYENB.Reg) & 0x3ff
}

// USBHS.NRDYENB: NRDY Interrupt Enable Register
func (o *USBHS_Type) SetNRDYENB_PIPENRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetNRDYENB_PIPENRDYE() uint16 {
	return volatile.LoadUint16(&o.NRDYENB.Reg) & 0x3ff
}

// USBHS.BEMPENB: BEMP Interrupt Enable Register
func (o *USBHS_Type) SetBEMPENB_PIPEBEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetBEMPENB_PIPEBEMPE() uint16 {
	return volatile.LoadUint16(&o.BEMPENB.Reg) & 0x3ff
}

// USBHS.SOFCFG: SOF Pin Configuration Register
func (o *USBHS_Type) SetSOFCFG_TRNENSEL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetSOFCFG_TRNENSEL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetSOFCFG_BRDYM(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetSOFCFG_BRDYM() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetSOFCFG_INTL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetSOFCFG_INTL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetSOFCFG_EDGESTS(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetSOFCFG_EDGESTS() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x10) >> 4
}

// USBHS.PHYSET: PHY Setting Register
func (o *USBHS_Type) SetPHYSET_HSEB(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPHYSET_HSEB() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPHYSET_REPSTART(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetPHYSET_REPSTART() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetPHYSET_REPSEL(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x300)|value<<8)
}
func (o *USBHS_Type) GetPHYSET_REPSEL() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x300) >> 8
}
func (o *USBHS_Type) SetPHYSET_CLKSEL(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x30)|value<<4)
}
func (o *USBHS_Type) GetPHYSET_CLKSEL() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x30) >> 4
}
func (o *USBHS_Type) SetPHYSET_CDPEN(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetPHYSET_CDPEN() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetPHYSET_PLLRESET(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetPHYSET_PLLRESET() uint16 {
	return (volatile.LoadUint16(&o.PHYSET.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetPHYSET_DIRPD(value uint16) {
	volatile.StoreUint16(&o.PHYSET.Reg, volatile.LoadUint16(&o.PHYSET.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetPHYSET_DIRPD() uint16 {
	return volatile.LoadUint16(&o.PHYSET.Reg) & 0x1
}

// USBHS.INTSTS0: Interrupt Status Register 0
func (o *USBHS_Type) SetINTSTS0_VBINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetINTSTS0_VBINT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetINTSTS0_RESM(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetINTSTS0_RESM() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetINTSTS0_SOFR(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetINTSTS0_SOFR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetINTSTS0_DVST(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetINTSTS0_DVST() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetINTSTS0_CTRT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetINTSTS0_CTRT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetINTSTS0_BEMP(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetINTSTS0_BEMP() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetINTSTS0_NRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetINTSTS0_NRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetINTSTS0_BRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetINTSTS0_BRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetINTSTS0_VBSTS(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetINTSTS0_VBSTS() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetINTSTS0_DVSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x70)|value<<4)
}
func (o *USBHS_Type) GetINTSTS0_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x70) >> 4
}
func (o *USBHS_Type) SetINTSTS0_VALID(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetINTSTS0_VALID() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetINTSTS0_CTSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetINTSTS0_CTSQ() uint16 {
	return volatile.LoadUint16(&o.INTSTS0.Reg) & 0x7
}

// USBHS.INTSTS1: Interrupt Status Register 1
func (o *USBHS_Type) SetINTSTS1_OVRCR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetINTSTS1_OVRCR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetINTSTS1_BCHG(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetINTSTS1_BCHG() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetINTSTS1_DTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetINTSTS1_DTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetINTSTS1_ATTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetINTSTS1_ATTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetINTSTS1_L1RSMEND(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetINTSTS1_L1RSMEND() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetINTSTS1_LPMEND(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetINTSTS1_LPMEND() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetINTSTS1_EOFERR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetINTSTS1_EOFERR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetINTSTS1_SIGN(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetINTSTS1_SIGN() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetINTSTS1_SACK(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetINTSTS1_SACK() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetINTSTS1_PDDETINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetINTSTS1_PDDETINT() uint16 {
	return volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1
}

// USBHS.BRDYSTS: BRDY Interrupt Status Register
func (o *USBHS_Type) SetBRDYSTS_PIPEBRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetBRDYSTS_PIPEBRDY() uint16 {
	return volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x3ff
}

// USBHS.NRDYSTS: NRDY Interrupt Status Register
func (o *USBHS_Type) SetNRDYSTS_PIPENRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetNRDYSTS_PIPENRDY() uint16 {
	return volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x3ff
}

// USBHS.BEMPSTS: BEMP Interrupt Status Register
func (o *USBHS_Type) SetBEMPSTS_PIPEBEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x3ff)|value)
}
func (o *USBHS_Type) GetBEMPSTS_PIPEBEMP() uint16 {
	return volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x3ff
}

// USBHS.FRMNUM: Frame Number Register
func (o *USBHS_Type) SetFRMNUM_OVRN(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetFRMNUM_OVRN() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetFRMNUM_CRCE(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetFRMNUM_CRCE() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetFRMNUM_FRNM(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x7ff)|value)
}
func (o *USBHS_Type) GetFRMNUM_FRNM() uint16 {
	return volatile.LoadUint16(&o.FRMNUM.Reg) & 0x7ff
}

// USBHS.UFRMNUM: uFrame Number Register
func (o *USBHS_Type) SetUFRMNUM_DVCHG(value uint16) {
	volatile.StoreUint16(&o.UFRMNUM.Reg, volatile.LoadUint16(&o.UFRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetUFRMNUM_DVCHG() uint16 {
	return (volatile.LoadUint16(&o.UFRMNUM.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetUFRMNUM_UFRNM(value uint16) {
	volatile.StoreUint16(&o.UFRMNUM.Reg, volatile.LoadUint16(&o.UFRMNUM.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetUFRMNUM_UFRNM() uint16 {
	return volatile.LoadUint16(&o.UFRMNUM.Reg) & 0x7
}

// USBHS.USBADDR: USB Address Register
func (o *USBHS_Type) SetUSBADDR_STSRECOV0(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetUSBADDR_STSRECOV0() uint16 {
	return (volatile.LoadUint16(&o.USBADDR.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetUSBADDR(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetUSBADDR() uint16 {
	return volatile.LoadUint16(&o.USBADDR.Reg) & 0x7f
}

// USBHS.USBREQ: USB Request Type Register
func (o *USBHS_Type) SetUSBREQ_BREQUEST(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff00)|value<<8)
}
func (o *USBHS_Type) GetUSBREQ_BREQUEST() uint16 {
	return (volatile.LoadUint16(&o.USBREQ.Reg) & 0xff00) >> 8
}
func (o *USBHS_Type) SetUSBREQ_BMREQUESTTYPE(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetUSBREQ_BMREQUESTTYPE() uint16 {
	return volatile.LoadUint16(&o.USBREQ.Reg) & 0xff
}

// USBHS.USBVAL: USB Request Value Register
func (o *USBHS_Type) SetUSBVAL(value uint16) {
	volatile.StoreUint16(&o.USBVAL.Reg, value)
}
func (o *USBHS_Type) GetUSBVAL() uint16 {
	return volatile.LoadUint16(&o.USBVAL.Reg)
}

// USBHS.USBINDX: USB Request Index Register
func (o *USBHS_Type) SetUSBINDX(value uint16) {
	volatile.StoreUint16(&o.USBINDX.Reg, value)
}
func (o *USBHS_Type) GetUSBINDX() uint16 {
	return volatile.LoadUint16(&o.USBINDX.Reg)
}

// USBHS.USBLENG: USB Request Length Register
func (o *USBHS_Type) SetUSBLENG(value uint16) {
	volatile.StoreUint16(&o.USBLENG.Reg, value)
}
func (o *USBHS_Type) GetUSBLENG() uint16 {
	return volatile.LoadUint16(&o.USBLENG.Reg)
}

// USBHS.DCPCFG: DCP Configuration Register
func (o *USBHS_Type) SetDCPCFG_CNTMD(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDCPCFG_CNTMD() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDCPCFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDCPCFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDCPCFG_DIR(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDCPCFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x10) >> 4
}

// USBHS.DCPMAXP: DCP Maximum Packet Size Register
func (o *USBHS_Type) SetDCPMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBHS_Type) GetDCPMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf000) >> 12
}
func (o *USBHS_Type) SetDCPMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0x7f)|value)
}
func (o *USBHS_Type) GetDCPMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.DCPMAXP.Reg) & 0x7f
}

// USBHS.DCPCTR: DCP Control Register
func (o *USBHS_Type) SetDCPCTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetDCPCTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetDCPCTR_SUREQ(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetDCPCTR_SUREQ() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetDCPCTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetDCPCTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetDCPCTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetDCPCTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetDCPCTR_SUREQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x800)|value<<11)
}
func (o *USBHS_Type) GetDCPCTR_SUREQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x800) >> 11
}
func (o *USBHS_Type) SetDCPCTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDCPCTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDCPCTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDCPCTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDCPCTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetDCPCTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetDCPCTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDCPCTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDCPCTR_PINGE(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDCPCTR_PINGE() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDCPCTR_CCPL(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetDCPCTR_CCPL() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetDCPCTR_PID(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetDCPCTR_PID() uint16 {
	return volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3
}

// USBHS.PIPESEL: Pipe Window Select Register
func (o *USBHS_Type) SetPIPESEL(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetPIPESEL() uint16 {
	return volatile.LoadUint16(&o.PIPESEL.Reg) & 0xf
}

// USBHS.PIPECFG: Pipe Configuration Register
func (o *USBHS_Type) SetPIPECFG_TYPE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xc000)|value<<14)
}
func (o *USBHS_Type) GetPIPECFG_TYPE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0xc000) >> 14
}
func (o *USBHS_Type) SetPIPECFG_BFRE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPECFG_BFRE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPECFG_DBLB(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPECFG_DBLB() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPECFG_CNTMD(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPECFG_CNTMD() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPECFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPECFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPECFG_DIR(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetPIPECFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetPIPECFG_EPNUM(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetPIPECFG_EPNUM() uint16 {
	return volatile.LoadUint16(&o.PIPECFG.Reg) & 0xf
}

// USBHS.PIPEBUF: Pipe Buffer Register
func (o *USBHS_Type) SetPIPEBUF_BUFSIZE(value uint16) {
	volatile.StoreUint16(&o.PIPEBUF.Reg, volatile.LoadUint16(&o.PIPEBUF.Reg)&^(0x7c00)|value<<10)
}
func (o *USBHS_Type) GetPIPEBUF_BUFSIZE() uint16 {
	return (volatile.LoadUint16(&o.PIPEBUF.Reg) & 0x7c00) >> 10
}
func (o *USBHS_Type) SetPIPEBUF_BUFNMB(value uint16) {
	volatile.StoreUint16(&o.PIPEBUF.Reg, volatile.LoadUint16(&o.PIPEBUF.Reg)&^(0xff)|value)
}
func (o *USBHS_Type) GetPIPEBUF_BUFNMB() uint16 {
	return volatile.LoadUint16(&o.PIPEBUF.Reg) & 0xff
}

// USBHS.PIPEMAXP: Pipe Maximum Packet Size Register
func (o *USBHS_Type) SetPIPEMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBHS_Type) GetPIPEMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xf000) >> 12
}
func (o *USBHS_Type) SetPIPEMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0x7ff)|value)
}
func (o *USBHS_Type) GetPIPEMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0x7ff
}

// USBHS.PIPEPERI: Pipe Cycle Control Register
func (o *USBHS_Type) SetPIPEPERI_IFIS(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPEPERI_IFIS() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPEPERI_IITV(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x7)|value)
}
func (o *USBHS_Type) GetPIPEPERI_IITV() uint16 {
	return volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x7
}

// USBHS.PIPE1CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE1CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE1CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE1CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE1CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE1CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE1CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE1CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE1CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE1CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE1CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE1CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE1CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE1CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE1CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE1CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE1CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE1CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE1CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE1CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE1CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE1CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE1CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x3
}

// USBHS.PIPE2CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE2CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE2CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE2CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE2CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE2CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE2CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE2CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE2CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE2CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE2CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE2CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE2CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE2CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE2CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE2CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE2CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE2CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE2CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE2CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE2CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE2CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE2CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x3
}

// USBHS.PIPE3CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE3CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE3CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE3CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE3CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE3CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE3CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE3CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE3CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE3CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE3CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE3CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE3CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE3CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE3CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE3CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE3CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE3CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE3CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE3CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE3CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE3CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE3CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x3
}

// USBHS.PIPE4CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE4CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE4CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE4CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE4CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE4CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE4CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE4CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE4CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE4CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE4CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE4CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE4CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE4CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE4CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE4CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE4CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE4CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE4CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE4CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE4CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE4CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE4CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3
}

// USBHS.PIPE5CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE5CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE5CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE5CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE5CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE5CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE5CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE5CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE5CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE5CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE5CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE5CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE5CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE5CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE5CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE5CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE5CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE5CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE5CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE5CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE5CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE5CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE5CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3
}

// USBHS.PIPE6CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE6CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE6CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE6CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE6CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE6CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE6CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE6CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE6CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE6CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE6CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE6CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE6CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE6CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE6CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE6CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE6CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE6CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE6CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE6CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE6CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE6CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE6CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x3
}

// USBHS.PIPE7CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE7CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE7CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE7CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE7CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE7CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE7CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE7CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE7CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE7CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE7CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE7CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE7CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE7CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE7CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE7CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE7CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE7CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE7CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE7CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE7CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE7CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE7CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x3
}

// USBHS.PIPE8CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE8CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE8CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE8CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE8CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE8CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE8CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE8CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE8CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE8CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE8CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE8CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE8CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE8CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE8CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE8CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE8CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE8CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE8CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE8CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE8CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE8CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE8CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x3
}

// USBHS.PIPE9CTR: PIPE Control Register
func (o *USBHS_Type) SetPIPE9CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetPIPE9CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetPIPE9CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPIPE9CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPIPE9CTR_CSCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBHS_Type) GetPIPE9CTR_CSCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x2000) >> 13
}
func (o *USBHS_Type) SetPIPE9CTR_CSSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPIPE9CTR_CSSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPIPE9CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBHS_Type) GetPIPE9CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x400) >> 10
}
func (o *USBHS_Type) SetPIPE9CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE9CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE9CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE9CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetPIPE9CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetPIPE9CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetPIPE9CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBHS_Type) GetPIPE9CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x40) >> 6
}
func (o *USBHS_Type) SetPIPE9CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetPIPE9CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetPIPE9CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x3)|value)
}
func (o *USBHS_Type) GetPIPE9CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x3
}

// USBHS.PIPE1TRE: PIPE Transaction Counter Enable Register
func (o *USBHS_Type) SetPIPE1TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE1TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE1TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE1TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x100) >> 8
}

// USBHS.PIPE1TRN: PIPE Transaction Counter Register
func (o *USBHS_Type) SetPIPE1TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRN.Reg, value)
}
func (o *USBHS_Type) GetPIPE1TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE1TRN.Reg)
}

// USBHS.PIPE2TRE: PIPE Transaction Counter Enable Register
func (o *USBHS_Type) SetPIPE2TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE2TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE2TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE2TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x100) >> 8
}

// USBHS.PIPE2TRN: PIPE Transaction Counter Register
func (o *USBHS_Type) SetPIPE2TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRN.Reg, value)
}
func (o *USBHS_Type) GetPIPE2TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE2TRN.Reg)
}

// USBHS.PIPE3TRE: PIPE Transaction Counter Enable Register
func (o *USBHS_Type) SetPIPE3TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE3TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE3TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE3TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x100) >> 8
}

// USBHS.PIPE3TRN: PIPE Transaction Counter Register
func (o *USBHS_Type) SetPIPE3TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRN.Reg, value)
}
func (o *USBHS_Type) GetPIPE3TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE3TRN.Reg)
}

// USBHS.PIPE4TRE: PIPE Transaction Counter Enable Register
func (o *USBHS_Type) SetPIPE4TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE4TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE4TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE4TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x100) >> 8
}

// USBHS.PIPE4TRN: PIPE Transaction Counter Register
func (o *USBHS_Type) SetPIPE4TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRN.Reg, value)
}
func (o *USBHS_Type) GetPIPE4TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRN.Reg)
}

// USBHS.PIPE5TRE: PIPE Transaction Counter Enable Register
func (o *USBHS_Type) SetPIPE5TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetPIPE5TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetPIPE5TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetPIPE5TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x100) >> 8
}

// USBHS.PIPE5TRN: PIPE Transaction Counter Register
func (o *USBHS_Type) SetPIPE5TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRN.Reg, value)
}
func (o *USBHS_Type) GetPIPE5TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRN.Reg)
}

// USBHS.DEVADD0: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD0_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD0_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD0_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD0_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD0_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD0_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD1: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD1_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD1_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD1_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD1_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD1_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD1_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD2: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD2_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD2_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD2_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD2_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD2_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD2_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD3: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD3_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD3_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD3_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD3_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD3_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD3_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD4: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD4_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD4_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD4_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD4_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD4_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD4_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD5: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD5_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD5_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD5_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD5_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD5_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD5_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD6: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD6_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD6.Reg, volatile.LoadUint16(&o.DEVADD6.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD6_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD6.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD6_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD6.Reg, volatile.LoadUint16(&o.DEVADD6.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD6_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD6.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD6_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD6.Reg, volatile.LoadUint16(&o.DEVADD6.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD6_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD6.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD7: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD7_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD7.Reg, volatile.LoadUint16(&o.DEVADD7.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD7_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD7.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD7_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD7.Reg, volatile.LoadUint16(&o.DEVADD7.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD7_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD7.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD7_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD7.Reg, volatile.LoadUint16(&o.DEVADD7.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD7_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD7.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD8: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD8_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD8.Reg, volatile.LoadUint16(&o.DEVADD8.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD8_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD8.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD8_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD8.Reg, volatile.LoadUint16(&o.DEVADD8.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD8_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD8.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD8_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD8.Reg, volatile.LoadUint16(&o.DEVADD8.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD8_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD8.Reg) & 0xc0) >> 6
}

// USBHS.DEVADD9: Device Address Configuration Register
func (o *USBHS_Type) SetDEVADD9_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADD9.Reg, volatile.LoadUint16(&o.DEVADD9.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADD9_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADD9.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADD9_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADD9.Reg, volatile.LoadUint16(&o.DEVADD9.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADD9_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADD9.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADD9_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD9.Reg, volatile.LoadUint16(&o.DEVADD9.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADD9_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD9.Reg) & 0xc0) >> 6
}

// USBHS.DEVADDA: Device Address Configuration Register A
func (o *USBHS_Type) SetDEVADDA_UPPHUB(value uint16) {
	volatile.StoreUint16(&o.DEVADDA.Reg, volatile.LoadUint16(&o.DEVADDA.Reg)&^(0x7800)|value<<11)
}
func (o *USBHS_Type) GetDEVADDA_UPPHUB() uint16 {
	return (volatile.LoadUint16(&o.DEVADDA.Reg) & 0x7800) >> 11
}
func (o *USBHS_Type) SetDEVADDA_HUBPORT(value uint16) {
	volatile.StoreUint16(&o.DEVADDA.Reg, volatile.LoadUint16(&o.DEVADDA.Reg)&^(0x700)|value<<8)
}
func (o *USBHS_Type) GetDEVADDA_HUBPORT() uint16 {
	return (volatile.LoadUint16(&o.DEVADDA.Reg) & 0x700) >> 8
}
func (o *USBHS_Type) SetDEVADDA_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADDA.Reg, volatile.LoadUint16(&o.DEVADDA.Reg)&^(0xc0)|value<<6)
}
func (o *USBHS_Type) GetDEVADDA_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADDA.Reg) & 0xc0) >> 6
}

// USBHS.LPCTRL: Low Power Control Register
func (o *USBHS_Type) SetLPCTRL_HWUPM(value uint16) {
	volatile.StoreUint16(&o.LPCTRL.Reg, volatile.LoadUint16(&o.LPCTRL.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetLPCTRL_HWUPM() uint16 {
	return (volatile.LoadUint16(&o.LPCTRL.Reg) & 0x80) >> 7
}

// USBHS.LPSTS: Low Power Status Register
func (o *USBHS_Type) SetLPSTS_SUSPENDM(value uint16) {
	volatile.StoreUint16(&o.LPSTS.Reg, volatile.LoadUint16(&o.LPSTS.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetLPSTS_SUSPENDM() uint16 {
	return (volatile.LoadUint16(&o.LPSTS.Reg) & 0x4000) >> 14
}

// USBHS.BCCTRL: Battery Charging Control Register
func (o *USBHS_Type) SetBCCTRL_PDDETSTS(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetBCCTRL_PDDETSTS() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetBCCTRL_CHGDETSTS(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetBCCTRL_CHGDETSTS() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetBCCTRL_DCPMODE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetBCCTRL_DCPMODE() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetBCCTRL_VDMSRCE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetBCCTRL_VDMSRCE() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetBCCTRL_IDPSINKE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetBCCTRL_IDPSINKE() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetBCCTRL_VDPSRCE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x4)|value<<2)
}
func (o *USBHS_Type) GetBCCTRL_VDPSRCE() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x4) >> 2
}
func (o *USBHS_Type) SetBCCTRL_IDMSINKE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetBCCTRL_IDMSINKE() uint16 {
	return (volatile.LoadUint16(&o.BCCTRL.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetBCCTRL_IDPSRCE(value uint16) {
	volatile.StoreUint16(&o.BCCTRL.Reg, volatile.LoadUint16(&o.BCCTRL.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetBCCTRL_IDPSRCE() uint16 {
	return volatile.LoadUint16(&o.BCCTRL.Reg) & 0x1
}

// USBHS.PL1CTRL1: Function L1 Control Register 1
func (o *USBHS_Type) SetPL1CTRL1_L1EXTMD(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0x4000)|value<<14)
}
func (o *USBHS_Type) GetPL1CTRL1_L1EXTMD() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0x4000) >> 14
}
func (o *USBHS_Type) SetPL1CTRL1_HIRDTHR(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0xf00)|value<<8)
}
func (o *USBHS_Type) GetPL1CTRL1_HIRDTHR() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0xf00) >> 8
}
func (o *USBHS_Type) SetPL1CTRL1_DVSQ(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0xf0)|value<<4)
}
func (o *USBHS_Type) GetPL1CTRL1_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0xf0) >> 4
}
func (o *USBHS_Type) SetPL1CTRL1_L1NEGOMD(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0x8)|value<<3)
}
func (o *USBHS_Type) GetPL1CTRL1_L1NEGOMD() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0x8) >> 3
}
func (o *USBHS_Type) SetPL1CTRL1_L1RESPMD(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0x6)|value<<1)
}
func (o *USBHS_Type) GetPL1CTRL1_L1RESPMD() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0x6) >> 1
}
func (o *USBHS_Type) SetPL1CTRL1_L1RESPEN(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL1.Reg, volatile.LoadUint16(&o.PL1CTRL1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetPL1CTRL1_L1RESPEN() uint16 {
	return volatile.LoadUint16(&o.PL1CTRL1.Reg) & 0x1
}

// USBHS.PL1CTRL2: Function L1 Control Register 2
func (o *USBHS_Type) SetPL1CTRL2_RWEMON(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL2.Reg, volatile.LoadUint16(&o.PL1CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetPL1CTRL2_RWEMON() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL2.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetPL1CTRL2_HIRDMON(value uint16) {
	volatile.StoreUint16(&o.PL1CTRL2.Reg, volatile.LoadUint16(&o.PL1CTRL2.Reg)&^(0xf00)|value<<8)
}
func (o *USBHS_Type) GetPL1CTRL2_HIRDMON() uint16 {
	return (volatile.LoadUint16(&o.PL1CTRL2.Reg) & 0xf00) >> 8
}

// USBHS.HL1CTRL1: Host L1 Control Register 1
func (o *USBHS_Type) SetHL1CTRL1_L1STATUS(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL1.Reg, volatile.LoadUint16(&o.HL1CTRL1.Reg)&^(0x6)|value<<1)
}
func (o *USBHS_Type) GetHL1CTRL1_L1STATUS() uint16 {
	return (volatile.LoadUint16(&o.HL1CTRL1.Reg) & 0x6) >> 1
}
func (o *USBHS_Type) SetHL1CTRL1_L1REQ(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL1.Reg, volatile.LoadUint16(&o.HL1CTRL1.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetHL1CTRL1_L1REQ() uint16 {
	return volatile.LoadUint16(&o.HL1CTRL1.Reg) & 0x1
}

// USBHS.HL1CTRL2: Host L1 Control Register 2
func (o *USBHS_Type) SetHL1CTRL2_BESL(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL2.Reg, volatile.LoadUint16(&o.HL1CTRL2.Reg)&^(0x8000)|value<<15)
}
func (o *USBHS_Type) GetHL1CTRL2_BESL() uint16 {
	return (volatile.LoadUint16(&o.HL1CTRL2.Reg) & 0x8000) >> 15
}
func (o *USBHS_Type) SetHL1CTRL2_L1RWE(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL2.Reg, volatile.LoadUint16(&o.HL1CTRL2.Reg)&^(0x1000)|value<<12)
}
func (o *USBHS_Type) GetHL1CTRL2_L1RWE() uint16 {
	return (volatile.LoadUint16(&o.HL1CTRL2.Reg) & 0x1000) >> 12
}
func (o *USBHS_Type) SetHL1CTRL2_HIRD(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL2.Reg, volatile.LoadUint16(&o.HL1CTRL2.Reg)&^(0xf00)|value<<8)
}
func (o *USBHS_Type) GetHL1CTRL2_HIRD() uint16 {
	return (volatile.LoadUint16(&o.HL1CTRL2.Reg) & 0xf00) >> 8
}
func (o *USBHS_Type) SetHL1CTRL2_L1ADDR(value uint16) {
	volatile.StoreUint16(&o.HL1CTRL2.Reg, volatile.LoadUint16(&o.HL1CTRL2.Reg)&^(0xf)|value)
}
func (o *USBHS_Type) GetHL1CTRL2_L1ADDR() uint16 {
	return volatile.LoadUint16(&o.HL1CTRL2.Reg) & 0xf
}

// USBHS.DPUSR0R: Deep Standby USB Transceiver Control/Pin Monitor Register
func (o *USBHS_Type) SetDPUSR0R_DVBSTSHM(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDPUSR0R_DVBSTSHM() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDPUSR0R_DOVCBHM(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDPUSR0R_DOVCBHM() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDPUSR0R_DOVCAHM(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDPUSR0R_DOVCAHM() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x100000) >> 20
}

// USBHS.DPUSR1R: Deep Standby USB Suspend/Resume Interrupt Register
func (o *USBHS_Type) SetDPUSR1R_DVBSTSH(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x800000)|value<<23)
}
func (o *USBHS_Type) GetDPUSR1R_DVBSTSH() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x800000) >> 23
}
func (o *USBHS_Type) SetDPUSR1R_DOVCBH(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x200000)|value<<21)
}
func (o *USBHS_Type) GetDPUSR1R_DOVCBH() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x200000) >> 21
}
func (o *USBHS_Type) SetDPUSR1R_DOVCAH(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x100000)|value<<20)
}
func (o *USBHS_Type) GetDPUSR1R_DOVCAH() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x100000) >> 20
}
func (o *USBHS_Type) SetDPUSR1R_DVBSTSHE(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x80)|value<<7)
}
func (o *USBHS_Type) GetDPUSR1R_DVBSTSHE() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x80) >> 7
}
func (o *USBHS_Type) SetDPUSR1R_DOVCBHE(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDPUSR1R_DOVCBHE() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDPUSR1R_DOVCAHE(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDPUSR1R_DOVCAHE() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x10) >> 4
}

// USBHS.DPUSR2R: Deep Standby USB Suspend/Resume Interrupt Register
func (o *USBHS_Type) SetDPUSR2R_DMINTE(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x200)|value<<9)
}
func (o *USBHS_Type) GetDPUSR2R_DMINTE() uint16 {
	return (volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x200) >> 9
}
func (o *USBHS_Type) SetDPUSR2R_DPINTE(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x100)|value<<8)
}
func (o *USBHS_Type) GetDPUSR2R_DPINTE() uint16 {
	return (volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x100) >> 8
}
func (o *USBHS_Type) SetDPUSR2R_DMVAL(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x20)|value<<5)
}
func (o *USBHS_Type) GetDPUSR2R_DMVAL() uint16 {
	return (volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x20) >> 5
}
func (o *USBHS_Type) SetDPUSR2R_DPVAL(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x10)|value<<4)
}
func (o *USBHS_Type) GetDPUSR2R_DPVAL() uint16 {
	return (volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x10) >> 4
}
func (o *USBHS_Type) SetDPUSR2R_DMINT(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDPUSR2R_DMINT() uint16 {
	return (volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDPUSR2R_DPINT(value uint16) {
	volatile.StoreUint16(&o.DPUSR2R.Reg, volatile.LoadUint16(&o.DPUSR2R.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDPUSR2R_DPINT() uint16 {
	return volatile.LoadUint16(&o.DPUSR2R.Reg) & 0x1
}

// USBHS.DPUSRCR: Deep Standby USB Suspend/Resume Command Register
func (o *USBHS_Type) SetDPUSRCR_FIXPHYPD(value uint16) {
	volatile.StoreUint16(&o.DPUSRCR.Reg, volatile.LoadUint16(&o.DPUSRCR.Reg)&^(0x2)|value<<1)
}
func (o *USBHS_Type) GetDPUSRCR_FIXPHYPD() uint16 {
	return (volatile.LoadUint16(&o.DPUSRCR.Reg) & 0x2) >> 1
}
func (o *USBHS_Type) SetDPUSRCR_FIXPHY(value uint16) {
	volatile.StoreUint16(&o.DPUSRCR.Reg, volatile.LoadUint16(&o.DPUSRCR.Reg)&^(0x1)|value)
}
func (o *USBHS_Type) GetDPUSRCR_FIXPHY() uint16 {
	return volatile.LoadUint16(&o.DPUSRCR.Reg) & 0x1
}

// Serial Communication Interface 0
type SCI0_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
	DCCR  volatile.Register8  // 0x13
	FCR   volatile.Register16 // 0x14
	FDR   volatile.Register16 // 0x16
	LSR   volatile.Register16 // 0x18
	CDR   volatile.Register16 // 0x1A
	SPTR  volatile.Register8  // 0x1C
}

// SCI0.SMR: Serial Mode Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}

// SCI0.BRR: Bit Rate Register
func (o *SCI0_Type) SetBRR(value uint8) {
	volatile.StoreUint8(&o.BRR.Reg, value)
}
func (o *SCI0_Type) GetBRR() uint8 {
	return volatile.LoadUint8(&o.BRR.Reg)
}

// SCI0.SCR: Serial Control Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}

// SCI0.TDR: Transmit Data Register
func (o *SCI0_Type) SetTDR(value uint8) {
	volatile.StoreUint8(&o.TDR.Reg, value)
}
func (o *SCI0_Type) GetTDR() uint8 {
	return volatile.LoadUint8(&o.TDR.Reg)
}

// SCI0.SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
func (o *SCI0_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}

// SCI0.RDR: Receive Data Register
func (o *SCI0_Type) SetRDR(value uint8) {
	volatile.StoreUint8(&o.RDR.Reg, value)
}
func (o *SCI0_Type) GetRDR() uint8 {
	return volatile.LoadUint8(&o.RDR.Reg)
}

// SCI0.SCMR: Smart Card Mode Register
func (o *SCI0_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}

// SCI0.SEMR: Serial Extended Mode Register
func (o *SCI0_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}

// SCI0.SNFR: Noise Filter Setting Register
func (o *SCI0_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI0.SIMR1: I2C Mode Register 1
func (o *SCI0_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}

// SCI0.SIMR2: I2C Mode Register 2
func (o *SCI0_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}

// SCI0.SIMR3: I2C Mode Register 3
func (o *SCI0_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}

// SCI0.SISR: I2C Status Register
func (o *SCI0_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI0.SPMR: SPI Mode Register
func (o *SCI0_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}

// SCI0.TDRHL: Transmit 9-bit Data Register
func (o *SCI0_Type) SetTDRHL(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, value)
}
func (o *SCI0_Type) GetTDRHL() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg)
}

// SCI0.RDRHL: Receive 9-bit Data Register
func (o *SCI0_Type) SetRDRHL(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, value)
}
func (o *SCI0_Type) GetRDRHL() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg)
}

// SCI0.MDDR: Modulation Duty Register
func (o *SCI0_Type) SetMDDR(value uint8) {
	volatile.StoreUint8(&o.MDDR.Reg, value)
}
func (o *SCI0_Type) GetMDDR() uint8 {
	return volatile.LoadUint8(&o.MDDR.Reg)
}

// SCI0.DCCR: Data Compare Match Control Register
func (o *SCI0_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}

// SCI0.FCR: FIFO Control Register
func (o *SCI0_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI0_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}
func (o *SCI0_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI0_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI0_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI0_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI0_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}

// SCI0.FDR: FIFO Data Count Register
func (o *SCI0_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI0_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}

// SCI0.LSR: Line Status Register
func (o *SCI0_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI0_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI0_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}

// SCI0.CDR: Compare Match Data Register
func (o *SCI0_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI0.SPTR: Serial Port Register
func (o *SCI0_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}

// Inter-Integrated Circuit 0
type IIC0_Type struct {
	ICCR1  volatile.Register8 // 0x0
	ICCR2  volatile.Register8 // 0x1
	ICMR1  volatile.Register8 // 0x2
	ICMR2  volatile.Register8 // 0x3
	ICMR3  volatile.Register8 // 0x4
	ICFER  volatile.Register8 // 0x5
	ICSER  volatile.Register8 // 0x6
	ICIER  volatile.Register8 // 0x7
	ICSR1  volatile.Register8 // 0x8
	ICSR2  volatile.Register8 // 0x9
	SARL0  volatile.Register8 // 0xA
	SARU0  volatile.Register8 // 0xB
	SARL1  volatile.Register8 // 0xC
	SARU1  volatile.Register8 // 0xD
	SARL2  volatile.Register8 // 0xE
	SARU2  volatile.Register8 // 0xF
	ICBRL  volatile.Register8 // 0x10
	ICBRH  volatile.Register8 // 0x11
	ICDRT  volatile.Register8 // 0x12
	ICDRR  volatile.Register8 // 0x13
	_      [2]byte
	ICWUR  volatile.Register8 // 0x16
	ICWUR2 volatile.Register8 // 0x17
}

// IIC0.ICCR1: I2C Bus Control Register 1
func (o *IIC0_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC0.ICCR2: I2C Bus Control Register 2
func (o *IIC0_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}

// IIC0.ICMR1: I2C Bus Mode Register 1
func (o *IIC0_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC0_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC0.ICMR2: I2C Bus Mode Register 2
func (o *IIC0_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC0.ICMR3: I2C Bus Mode Register 3
func (o *IIC0_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC0_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC0.ICFER: I2C Bus Function Enable Register
func (o *IIC0_Type) SetICFER_FMPE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICFER_FMPE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC0.ICSER: I2C Bus Status Enable Register
func (o *IIC0_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC0.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC0_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC0.ICSR1: I2C Bus Status Register 1
func (o *IIC0_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC0.ICSR2: I2C Bus Status Register 2
func (o *IIC0_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC0.SARL0: Slave Address Register L%s
func (o *IIC0_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC0_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC0.SARU0: Slave Address Register U%s
func (o *IIC0_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC0.SARL1: Slave Address Register L%s
func (o *IIC0_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC0_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC0.SARU1: Slave Address Register U%s
func (o *IIC0_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC0.SARL2: Slave Address Register L%s
func (o *IIC0_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC0_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC0.SARU2: Slave Address Register U%s
func (o *IIC0_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC0.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC0_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC0.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC0_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC0.ICDRT: I2C Bus Transmit Data Register
func (o *IIC0_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC0_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC0.ICDRR: I2C Bus Receive Data Register
func (o *IIC0_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC0_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// IIC0.ICWUR: I2C Bus Wake Up Unit Register
func (o *IIC0_Type) SetICWUR_WUE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICWUR_WUE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICWUR_WUIE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICWUR_WUIE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICWUR_WUF(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICWUR_WUF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICWUR_WUACK(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICWUR_WUACK() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICWUR_WUAFA(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR_WUAFA() uint8 {
	return volatile.LoadUint8(&o.ICWUR.Reg) & 0x1
}

// IIC0.ICWUR2: I2C Bus Wake Up Unit Register 2
func (o *IIC0_Type) SetICWUR2_WUSYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICWUR2_WUSYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICWUR2_WUASYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICWUR2_WUASYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICWUR2_WUSEN(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR2_WUSEN() uint8 {
	return volatile.LoadUint8(&o.ICWUR2.Reg) & 0x1
}

// Inter-Integrated Circuit 1
type IIC1_Type struct {
	ICCR1 volatile.Register8 // 0x0
	ICCR2 volatile.Register8 // 0x1
	ICMR1 volatile.Register8 // 0x2
	ICMR2 volatile.Register8 // 0x3
	ICMR3 volatile.Register8 // 0x4
	ICFER volatile.Register8 // 0x5
	ICSER volatile.Register8 // 0x6
	ICIER volatile.Register8 // 0x7
	ICSR1 volatile.Register8 // 0x8
	ICSR2 volatile.Register8 // 0x9
	SARL0 volatile.Register8 // 0xA
	SARU0 volatile.Register8 // 0xB
	SARL1 volatile.Register8 // 0xC
	SARU1 volatile.Register8 // 0xD
	SARL2 volatile.Register8 // 0xE
	SARU2 volatile.Register8 // 0xF
	ICBRL volatile.Register8 // 0x10
	ICBRH volatile.Register8 // 0x11
	ICDRT volatile.Register8 // 0x12
	ICDRR volatile.Register8 // 0x13
}

// IIC1.ICCR1: I2C Bus Control Register 1
func (o *IIC1_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC1.ICCR2: I2C Bus Control Register 2
func (o *IIC1_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}

// IIC1.ICMR1: I2C Bus Mode Register 1
func (o *IIC1_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC1_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC1.ICMR2: I2C Bus Mode Register 2
func (o *IIC1_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC1.ICMR3: I2C Bus Mode Register 3
func (o *IIC1_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC1_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC1.ICFER: I2C Bus Function Enable Register
func (o *IIC1_Type) SetICFER_FMPE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICFER_FMPE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC1.ICSER: I2C Bus Status Enable Register
func (o *IIC1_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC1.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC1_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC1.ICSR1: I2C Bus Status Register 1
func (o *IIC1_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC1.ICSR2: I2C Bus Status Register 2
func (o *IIC1_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC1.SARL0: Slave Address Register L%s
func (o *IIC1_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC1_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC1.SARU0: Slave Address Register U%s
func (o *IIC1_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC1.SARL1: Slave Address Register L%s
func (o *IIC1_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC1_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC1.SARU1: Slave Address Register U%s
func (o *IIC1_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC1.SARL2: Slave Address Register L%s
func (o *IIC1_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC1_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC1.SARU2: Slave Address Register U%s
func (o *IIC1_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC1.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC1_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC1.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC1_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC1.ICDRT: I2C Bus Transmit Data Register
func (o *IIC1_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC1_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC1.ICDRR: I2C Bus Receive Data Register
func (o *IIC1_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC1_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// System Control
type SYSTEM_Type struct {
	_         [12]byte
	SBYCR     volatile.Register16 // 0xC
	_         [14]byte
	MSTPCRA   volatile.Register32 // 0x1C
	SCKDIVCR  volatile.Register32 // 0x20
	SCKDIVCR2 volatile.Register8  // 0x24
	_         byte
	SCKSCR    volatile.Register8 // 0x26
	_         byte
	PLLCCR    volatile.Register16 // 0x28
	PLLCR     volatile.Register8  // 0x2A
	_         [5]byte
	BCKCR     volatile.Register8 // 0x30
	_         byte
	MOSCCR    volatile.Register8 // 0x32
	_         [3]byte
	HOCOCR    volatile.Register8 // 0x36
	_         byte
	MOCOCR    volatile.Register8  // 0x38
	FLLCR1    volatile.Register8  // 0x39
	FLLCR2    volatile.Register16 // 0x3A
	OSCSF     volatile.Register8  // 0x3C
	_         byte
	CKOCR     volatile.Register8 // 0x3E
	TRCKCR    volatile.Register8 // 0x3F
	OSTDCR    volatile.Register8 // 0x40
	OSTDSR    volatile.Register8 // 0x41
	_         [16]byte
	EBCKOCR   volatile.Register8 // 0x52
	SDCKOCR   volatile.Register8 // 0x53
	_         [13]byte
	MOCOUTCR  volatile.Register8 // 0x61
	HOCOUTCR  volatile.Register8 // 0x62
	_         [47]byte
	SNZCR     volatile.Register8 // 0x92
	_         byte
	SNZEDCR   volatile.Register8 // 0x94
	_         [3]byte
	SNZREQCR  volatile.Register32 // 0x98
	_         [4]byte
	OPCCR     volatile.Register8 // 0xA0
	_         byte
	MOSCWTCR  volatile.Register8 // 0xA2
	_         [2]byte
	HOCOWTCR  volatile.Register8 // 0xA5
	_         [4]byte
	SOPCCR    volatile.Register8 // 0xAA
	_         [21]byte
	RSTSR1    volatile.Register16 // 0xC0
	_         [30]byte
	LVD1CR1   volatile.Register8 // 0xE0
	LVD1SR    volatile.Register8 // 0xE1
	LVD2CR1   volatile.Register8 // 0xE2
	LVD2SR    volatile.Register8 // 0xE3
	_         [794]byte
	PRCR      volatile.Register16 // 0x3FE
	DPSBYCR   volatile.Register8  // 0x400
	_         byte
	DPSIER0   volatile.Register8 // 0x402
	DPSIER1   volatile.Register8 // 0x403
	DPSIER2   volatile.Register8 // 0x404
	DPSIER3   volatile.Register8 // 0x405
	DPSIFR0   volatile.Register8 // 0x406
	DPSIFR1   volatile.Register8 // 0x407
	DPSIFR2   volatile.Register8 // 0x408
	DPSIFR3   volatile.Register8 // 0x409
	DPSIEGR0  volatile.Register8 // 0x40A
	DPSIEGR1  volatile.Register8 // 0x40B
	DPSIEGR2  volatile.Register8 // 0x40C
	_         byte
	SYOCDCR   volatile.Register8 // 0x40E
	STCONR    volatile.Register8 // 0x40F
	RSTSR0    volatile.Register8 // 0x410
	RSTSR2    volatile.Register8 // 0x411
	_         byte
	MOMCR     volatile.Register8 // 0x413
	_         [2]byte
	FWEPROR   volatile.Register8 // 0x416
	LVCMPCR   volatile.Register8 // 0x417
	LVDLVLR   volatile.Register8 // 0x418
	_         byte
	LVD1CR0   volatile.Register8 // 0x41A
	LVD2CR0   volatile.Register8 // 0x41B
	_         [100]byte
	SOSCCR    volatile.Register8 // 0x480
	SOMCR     volatile.Register8 // 0x481
	_         [14]byte
	LOCOCR    volatile.Register8 // 0x490
	_         byte
	LOCOUTCR  volatile.Register8 // 0x492
	_         [40]byte
	VBTICTLR  volatile.Register8 // 0x4BB
	_         [68]byte
	VBTBKR    [512]volatile.Register8 // 0x500
}

// SYSTEM.SBYCR: Standby Control Register
func (o *SYSTEM_Type) SetSBYCR_SSBY(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSBYCR_SSBY() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSBYCR_OPE(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetSBYCR_OPE() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x4000) >> 14
}

// SYSTEM.MSTPCRA: Module Stop Control Register A
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA7(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA7() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x1
}

// SYSTEM.SCKDIVCR: System Clock Division Control Register
func (o *SYSTEM_Type) SetSCKDIVCR_FCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSTEM_Type) GetSCKDIVCR_FCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000000) >> 28
}
func (o *SYSTEM_Type) SetSCKDIVCR_ICK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSTEM_Type) GetSCKDIVCR_ICK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000000) >> 24
}
func (o *SYSTEM_Type) SetSCKDIVCR_BCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000)|value<<16)
}
func (o *SYSTEM_Type) GetSCKDIVCR_BCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000) >> 16
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKA(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000)|value<<12)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKA() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000) >> 12
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKB(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x700)|value<<8)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKB() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x700) >> 8
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKC(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKC() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKD(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKD() uint32 {
	return volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7
}

// SYSTEM.SCKDIVCR2: System Clock Division Control Register 2
func (o *SYSTEM_Type) SetSCKDIVCR2_UCK(value uint8) {
	volatile.StoreUint8(&o.SCKDIVCR2.Reg, volatile.LoadUint8(&o.SCKDIVCR2.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetSCKDIVCR2_UCK() uint8 {
	return (volatile.LoadUint8(&o.SCKDIVCR2.Reg) & 0x70) >> 4
}

// SYSTEM.SCKSCR: System Clock Source Control Register
func (o *SYSTEM_Type) SetSCKSCR_CKSEL(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKSCR_CKSEL() uint8 {
	return volatile.LoadUint8(&o.SCKSCR.Reg) & 0x7
}

// SYSTEM.PLLCCR: PLL Clock Control Register
func (o *SYSTEM_Type) SetPLLCCR_PLLMUL(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x3f00)|value<<8)
}
func (o *SYSTEM_Type) GetPLLCCR_PLLMUL() uint16 {
	return (volatile.LoadUint16(&o.PLLCCR.Reg) & 0x3f00) >> 8
}
func (o *SYSTEM_Type) SetPLLCCR_PLSRCSEL(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetPLLCCR_PLSRCSEL() uint16 {
	return (volatile.LoadUint16(&o.PLLCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetPLLCCR_PLIDIV(value uint16) {
	volatile.StoreUint16(&o.PLLCCR.Reg, volatile.LoadUint16(&o.PLLCCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetPLLCCR_PLIDIV() uint16 {
	return volatile.LoadUint16(&o.PLLCCR.Reg) & 0x3
}

// SYSTEM.PLLCR: PLL Control Register
func (o *SYSTEM_Type) SetPLLCR_PLLSTP(value uint8) {
	volatile.StoreUint8(&o.PLLCR.Reg, volatile.LoadUint8(&o.PLLCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPLLCR_PLLSTP() uint8 {
	return volatile.LoadUint8(&o.PLLCR.Reg) & 0x1
}

// SYSTEM.BCKCR: External Bus Clock Control Register
func (o *SYSTEM_Type) SetBCKCR_BCLKDIV(value uint8) {
	volatile.StoreUint8(&o.BCKCR.Reg, volatile.LoadUint8(&o.BCKCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetBCKCR_BCLKDIV() uint8 {
	return volatile.LoadUint8(&o.BCKCR.Reg) & 0x1
}

// SYSTEM.MOSCCR: Main Clock Oscillator Control Register
func (o *SYSTEM_Type) SetMOSCCR_MOSTP(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOSCCR_MOSTP() uint8 {
	return volatile.LoadUint8(&o.MOSCCR.Reg) & 0x1
}

// SYSTEM.HOCOCR: High-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetHOCOCR_HCSTP(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetHOCOCR_HCSTP() uint8 {
	return volatile.LoadUint8(&o.HOCOCR.Reg) & 0x1
}

// SYSTEM.MOCOCR: Middle-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetMOCOCR_MCSTP(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOCOCR_MCSTP() uint8 {
	return volatile.LoadUint8(&o.MOCOCR.Reg) & 0x1
}

// SYSTEM.FLLCR1: FLL Control Register 1
func (o *SYSTEM_Type) SetFLLCR1_FLLEN(value uint8) {
	volatile.StoreUint8(&o.FLLCR1.Reg, volatile.LoadUint8(&o.FLLCR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetFLLCR1_FLLEN() uint8 {
	return volatile.LoadUint8(&o.FLLCR1.Reg) & 0x1
}

// SYSTEM.FLLCR2: FLL Control Register 2
func (o *SYSTEM_Type) SetFLLCR2_FLLCNTL(value uint16) {
	volatile.StoreUint16(&o.FLLCR2.Reg, volatile.LoadUint16(&o.FLLCR2.Reg)&^(0x7ff)|value)
}
func (o *SYSTEM_Type) GetFLLCR2_FLLCNTL() uint16 {
	return volatile.LoadUint16(&o.FLLCR2.Reg) & 0x7ff
}

// SYSTEM.OSCSF: Oscillation Stabilization Flag Register
func (o *SYSTEM_Type) SetOSCSF_PLLSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetOSCSF_PLLSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetOSCSF_MOSCSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetOSCSF_MOSCSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetOSCSF_HOCOSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSCSF_HOCOSF() uint8 {
	return volatile.LoadUint8(&o.OSCSF.Reg) & 0x1
}

// SYSTEM.CKOCR: Clock Out Control Register
func (o *SYSTEM_Type) SetCKOCR_CKOEN(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCKOCR_CKOEN() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetCKOCR_CKODIV(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetCKOCR_CKODIV() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetCKOCR_CKOSEL(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetCKOCR_CKOSEL() uint8 {
	return volatile.LoadUint8(&o.CKOCR.Reg) & 0x7
}

// SYSTEM.TRCKCR: Trace Clock Control Register
func (o *SYSTEM_Type) SetTRCKCR_TRCKEN(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetTRCKCR_TRCKEN() uint8 {
	return (volatile.LoadUint8(&o.TRCKCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetTRCKCR_TRCK(value uint8) {
	volatile.StoreUint8(&o.TRCKCR.Reg, volatile.LoadUint8(&o.TRCKCR.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetTRCKCR_TRCK() uint8 {
	return volatile.LoadUint8(&o.TRCKCR.Reg) & 0xf
}

// SYSTEM.OSTDCR: Oscillation Stop Detection Control Register
func (o *SYSTEM_Type) SetOSTDCR_OSTDE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDE() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetOSTDCR_OSTDIE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDIE() uint8 {
	return volatile.LoadUint8(&o.OSTDCR.Reg) & 0x1
}

// SYSTEM.OSTDSR: Oscillation Stop Detection Status Register
func (o *SYSTEM_Type) SetOSTDSR_OSTDF(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDSR_OSTDF() uint8 {
	return volatile.LoadUint8(&o.OSTDSR.Reg) & 0x1
}

// SYSTEM.EBCKOCR: External Bus Clock Output Control Register
func (o *SYSTEM_Type) SetEBCKOCR_EBCKOEN(value uint8) {
	volatile.StoreUint8(&o.EBCKOCR.Reg, volatile.LoadUint8(&o.EBCKOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetEBCKOCR_EBCKOEN() uint8 {
	return volatile.LoadUint8(&o.EBCKOCR.Reg) & 0x1
}

// SYSTEM.SDCKOCR: SDRAM Clock Output Control Register
func (o *SYSTEM_Type) SetSDCKOCR_SDCKOEN(value uint8) {
	volatile.StoreUint8(&o.SDCKOCR.Reg, volatile.LoadUint8(&o.SDCKOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSDCKOCR_SDCKOEN() uint8 {
	return volatile.LoadUint8(&o.SDCKOCR.Reg) & 0x1
}

// SYSTEM.MOCOUTCR: MOCO User Trimming Control Register
func (o *SYSTEM_Type) SetMOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.MOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetMOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.MOCOUTCR.Reg)
}

// SYSTEM.HOCOUTCR: HOCO User Trimming Control Register
func (o *SYSTEM_Type) SetHOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.HOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetHOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.HOCOUTCR.Reg)
}

// SYSTEM.SNZCR: Snooze Control Register
func (o *SYSTEM_Type) SetSNZCR_SNZE(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZCR_SNZE() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZCR_SNZDTCEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZCR_SNZDTCEN() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZCR_RXDREQEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZCR_RXDREQEN() uint8 {
	return volatile.LoadUint8(&o.SNZCR.Reg) & 0x1
}

// SYSTEM.SNZEDCR: Snooze End Control Register
func (o *SYSTEM_Type) SetSNZEDCR_SCI0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZEDCR_SCI0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZEDCR_AD1UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD1UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetSNZEDCR_AD1MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD1MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCNZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCNZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZEDCR_AGT1UNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZEDCR_AGT1UNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x1
}

// SYSTEM.SNZREQCR: Snooze Request Control Register
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN30(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN30() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN29(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN29() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN28(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN28() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN25(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN25() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN24(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN24() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN22(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN22() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN17(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN17() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN15(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN15() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN14(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x4000)|value<<14)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN14() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x4000) >> 14
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN13(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2000)|value<<13)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN13() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2000) >> 13
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN12(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN12() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN11(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN11() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN10(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN10() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN9(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN9() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN8(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN8() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN7(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN7() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN6(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN6() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN5(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN5() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN4(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN4() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN3(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN3() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1
}

// SYSTEM.OPCCR: Operating Power Control Register
func (o *SYSTEM_Type) SetOPCCR_OPCMTSF(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetOPCCR_OPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetOPCCR_OPCM(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetOPCCR_OPCM() uint8 {
	return volatile.LoadUint8(&o.OPCCR.Reg) & 0x3
}

// SYSTEM.MOSCWTCR: Main Clock Oscillator Wait Control Register
func (o *SYSTEM_Type) SetMOSCWTCR_MSTS(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetMOSCWTCR_MSTS() uint8 {
	return volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf
}

// SYSTEM.HOCOWTCR: High-speed on-chip oscillator wait control register
func (o *SYSTEM_Type) SetHOCOWTCR_HSTS(value uint8) {
	volatile.StoreUint8(&o.HOCOWTCR.Reg, volatile.LoadUint8(&o.HOCOWTCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetHOCOWTCR_HSTS() uint8 {
	return volatile.LoadUint8(&o.HOCOWTCR.Reg) & 0x7
}

// SYSTEM.SOPCCR: Sub Operating Power Control Register
func (o *SYSTEM_Type) SetSOPCCR_SOPCMTSF(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSOPCCR_SOPCM(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCM() uint8 {
	return volatile.LoadUint8(&o.SOPCCR.Reg) & 0x1
}

// SYSTEM.RSTSR1: Reset Status Register 1
func (o *SYSTEM_Type) SetRSTSR1_SPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetRSTSR1_SPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetRSTSR1_BUSMRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSMRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetRSTSR1_BUSSRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSSRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetRSTSR1_REERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetRSTSR1_REERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetRSTSR1_RPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetRSTSR1_RPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetRSTSR1_SWRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR1_SWRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR1_WDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR1_WDTRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR1_IWDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR1_IWDTRF() uint16 {
	return volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1
}

// SYSTEM.LVD1CR1: Voltage Monitor %s Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD1CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD1CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x3
}

// SYSTEM.LVD1SR: Voltage Monitor %s Circuit Status Register
func (o *SYSTEM_Type) SetLVD1SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD1SR.Reg) & 0x1
}

// SYSTEM.LVD2CR1: Voltage Monitor %s Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD2CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD2CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x3
}

// SYSTEM.LVD2SR: Voltage Monitor %s Circuit Status Register
func (o *SYSTEM_Type) SetLVD2SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD2SR.Reg) & 0x1
}

// SYSTEM.PRCR: Protect Register
func (o *SYSTEM_Type) SetPRCR_PRKEY(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xff00)|value<<8)
}
func (o *SYSTEM_Type) GetPRCR_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xff00) >> 8
}
func (o *SYSTEM_Type) SetPRCR_PRC3(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPRCR_PRC3() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPRCR_PRC1(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPRCR_PRC1() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPRCR_PRC0(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPRCR_PRC0() uint16 {
	return volatile.LoadUint16(&o.PRCR.Reg) & 0x1
}

// SYSTEM.DPSBYCR: Deep Standby Control Register
func (o *SYSTEM_Type) SetDPSBYCR_DPSBY(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetDPSBYCR_DPSBY() uint8 {
	return (volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetDPSBYCR_IOKEEP(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSBYCR_IOKEEP() uint8 {
	return (volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSBYCR_DEEPCUT(value uint8) {
	volatile.StoreUint8(&o.DPSBYCR.Reg, volatile.LoadUint8(&o.DPSBYCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetDPSBYCR_DEEPCUT() uint8 {
	return volatile.LoadUint8(&o.DPSBYCR.Reg) & 0x3
}

// SYSTEM.DPSIER0: Deep Standby Interrupt Enable Register 0
func (o *SYSTEM_Type) SetDPSIER0_DIRQ7E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ7E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ6E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ6E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ5E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ5E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ4E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ4E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ3E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ3E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ2E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ2E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ1E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ1E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIER0_DIRQ0E(value uint8) {
	volatile.StoreUint8(&o.DPSIER0.Reg, volatile.LoadUint8(&o.DPSIER0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIER0_DIRQ0E() uint8 {
	return volatile.LoadUint8(&o.DPSIER0.Reg) & 0x1
}

// SYSTEM.DPSIER1: Deep Standby Interrupt Enable Register 1
func (o *SYSTEM_Type) SetDPSIER1_DIRQ14E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ14E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ13E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ13E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ12E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ12E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ11E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ11E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ10E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ10E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ9E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ9E() uint8 {
	return (volatile.LoadUint8(&o.DPSIER1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIER1_DIRQ8E(value uint8) {
	volatile.StoreUint8(&o.DPSIER1.Reg, volatile.LoadUint8(&o.DPSIER1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIER1_DIRQ8E() uint8 {
	return volatile.LoadUint8(&o.DPSIER1.Reg) & 0x1
}

// SYSTEM.DPSIER2: Deep Standby Interrupt Enable Register 2
func (o *SYSTEM_Type) SetDPSIER2_DNMIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIER2_DNMIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIER2_DRTCAIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIER2_DRTCAIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIER2_DTRTCIIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIER2_DTRTCIIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIER2_DLVD2IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIER2_DLVD2IE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER2.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIER2_DLVD1IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER2.Reg, volatile.LoadUint8(&o.DPSIER2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIER2_DLVD1IE() uint8 {
	return volatile.LoadUint8(&o.DPSIER2.Reg) & 0x1
}

// SYSTEM.DPSIER3: Deep Standby Interrupt Enable Register 3
func (o *SYSTEM_Type) SetDPSIER3_DAGT1IE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIER3_DAGT1IE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER3.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIER3_DUSBHSIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIER3_DUSBHSIE() uint8 {
	return (volatile.LoadUint8(&o.DPSIER3.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIER3_DUSBFSIE(value uint8) {
	volatile.StoreUint8(&o.DPSIER3.Reg, volatile.LoadUint8(&o.DPSIER3.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIER3_DUSBFSIE() uint8 {
	return volatile.LoadUint8(&o.DPSIER3.Reg) & 0x1
}

// SYSTEM.DPSIFR0: Deep Standby Interrupt Flag Register 0
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ7F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ7F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ6F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ6F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ5F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ5F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ4F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ4F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ3F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ3F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ2F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ2F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ1F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ1F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIFR0_DIRQ0F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR0.Reg, volatile.LoadUint8(&o.DPSIFR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIFR0_DIRQ0F() uint8 {
	return volatile.LoadUint8(&o.DPSIFR0.Reg) & 0x1
}

// SYSTEM.DPSIFR1: Deep Standby Interrupt Flag Register 1
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ14F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ14F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ13F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ13F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ12F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ12F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ11F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ11F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ10F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ10F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ9F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ9F() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIFR1_DIRQ8F(value uint8) {
	volatile.StoreUint8(&o.DPSIFR1.Reg, volatile.LoadUint8(&o.DPSIFR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIFR1_DIRQ8F() uint8 {
	return volatile.LoadUint8(&o.DPSIFR1.Reg) & 0x1
}

// SYSTEM.DPSIFR2: Deep Standby Interrupt Flag Register 2
func (o *SYSTEM_Type) SetDPSIFR2_DNMIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIFR2_DNMIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIFR2_DRTCAIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIFR2_DRTCAIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIFR2_DTRTCIIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIFR2_DTRTCIIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIFR2_DLVD2IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIFR2_DLVD2IF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIFR2_DLVD1IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR2.Reg, volatile.LoadUint8(&o.DPSIFR2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIFR2_DLVD1IF() uint8 {
	return volatile.LoadUint8(&o.DPSIFR2.Reg) & 0x1
}

// SYSTEM.DPSIFR3: Deep Standby Interrupt Flag Register 3
func (o *SYSTEM_Type) SetDPSIFR3_DAGT1IF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIFR3_DAGT1IF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIFR3_DUSBHSIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIFR3_DUSBHSIF() uint8 {
	return (volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIFR3_DUSBFSIF(value uint8) {
	volatile.StoreUint8(&o.DPSIFR3.Reg, volatile.LoadUint8(&o.DPSIFR3.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIFR3_DUSBFSIF() uint8 {
	return volatile.LoadUint8(&o.DPSIFR3.Reg) & 0x1
}

// SYSTEM.DPSIEGR0: Deep Standby Interrupt Edge Register 0
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ7EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ7EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ6EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ6EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ5EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ5EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ4EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ4EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ3EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ3EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ2EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ2EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ1EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ1EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIEGR0_DIRQ0EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR0.Reg, volatile.LoadUint8(&o.DPSIEGR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIEGR0_DIRQ0EG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR0.Reg) & 0x1
}

// SYSTEM.DPSIEGR1: Deep Standby Interrupt Edge Register 1
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ14EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ14EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ13EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ13EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ12EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ12EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ11EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ11EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ10EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ10EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ9EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ9EG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIEGR1_DIRQ8EG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR1.Reg, volatile.LoadUint8(&o.DPSIEGR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIEGR1_DIRQ8EG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR1.Reg) & 0x1
}

// SYSTEM.DPSIEGR2: Deep Standby Interrupt Edge Register 2
func (o *SYSTEM_Type) SetDPSIEGR2_DNMIEG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetDPSIEGR2_DNMIEG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetDPSIEGR2_DLVD2IEG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetDPSIEGR2_DLVD2IEG() uint8 {
	return (volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetDPSIEGR2_DLVD1IEG(value uint8) {
	volatile.StoreUint8(&o.DPSIEGR2.Reg, volatile.LoadUint8(&o.DPSIEGR2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetDPSIEGR2_DLVD1IEG() uint8 {
	return volatile.LoadUint8(&o.DPSIEGR2.Reg) & 0x1
}

// SYSTEM.SYOCDCR: System Control OCD Control Register
func (o *SYSTEM_Type) SetSYOCDCR_DBGEN(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSYOCDCR_DBGEN() uint8 {
	return (volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSYOCDCR_DOCDF(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSYOCDCR_DOCDF() uint8 {
	return volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x1
}

// SYSTEM.STCONR: Standby Condition Register
func (o *SYSTEM_Type) SetSTCONR_STCON(value uint8) {
	volatile.StoreUint8(&o.STCONR.Reg, volatile.LoadUint8(&o.STCONR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetSTCONR_STCON() uint8 {
	return volatile.LoadUint8(&o.STCONR.Reg) & 0x3
}

// SYSTEM.RSTSR0: Reset Status Register 0
func (o *SYSTEM_Type) SetRSTSR0_DPSRSTF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetRSTSR0_DPSRSTF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetRSTSR0_LVD2RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD2RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetRSTSR0_LVD1RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD1RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR0_LVD0RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD0RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR0_PORF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR0_PORF() uint8 {
	return volatile.LoadUint8(&o.RSTSR0.Reg) & 0x1
}

// SYSTEM.RSTSR2: Reset Status Register 2
func (o *SYSTEM_Type) SetRSTSR2_CWSF(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR2_CWSF() uint8 {
	return volatile.LoadUint8(&o.RSTSR2.Reg) & 0x1
}

// SYSTEM.MOMCR: Main Clock Oscillator Mode Oscillation Control Register
func (o *SYSTEM_Type) SetMOMCR_AUTODRVEN(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetMOMCR_AUTODRVEN() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetMOMCR_MOSEL(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetMOMCR_MOSEL() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetMOMCR_MODRV0(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x30)|value<<4)
}
func (o *SYSTEM_Type) GetMOMCR_MODRV0() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x30) >> 4
}

// SYSTEM.FWEPROR: Flash P/E Protect Register
func (o *SYSTEM_Type) SetFWEPROR_FLWE(value uint8) {
	volatile.StoreUint8(&o.FWEPROR.Reg, volatile.LoadUint8(&o.FWEPROR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetFWEPROR_FLWE() uint8 {
	return volatile.LoadUint8(&o.FWEPROR.Reg) & 0x3
}

// SYSTEM.LVCMPCR: Voltage Monitor Circuit Control Register
func (o *SYSTEM_Type) SetLVCMPCR_LVD2E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD2E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVCMPCR_LVD1E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD1E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x20) >> 5
}

// SYSTEM.LVDLVLR: Voltage Detection Level Select Register
func (o *SYSTEM_Type) SetLVDLVLR_LVD2LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD2LVL() uint8 {
	return (volatile.LoadUint8(&o.LVDLVLR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetLVDLVLR_LVD1LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0x1f)|value)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD1LVL() uint8 {
	return volatile.LoadUint8(&o.LVDLVLR.Reg) & 0x1f
}

// SYSTEM.LVD1CR0: Voltage Monitor %s Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD1CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD1CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD1CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD1CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD1CR0_FSAMP(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x30)|value<<4)
}
func (o *SYSTEM_Type) GetLVD1CR0_FSAMP() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x30) >> 4
}
func (o *SYSTEM_Type) SetLVD1CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR0_DFDIS(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1CR0_DFDIS() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x1
}

// SYSTEM.LVD2CR0: Voltage Monitor %s Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD2CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD2CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD2CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD2CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD2CR0_FSAMP(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x30)|value<<4)
}
func (o *SYSTEM_Type) GetLVD2CR0_FSAMP() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x30) >> 4
}
func (o *SYSTEM_Type) SetLVD2CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR0_DFDIS(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2CR0_DFDIS() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x1
}

// SYSTEM.SOSCCR: Sub-clock oscillator control register
func (o *SYSTEM_Type) SetSOSCCR_SOSTP(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOSCCR_SOSTP() uint8 {
	return volatile.LoadUint8(&o.SOSCCR.Reg) & 0x1
}

// SYSTEM.SOMCR: Sub Clock Oscillator Mode Control Register
func (o *SYSTEM_Type) SetSOMCR_SODRV1(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSOMCR_SODRV1() uint8 {
	return (volatile.LoadUint8(&o.SOMCR.Reg) & 0x2) >> 1
}

// SYSTEM.LOCOCR: Low-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetLOCOCR_LCSTP(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLOCOCR_LCSTP() uint8 {
	return volatile.LoadUint8(&o.LOCOCR.Reg) & 0x1
}

// SYSTEM.LOCOUTCR: LOCO User Trimming Control Register
func (o *SYSTEM_Type) SetLOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.LOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetLOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.LOCOUTCR.Reg)
}

// SYSTEM.VBTICTLR: VBATT Input Control Register
func (o *SYSTEM_Type) SetVBTICTLR_VCH2INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH2INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetVBTICTLR_VCH1INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH1INEN() uint8 {
	return (volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetVBTICTLR_VCH0INEN(value uint8) {
	volatile.StoreUint8(&o.VBTICTLR.Reg, volatile.LoadUint8(&o.VBTICTLR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetVBTICTLR_VCH0INEN() uint8 {
	return volatile.LoadUint8(&o.VBTICTLR.Reg) & 0x1
}

// SYSTEM.VBTBKR: VBATT Backup Register [%s]
func (o *SYSTEM_Type) SetVBTBKR(idx int, value uint8) {
	volatile.StoreUint8(&o.VBTBKR[idx].Reg, value)
}
func (o *SYSTEM_Type) GetVBTBKR(idx int) uint8 {
	return volatile.LoadUint8(&o.VBTBKR[idx].Reg)
}

// DMA Controller for the Ethernet Controller Channel 0
type EDMAC0_Type struct {
	EDMR   volatile.Register32 // 0x0
	_      [4]byte
	EDTRR  volatile.Register32 // 0x8
	_      [4]byte
	EDRRR  volatile.Register32 // 0x10
	_      [4]byte
	TDLAR  volatile.Register32 // 0x18
	_      [4]byte
	RDLAR  volatile.Register32 // 0x20
	_      [4]byte
	EESR   volatile.Register32 // 0x28
	_      [4]byte
	EESIPR volatile.Register32 // 0x30
	_      [4]byte
	TRSCER volatile.Register32 // 0x38
	_      [4]byte
	RMFCR  volatile.Register32 // 0x40
	_      [4]byte
	TFTR   volatile.Register32 // 0x48
	_      [4]byte
	FDR    volatile.Register32 // 0x50
	_      [4]byte
	RMCR   volatile.Register32 // 0x58
	_      [8]byte
	TFUCR  volatile.Register32 // 0x64
	RFOCR  volatile.Register32 // 0x68
	IOSR   volatile.Register32 // 0x6C
	FCFTR  volatile.Register32 // 0x70
	_      [4]byte
	RPADIR volatile.Register32 // 0x78
	TRIMD  volatile.Register32 // 0x7C
	_      [72]byte
	RBWAR  volatile.Register32 // 0xC8
	RDFAR  volatile.Register32 // 0xCC
	_      [4]byte
	TBRAR  volatile.Register32 // 0xD4
	TDFAR  volatile.Register32 // 0xD8
}

// EDMAC0.EDMR: EDMAC Mode Register
func (o *EDMAC0_Type) SetEDMR_DE(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x40)|value<<6)
}
func (o *EDMAC0_Type) GetEDMR_DE() uint32 {
	return (volatile.LoadUint32(&o.EDMR.Reg) & 0x40) >> 6
}
func (o *EDMAC0_Type) SetEDMR_DL(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x30)|value<<4)
}
func (o *EDMAC0_Type) GetEDMR_DL() uint32 {
	return (volatile.LoadUint32(&o.EDMR.Reg) & 0x30) >> 4
}
func (o *EDMAC0_Type) SetEDMR_SWR(value uint32) {
	volatile.StoreUint32(&o.EDMR.Reg, volatile.LoadUint32(&o.EDMR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDMR_SWR() uint32 {
	return volatile.LoadUint32(&o.EDMR.Reg) & 0x1
}

// EDMAC0.EDTRR: EDMAC Transmit Request Register
func (o *EDMAC0_Type) SetEDTRR_TR(value uint32) {
	volatile.StoreUint32(&o.EDTRR.Reg, volatile.LoadUint32(&o.EDTRR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDTRR_TR() uint32 {
	return volatile.LoadUint32(&o.EDTRR.Reg) & 0x1
}

// EDMAC0.EDRRR: EDMAC Receive Request Register
func (o *EDMAC0_Type) SetEDRRR_RR(value uint32) {
	volatile.StoreUint32(&o.EDRRR.Reg, volatile.LoadUint32(&o.EDRRR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEDRRR_RR() uint32 {
	return volatile.LoadUint32(&o.EDRRR.Reg) & 0x1
}

// EDMAC0.TDLAR: Transmit Descriptor List Start Address Register
func (o *EDMAC0_Type) SetTDLAR(value uint32) {
	volatile.StoreUint32(&o.TDLAR.Reg, value)
}
func (o *EDMAC0_Type) GetTDLAR() uint32 {
	return volatile.LoadUint32(&o.TDLAR.Reg)
}

// EDMAC0.RDLAR: Receive Descriptor List Start Address Register
func (o *EDMAC0_Type) SetRDLAR(value uint32) {
	volatile.StoreUint32(&o.RDLAR.Reg, value)
}
func (o *EDMAC0_Type) GetRDLAR() uint32 {
	return volatile.LoadUint32(&o.RDLAR.Reg)
}

// EDMAC0.EESR: ETHERC/EDMAC Status Register
func (o *EDMAC0_Type) SetEESR_TWB(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x40000000)|value<<30)
}
func (o *EDMAC0_Type) GetEESR_TWB() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x40000000) >> 30
}
func (o *EDMAC0_Type) SetEESR_TABT(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x4000000)|value<<26)
}
func (o *EDMAC0_Type) GetEESR_TABT() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x4000000) >> 26
}
func (o *EDMAC0_Type) SetEESR_RABT(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x2000000)|value<<25)
}
func (o *EDMAC0_Type) GetEESR_RABT() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x2000000) >> 25
}
func (o *EDMAC0_Type) SetEESR_RFCOF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x1000000)|value<<24)
}
func (o *EDMAC0_Type) GetEESR_RFCOF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x1000000) >> 24
}
func (o *EDMAC0_Type) SetEESR_ADE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x800000)|value<<23)
}
func (o *EDMAC0_Type) GetEESR_ADE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x800000) >> 23
}
func (o *EDMAC0_Type) SetEESR_ECI(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x400000)|value<<22)
}
func (o *EDMAC0_Type) GetEESR_ECI() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x400000) >> 22
}
func (o *EDMAC0_Type) SetEESR_TC(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x200000)|value<<21)
}
func (o *EDMAC0_Type) GetEESR_TC() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x200000) >> 21
}
func (o *EDMAC0_Type) SetEESR_TDE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x100000)|value<<20)
}
func (o *EDMAC0_Type) GetEESR_TDE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x100000) >> 20
}
func (o *EDMAC0_Type) SetEESR_TFUF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x80000)|value<<19)
}
func (o *EDMAC0_Type) GetEESR_TFUF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x80000) >> 19
}
func (o *EDMAC0_Type) SetEESR_FR(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x40000)|value<<18)
}
func (o *EDMAC0_Type) GetEESR_FR() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x40000) >> 18
}
func (o *EDMAC0_Type) SetEESR_RDE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x20000)|value<<17)
}
func (o *EDMAC0_Type) GetEESR_RDE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x20000) >> 17
}
func (o *EDMAC0_Type) SetEESR_RFOF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x10000)|value<<16)
}
func (o *EDMAC0_Type) GetEESR_RFOF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x10000) >> 16
}
func (o *EDMAC0_Type) SetEESR_CND(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x800)|value<<11)
}
func (o *EDMAC0_Type) GetEESR_CND() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x800) >> 11
}
func (o *EDMAC0_Type) SetEESR_DLC(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x400)|value<<10)
}
func (o *EDMAC0_Type) GetEESR_DLC() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x400) >> 10
}
func (o *EDMAC0_Type) SetEESR_CD(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x200)|value<<9)
}
func (o *EDMAC0_Type) GetEESR_CD() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x200) >> 9
}
func (o *EDMAC0_Type) SetEESR_TRO(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x100)|value<<8)
}
func (o *EDMAC0_Type) GetEESR_TRO() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x100) >> 8
}
func (o *EDMAC0_Type) SetEESR_RMAF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetEESR_RMAF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x80) >> 7
}
func (o *EDMAC0_Type) SetEESR_RRF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetEESR_RRF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetEESR_RTLF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x8)|value<<3)
}
func (o *EDMAC0_Type) GetEESR_RTLF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x8) >> 3
}
func (o *EDMAC0_Type) SetEESR_RTSF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x4)|value<<2)
}
func (o *EDMAC0_Type) GetEESR_RTSF() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x4) >> 2
}
func (o *EDMAC0_Type) SetEESR_PRE(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x2)|value<<1)
}
func (o *EDMAC0_Type) GetEESR_PRE() uint32 {
	return (volatile.LoadUint32(&o.EESR.Reg) & 0x2) >> 1
}
func (o *EDMAC0_Type) SetEESR_CERF(value uint32) {
	volatile.StoreUint32(&o.EESR.Reg, volatile.LoadUint32(&o.EESR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEESR_CERF() uint32 {
	return volatile.LoadUint32(&o.EESR.Reg) & 0x1
}

// EDMAC0.EESIPR: ETHERC/EDMAC Status Interrupt Enable Register
func (o *EDMAC0_Type) SetEESIPR_TWBIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x40000000)|value<<30)
}
func (o *EDMAC0_Type) GetEESIPR_TWBIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x40000000) >> 30
}
func (o *EDMAC0_Type) SetEESIPR_TABTIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x4000000)|value<<26)
}
func (o *EDMAC0_Type) GetEESIPR_TABTIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x4000000) >> 26
}
func (o *EDMAC0_Type) SetEESIPR_RABTIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x2000000)|value<<25)
}
func (o *EDMAC0_Type) GetEESIPR_RABTIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x2000000) >> 25
}
func (o *EDMAC0_Type) SetEESIPR_RFCOFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x1000000)|value<<24)
}
func (o *EDMAC0_Type) GetEESIPR_RFCOFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x1000000) >> 24
}
func (o *EDMAC0_Type) SetEESIPR_ADEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x800000)|value<<23)
}
func (o *EDMAC0_Type) GetEESIPR_ADEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x800000) >> 23
}
func (o *EDMAC0_Type) SetEESIPR_ECIIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x400000)|value<<22)
}
func (o *EDMAC0_Type) GetEESIPR_ECIIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x400000) >> 22
}
func (o *EDMAC0_Type) SetEESIPR_TCIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x200000)|value<<21)
}
func (o *EDMAC0_Type) GetEESIPR_TCIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x200000) >> 21
}
func (o *EDMAC0_Type) SetEESIPR_TDEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x100000)|value<<20)
}
func (o *EDMAC0_Type) GetEESIPR_TDEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x100000) >> 20
}
func (o *EDMAC0_Type) SetEESIPR_TFUFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x80000)|value<<19)
}
func (o *EDMAC0_Type) GetEESIPR_TFUFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x80000) >> 19
}
func (o *EDMAC0_Type) SetEESIPR_FRIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x40000)|value<<18)
}
func (o *EDMAC0_Type) GetEESIPR_FRIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x40000) >> 18
}
func (o *EDMAC0_Type) SetEESIPR_RDEIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x20000)|value<<17)
}
func (o *EDMAC0_Type) GetEESIPR_RDEIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x20000) >> 17
}
func (o *EDMAC0_Type) SetEESIPR_RFOFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x10000)|value<<16)
}
func (o *EDMAC0_Type) GetEESIPR_RFOFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x10000) >> 16
}
func (o *EDMAC0_Type) SetEESIPR_CNDIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x800)|value<<11)
}
func (o *EDMAC0_Type) GetEESIPR_CNDIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x800) >> 11
}
func (o *EDMAC0_Type) SetEESIPR_DLCIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x400)|value<<10)
}
func (o *EDMAC0_Type) GetEESIPR_DLCIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x400) >> 10
}
func (o *EDMAC0_Type) SetEESIPR_CDIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x200)|value<<9)
}
func (o *EDMAC0_Type) GetEESIPR_CDIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x200) >> 9
}
func (o *EDMAC0_Type) SetEESIPR_TROIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x100)|value<<8)
}
func (o *EDMAC0_Type) GetEESIPR_TROIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x100) >> 8
}
func (o *EDMAC0_Type) SetEESIPR_RMAFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetEESIPR_RMAFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x80) >> 7
}
func (o *EDMAC0_Type) SetEESIPR_RRFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetEESIPR_RRFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetEESIPR_RTLFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x8)|value<<3)
}
func (o *EDMAC0_Type) GetEESIPR_RTLFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x8) >> 3
}
func (o *EDMAC0_Type) SetEESIPR_RTSFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x4)|value<<2)
}
func (o *EDMAC0_Type) GetEESIPR_RTSFIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x4) >> 2
}
func (o *EDMAC0_Type) SetEESIPR_PREIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x2)|value<<1)
}
func (o *EDMAC0_Type) GetEESIPR_PREIP() uint32 {
	return (volatile.LoadUint32(&o.EESIPR.Reg) & 0x2) >> 1
}
func (o *EDMAC0_Type) SetEESIPR_CERFIP(value uint32) {
	volatile.StoreUint32(&o.EESIPR.Reg, volatile.LoadUint32(&o.EESIPR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetEESIPR_CERFIP() uint32 {
	return volatile.LoadUint32(&o.EESIPR.Reg) & 0x1
}

// EDMAC0.TRSCER: ETHERC/EDMAC Transmit/Receive Status Copy Enable Register
func (o *EDMAC0_Type) SetTRSCER_RMAFCE(value uint32) {
	volatile.StoreUint32(&o.TRSCER.Reg, volatile.LoadUint32(&o.TRSCER.Reg)&^(0x80)|value<<7)
}
func (o *EDMAC0_Type) GetTRSCER_RMAFCE() uint32 {
	return (volatile.LoadUint32(&o.TRSCER.Reg) & 0x80) >> 7
}
func (o *EDMAC0_Type) SetTRSCER_RRFCE(value uint32) {
	volatile.StoreUint32(&o.TRSCER.Reg, volatile.LoadUint32(&o.TRSCER.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetTRSCER_RRFCE() uint32 {
	return (volatile.LoadUint32(&o.TRSCER.Reg) & 0x10) >> 4
}

// EDMAC0.RMFCR: Missed-Frame Counter Register
func (o *EDMAC0_Type) SetRMFCR_MFC(value uint32) {
	volatile.StoreUint32(&o.RMFCR.Reg, volatile.LoadUint32(&o.RMFCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetRMFCR_MFC() uint32 {
	return volatile.LoadUint32(&o.RMFCR.Reg) & 0xffff
}

// EDMAC0.TFTR: Transmit FIFO Threshold Register
func (o *EDMAC0_Type) SetTFTR_TFT(value uint32) {
	volatile.StoreUint32(&o.TFTR.Reg, volatile.LoadUint32(&o.TFTR.Reg)&^(0x7ff)|value)
}
func (o *EDMAC0_Type) GetTFTR_TFT() uint32 {
	return volatile.LoadUint32(&o.TFTR.Reg) & 0x7ff
}

// EDMAC0.FDR: Transmit FIFO Threshold Register
func (o *EDMAC0_Type) SetFDR_TFD(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *EDMAC0_Type) GetFDR_TFD() uint32 {
	return (volatile.LoadUint32(&o.FDR.Reg) & 0x1f00) >> 8
}
func (o *EDMAC0_Type) SetFDR_RFD(value uint32) {
	volatile.StoreUint32(&o.FDR.Reg, volatile.LoadUint32(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *EDMAC0_Type) GetFDR_RFD() uint32 {
	return volatile.LoadUint32(&o.FDR.Reg) & 0x1f
}

// EDMAC0.RMCR: Receive Method Control Register
func (o *EDMAC0_Type) SetRMCR_RNR(value uint32) {
	volatile.StoreUint32(&o.RMCR.Reg, volatile.LoadUint32(&o.RMCR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetRMCR_RNR() uint32 {
	return volatile.LoadUint32(&o.RMCR.Reg) & 0x1
}

// EDMAC0.TFUCR: Transmit FIFO Underflow Counter
func (o *EDMAC0_Type) SetTFUCR_UNDER(value uint32) {
	volatile.StoreUint32(&o.TFUCR.Reg, volatile.LoadUint32(&o.TFUCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetTFUCR_UNDER() uint32 {
	return volatile.LoadUint32(&o.TFUCR.Reg) & 0xffff
}

// EDMAC0.RFOCR: Receive FIFO Overflow Counter
func (o *EDMAC0_Type) SetRFOCR_OVER(value uint32) {
	volatile.StoreUint32(&o.RFOCR.Reg, volatile.LoadUint32(&o.RFOCR.Reg)&^(0xffff)|value)
}
func (o *EDMAC0_Type) GetRFOCR_OVER() uint32 {
	return volatile.LoadUint32(&o.RFOCR.Reg) & 0xffff
}

// EDMAC0.IOSR: Independent Output Signal Setting Register
func (o *EDMAC0_Type) SetIOSR_ELB(value uint32) {
	volatile.StoreUint32(&o.IOSR.Reg, volatile.LoadUint32(&o.IOSR.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetIOSR_ELB() uint32 {
	return volatile.LoadUint32(&o.IOSR.Reg) & 0x1
}

// EDMAC0.FCFTR: Flow Control Start FIFO Threshold Setting Register
func (o *EDMAC0_Type) SetFCFTR_RFFO(value uint32) {
	volatile.StoreUint32(&o.FCFTR.Reg, volatile.LoadUint32(&o.FCFTR.Reg)&^(0x70000)|value<<16)
}
func (o *EDMAC0_Type) GetFCFTR_RFFO() uint32 {
	return (volatile.LoadUint32(&o.FCFTR.Reg) & 0x70000) >> 16
}
func (o *EDMAC0_Type) SetFCFTR_RFDO(value uint32) {
	volatile.StoreUint32(&o.FCFTR.Reg, volatile.LoadUint32(&o.FCFTR.Reg)&^(0x7)|value)
}
func (o *EDMAC0_Type) GetFCFTR_RFDO() uint32 {
	return volatile.LoadUint32(&o.FCFTR.Reg) & 0x7
}

// EDMAC0.RPADIR: Receive Data Padding Insert Register
func (o *EDMAC0_Type) SetRPADIR_PADS(value uint32) {
	volatile.StoreUint32(&o.RPADIR.Reg, volatile.LoadUint32(&o.RPADIR.Reg)&^(0x30000)|value<<16)
}
func (o *EDMAC0_Type) GetRPADIR_PADS() uint32 {
	return (volatile.LoadUint32(&o.RPADIR.Reg) & 0x30000) >> 16
}
func (o *EDMAC0_Type) SetRPADIR_PADR(value uint32) {
	volatile.StoreUint32(&o.RPADIR.Reg, volatile.LoadUint32(&o.RPADIR.Reg)&^(0x3f)|value)
}
func (o *EDMAC0_Type) GetRPADIR_PADR() uint32 {
	return volatile.LoadUint32(&o.RPADIR.Reg) & 0x3f
}

// EDMAC0.TRIMD: Transmit Interrupt Setting Register
func (o *EDMAC0_Type) SetTRIMD_TIM(value uint32) {
	volatile.StoreUint32(&o.TRIMD.Reg, volatile.LoadUint32(&o.TRIMD.Reg)&^(0x10)|value<<4)
}
func (o *EDMAC0_Type) GetTRIMD_TIM() uint32 {
	return (volatile.LoadUint32(&o.TRIMD.Reg) & 0x10) >> 4
}
func (o *EDMAC0_Type) SetTRIMD_TIS(value uint32) {
	volatile.StoreUint32(&o.TRIMD.Reg, volatile.LoadUint32(&o.TRIMD.Reg)&^(0x1)|value)
}
func (o *EDMAC0_Type) GetTRIMD_TIS() uint32 {
	return volatile.LoadUint32(&o.TRIMD.Reg) & 0x1
}

// EDMAC0.RBWAR: Receive Buffer Write Address Register
func (o *EDMAC0_Type) SetRBWAR(value uint32) {
	volatile.StoreUint32(&o.RBWAR.Reg, value)
}
func (o *EDMAC0_Type) GetRBWAR() uint32 {
	return volatile.LoadUint32(&o.RBWAR.Reg)
}

// EDMAC0.RDFAR: Receive Descriptor Fetch Address Register
func (o *EDMAC0_Type) SetRDFAR(value uint32) {
	volatile.StoreUint32(&o.RDFAR.Reg, value)
}
func (o *EDMAC0_Type) GetRDFAR() uint32 {
	return volatile.LoadUint32(&o.RDFAR.Reg)
}

// EDMAC0.TBRAR: Transmit Buffer Read Address Register
func (o *EDMAC0_Type) SetTBRAR(value uint32) {
	volatile.StoreUint32(&o.TBRAR.Reg, value)
}
func (o *EDMAC0_Type) GetTBRAR() uint32 {
	return volatile.LoadUint32(&o.TBRAR.Reg)
}

// EDMAC0.TDFAR: Transmit Descriptor Fetch Address Register
func (o *EDMAC0_Type) SetTDFAR(value uint32) {
	volatile.StoreUint32(&o.TDFAR.Reg, value)
}
func (o *EDMAC0_Type) GetTDFAR() uint32 {
	return volatile.LoadUint32(&o.TDFAR.Reg)
}

// Ethernet Controller Channel 0
type ETHERC0_Type struct {
	ECMR     volatile.Register32 // 0x0
	_        [4]byte
	RFLR     volatile.Register32 // 0x8
	_        [4]byte
	ECSR     volatile.Register32 // 0x10
	_        [4]byte
	ECSIPR   volatile.Register32 // 0x18
	_        [4]byte
	PIR      volatile.Register32 // 0x20
	_        [4]byte
	PSR      volatile.Register32 // 0x28
	_        [20]byte
	RDMLR    volatile.Register32 // 0x40
	_        [12]byte
	IPGR     volatile.Register32 // 0x50
	APR      volatile.Register32 // 0x54
	MPR      volatile.Register32 // 0x58
	_        [4]byte
	RFCF     volatile.Register32 // 0x60
	TPAUSER  volatile.Register32 // 0x64
	TPAUSECR volatile.Register32 // 0x68
	BCFRR    volatile.Register32 // 0x6C
	_        [80]byte
	MAHR     volatile.Register32 // 0xC0
	_        [4]byte
	MALR     volatile.Register32 // 0xC8
	_        [4]byte
	TROCR    volatile.Register32 // 0xD0
	CDCR     volatile.Register32 // 0xD4
	LCCR     volatile.Register32 // 0xD8
	CNDCR    volatile.Register32 // 0xDC
	_        [4]byte
	CEFCR    volatile.Register32 // 0xE4
	FRECR    volatile.Register32 // 0xE8
	TSFRCR   volatile.Register32 // 0xEC
	TLFRCR   volatile.Register32 // 0xF0
	RFCR     volatile.Register32 // 0xF4
	MAFCR    volatile.Register32 // 0xF8
}

// ETHERC0.ECMR: ETHERC Mode Register
func (o *ETHERC0_Type) SetECMR_TPC(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x100000)|value<<20)
}
func (o *ETHERC0_Type) GetECMR_TPC() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x100000) >> 20
}
func (o *ETHERC0_Type) SetECMR_ZPF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x80000)|value<<19)
}
func (o *ETHERC0_Type) GetECMR_ZPF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x80000) >> 19
}
func (o *ETHERC0_Type) SetECMR_PFR(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x40000)|value<<18)
}
func (o *ETHERC0_Type) GetECMR_PFR() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x40000) >> 18
}
func (o *ETHERC0_Type) SetECMR_RXF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x20000)|value<<17)
}
func (o *ETHERC0_Type) GetECMR_RXF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x20000) >> 17
}
func (o *ETHERC0_Type) SetECMR_TXF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x10000)|value<<16)
}
func (o *ETHERC0_Type) GetECMR_TXF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x10000) >> 16
}
func (o *ETHERC0_Type) SetECMR_PRCEF(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x1000)|value<<12)
}
func (o *ETHERC0_Type) GetECMR_PRCEF() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x1000) >> 12
}
func (o *ETHERC0_Type) SetECMR_MPDE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x200)|value<<9)
}
func (o *ETHERC0_Type) GetECMR_MPDE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x200) >> 9
}
func (o *ETHERC0_Type) SetECMR_RE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x40)|value<<6)
}
func (o *ETHERC0_Type) GetECMR_RE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x40) >> 6
}
func (o *ETHERC0_Type) SetECMR_TE(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECMR_TE() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x20) >> 5
}
func (o *ETHERC0_Type) SetECMR_ILB(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERC0_Type) GetECMR_ILB() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x8) >> 3
}
func (o *ETHERC0_Type) SetECMR_RTM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECMR_RTM() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECMR_DM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECMR_DM() uint32 {
	return (volatile.LoadUint32(&o.ECMR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECMR_PRM(value uint32) {
	volatile.StoreUint32(&o.ECMR.Reg, volatile.LoadUint32(&o.ECMR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECMR_PRM() uint32 {
	return volatile.LoadUint32(&o.ECMR.Reg) & 0x1
}

// ETHERC0.RFLR: Receive Frame Maximum Length Register
func (o *ETHERC0_Type) SetRFLR_RFL(value uint32) {
	volatile.StoreUint32(&o.RFLR.Reg, volatile.LoadUint32(&o.RFLR.Reg)&^(0xfff)|value)
}
func (o *ETHERC0_Type) GetRFLR_RFL() uint32 {
	return volatile.LoadUint32(&o.RFLR.Reg) & 0xfff
}

// ETHERC0.ECSR: ETHERC Status Register
func (o *ETHERC0_Type) SetECSR_BFR(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECSR_BFR() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *ETHERC0_Type) SetECSR_PSRTO(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERC0_Type) GetECSR_PSRTO() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *ETHERC0_Type) SetECSR_LCHNG(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECSR_LCHNG() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECSR_MPD(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECSR_MPD() uint32 {
	return (volatile.LoadUint32(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECSR_ICD(value uint32) {
	volatile.StoreUint32(&o.ECSR.Reg, volatile.LoadUint32(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECSR_ICD() uint32 {
	return volatile.LoadUint32(&o.ECSR.Reg) & 0x1
}

// ETHERC0.ECSIPR: ETHERC Interrupt Enable Register
func (o *ETHERC0_Type) SetECSIPR_BFSIPR(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x20)|value<<5)
}
func (o *ETHERC0_Type) GetECSIPR_BFSIPR() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x20) >> 5
}
func (o *ETHERC0_Type) SetECSIPR_PSRTOIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x10)|value<<4)
}
func (o *ETHERC0_Type) GetECSIPR_PSRTOIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x10) >> 4
}
func (o *ETHERC0_Type) SetECSIPR_LCHNGIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetECSIPR_LCHNGIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetECSIPR_MPDIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetECSIPR_MPDIP() uint32 {
	return (volatile.LoadUint32(&o.ECSIPR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetECSIPR_ICDIP(value uint32) {
	volatile.StoreUint32(&o.ECSIPR.Reg, volatile.LoadUint32(&o.ECSIPR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetECSIPR_ICDIP() uint32 {
	return volatile.LoadUint32(&o.ECSIPR.Reg) & 0x1
}

// ETHERC0.PIR: PHY Interface Register
func (o *ETHERC0_Type) SetPIR_MDI(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x8)|value<<3)
}
func (o *ETHERC0_Type) GetPIR_MDI() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x8) >> 3
}
func (o *ETHERC0_Type) SetPIR_MDO(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x4)|value<<2)
}
func (o *ETHERC0_Type) GetPIR_MDO() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x4) >> 2
}
func (o *ETHERC0_Type) SetPIR_MMD(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x2)|value<<1)
}
func (o *ETHERC0_Type) GetPIR_MMD() uint32 {
	return (volatile.LoadUint32(&o.PIR.Reg) & 0x2) >> 1
}
func (o *ETHERC0_Type) SetPIR_MDC(value uint32) {
	volatile.StoreUint32(&o.PIR.Reg, volatile.LoadUint32(&o.PIR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetPIR_MDC() uint32 {
	return volatile.LoadUint32(&o.PIR.Reg) & 0x1
}

// ETHERC0.PSR: PHY Status Register
func (o *ETHERC0_Type) SetPSR_LMON(value uint32) {
	volatile.StoreUint32(&o.PSR.Reg, volatile.LoadUint32(&o.PSR.Reg)&^(0x1)|value)
}
func (o *ETHERC0_Type) GetPSR_LMON() uint32 {
	return volatile.LoadUint32(&o.PSR.Reg) & 0x1
}

// ETHERC0.RDMLR: Random Number Generation Counter Upper Limit Setting Register
func (o *ETHERC0_Type) SetRDMLR_RMD(value uint32) {
	volatile.StoreUint32(&o.RDMLR.Reg, volatile.LoadUint32(&o.RDMLR.Reg)&^(0xfffff)|value)
}
func (o *ETHERC0_Type) GetRDMLR_RMD() uint32 {
	return volatile.LoadUint32(&o.RDMLR.Reg) & 0xfffff
}

// ETHERC0.IPGR: IPG Register
func (o *ETHERC0_Type) SetIPGR_IPG(value uint32) {
	volatile.StoreUint32(&o.IPGR.Reg, volatile.LoadUint32(&o.IPGR.Reg)&^(0x1f)|value)
}
func (o *ETHERC0_Type) GetIPGR_IPG() uint32 {
	return volatile.LoadUint32(&o.IPGR.Reg) & 0x1f
}

// ETHERC0.APR: Automatic PAUSE Frame Register
func (o *ETHERC0_Type) SetAPR_AP(value uint32) {
	volatile.StoreUint32(&o.APR.Reg, volatile.LoadUint32(&o.APR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetAPR_AP() uint32 {
	return volatile.LoadUint32(&o.APR.Reg) & 0xffff
}

// ETHERC0.MPR: Manual PAUSE Frame Register
func (o *ETHERC0_Type) SetMPR_MP(value uint32) {
	volatile.StoreUint32(&o.MPR.Reg, volatile.LoadUint32(&o.MPR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetMPR_MP() uint32 {
	return volatile.LoadUint32(&o.MPR.Reg) & 0xffff
}

// ETHERC0.RFCF: Received PAUSE Frame Counter
func (o *ETHERC0_Type) SetRFCF_RPAUSE(value uint32) {
	volatile.StoreUint32(&o.RFCF.Reg, volatile.LoadUint32(&o.RFCF.Reg)&^(0xff)|value)
}
func (o *ETHERC0_Type) GetRFCF_RPAUSE() uint32 {
	return volatile.LoadUint32(&o.RFCF.Reg) & 0xff
}

// ETHERC0.TPAUSER: PAUSE Frame Retransmit Count Setting Register
func (o *ETHERC0_Type) SetTPAUSER_TPAUSE(value uint32) {
	volatile.StoreUint32(&o.TPAUSER.Reg, volatile.LoadUint32(&o.TPAUSER.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetTPAUSER_TPAUSE() uint32 {
	return volatile.LoadUint32(&o.TPAUSER.Reg) & 0xffff
}

// ETHERC0.BCFRR: Broadcast Frame Receive Count Setting Register
func (o *ETHERC0_Type) SetBCFRR_BCF(value uint32) {
	volatile.StoreUint32(&o.BCFRR.Reg, volatile.LoadUint32(&o.BCFRR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetBCFRR_BCF() uint32 {
	return volatile.LoadUint32(&o.BCFRR.Reg) & 0xffff
}

// ETHERC0.MAHR: MAC Address Upper Bit Register
func (o *ETHERC0_Type) SetMAHR(value uint32) {
	volatile.StoreUint32(&o.MAHR.Reg, value)
}
func (o *ETHERC0_Type) GetMAHR() uint32 {
	return volatile.LoadUint32(&o.MAHR.Reg)
}

// ETHERC0.MALR: MAC Address Lower Bit Register
func (o *ETHERC0_Type) SetMALR(value uint32) {
	volatile.StoreUint32(&o.MALR.Reg, volatile.LoadUint32(&o.MALR.Reg)&^(0xffff)|value)
}
func (o *ETHERC0_Type) GetMALR() uint32 {
	return volatile.LoadUint32(&o.MALR.Reg) & 0xffff
}

// ETHERC0.TROCR: Transmit Retry Over Counter Register
func (o *ETHERC0_Type) SetTROCR(value uint32) {
	volatile.StoreUint32(&o.TROCR.Reg, value)
}
func (o *ETHERC0_Type) GetTROCR() uint32 {
	return volatile.LoadUint32(&o.TROCR.Reg)
}

// ETHERC0.LCCR: Lost Carrier Counter Register
func (o *ETHERC0_Type) SetLCCR(value uint32) {
	volatile.StoreUint32(&o.LCCR.Reg, value)
}
func (o *ETHERC0_Type) GetLCCR() uint32 {
	return volatile.LoadUint32(&o.LCCR.Reg)
}

// ETHERC0.CNDCR: Carrier Not Detect Counter Register
func (o *ETHERC0_Type) SetCNDCR(value uint32) {
	volatile.StoreUint32(&o.CNDCR.Reg, value)
}
func (o *ETHERC0_Type) GetCNDCR() uint32 {
	return volatile.LoadUint32(&o.CNDCR.Reg)
}

// ETHERC0.CEFCR: CRC Error Frame Receive Counter Register
func (o *ETHERC0_Type) SetCEFCR(value uint32) {
	volatile.StoreUint32(&o.CEFCR.Reg, value)
}
func (o *ETHERC0_Type) GetCEFCR() uint32 {
	return volatile.LoadUint32(&o.CEFCR.Reg)
}

// ETHERC0.FRECR: Frame Receive Error Counter Register
func (o *ETHERC0_Type) SetFRECR(value uint32) {
	volatile.StoreUint32(&o.FRECR.Reg, value)
}
func (o *ETHERC0_Type) GetFRECR() uint32 {
	return volatile.LoadUint32(&o.FRECR.Reg)
}

// ETHERC0.TSFRCR: Too-Short Frame Receive Counter Register
func (o *ETHERC0_Type) SetTSFRCR(value uint32) {
	volatile.StoreUint32(&o.TSFRCR.Reg, value)
}
func (o *ETHERC0_Type) GetTSFRCR() uint32 {
	return volatile.LoadUint32(&o.TSFRCR.Reg)
}

// ETHERC0.TLFRCR: Too-Long Frame Receive Counter Register
func (o *ETHERC0_Type) SetTLFRCR(value uint32) {
	volatile.StoreUint32(&o.TLFRCR.Reg, value)
}
func (o *ETHERC0_Type) GetTLFRCR() uint32 {
	return volatile.LoadUint32(&o.TLFRCR.Reg)
}

// ETHERC0.RFCR: Received Alignment Error Frame Counter Register
func (o *ETHERC0_Type) SetRFCR(value uint32) {
	volatile.StoreUint32(&o.RFCR.Reg, value)
}
func (o *ETHERC0_Type) GetRFCR() uint32 {
	return volatile.LoadUint32(&o.RFCR.Reg)
}

// ETHERC0.MAFCR: Multicast Address Frame Receive Counter Register
func (o *ETHERC0_Type) SetMAFCR(value uint32) {
	volatile.StoreUint32(&o.MAFCR.Reg, value)
}
func (o *ETHERC0_Type) GetMAFCR() uint32 {
	return volatile.LoadUint32(&o.MAFCR.Reg)
}

// SD Host Interface 0
type SDHI0_Type struct {
	SD_CMD          volatile.Register32 // 0x0
	_               [4]byte
	SD_ARG          volatile.Register32 // 0x8
	SD_ARG1         volatile.Register32 // 0xC
	SD_STOP         volatile.Register32 // 0x10
	SD_SECCNT       volatile.Register32 // 0x14
	SD_RSP10        volatile.Register32 // 0x18
	SD_RSP1         volatile.Register32 // 0x1C
	SD_RSP32        volatile.Register32 // 0x20
	SD_RSP3         volatile.Register32 // 0x24
	SD_RSP54        volatile.Register32 // 0x28
	SD_RSP5         volatile.Register32 // 0x2C
	SD_RSP76        volatile.Register32 // 0x30
	SD_RSP7         volatile.Register32 // 0x34
	SD_INFO1        volatile.Register32 // 0x38
	SD_INFO2        volatile.Register32 // 0x3C
	SD_INFO1_MASK   volatile.Register32 // 0x40
	SD_INFO2_MASK   volatile.Register32 // 0x44
	SD_CLK_CTRL     volatile.Register32 // 0x48
	SD_SIZE         volatile.Register32 // 0x4C
	SD_OPTION       volatile.Register32 // 0x50
	_               [4]byte
	SD_ERR_STS1     volatile.Register32 // 0x58
	SD_ERR_STS2     volatile.Register32 // 0x5C
	SD_BUF0         volatile.Register32 // 0x60
	_               [4]byte
	SDIO_MODE       volatile.Register32 // 0x68
	SDIO_INFO1      volatile.Register32 // 0x6C
	SDIO_INFO1_MASK volatile.Register32 // 0x70
	_               [316]byte
	SD_DMAEN        volatile.Register32 // 0x1B0
	_               [12]byte
	SOFT_RST        volatile.Register32 // 0x1C0
	_               [8]byte
	SDIF_MODE       volatile.Register32 // 0x1CC
	_               [16]byte
	EXT_SWAP        volatile.Register32 // 0x1E0
}

// SDHI0.SD_CMD: Command Type Register
func (o *SDHI0_Type) SetSD_CMD_CMD12AT(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0xc000)|value<<14)
}
func (o *SDHI0_Type) GetSD_CMD_CMD12AT() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0xc000) >> 14
}
func (o *SDHI0_Type) SetSD_CMD_TRSTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_CMD_TRSTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_CMD_CMDRW(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x1000)|value<<12)
}
func (o *SDHI0_Type) GetSD_CMD_CMDRW() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x1000) >> 12
}
func (o *SDHI0_Type) SetSD_CMD_CMDTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x800)|value<<11)
}
func (o *SDHI0_Type) GetSD_CMD_CMDTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x800) >> 11
}
func (o *SDHI0_Type) SetSD_CMD_RSPTP(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x700)|value<<8)
}
func (o *SDHI0_Type) GetSD_CMD_RSPTP() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0x700) >> 8
}
func (o *SDHI0_Type) SetSD_CMD_ACMD(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0xc0)|value<<6)
}
func (o *SDHI0_Type) GetSD_CMD_ACMD() uint32 {
	return (volatile.LoadUint32(&o.SD_CMD.Reg) & 0xc0) >> 6
}
func (o *SDHI0_Type) SetSD_CMD_CMDIDX(value uint32) {
	volatile.StoreUint32(&o.SD_CMD.Reg, volatile.LoadUint32(&o.SD_CMD.Reg)&^(0x3f)|value)
}
func (o *SDHI0_Type) GetSD_CMD_CMDIDX() uint32 {
	return volatile.LoadUint32(&o.SD_CMD.Reg) & 0x3f
}

// SDHI0.SD_ARG: SD Command Argument Register
func (o *SDHI0_Type) SetSD_ARG(value uint32) {
	volatile.StoreUint32(&o.SD_ARG.Reg, value)
}
func (o *SDHI0_Type) GetSD_ARG() uint32 {
	return volatile.LoadUint32(&o.SD_ARG.Reg)
}

// SDHI0.SD_ARG1: SD Command Argument Register 1
func (o *SDHI0_Type) SetSD_ARG1(value uint32) {
	volatile.StoreUint32(&o.SD_ARG1.Reg, volatile.LoadUint32(&o.SD_ARG1.Reg)&^(0xffff)|value)
}
func (o *SDHI0_Type) GetSD_ARG1() uint32 {
	return volatile.LoadUint32(&o.SD_ARG1.Reg) & 0xffff
}

// SDHI0.SD_STOP: Data Stop Register
func (o *SDHI0_Type) SetSD_STOP_SEC(value uint32) {
	volatile.StoreUint32(&o.SD_STOP.Reg, volatile.LoadUint32(&o.SD_STOP.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_STOP_SEC() uint32 {
	return (volatile.LoadUint32(&o.SD_STOP.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_STOP_STP(value uint32) {
	volatile.StoreUint32(&o.SD_STOP.Reg, volatile.LoadUint32(&o.SD_STOP.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_STOP_STP() uint32 {
	return volatile.LoadUint32(&o.SD_STOP.Reg) & 0x1
}

// SDHI0.SD_SECCNT: Block Count Register
func (o *SDHI0_Type) SetSD_SECCNT(value uint32) {
	volatile.StoreUint32(&o.SD_SECCNT.Reg, value)
}
func (o *SDHI0_Type) GetSD_SECCNT() uint32 {
	return volatile.LoadUint32(&o.SD_SECCNT.Reg)
}

// SDHI0.SD_RSP10: SD Card Response Register 10
func (o *SDHI0_Type) SetSD_RSP10(value uint32) {
	volatile.StoreUint32(&o.SD_RSP10.Reg, value)
}
func (o *SDHI0_Type) GetSD_RSP10() uint32 {
	return volatile.LoadUint32(&o.SD_RSP10.Reg)
}

// SDHI0.SD_RSP1: SD Card Response Register 1
func (o *SDHI0_Type) SetSD_RSP1(value uint32) {
	volatile.StoreUint32(&o.SD_RSP1.Reg, volatile.LoadUint32(&o.SD_RSP1.Reg)&^(0xffff)|value)
}
func (o *SDHI0_Type) GetSD_RSP1() uint32 {
	return volatile.LoadUint32(&o.SD_RSP1.Reg) & 0xffff
}

// SDHI0.SD_RSP32: SD Card Response Register 32
func (o *SDHI0_Type) SetSD_RSP32(value uint32) {
	volatile.StoreUint32(&o.SD_RSP32.Reg, value)
}
func (o *SDHI0_Type) GetSD_RSP32() uint32 {
	return volatile.LoadUint32(&o.SD_RSP32.Reg)
}

// SDHI0.SD_RSP3: SD Card Response Register 3
func (o *SDHI0_Type) SetSD_RSP3(value uint32) {
	volatile.StoreUint32(&o.SD_RSP3.Reg, volatile.LoadUint32(&o.SD_RSP3.Reg)&^(0xffff)|value)
}
func (o *SDHI0_Type) GetSD_RSP3() uint32 {
	return volatile.LoadUint32(&o.SD_RSP3.Reg) & 0xffff
}

// SDHI0.SD_RSP54: SD Card Response Register 54
func (o *SDHI0_Type) SetSD_RSP54(value uint32) {
	volatile.StoreUint32(&o.SD_RSP54.Reg, value)
}
func (o *SDHI0_Type) GetSD_RSP54() uint32 {
	return volatile.LoadUint32(&o.SD_RSP54.Reg)
}

// SDHI0.SD_RSP5: SD Card Response Register 5
func (o *SDHI0_Type) SetSD_RSP5(value uint32) {
	volatile.StoreUint32(&o.SD_RSP5.Reg, volatile.LoadUint32(&o.SD_RSP5.Reg)&^(0xffff)|value)
}
func (o *SDHI0_Type) GetSD_RSP5() uint32 {
	return volatile.LoadUint32(&o.SD_RSP5.Reg) & 0xffff
}

// SDHI0.SD_RSP76: SD Card Response Register 76
func (o *SDHI0_Type) SetSD_RSP76(value uint32) {
	volatile.StoreUint32(&o.SD_RSP76.Reg, volatile.LoadUint32(&o.SD_RSP76.Reg)&^(0xffffff)|value)
}
func (o *SDHI0_Type) GetSD_RSP76() uint32 {
	return volatile.LoadUint32(&o.SD_RSP76.Reg) & 0xffffff
}

// SDHI0.SD_RSP7: SD Card Response Register 7
func (o *SDHI0_Type) SetSD_RSP7(value uint32) {
	volatile.StoreUint32(&o.SD_RSP7.Reg, volatile.LoadUint32(&o.SD_RSP7.Reg)&^(0xff)|value)
}
func (o *SDHI0_Type) GetSD_RSP7() uint32 {
	return volatile.LoadUint32(&o.SD_RSP7.Reg) & 0xff
}

// SDHI0.SD_INFO1: SD Card Interrupt Flag Register 1
func (o *SDHI0_Type) SetSD_INFO1_SDD3MON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x400)|value<<10)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3MON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x400) >> 10
}
func (o *SDHI0_Type) SetSD_INFO1_SDD3IN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3IN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO1_SDD3RM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO1_SDD3RM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO1_SDWPMON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetSD_INFO1_SDWPMON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x80) >> 7
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDMON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDMON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDIN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDIN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO1_SDCDRM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO1_SDCDRM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO1_ACEND(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO1_ACEND() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO1_RSPEND(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1.Reg, volatile.LoadUint32(&o.SD_INFO1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO1_RSPEND() uint32 {
	return volatile.LoadUint32(&o.SD_INFO1.Reg) & 0x1
}

// SDHI0.SD_INFO2: SD Card Interrupt Flag Register 2
func (o *SDHI0_Type) SetSD_INFO2_ILA(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_INFO2_ILA() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x8000) >> 15
}
func (o *SDHI0_Type) SetSD_INFO2_CBSY(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSD_INFO2_CBSY() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSD_INFO2_SD_CLK_CTRLEN(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_INFO2_SD_CLK_CTRLEN() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_INFO2_BWE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO2_BWE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO2_BRE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO2_BRE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO2_SDD0MON(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetSD_INFO2_SDD0MON() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x80) >> 7
}
func (o *SDHI0_Type) SetSD_INFO2_RSPTO(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_INFO2_RSPTO() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetSD_INFO2_ILR(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO2_ILR() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO2_ILW(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO2_ILW() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO2_DTO(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO2_DTO() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO2_ENDE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO2_ENDE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO2_CRCE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_INFO2_CRCE() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_INFO2_CMDE(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2.Reg, volatile.LoadUint32(&o.SD_INFO2.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO2_CMDE() uint32 {
	return volatile.LoadUint32(&o.SD_INFO2.Reg) & 0x1
}

// SDHI0.SD_INFO1_MASK: SD_INFO1 Interrupt Mask Register
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDD3INM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDD3INM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDD3RMM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDD3RMM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDCDINM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDCDINM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_SDCDRMM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_SDCDRMM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_ACENDM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_ACENDM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO1_MASK_RSPENDM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO1_MASK.Reg, volatile.LoadUint32(&o.SD_INFO1_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO1_MASK_RSPENDM() uint32 {
	return volatile.LoadUint32(&o.SD_INFO1_MASK.Reg) & 0x1
}

// SDHI0.SD_INFO2_MASK: SD_INFO2 Interrupt Mask Register
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILAM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILAM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x8000) >> 15
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_BWEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_BWEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_BREM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_BREM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_RSPTOM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_RSPTOM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILRM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILRM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ILWM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ILWM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_DTOM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_DTOM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_ENDEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_ENDEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_CRCEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_CRCEM() uint32 {
	return (volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_INFO2_MASK_CMDEM(value uint32) {
	volatile.StoreUint32(&o.SD_INFO2_MASK.Reg, volatile.LoadUint32(&o.SD_INFO2_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_INFO2_MASK_CMDEM() uint32 {
	return volatile.LoadUint32(&o.SD_INFO2_MASK.Reg) & 0x1
}

// SDHI0.SD_CLK_CTRL: SD Clock Control Register
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKCTRLEN(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKCTRLEN() uint32 {
	return (volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKEN(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKEN() uint32 {
	return (volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_CLK_CTRL_CLKSEL(value uint32) {
	volatile.StoreUint32(&o.SD_CLK_CTRL.Reg, volatile.LoadUint32(&o.SD_CLK_CTRL.Reg)&^(0xff)|value)
}
func (o *SDHI0_Type) GetSD_CLK_CTRL_CLKSEL() uint32 {
	return volatile.LoadUint32(&o.SD_CLK_CTRL.Reg) & 0xff
}

// SDHI0.SD_SIZE: Transfer Data Length Register
func (o *SDHI0_Type) SetSD_SIZE_LEN(value uint32) {
	volatile.StoreUint32(&o.SD_SIZE.Reg, volatile.LoadUint32(&o.SD_SIZE.Reg)&^(0x3ff)|value)
}
func (o *SDHI0_Type) GetSD_SIZE_LEN() uint32 {
	return volatile.LoadUint32(&o.SD_SIZE.Reg) & 0x3ff
}

// SDHI0.SD_OPTION: SD Card Access Control Option Register
func (o *SDHI0_Type) SetSD_OPTION_WIDTH(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSD_OPTION_WIDTH() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x8000) >> 15
}
func (o *SDHI0_Type) SetSD_OPTION_WIDTH8(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x2000)|value<<13)
}
func (o *SDHI0_Type) GetSD_OPTION_WIDTH8() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x2000) >> 13
}
func (o *SDHI0_Type) SetSD_OPTION_TOUTMASK(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_OPTION_TOUTMASK() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_OPTION_TOP(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0xf0)|value<<4)
}
func (o *SDHI0_Type) GetSD_OPTION_TOP() uint32 {
	return (volatile.LoadUint32(&o.SD_OPTION.Reg) & 0xf0) >> 4
}
func (o *SDHI0_Type) SetSD_OPTION_CTOP(value uint32) {
	volatile.StoreUint32(&o.SD_OPTION.Reg, volatile.LoadUint32(&o.SD_OPTION.Reg)&^(0xf)|value)
}
func (o *SDHI0_Type) GetSD_OPTION_CTOP() uint32 {
	return volatile.LoadUint32(&o.SD_OPTION.Reg) & 0xf
}

// SDHI0.SD_ERR_STS1: SD Error Status Register 1
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCTK(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x7000)|value<<12)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCTK() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x7000) >> 12
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCTKE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x800)|value<<11)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCTKE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x800) >> 11
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RDCRCE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x400)|value<<10)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RDCRCE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x400) >> 10
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPCRCE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPCRCE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPCRCE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPCRCE0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CRCLENE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CRCLENE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RDLENE(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RDLENE() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPLENE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPLENE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_ERR_STS1_RSPLENE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_RSPLENE0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CMDE1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CMDE1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_ERR_STS1_CMDE0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS1.Reg, volatile.LoadUint32(&o.SD_ERR_STS1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_ERR_STS1_CMDE0() uint32 {
	return volatile.LoadUint32(&o.SD_ERR_STS1.Reg) & 0x1
}

// SDHI0.SD_ERR_STS2: SD Error Status Register 2
func (o *SDHI0_Type) SetSD_ERR_STS2_CRCBSYTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_CRCBSYTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x40) >> 6
}
func (o *SDHI0_Type) SetSD_ERR_STS2_CRCTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x20)|value<<5)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_CRCTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x20) >> 5
}
func (o *SDHI0_Type) SetSD_ERR_STS2_RDTO(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x10)|value<<4)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RDTO() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x10) >> 4
}
func (o *SDHI0_Type) SetSD_ERR_STS2_BSYTO1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x8)|value<<3)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_BSYTO1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x8) >> 3
}
func (o *SDHI0_Type) SetSD_ERR_STS2_BSYTO0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_BSYTO0() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSD_ERR_STS2_RSPTO1(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RSPTO1() uint32 {
	return (volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x2) >> 1
}
func (o *SDHI0_Type) SetSD_ERR_STS2_RSPTO0(value uint32) {
	volatile.StoreUint32(&o.SD_ERR_STS2.Reg, volatile.LoadUint32(&o.SD_ERR_STS2.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSD_ERR_STS2_RSPTO0() uint32 {
	return volatile.LoadUint32(&o.SD_ERR_STS2.Reg) & 0x1
}

// SDHI0.SD_BUF0: SD Buffer Register
func (o *SDHI0_Type) SetSD_BUF0(value uint32) {
	volatile.StoreUint32(&o.SD_BUF0.Reg, value)
}
func (o *SDHI0_Type) GetSD_BUF0() uint32 {
	return volatile.LoadUint32(&o.SD_BUF0.Reg)
}

// SDHI0.SDIO_MODE: SDIO Mode Control Register
func (o *SDHI0_Type) SetSDIO_MODE_C52PUB(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x200)|value<<9)
}
func (o *SDHI0_Type) GetSDIO_MODE_C52PUB() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x200) >> 9
}
func (o *SDHI0_Type) SetSDIO_MODE_IOABT(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSDIO_MODE_IOABT() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x100) >> 8
}
func (o *SDHI0_Type) SetSDIO_MODE_RWREQ(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x4)|value<<2)
}
func (o *SDHI0_Type) GetSDIO_MODE_RWREQ() uint32 {
	return (volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x4) >> 2
}
func (o *SDHI0_Type) SetSDIO_MODE_INTEN(value uint32) {
	volatile.StoreUint32(&o.SDIO_MODE.Reg, volatile.LoadUint32(&o.SDIO_MODE.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_MODE_INTEN() uint32 {
	return volatile.LoadUint32(&o.SDIO_MODE.Reg) & 0x1
}

// SDHI0.SDIO_INFO1: SDIO Interrupt Flag Register 1
func (o *SDHI0_Type) SetSDIO_INFO1_EXWT(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSDIO_INFO1_EXWT() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x8000) >> 15
}
func (o *SDHI0_Type) SetSDIO_INFO1_EXPUB52(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSDIO_INFO1_EXPUB52() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSDIO_INFO1_IOIRQ(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1.Reg, volatile.LoadUint32(&o.SDIO_INFO1.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_INFO1_IOIRQ() uint32 {
	return volatile.LoadUint32(&o.SDIO_INFO1.Reg) & 0x1
}

// SDHI0.SDIO_INFO1_MASK: SDIO_INFO1 Interrupt Mask Register
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_EXWTM(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x8000)|value<<15)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_EXWTM() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x8000) >> 15
}
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_EXPUB52M(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x4000)|value<<14)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_EXPUB52M() uint32 {
	return (volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x4000) >> 14
}
func (o *SDHI0_Type) SetSDIO_INFO1_MASK_IOIRQM(value uint32) {
	volatile.StoreUint32(&o.SDIO_INFO1_MASK.Reg, volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSDIO_INFO1_MASK_IOIRQM() uint32 {
	return volatile.LoadUint32(&o.SDIO_INFO1_MASK.Reg) & 0x1
}

// SDHI0.SD_DMAEN: DMA Mode Enable Register
func (o *SDHI0_Type) SetSD_DMAEN_DMAEN(value uint32) {
	volatile.StoreUint32(&o.SD_DMAEN.Reg, volatile.LoadUint32(&o.SD_DMAEN.Reg)&^(0x2)|value<<1)
}
func (o *SDHI0_Type) GetSD_DMAEN_DMAEN() uint32 {
	return (volatile.LoadUint32(&o.SD_DMAEN.Reg) & 0x2) >> 1
}

// SDHI0.SOFT_RST: Software Reset Register
func (o *SDHI0_Type) SetSOFT_RST_SDRST(value uint32) {
	volatile.StoreUint32(&o.SOFT_RST.Reg, volatile.LoadUint32(&o.SOFT_RST.Reg)&^(0x1)|value)
}
func (o *SDHI0_Type) GetSOFT_RST_SDRST() uint32 {
	return volatile.LoadUint32(&o.SOFT_RST.Reg) & 0x1
}

// SDHI0.SDIF_MODE: SD Interface Mode Setting Register
func (o *SDHI0_Type) SetSDIF_MODE_NOCHKCR(value uint32) {
	volatile.StoreUint32(&o.SDIF_MODE.Reg, volatile.LoadUint32(&o.SDIF_MODE.Reg)&^(0x100)|value<<8)
}
func (o *SDHI0_Type) GetSDIF_MODE_NOCHKCR() uint32 {
	return (volatile.LoadUint32(&o.SDIF_MODE.Reg) & 0x100) >> 8
}

// SDHI0.EXT_SWAP: Swap Control Register
func (o *SDHI0_Type) SetEXT_SWAP_BRSWP(value uint32) {
	volatile.StoreUint32(&o.EXT_SWAP.Reg, volatile.LoadUint32(&o.EXT_SWAP.Reg)&^(0x80)|value<<7)
}
func (o *SDHI0_Type) GetEXT_SWAP_BRSWP() uint32 {
	return (volatile.LoadUint32(&o.EXT_SWAP.Reg) & 0x80) >> 7
}
func (o *SDHI0_Type) SetEXT_SWAP_BWSWP(value uint32) {
	volatile.StoreUint32(&o.EXT_SWAP.Reg, volatile.LoadUint32(&o.EXT_SWAP.Reg)&^(0x40)|value<<6)
}
func (o *SDHI0_Type) GetEXT_SWAP_BWSWP() uint32 {
	return (volatile.LoadUint32(&o.EXT_SWAP.Reg) & 0x40) >> 6
}

// CRC Calculator
type CRC_Type struct {
	CRCCR0 volatile.Register8 // 0x0
	CRCCR1 volatile.Register8 // 0x1
	_      [2]byte
	CRCDIR volatile.Register32 // 0x4
	CRCDOR volatile.Register32 // 0x8
	CRCSAR volatile.Register16 // 0xC
}

// CRC.CRCCR0: CRC Control Register0
func (o *CRC_Type) SetCRCCR0_DORCLR(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR0_DORCLR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR0_LMS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR0_LMS() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR0_GPS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x7)|value)
}
func (o *CRC_Type) GetCRCCR0_GPS() uint8 {
	return volatile.LoadUint8(&o.CRCCR0.Reg) & 0x7
}

// CRC.CRCCR1: CRC Control Register1
func (o *CRC_Type) SetCRCCR1_CRCSEN(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR1_CRCSEN() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR1_CRCSWR(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR1_CRCSWR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x40) >> 6
}

// CRC.CRCDIR: CRC Data Input Register
func (o *CRC_Type) SetCRCDIR(value uint32) {
	volatile.StoreUint32(&o.CRCDIR.Reg, value)
}
func (o *CRC_Type) GetCRCDIR() uint32 {
	return volatile.LoadUint32(&o.CRCDIR.Reg)
}

// CRC.CRCDOR: CRC Data Output Register
func (o *CRC_Type) SetCRCDOR(value uint32) {
	volatile.StoreUint32(&o.CRCDOR.Reg, value)
}
func (o *CRC_Type) GetCRCDOR() uint32 {
	return volatile.LoadUint32(&o.CRCDOR.Reg)
}

// CRC.CRCSAR: Snoop Address Register
func (o *CRC_Type) SetCRCSAR_CRCSA(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0x3fff)|value)
}
func (o *CRC_Type) GetCRCSAR_CRCSA() uint16 {
	return volatile.LoadUint16(&o.CRCSAR.Reg) & 0x3fff
}

// Capacitive Touch Sensing Unit
type CTSU_Type struct {
	CTSUCR0    volatile.Register8 // 0x0
	CTSUCR1    volatile.Register8 // 0x1
	CTSUSDPRS  volatile.Register8 // 0x2
	CTSUSST    volatile.Register8 // 0x3
	CTSUMCH0   volatile.Register8 // 0x4
	CTSUMCH1   volatile.Register8 // 0x5
	CTSUCHAC0  volatile.Register8 // 0x6
	CTSUCHAC1  volatile.Register8 // 0x7
	CTSUCHAC2  volatile.Register8 // 0x8
	_          [2]byte
	CTSUCHTRC0 volatile.Register8 // 0xB
	CTSUCHTRC1 volatile.Register8 // 0xC
	CTSUCHTRC2 volatile.Register8 // 0xD
	_          [2]byte
	CTSUDCLKC  volatile.Register8  // 0x10
	CTSUST     volatile.Register8  // 0x11
	CTSUSSC    volatile.Register16 // 0x12
	CTSUSO0    volatile.Register16 // 0x14
	CTSUSO1    volatile.Register16 // 0x16
	CTSUSC     volatile.Register16 // 0x18
	CTSURC     volatile.Register16 // 0x1A
	CTSUERRS   volatile.Register16 // 0x1C
}

// CTSU.CTSUCR0: CTSU Control Register 0
func (o *CTSU_Type) SetCTSUCR0_CTSUTXVSEL(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUTXVSEL() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUCR0_CTSUINIT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUINIT() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSNZ(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSNZ() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCR0_CTSUCAP(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUCAP() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSTRT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSTRT() uint8 {
	return volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x1
}

// CTSU.CTSUCR1: CTSU Control Register 1
func (o *CTSU_Type) SetCTSUCR1_CTSUMD(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUMD() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCLK(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCLK() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUCR1_CTSUATUNE1(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUATUNE1() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCSW(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCSW() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR1_CTSUPON(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUPON() uint8 {
	return volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x1
}

// CTSU.CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
func (o *CTSU_Type) SetCTSUSDPRS_CTSUSOFF(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUSOFF() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRMODE(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRMODE() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRRATIO(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRRATIO() uint8 {
	return volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0xf
}

// CTSU.CTSUSST: CTSU Sensor Stabilization Wait Control Register
func (o *CTSU_Type) SetCTSUSST(value uint8) {
	volatile.StoreUint8(&o.CTSUSST.Reg, value)
}
func (o *CTSU_Type) GetCTSUSST() uint8 {
	return volatile.LoadUint8(&o.CTSUSST.Reg)
}

// CTSU.CTSUMCH0: CTSU Measurement Channel Register 0
func (o *CTSU_Type) SetCTSUMCH0(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH0.Reg, volatile.LoadUint8(&o.CTSUMCH0.Reg)&^(0x1f)|value)
}
func (o *CTSU_Type) GetCTSUMCH0() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH0.Reg) & 0x1f
}

// CTSU.CTSUMCH1: CTSU Measurement Channel Register 1
func (o *CTSU_Type) SetCTSUMCH1(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH1.Reg, volatile.LoadUint8(&o.CTSUMCH1.Reg)&^(0x1f)|value)
}
func (o *CTSU_Type) GetCTSUMCH1() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH1.Reg) & 0x1f
}

// CTSU.CTSUCHAC0: CTSU Channel Enable Control Register 0
func (o *CTSU_Type) SetCTSUCHAC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC0.Reg)
}

// CTSU.CTSUCHAC1: CTSU Channel Enable Control Register 1
func (o *CTSU_Type) SetCTSUCHAC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC1.Reg)
}

// CTSU.CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
func (o *CTSU_Type) SetCTSUCHTRC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC0.Reg)
}

// CTSU.CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
func (o *CTSU_Type) SetCTSUCHTRC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC1.Reg)
}

// CTSU.CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSCNT(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSCNT() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSMOD(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x3)|value)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSMOD() uint8 {
	return volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x3
}

// CTSU.CTSUST: CTSU Status Register
func (o *CTSU_Type) SetCTSUST_CTSUPS(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUST_CTSUPS() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUST_CTSUROVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUST_CTSUROVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUST_CTSUSOVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUST_CTSUSOVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUST_CTSUDTSR(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUST_CTSUDTSR() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUST_CTSUSTC(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x7)|value)
}
func (o *CTSU_Type) GetCTSUST_CTSUSTC() uint8 {
	return volatile.LoadUint8(&o.CTSUST.Reg) & 0x7
}

// CTSU.CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
func (o *CTSU_Type) SetCTSUSSC_CTSUSSDIV(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xf00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSSC_CTSUSSDIV() uint16 {
	return (volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xf00) >> 8
}

// CTSU.CTSUSO0: CTSU Sensor Offset Register 0
func (o *CTSU_Type) SetCTSUSO0_CTSUSNUM(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0xfc00)|value<<10)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSNUM() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO0.Reg) & 0xfc00) >> 10
}
func (o *CTSU_Type) SetCTSUSO0_CTSUSO(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0x3ff)|value)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSO() uint16 {
	return volatile.LoadUint16(&o.CTSUSO0.Reg) & 0x3ff
}

// CTSU.CTSUSO1: CTSU Sensor Offset Register 1
func (o *CTSU_Type) SetCTSUSO1_CTSUICOG(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x6000)|value<<13)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUICOG() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x6000) >> 13
}
func (o *CTSU_Type) SetCTSUSO1_CTSUSDPA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x1f00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUSDPA() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x1f00) >> 8
}
func (o *CTSU_Type) SetCTSUSO1_CTSURICOA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSO1_CTSURICOA() uint16 {
	return volatile.LoadUint16(&o.CTSUSO1.Reg) & 0xff
}

// CTSU.CTSUSC: CTSU Sensor Counter
func (o *CTSU_Type) SetCTSUSC(value uint16) {
	volatile.StoreUint16(&o.CTSUSC.Reg, value)
}
func (o *CTSU_Type) GetCTSUSC() uint16 {
	return volatile.LoadUint16(&o.CTSUSC.Reg)
}

// CTSU.CTSURC: CTSU Reference Counter
func (o *CTSU_Type) SetCTSURC(value uint16) {
	volatile.StoreUint16(&o.CTSURC.Reg, value)
}
func (o *CTSU_Type) GetCTSURC() uint16 {
	return volatile.LoadUint16(&o.CTSURC.Reg)
}

// CTSU.CTSUERRS: CTSU Error Status Register
func (o *CTSU_Type) SetCTSUERRS_CTSUICOMP(value uint16) {
	volatile.StoreUint16(&o.CTSUERRS.Reg, volatile.LoadUint16(&o.CTSUERRS.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUERRS_CTSUICOMP() uint16 {
	return (volatile.LoadUint16(&o.CTSUERRS.Reg) & 0x8000) >> 15
}

// Bus Master MPU
type MMPU_Type struct {
	MMPUCTLA  volatile.Register16 // 0x0
	_         [256]byte
	MMPUPTA   volatile.Register16 // 0x102
	_         [252]byte
	MMPUACA0  volatile.Register16 // 0x200
	_         [2]byte
	MMPUSA0   volatile.Register32 // 0x204
	MMPUEA0   volatile.Register32 // 0x208
	_         [4]byte
	MMPUACA1  volatile.Register16 // 0x210
	_         [2]byte
	MMPUSA1   volatile.Register32 // 0x214
	MMPUEA1   volatile.Register32 // 0x218
	_         [4]byte
	MMPUACA2  volatile.Register16 // 0x220
	_         [2]byte
	MMPUSA2   volatile.Register32 // 0x224
	MMPUEA2   volatile.Register32 // 0x228
	_         [4]byte
	MMPUACA3  volatile.Register16 // 0x230
	_         [2]byte
	MMPUSA3   volatile.Register32 // 0x234
	MMPUEA3   volatile.Register32 // 0x238
	_         [4]byte
	MMPUACA4  volatile.Register16 // 0x240
	_         [2]byte
	MMPUSA4   volatile.Register32 // 0x244
	MMPUEA4   volatile.Register32 // 0x248
	_         [4]byte
	MMPUACA5  volatile.Register16 // 0x250
	_         [2]byte
	MMPUSA5   volatile.Register32 // 0x254
	MMPUEA5   volatile.Register32 // 0x258
	_         [4]byte
	MMPUACA6  volatile.Register16 // 0x260
	_         [2]byte
	MMPUSA6   volatile.Register32 // 0x264
	MMPUEA6   volatile.Register32 // 0x268
	_         [4]byte
	MMPUACA7  volatile.Register16 // 0x270
	_         [2]byte
	MMPUSA7   volatile.Register32 // 0x274
	MMPUEA7   volatile.Register32 // 0x278
	_         [4]byte
	MMPUACA8  volatile.Register16 // 0x280
	_         [2]byte
	MMPUSA8   volatile.Register32 // 0x284
	MMPUEA8   volatile.Register32 // 0x288
	_         [4]byte
	MMPUACA9  volatile.Register16 // 0x290
	_         [2]byte
	MMPUSA9   volatile.Register32 // 0x294
	MMPUEA9   volatile.Register32 // 0x298
	_         [4]byte
	MMPUACA10 volatile.Register16 // 0x2A0
	_         [2]byte
	MMPUSA10  volatile.Register32 // 0x2A4
	MMPUEA10  volatile.Register32 // 0x2A8
	_         [4]byte
	MMPUACA11 volatile.Register16 // 0x2B0
	_         [2]byte
	MMPUSA11  volatile.Register32 // 0x2B4
	MMPUEA11  volatile.Register32 // 0x2B8
	_         [4]byte
	MMPUACA12 volatile.Register16 // 0x2C0
	_         [2]byte
	MMPUSA12  volatile.Register32 // 0x2C4
	MMPUEA12  volatile.Register32 // 0x2C8
	_         [4]byte
	MMPUACA13 volatile.Register16 // 0x2D0
	_         [2]byte
	MMPUSA13  volatile.Register32 // 0x2D4
	MMPUEA13  volatile.Register32 // 0x2D8
	_         [4]byte
	MMPUACA14 volatile.Register16 // 0x2E0
	_         [2]byte
	MMPUSA14  volatile.Register32 // 0x2E4
	MMPUEA14  volatile.Register32 // 0x2E8
	_         [4]byte
	MMPUACA15 volatile.Register16 // 0x2F0
	_         [2]byte
	MMPUSA15  volatile.Register32 // 0x2F4
	MMPUEA15  volatile.Register32 // 0x2F8
	_         [4]byte
	MMPUACA16 volatile.Register16 // 0x300
	_         [2]byte
	MMPUSA16  volatile.Register32 // 0x304
	MMPUEA16  volatile.Register32 // 0x308
	_         [4]byte
	MMPUACA17 volatile.Register16 // 0x310
	_         [2]byte
	MMPUSA17  volatile.Register32 // 0x314
	MMPUEA17  volatile.Register32 // 0x318
	_         [4]byte
	MMPUACA18 volatile.Register16 // 0x320
	_         [2]byte
	MMPUSA18  volatile.Register32 // 0x324
	MMPUEA18  volatile.Register32 // 0x328
	_         [4]byte
	MMPUACA19 volatile.Register16 // 0x330
	_         [2]byte
	MMPUSA19  volatile.Register32 // 0x334
	MMPUEA19  volatile.Register32 // 0x338
	_         [4]byte
	MMPUACA20 volatile.Register16 // 0x340
	_         [2]byte
	MMPUSA20  volatile.Register32 // 0x344
	MMPUEA20  volatile.Register32 // 0x348
	_         [4]byte
	MMPUACA21 volatile.Register16 // 0x350
	_         [2]byte
	MMPUSA21  volatile.Register32 // 0x354
	MMPUEA21  volatile.Register32 // 0x358
	_         [4]byte
	MMPUACA22 volatile.Register16 // 0x360
	_         [2]byte
	MMPUSA22  volatile.Register32 // 0x364
	MMPUEA22  volatile.Register32 // 0x368
	_         [4]byte
	MMPUACA23 volatile.Register16 // 0x370
	_         [2]byte
	MMPUSA23  volatile.Register32 // 0x374
	MMPUEA23  volatile.Register32 // 0x378
	_         [4]byte
	MMPUACA24 volatile.Register16 // 0x380
	_         [2]byte
	MMPUSA24  volatile.Register32 // 0x384
	MMPUEA24  volatile.Register32 // 0x388
	_         [4]byte
	MMPUACA25 volatile.Register16 // 0x390
	_         [2]byte
	MMPUSA25  volatile.Register32 // 0x394
	MMPUEA25  volatile.Register32 // 0x398
	_         [4]byte
	MMPUACA26 volatile.Register16 // 0x3A0
	_         [2]byte
	MMPUSA26  volatile.Register32 // 0x3A4
	MMPUEA26  volatile.Register32 // 0x3A8
	_         [4]byte
	MMPUACA27 volatile.Register16 // 0x3B0
	_         [2]byte
	MMPUSA27  volatile.Register32 // 0x3B4
	MMPUEA27  volatile.Register32 // 0x3B8
	_         [4]byte
	MMPUACA28 volatile.Register16 // 0x3C0
	_         [2]byte
	MMPUSA28  volatile.Register32 // 0x3C4
	MMPUEA28  volatile.Register32 // 0x3C8
	_         [4]byte
	MMPUACA29 volatile.Register16 // 0x3D0
	_         [2]byte
	MMPUSA29  volatile.Register32 // 0x3D4
	MMPUEA29  volatile.Register32 // 0x3D8
	_         [4]byte
	MMPUACA30 volatile.Register16 // 0x3E0
	_         [2]byte
	MMPUSA30  volatile.Register32 // 0x3E4
	MMPUEA30  volatile.Register32 // 0x3E8
	_         [4]byte
	MMPUACA31 volatile.Register16 // 0x3F0
	_         [2]byte
	MMPUSA31  volatile.Register32 // 0x3F4
	MMPUEA31  volatile.Register32 // 0x3F8
	_         [4]byte
	MMPUCTLB  volatile.Register16 // 0x400
	_         [256]byte
	MMPUPTB   volatile.Register16 // 0x502
	_         [252]byte
	MMPUACB0  volatile.Register16 // 0x600
	_         [2]byte
	MMPUSB0   volatile.Register32 // 0x604
	MMPUEB0   volatile.Register32 // 0x608
	_         [4]byte
	MMPUACB1  volatile.Register16 // 0x610
	_         [2]byte
	MMPUSB1   volatile.Register32 // 0x614
	MMPUEB1   volatile.Register32 // 0x618
	_         [4]byte
	MMPUACB2  volatile.Register16 // 0x620
	_         [2]byte
	MMPUSB2   volatile.Register32 // 0x624
	MMPUEB2   volatile.Register32 // 0x628
	_         [4]byte
	MMPUACB3  volatile.Register16 // 0x630
	_         [2]byte
	MMPUSB3   volatile.Register32 // 0x634
	MMPUEB3   volatile.Register32 // 0x638
	_         [4]byte
	MMPUACB4  volatile.Register16 // 0x640
	_         [2]byte
	MMPUSB4   volatile.Register32 // 0x644
	MMPUEB4   volatile.Register32 // 0x648
	_         [4]byte
	MMPUACB5  volatile.Register16 // 0x650
	_         [2]byte
	MMPUSB5   volatile.Register32 // 0x654
	MMPUEB5   volatile.Register32 // 0x658
	_         [4]byte
	MMPUACB6  volatile.Register16 // 0x660
	_         [2]byte
	MMPUSB6   volatile.Register32 // 0x664
	MMPUEB6   volatile.Register32 // 0x668
	_         [4]byte
	MMPUACB7  volatile.Register16 // 0x670
	_         [2]byte
	MMPUSB7   volatile.Register32 // 0x674
	MMPUEB7   volatile.Register32 // 0x678
	_         [388]byte
	MMPUCTLC  volatile.Register16 // 0x800
	_         [256]byte
	MMPUPTC   volatile.Register16 // 0x902
	_         [252]byte
	MMPUACC0  volatile.Register16 // 0xA00
	_         [2]byte
	MMPUSC0   volatile.Register32 // 0xA04
	MMPUEC0   volatile.Register32 // 0xA08
	_         [4]byte
	MMPUACC1  volatile.Register16 // 0xA10
	_         [2]byte
	MMPUSC1   volatile.Register32 // 0xA14
	MMPUEC1   volatile.Register32 // 0xA18
	_         [4]byte
	MMPUACC2  volatile.Register16 // 0xA20
	_         [2]byte
	MMPUSC2   volatile.Register32 // 0xA24
	MMPUEC2   volatile.Register32 // 0xA28
	_         [4]byte
	MMPUACC3  volatile.Register16 // 0xA30
	_         [2]byte
	MMPUSC3   volatile.Register32 // 0xA34
	MMPUEC3   volatile.Register32 // 0xA38
	_         [4]byte
	MMPUACC4  volatile.Register16 // 0xA40
	_         [2]byte
	MMPUSC4   volatile.Register32 // 0xA44
	MMPUEC4   volatile.Register32 // 0xA48
	_         [4]byte
	MMPUACC5  volatile.Register16 // 0xA50
	_         [2]byte
	MMPUSC5   volatile.Register32 // 0xA54
	MMPUEC5   volatile.Register32 // 0xA58
	_         [4]byte
	MMPUACC6  volatile.Register16 // 0xA60
	_         [2]byte
	MMPUSC6   volatile.Register32 // 0xA64
	MMPUEC6   volatile.Register32 // 0xA68
	_         [4]byte
	MMPUACC7  volatile.Register16 // 0xA70
	_         [2]byte
	MMPUSC7   volatile.Register32 // 0xA74
	MMPUEC7   volatile.Register32 // 0xA78
}

// MMPU.MMPUCTLA: Bus Master MPU Control Register
func (o *MMPU_Type) SetMMPUCTLA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUCTLA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUCTLA_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUCTLA_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUCTLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUCTLA_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x1
}

// MMPU.MMPUPTA: Group A Protection of Register
func (o *MMPU_Type) SetMMPUPTA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUPTA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUPTA_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUPTA_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTA.Reg) & 0x1
}

// MMPU.MMPUACA0: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x1
}

// MMPU.MMPUSA0: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA0(value uint32) {
	volatile.StoreUint32(&o.MMPUSA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA0() uint32 {
	return volatile.LoadUint32(&o.MMPUSA0.Reg)
}

// MMPU.MMPUEA0: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA0(value uint32) {
	volatile.StoreUint32(&o.MMPUEA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA0() uint32 {
	return volatile.LoadUint32(&o.MMPUEA0.Reg)
}

// MMPU.MMPUACA1: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x1
}

// MMPU.MMPUSA1: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA1(value uint32) {
	volatile.StoreUint32(&o.MMPUSA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA1() uint32 {
	return volatile.LoadUint32(&o.MMPUSA1.Reg)
}

// MMPU.MMPUEA1: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA1(value uint32) {
	volatile.StoreUint32(&o.MMPUEA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA1() uint32 {
	return volatile.LoadUint32(&o.MMPUEA1.Reg)
}

// MMPU.MMPUACA2: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x1
}

// MMPU.MMPUSA2: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA2(value uint32) {
	volatile.StoreUint32(&o.MMPUSA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA2() uint32 {
	return volatile.LoadUint32(&o.MMPUSA2.Reg)
}

// MMPU.MMPUEA2: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA2(value uint32) {
	volatile.StoreUint32(&o.MMPUEA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA2() uint32 {
	return volatile.LoadUint32(&o.MMPUEA2.Reg)
}

// MMPU.MMPUACA3: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x1
}

// MMPU.MMPUSA3: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA3(value uint32) {
	volatile.StoreUint32(&o.MMPUSA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA3() uint32 {
	return volatile.LoadUint32(&o.MMPUSA3.Reg)
}

// MMPU.MMPUEA3: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA3(value uint32) {
	volatile.StoreUint32(&o.MMPUEA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA3() uint32 {
	return volatile.LoadUint32(&o.MMPUEA3.Reg)
}

// MMPU.MMPUACA4: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA4_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA4_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA4_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA4_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA4_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA4.Reg, volatile.LoadUint16(&o.MMPUACA4.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA4_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA4.Reg) & 0x1
}

// MMPU.MMPUSA4: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA4(value uint32) {
	volatile.StoreUint32(&o.MMPUSA4.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA4() uint32 {
	return volatile.LoadUint32(&o.MMPUSA4.Reg)
}

// MMPU.MMPUEA4: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA4(value uint32) {
	volatile.StoreUint32(&o.MMPUEA4.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA4() uint32 {
	return volatile.LoadUint32(&o.MMPUEA4.Reg)
}

// MMPU.MMPUACA5: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA5_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA5_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA5_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA5_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA5_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA5.Reg, volatile.LoadUint16(&o.MMPUACA5.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA5_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA5.Reg) & 0x1
}

// MMPU.MMPUSA5: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA5(value uint32) {
	volatile.StoreUint32(&o.MMPUSA5.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA5() uint32 {
	return volatile.LoadUint32(&o.MMPUSA5.Reg)
}

// MMPU.MMPUEA5: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA5(value uint32) {
	volatile.StoreUint32(&o.MMPUEA5.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA5() uint32 {
	return volatile.LoadUint32(&o.MMPUEA5.Reg)
}

// MMPU.MMPUACA6: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA6_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA6_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA6_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA6_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA6_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA6.Reg, volatile.LoadUint16(&o.MMPUACA6.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA6_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA6.Reg) & 0x1
}

// MMPU.MMPUSA6: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA6(value uint32) {
	volatile.StoreUint32(&o.MMPUSA6.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA6() uint32 {
	return volatile.LoadUint32(&o.MMPUSA6.Reg)
}

// MMPU.MMPUEA6: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA6(value uint32) {
	volatile.StoreUint32(&o.MMPUEA6.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA6() uint32 {
	return volatile.LoadUint32(&o.MMPUEA6.Reg)
}

// MMPU.MMPUACA7: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA7_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA7_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA7_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA7_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA7_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA7.Reg, volatile.LoadUint16(&o.MMPUACA7.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA7_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA7.Reg) & 0x1
}

// MMPU.MMPUSA7: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA7(value uint32) {
	volatile.StoreUint32(&o.MMPUSA7.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA7() uint32 {
	return volatile.LoadUint32(&o.MMPUSA7.Reg)
}

// MMPU.MMPUEA7: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA7(value uint32) {
	volatile.StoreUint32(&o.MMPUEA7.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA7() uint32 {
	return volatile.LoadUint32(&o.MMPUEA7.Reg)
}

// MMPU.MMPUACA8: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA8_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA8_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA8_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA8_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA8_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA8.Reg, volatile.LoadUint16(&o.MMPUACA8.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA8_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA8.Reg) & 0x1
}

// MMPU.MMPUSA8: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA8(value uint32) {
	volatile.StoreUint32(&o.MMPUSA8.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA8() uint32 {
	return volatile.LoadUint32(&o.MMPUSA8.Reg)
}

// MMPU.MMPUEA8: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA8(value uint32) {
	volatile.StoreUint32(&o.MMPUEA8.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA8() uint32 {
	return volatile.LoadUint32(&o.MMPUEA8.Reg)
}

// MMPU.MMPUACA9: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA9_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA9_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA9_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA9_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA9_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA9.Reg, volatile.LoadUint16(&o.MMPUACA9.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA9_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA9.Reg) & 0x1
}

// MMPU.MMPUSA9: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA9(value uint32) {
	volatile.StoreUint32(&o.MMPUSA9.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA9() uint32 {
	return volatile.LoadUint32(&o.MMPUSA9.Reg)
}

// MMPU.MMPUEA9: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA9(value uint32) {
	volatile.StoreUint32(&o.MMPUEA9.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA9() uint32 {
	return volatile.LoadUint32(&o.MMPUEA9.Reg)
}

// MMPU.MMPUACA10: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA10_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA10_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA10_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA10_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA10_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA10.Reg, volatile.LoadUint16(&o.MMPUACA10.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA10_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA10.Reg) & 0x1
}

// MMPU.MMPUSA10: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA10(value uint32) {
	volatile.StoreUint32(&o.MMPUSA10.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA10() uint32 {
	return volatile.LoadUint32(&o.MMPUSA10.Reg)
}

// MMPU.MMPUEA10: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA10(value uint32) {
	volatile.StoreUint32(&o.MMPUEA10.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA10() uint32 {
	return volatile.LoadUint32(&o.MMPUEA10.Reg)
}

// MMPU.MMPUACA11: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA11_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA11_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA11_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA11_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA11_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA11.Reg, volatile.LoadUint16(&o.MMPUACA11.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA11_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA11.Reg) & 0x1
}

// MMPU.MMPUSA11: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA11(value uint32) {
	volatile.StoreUint32(&o.MMPUSA11.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA11() uint32 {
	return volatile.LoadUint32(&o.MMPUSA11.Reg)
}

// MMPU.MMPUEA11: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA11(value uint32) {
	volatile.StoreUint32(&o.MMPUEA11.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA11() uint32 {
	return volatile.LoadUint32(&o.MMPUEA11.Reg)
}

// MMPU.MMPUACA12: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA12_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA12_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA12_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA12_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA12_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA12.Reg, volatile.LoadUint16(&o.MMPUACA12.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA12_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA12.Reg) & 0x1
}

// MMPU.MMPUSA12: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA12(value uint32) {
	volatile.StoreUint32(&o.MMPUSA12.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA12() uint32 {
	return volatile.LoadUint32(&o.MMPUSA12.Reg)
}

// MMPU.MMPUEA12: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA12(value uint32) {
	volatile.StoreUint32(&o.MMPUEA12.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA12() uint32 {
	return volatile.LoadUint32(&o.MMPUEA12.Reg)
}

// MMPU.MMPUACA13: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA13_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA13_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA13_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA13_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA13_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA13.Reg, volatile.LoadUint16(&o.MMPUACA13.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA13_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA13.Reg) & 0x1
}

// MMPU.MMPUSA13: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA13(value uint32) {
	volatile.StoreUint32(&o.MMPUSA13.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA13() uint32 {
	return volatile.LoadUint32(&o.MMPUSA13.Reg)
}

// MMPU.MMPUEA13: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA13(value uint32) {
	volatile.StoreUint32(&o.MMPUEA13.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA13() uint32 {
	return volatile.LoadUint32(&o.MMPUEA13.Reg)
}

// MMPU.MMPUACA14: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA14_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA14_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA14_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA14_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA14_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA14.Reg, volatile.LoadUint16(&o.MMPUACA14.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA14_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA14.Reg) & 0x1
}

// MMPU.MMPUSA14: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA14(value uint32) {
	volatile.StoreUint32(&o.MMPUSA14.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA14() uint32 {
	return volatile.LoadUint32(&o.MMPUSA14.Reg)
}

// MMPU.MMPUEA14: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA14(value uint32) {
	volatile.StoreUint32(&o.MMPUEA14.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA14() uint32 {
	return volatile.LoadUint32(&o.MMPUEA14.Reg)
}

// MMPU.MMPUACA15: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA15_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA15_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA15_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA15_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA15_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA15.Reg, volatile.LoadUint16(&o.MMPUACA15.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA15_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA15.Reg) & 0x1
}

// MMPU.MMPUSA15: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA15(value uint32) {
	volatile.StoreUint32(&o.MMPUSA15.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA15() uint32 {
	return volatile.LoadUint32(&o.MMPUSA15.Reg)
}

// MMPU.MMPUEA15: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA15(value uint32) {
	volatile.StoreUint32(&o.MMPUEA15.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA15() uint32 {
	return volatile.LoadUint32(&o.MMPUEA15.Reg)
}

// MMPU.MMPUACA16: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA16_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA16.Reg, volatile.LoadUint16(&o.MMPUACA16.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA16_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA16.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA16_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA16.Reg, volatile.LoadUint16(&o.MMPUACA16.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA16_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA16.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA16_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA16.Reg, volatile.LoadUint16(&o.MMPUACA16.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA16_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA16.Reg) & 0x1
}

// MMPU.MMPUSA16: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA16(value uint32) {
	volatile.StoreUint32(&o.MMPUSA16.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA16() uint32 {
	return volatile.LoadUint32(&o.MMPUSA16.Reg)
}

// MMPU.MMPUEA16: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA16(value uint32) {
	volatile.StoreUint32(&o.MMPUEA16.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA16() uint32 {
	return volatile.LoadUint32(&o.MMPUEA16.Reg)
}

// MMPU.MMPUACA17: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA17_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA17.Reg, volatile.LoadUint16(&o.MMPUACA17.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA17_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA17.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA17_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA17.Reg, volatile.LoadUint16(&o.MMPUACA17.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA17_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA17.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA17_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA17.Reg, volatile.LoadUint16(&o.MMPUACA17.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA17_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA17.Reg) & 0x1
}

// MMPU.MMPUSA17: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA17(value uint32) {
	volatile.StoreUint32(&o.MMPUSA17.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA17() uint32 {
	return volatile.LoadUint32(&o.MMPUSA17.Reg)
}

// MMPU.MMPUEA17: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA17(value uint32) {
	volatile.StoreUint32(&o.MMPUEA17.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA17() uint32 {
	return volatile.LoadUint32(&o.MMPUEA17.Reg)
}

// MMPU.MMPUACA18: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA18_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA18.Reg, volatile.LoadUint16(&o.MMPUACA18.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA18_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA18.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA18_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA18.Reg, volatile.LoadUint16(&o.MMPUACA18.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA18_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA18.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA18_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA18.Reg, volatile.LoadUint16(&o.MMPUACA18.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA18_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA18.Reg) & 0x1
}

// MMPU.MMPUSA18: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA18(value uint32) {
	volatile.StoreUint32(&o.MMPUSA18.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA18() uint32 {
	return volatile.LoadUint32(&o.MMPUSA18.Reg)
}

// MMPU.MMPUEA18: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA18(value uint32) {
	volatile.StoreUint32(&o.MMPUEA18.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA18() uint32 {
	return volatile.LoadUint32(&o.MMPUEA18.Reg)
}

// MMPU.MMPUACA19: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA19_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA19.Reg, volatile.LoadUint16(&o.MMPUACA19.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA19_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA19.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA19_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA19.Reg, volatile.LoadUint16(&o.MMPUACA19.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA19_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA19.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA19_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA19.Reg, volatile.LoadUint16(&o.MMPUACA19.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA19_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA19.Reg) & 0x1
}

// MMPU.MMPUSA19: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA19(value uint32) {
	volatile.StoreUint32(&o.MMPUSA19.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA19() uint32 {
	return volatile.LoadUint32(&o.MMPUSA19.Reg)
}

// MMPU.MMPUEA19: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA19(value uint32) {
	volatile.StoreUint32(&o.MMPUEA19.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA19() uint32 {
	return volatile.LoadUint32(&o.MMPUEA19.Reg)
}

// MMPU.MMPUACA20: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA20_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA20.Reg, volatile.LoadUint16(&o.MMPUACA20.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA20_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA20.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA20_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA20.Reg, volatile.LoadUint16(&o.MMPUACA20.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA20_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA20.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA20_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA20.Reg, volatile.LoadUint16(&o.MMPUACA20.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA20_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA20.Reg) & 0x1
}

// MMPU.MMPUSA20: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA20(value uint32) {
	volatile.StoreUint32(&o.MMPUSA20.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA20() uint32 {
	return volatile.LoadUint32(&o.MMPUSA20.Reg)
}

// MMPU.MMPUEA20: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA20(value uint32) {
	volatile.StoreUint32(&o.MMPUEA20.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA20() uint32 {
	return volatile.LoadUint32(&o.MMPUEA20.Reg)
}

// MMPU.MMPUACA21: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA21_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA21.Reg, volatile.LoadUint16(&o.MMPUACA21.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA21_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA21.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA21_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA21.Reg, volatile.LoadUint16(&o.MMPUACA21.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA21_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA21.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA21_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA21.Reg, volatile.LoadUint16(&o.MMPUACA21.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA21_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA21.Reg) & 0x1
}

// MMPU.MMPUSA21: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA21(value uint32) {
	volatile.StoreUint32(&o.MMPUSA21.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA21() uint32 {
	return volatile.LoadUint32(&o.MMPUSA21.Reg)
}

// MMPU.MMPUEA21: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA21(value uint32) {
	volatile.StoreUint32(&o.MMPUEA21.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA21() uint32 {
	return volatile.LoadUint32(&o.MMPUEA21.Reg)
}

// MMPU.MMPUACA22: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA22_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA22.Reg, volatile.LoadUint16(&o.MMPUACA22.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA22_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA22.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA22_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA22.Reg, volatile.LoadUint16(&o.MMPUACA22.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA22_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA22.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA22_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA22.Reg, volatile.LoadUint16(&o.MMPUACA22.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA22_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA22.Reg) & 0x1
}

// MMPU.MMPUSA22: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA22(value uint32) {
	volatile.StoreUint32(&o.MMPUSA22.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA22() uint32 {
	return volatile.LoadUint32(&o.MMPUSA22.Reg)
}

// MMPU.MMPUEA22: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA22(value uint32) {
	volatile.StoreUint32(&o.MMPUEA22.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA22() uint32 {
	return volatile.LoadUint32(&o.MMPUEA22.Reg)
}

// MMPU.MMPUACA23: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA23_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA23.Reg, volatile.LoadUint16(&o.MMPUACA23.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA23_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA23.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA23_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA23.Reg, volatile.LoadUint16(&o.MMPUACA23.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA23_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA23.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA23_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA23.Reg, volatile.LoadUint16(&o.MMPUACA23.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA23_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA23.Reg) & 0x1
}

// MMPU.MMPUSA23: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA23(value uint32) {
	volatile.StoreUint32(&o.MMPUSA23.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA23() uint32 {
	return volatile.LoadUint32(&o.MMPUSA23.Reg)
}

// MMPU.MMPUEA23: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA23(value uint32) {
	volatile.StoreUint32(&o.MMPUEA23.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA23() uint32 {
	return volatile.LoadUint32(&o.MMPUEA23.Reg)
}

// MMPU.MMPUACA24: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA24_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA24.Reg, volatile.LoadUint16(&o.MMPUACA24.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA24_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA24.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA24_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA24.Reg, volatile.LoadUint16(&o.MMPUACA24.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA24_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA24.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA24_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA24.Reg, volatile.LoadUint16(&o.MMPUACA24.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA24_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA24.Reg) & 0x1
}

// MMPU.MMPUSA24: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA24(value uint32) {
	volatile.StoreUint32(&o.MMPUSA24.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA24() uint32 {
	return volatile.LoadUint32(&o.MMPUSA24.Reg)
}

// MMPU.MMPUEA24: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA24(value uint32) {
	volatile.StoreUint32(&o.MMPUEA24.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA24() uint32 {
	return volatile.LoadUint32(&o.MMPUEA24.Reg)
}

// MMPU.MMPUACA25: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA25_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA25.Reg, volatile.LoadUint16(&o.MMPUACA25.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA25_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA25.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA25_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA25.Reg, volatile.LoadUint16(&o.MMPUACA25.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA25_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA25.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA25_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA25.Reg, volatile.LoadUint16(&o.MMPUACA25.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA25_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA25.Reg) & 0x1
}

// MMPU.MMPUSA25: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA25(value uint32) {
	volatile.StoreUint32(&o.MMPUSA25.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA25() uint32 {
	return volatile.LoadUint32(&o.MMPUSA25.Reg)
}

// MMPU.MMPUEA25: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA25(value uint32) {
	volatile.StoreUint32(&o.MMPUEA25.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA25() uint32 {
	return volatile.LoadUint32(&o.MMPUEA25.Reg)
}

// MMPU.MMPUACA26: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA26_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA26.Reg, volatile.LoadUint16(&o.MMPUACA26.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA26_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA26.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA26_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA26.Reg, volatile.LoadUint16(&o.MMPUACA26.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA26_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA26.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA26_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA26.Reg, volatile.LoadUint16(&o.MMPUACA26.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA26_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA26.Reg) & 0x1
}

// MMPU.MMPUSA26: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA26(value uint32) {
	volatile.StoreUint32(&o.MMPUSA26.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA26() uint32 {
	return volatile.LoadUint32(&o.MMPUSA26.Reg)
}

// MMPU.MMPUEA26: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA26(value uint32) {
	volatile.StoreUint32(&o.MMPUEA26.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA26() uint32 {
	return volatile.LoadUint32(&o.MMPUEA26.Reg)
}

// MMPU.MMPUACA27: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA27_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA27.Reg, volatile.LoadUint16(&o.MMPUACA27.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA27_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA27.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA27_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA27.Reg, volatile.LoadUint16(&o.MMPUACA27.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA27_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA27.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA27_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA27.Reg, volatile.LoadUint16(&o.MMPUACA27.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA27_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA27.Reg) & 0x1
}

// MMPU.MMPUSA27: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA27(value uint32) {
	volatile.StoreUint32(&o.MMPUSA27.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA27() uint32 {
	return volatile.LoadUint32(&o.MMPUSA27.Reg)
}

// MMPU.MMPUEA27: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA27(value uint32) {
	volatile.StoreUint32(&o.MMPUEA27.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA27() uint32 {
	return volatile.LoadUint32(&o.MMPUEA27.Reg)
}

// MMPU.MMPUACA28: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA28_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA28.Reg, volatile.LoadUint16(&o.MMPUACA28.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA28_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA28.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA28_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA28.Reg, volatile.LoadUint16(&o.MMPUACA28.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA28_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA28.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA28_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA28.Reg, volatile.LoadUint16(&o.MMPUACA28.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA28_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA28.Reg) & 0x1
}

// MMPU.MMPUSA28: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA28(value uint32) {
	volatile.StoreUint32(&o.MMPUSA28.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA28() uint32 {
	return volatile.LoadUint32(&o.MMPUSA28.Reg)
}

// MMPU.MMPUEA28: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA28(value uint32) {
	volatile.StoreUint32(&o.MMPUEA28.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA28() uint32 {
	return volatile.LoadUint32(&o.MMPUEA28.Reg)
}

// MMPU.MMPUACA29: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA29_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA29.Reg, volatile.LoadUint16(&o.MMPUACA29.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA29_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA29.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA29_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA29.Reg, volatile.LoadUint16(&o.MMPUACA29.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA29_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA29.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA29_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA29.Reg, volatile.LoadUint16(&o.MMPUACA29.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA29_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA29.Reg) & 0x1
}

// MMPU.MMPUSA29: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA29(value uint32) {
	volatile.StoreUint32(&o.MMPUSA29.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA29() uint32 {
	return volatile.LoadUint32(&o.MMPUSA29.Reg)
}

// MMPU.MMPUEA29: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA29(value uint32) {
	volatile.StoreUint32(&o.MMPUEA29.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA29() uint32 {
	return volatile.LoadUint32(&o.MMPUEA29.Reg)
}

// MMPU.MMPUACA30: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA30_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA30.Reg, volatile.LoadUint16(&o.MMPUACA30.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA30_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA30.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA30_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA30.Reg, volatile.LoadUint16(&o.MMPUACA30.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA30_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA30.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA30_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA30.Reg, volatile.LoadUint16(&o.MMPUACA30.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA30_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA30.Reg) & 0x1
}

// MMPU.MMPUSA30: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA30(value uint32) {
	volatile.StoreUint32(&o.MMPUSA30.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA30() uint32 {
	return volatile.LoadUint32(&o.MMPUSA30.Reg)
}

// MMPU.MMPUEA30: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA30(value uint32) {
	volatile.StoreUint32(&o.MMPUEA30.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA30() uint32 {
	return volatile.LoadUint32(&o.MMPUEA30.Reg)
}

// MMPU.MMPUACA31: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA31_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA31.Reg, volatile.LoadUint16(&o.MMPUACA31.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA31_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA31.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA31_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA31.Reg, volatile.LoadUint16(&o.MMPUACA31.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA31_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA31.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA31_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA31.Reg, volatile.LoadUint16(&o.MMPUACA31.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA31_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA31.Reg) & 0x1
}

// MMPU.MMPUSA31: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA31(value uint32) {
	volatile.StoreUint32(&o.MMPUSA31.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA31() uint32 {
	return volatile.LoadUint32(&o.MMPUSA31.Reg)
}

// MMPU.MMPUEA31: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA31(value uint32) {
	volatile.StoreUint32(&o.MMPUEA31.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA31() uint32 {
	return volatile.LoadUint32(&o.MMPUEA31.Reg)
}

// MMPU.MMPUCTLB: Bus Master MPU Control Register
func (o *MMPU_Type) SetMMPUCTLB_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLB.Reg, volatile.LoadUint16(&o.MMPUCTLB.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUCTLB_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLB.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUCTLB_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLB.Reg, volatile.LoadUint16(&o.MMPUCTLB.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUCTLB_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLB.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUCTLB_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLB.Reg, volatile.LoadUint16(&o.MMPUCTLB.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUCTLB_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLB.Reg) & 0x1
}

// MMPU.MMPUPTB: Group B Protection of Register
func (o *MMPU_Type) SetMMPUPTB_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTB.Reg, volatile.LoadUint16(&o.MMPUPTB.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUPTB_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTB.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUPTB_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTB.Reg, volatile.LoadUint16(&o.MMPUPTB.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUPTB_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTB.Reg) & 0x1
}

// MMPU.MMPUACB0: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB0.Reg, volatile.LoadUint16(&o.MMPUACB0.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB0.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB0.Reg, volatile.LoadUint16(&o.MMPUACB0.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB0.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB0.Reg, volatile.LoadUint16(&o.MMPUACB0.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB0.Reg) & 0x1
}

// MMPU.MMPUSB0: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB0(value uint32) {
	volatile.StoreUint32(&o.MMPUSB0.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB0() uint32 {
	return volatile.LoadUint32(&o.MMPUSB0.Reg)
}

// MMPU.MMPUEB0: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB0(value uint32) {
	volatile.StoreUint32(&o.MMPUEB0.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB0() uint32 {
	return volatile.LoadUint32(&o.MMPUEB0.Reg)
}

// MMPU.MMPUACB1: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB1.Reg, volatile.LoadUint16(&o.MMPUACB1.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB1.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB1.Reg, volatile.LoadUint16(&o.MMPUACB1.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB1.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB1.Reg, volatile.LoadUint16(&o.MMPUACB1.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB1.Reg) & 0x1
}

// MMPU.MMPUSB1: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB1(value uint32) {
	volatile.StoreUint32(&o.MMPUSB1.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB1() uint32 {
	return volatile.LoadUint32(&o.MMPUSB1.Reg)
}

// MMPU.MMPUEB1: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB1(value uint32) {
	volatile.StoreUint32(&o.MMPUEB1.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB1() uint32 {
	return volatile.LoadUint32(&o.MMPUEB1.Reg)
}

// MMPU.MMPUACB2: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB2.Reg, volatile.LoadUint16(&o.MMPUACB2.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB2.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB2.Reg, volatile.LoadUint16(&o.MMPUACB2.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB2.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB2.Reg, volatile.LoadUint16(&o.MMPUACB2.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB2.Reg) & 0x1
}

// MMPU.MMPUSB2: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB2(value uint32) {
	volatile.StoreUint32(&o.MMPUSB2.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB2() uint32 {
	return volatile.LoadUint32(&o.MMPUSB2.Reg)
}

// MMPU.MMPUEB2: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB2(value uint32) {
	volatile.StoreUint32(&o.MMPUEB2.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB2() uint32 {
	return volatile.LoadUint32(&o.MMPUEB2.Reg)
}

// MMPU.MMPUACB3: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB3.Reg, volatile.LoadUint16(&o.MMPUACB3.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB3.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB3.Reg, volatile.LoadUint16(&o.MMPUACB3.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB3.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB3.Reg, volatile.LoadUint16(&o.MMPUACB3.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB3.Reg) & 0x1
}

// MMPU.MMPUSB3: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB3(value uint32) {
	volatile.StoreUint32(&o.MMPUSB3.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB3() uint32 {
	return volatile.LoadUint32(&o.MMPUSB3.Reg)
}

// MMPU.MMPUEB3: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB3(value uint32) {
	volatile.StoreUint32(&o.MMPUEB3.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB3() uint32 {
	return volatile.LoadUint32(&o.MMPUEB3.Reg)
}

// MMPU.MMPUACB4: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB4_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB4.Reg, volatile.LoadUint16(&o.MMPUACB4.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB4_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB4.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB4_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB4.Reg, volatile.LoadUint16(&o.MMPUACB4.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB4_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB4.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB4_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB4.Reg, volatile.LoadUint16(&o.MMPUACB4.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB4_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB4.Reg) & 0x1
}

// MMPU.MMPUSB4: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB4(value uint32) {
	volatile.StoreUint32(&o.MMPUSB4.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB4() uint32 {
	return volatile.LoadUint32(&o.MMPUSB4.Reg)
}

// MMPU.MMPUEB4: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB4(value uint32) {
	volatile.StoreUint32(&o.MMPUEB4.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB4() uint32 {
	return volatile.LoadUint32(&o.MMPUEB4.Reg)
}

// MMPU.MMPUACB5: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB5_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB5.Reg, volatile.LoadUint16(&o.MMPUACB5.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB5_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB5.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB5_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB5.Reg, volatile.LoadUint16(&o.MMPUACB5.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB5_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB5.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB5_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB5.Reg, volatile.LoadUint16(&o.MMPUACB5.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB5_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB5.Reg) & 0x1
}

// MMPU.MMPUSB5: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB5(value uint32) {
	volatile.StoreUint32(&o.MMPUSB5.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB5() uint32 {
	return volatile.LoadUint32(&o.MMPUSB5.Reg)
}

// MMPU.MMPUEB5: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB5(value uint32) {
	volatile.StoreUint32(&o.MMPUEB5.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB5() uint32 {
	return volatile.LoadUint32(&o.MMPUEB5.Reg)
}

// MMPU.MMPUACB6: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB6_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB6.Reg, volatile.LoadUint16(&o.MMPUACB6.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB6_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB6.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB6_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB6.Reg, volatile.LoadUint16(&o.MMPUACB6.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB6_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB6.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB6_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB6.Reg, volatile.LoadUint16(&o.MMPUACB6.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB6_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB6.Reg) & 0x1
}

// MMPU.MMPUSB6: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB6(value uint32) {
	volatile.StoreUint32(&o.MMPUSB6.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB6() uint32 {
	return volatile.LoadUint32(&o.MMPUSB6.Reg)
}

// MMPU.MMPUEB6: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB6(value uint32) {
	volatile.StoreUint32(&o.MMPUEB6.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB6() uint32 {
	return volatile.LoadUint32(&o.MMPUEB6.Reg)
}

// MMPU.MMPUACB7: Group B Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACB7_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB7.Reg, volatile.LoadUint16(&o.MMPUACB7.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACB7_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB7.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACB7_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACB7.Reg, volatile.LoadUint16(&o.MMPUACB7.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACB7_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACB7.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACB7_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACB7.Reg, volatile.LoadUint16(&o.MMPUACB7.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACB7_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACB7.Reg) & 0x1
}

// MMPU.MMPUSB7: Group B Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSB7(value uint32) {
	volatile.StoreUint32(&o.MMPUSB7.Reg, value)
}
func (o *MMPU_Type) GetMMPUSB7() uint32 {
	return volatile.LoadUint32(&o.MMPUSB7.Reg)
}

// MMPU.MMPUEB7: Group B Region %s End Address Register
func (o *MMPU_Type) SetMMPUEB7(value uint32) {
	volatile.StoreUint32(&o.MMPUEB7.Reg, value)
}
func (o *MMPU_Type) GetMMPUEB7() uint32 {
	return volatile.LoadUint32(&o.MMPUEB7.Reg)
}

// MMPU.MMPUCTLC: Bus Master MPU Control Register
func (o *MMPU_Type) SetMMPUCTLC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLC.Reg, volatile.LoadUint16(&o.MMPUCTLC.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUCTLC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLC.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUCTLC_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLC.Reg, volatile.LoadUint16(&o.MMPUCTLC.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUCTLC_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLC.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUCTLC_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLC.Reg, volatile.LoadUint16(&o.MMPUCTLC.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUCTLC_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLC.Reg) & 0x1
}

// MMPU.MMPUPTC: Group C protection of register
func (o *MMPU_Type) SetMMPUPTC_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTC.Reg, volatile.LoadUint16(&o.MMPUPTC.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUPTC_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTC.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUPTC_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTC.Reg, volatile.LoadUint16(&o.MMPUPTC.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUPTC_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTC.Reg) & 0x1
}

// MMPU.MMPUACC0: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC0.Reg, volatile.LoadUint16(&o.MMPUACC0.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC0.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC0.Reg, volatile.LoadUint16(&o.MMPUACC0.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC0.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC0.Reg, volatile.LoadUint16(&o.MMPUACC0.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC0.Reg) & 0x1
}

// MMPU.MMPUSC0: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC0(value uint32) {
	volatile.StoreUint32(&o.MMPUSC0.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC0() uint32 {
	return volatile.LoadUint32(&o.MMPUSC0.Reg)
}

// MMPU.MMPUEC0: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC0(value uint32) {
	volatile.StoreUint32(&o.MMPUEC0.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC0() uint32 {
	return volatile.LoadUint32(&o.MMPUEC0.Reg)
}

// MMPU.MMPUACC1: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC1.Reg, volatile.LoadUint16(&o.MMPUACC1.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC1.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC1.Reg, volatile.LoadUint16(&o.MMPUACC1.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC1.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC1.Reg, volatile.LoadUint16(&o.MMPUACC1.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC1.Reg) & 0x1
}

// MMPU.MMPUSC1: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC1(value uint32) {
	volatile.StoreUint32(&o.MMPUSC1.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC1() uint32 {
	return volatile.LoadUint32(&o.MMPUSC1.Reg)
}

// MMPU.MMPUEC1: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC1(value uint32) {
	volatile.StoreUint32(&o.MMPUEC1.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC1() uint32 {
	return volatile.LoadUint32(&o.MMPUEC1.Reg)
}

// MMPU.MMPUACC2: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC2.Reg, volatile.LoadUint16(&o.MMPUACC2.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC2.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC2.Reg, volatile.LoadUint16(&o.MMPUACC2.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC2.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC2.Reg, volatile.LoadUint16(&o.MMPUACC2.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC2.Reg) & 0x1
}

// MMPU.MMPUSC2: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC2(value uint32) {
	volatile.StoreUint32(&o.MMPUSC2.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC2() uint32 {
	return volatile.LoadUint32(&o.MMPUSC2.Reg)
}

// MMPU.MMPUEC2: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC2(value uint32) {
	volatile.StoreUint32(&o.MMPUEC2.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC2() uint32 {
	return volatile.LoadUint32(&o.MMPUEC2.Reg)
}

// MMPU.MMPUACC3: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC3.Reg, volatile.LoadUint16(&o.MMPUACC3.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC3.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC3.Reg, volatile.LoadUint16(&o.MMPUACC3.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC3.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC3.Reg, volatile.LoadUint16(&o.MMPUACC3.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC3.Reg) & 0x1
}

// MMPU.MMPUSC3: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC3(value uint32) {
	volatile.StoreUint32(&o.MMPUSC3.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC3() uint32 {
	return volatile.LoadUint32(&o.MMPUSC3.Reg)
}

// MMPU.MMPUEC3: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC3(value uint32) {
	volatile.StoreUint32(&o.MMPUEC3.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC3() uint32 {
	return volatile.LoadUint32(&o.MMPUEC3.Reg)
}

// MMPU.MMPUACC4: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC4_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC4.Reg, volatile.LoadUint16(&o.MMPUACC4.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC4_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC4.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC4_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC4.Reg, volatile.LoadUint16(&o.MMPUACC4.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC4_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC4.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC4_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC4.Reg, volatile.LoadUint16(&o.MMPUACC4.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC4_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC4.Reg) & 0x1
}

// MMPU.MMPUSC4: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC4(value uint32) {
	volatile.StoreUint32(&o.MMPUSC4.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC4() uint32 {
	return volatile.LoadUint32(&o.MMPUSC4.Reg)
}

// MMPU.MMPUEC4: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC4(value uint32) {
	volatile.StoreUint32(&o.MMPUEC4.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC4() uint32 {
	return volatile.LoadUint32(&o.MMPUEC4.Reg)
}

// MMPU.MMPUACC5: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC5_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC5.Reg, volatile.LoadUint16(&o.MMPUACC5.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC5_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC5.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC5_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC5.Reg, volatile.LoadUint16(&o.MMPUACC5.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC5_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC5.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC5_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC5.Reg, volatile.LoadUint16(&o.MMPUACC5.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC5_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC5.Reg) & 0x1
}

// MMPU.MMPUSC5: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC5(value uint32) {
	volatile.StoreUint32(&o.MMPUSC5.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC5() uint32 {
	return volatile.LoadUint32(&o.MMPUSC5.Reg)
}

// MMPU.MMPUEC5: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC5(value uint32) {
	volatile.StoreUint32(&o.MMPUEC5.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC5() uint32 {
	return volatile.LoadUint32(&o.MMPUEC5.Reg)
}

// MMPU.MMPUACC6: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC6_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC6.Reg, volatile.LoadUint16(&o.MMPUACC6.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC6_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC6.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC6_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC6.Reg, volatile.LoadUint16(&o.MMPUACC6.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC6_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC6.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC6_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC6.Reg, volatile.LoadUint16(&o.MMPUACC6.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC6_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC6.Reg) & 0x1
}

// MMPU.MMPUSC6: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC6(value uint32) {
	volatile.StoreUint32(&o.MMPUSC6.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC6() uint32 {
	return volatile.LoadUint32(&o.MMPUSC6.Reg)
}

// MMPU.MMPUEC6: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC6(value uint32) {
	volatile.StoreUint32(&o.MMPUEC6.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC6() uint32 {
	return volatile.LoadUint32(&o.MMPUEC6.Reg)
}

// MMPU.MMPUACC7: Group C Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACC7_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC7.Reg, volatile.LoadUint16(&o.MMPUACC7.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACC7_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC7.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACC7_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACC7.Reg, volatile.LoadUint16(&o.MMPUACC7.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACC7_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACC7.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACC7_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACC7.Reg, volatile.LoadUint16(&o.MMPUACC7.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACC7_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACC7.Reg) & 0x1
}

// MMPU.MMPUSC7: Group C Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSC7(value uint32) {
	volatile.StoreUint32(&o.MMPUSC7.Reg, value)
}
func (o *MMPU_Type) GetMMPUSC7() uint32 {
	return volatile.LoadUint32(&o.MMPUSC7.Reg)
}

// MMPU.MMPUEC7: Group C Region %s End Address Register
func (o *MMPU_Type) SetMMPUEC7(value uint32) {
	volatile.StoreUint32(&o.MMPUEC7.Reg, value)
}
func (o *MMPU_Type) GetMMPUEC7() uint32 {
	return volatile.LoadUint32(&o.MMPUEC7.Reg)
}

// Bus Slave MPU
type SMPU_Type struct {
	SMPUCTL    volatile.Register16 // 0x0
	_          [14]byte
	SMPUMBIU   volatile.Register16 // 0x10
	_          [2]byte
	SMPUFBIU   volatile.Register16 // 0x14
	_          [2]byte
	SMPUSRAM0  volatile.Register16 // 0x18
	_          [2]byte
	SMPUSRAM1  volatile.Register16 // 0x1C
	_          [2]byte
	SMPUP0BIU  volatile.Register16 // 0x20
	_          [2]byte
	SMPUP2BIU  volatile.Register16 // 0x24
	_          [2]byte
	SMPUP6BIU  volatile.Register16 // 0x28
	_          [2]byte
	SMPUP7BIU  volatile.Register16 // 0x2C
	_          [2]byte
	SMPUEXBIU  volatile.Register16 // 0x30
	_          [2]byte
	SMPUEXBIU2 volatile.Register16 // 0x34
}

// SMPU.SMPUCTL: Slave MPU Control Register
func (o *SMPU_Type) SetSMPUCTL_KEY(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xff00)|value<<8)
}
func (o *SMPU_Type) GetSMPUCTL_KEY() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xff00) >> 8
}
func (o *SMPU_Type) SetSMPUCTL_PROTECT(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUCTL_PROTECT() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUCTL_OAD(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUCTL_OAD() uint16 {
	return volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x1
}

// SMPU.SMPUMBIU: Access Control Register for MBIU
func (o *SMPU_Type) SetSMPUMBIU_WPSRAMHS(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x8000)|value<<15)
}
func (o *SMPU_Type) GetSMPUMBIU_WPSRAMHS() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x8000) >> 15
}
func (o *SMPU_Type) SetSMPUMBIU_RPSRAMHS(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x4000)|value<<14)
}
func (o *SMPU_Type) GetSMPUMBIU_RPSRAMHS() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x4000) >> 14
}
func (o *SMPU_Type) SetSMPUMBIU_WPFLI(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x2000)|value<<13)
}
func (o *SMPU_Type) GetSMPUMBIU_WPFLI() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x2000) >> 13
}
func (o *SMPU_Type) SetSMPUMBIU_RPFLI(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x1000)|value<<12)
}
func (o *SMPU_Type) GetSMPUMBIU_RPFLI() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x1000) >> 12
}
func (o *SMPU_Type) SetSMPUMBIU_WPGRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUMBIU_WPGRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUMBIU_RPGRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUMBIU_RPGRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUMBIU_WPGRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUMBIU_WPGRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUMBIU_RPGRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUMBIU_RPGRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUMBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUMBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUMBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUMBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x4) >> 2
}

// SMPU.SMPUFBIU: Access Control Register for FBIU
func (o *SMPU_Type) SetSMPUFBIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUFBIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUFBIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUFBIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUFBIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUFBIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUFBIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUFBIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUFBIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUFBIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUFBIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUFBIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUFBIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUFBIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUFBIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUFBIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x1
}

// SMPU.SMPUSRAM0: Access Control Register for SRAM%s
func (o *SMPU_Type) SetSMPUSRAM0_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUSRAM0_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUSRAM0_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUSRAM0_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUSRAM0_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUSRAM0_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUSRAM0_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUSRAM0_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUSRAM0_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUSRAM0_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUSRAM0_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUSRAM0_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUSRAM0_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUSRAM0_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUSRAM0_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUSRAM0_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x1
}

// SMPU.SMPUSRAM1: Access Control Register for SRAM%s
func (o *SMPU_Type) SetSMPUSRAM1_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUSRAM1_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUSRAM1_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUSRAM1_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUSRAM1_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUSRAM1_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUSRAM1_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUSRAM1_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUSRAM1_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUSRAM1_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUSRAM1_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUSRAM1_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUSRAM1_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUSRAM1_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUSRAM1_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM1.Reg, volatile.LoadUint16(&o.SMPUSRAM1.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUSRAM1_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUSRAM1.Reg) & 0x1
}

// SMPU.SMPUP0BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP0BIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUP0BIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUP0BIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUP0BIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUP0BIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUP0BIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUP0BIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUP0BIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUP0BIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP0BIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP0BIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP0BIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP0BIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP0BIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP0BIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP0BIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x1
}

// SMPU.SMPUP2BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP2BIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUP2BIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUP2BIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUP2BIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUP2BIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUP2BIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUP2BIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUP2BIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUP2BIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP2BIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP2BIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP2BIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP2BIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP2BIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP2BIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP2BIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x1
}

// SMPU.SMPUP6BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP6BIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUP6BIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUP6BIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUP6BIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUP6BIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUP6BIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUP6BIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUP6BIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUP6BIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP6BIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP6BIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP6BIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP6BIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP6BIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP6BIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP6BIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x1
}

// SMPU.SMPUP7BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP7BIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUP7BIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUP7BIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUP7BIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUP7BIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUP7BIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUP7BIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUP7BIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUP7BIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP7BIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP7BIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP7BIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP7BIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP7BIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP7BIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP7BIU.Reg, volatile.LoadUint16(&o.SMPUP7BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP7BIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP7BIU.Reg) & 0x1
}

// SMPU.SMPUEXBIU: Access Control Register for EXBIU
func (o *SMPU_Type) SetSMPUEXBIU_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUEXBIU_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUEXBIU_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUEXBIU_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUEXBIU_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUEXBIU_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUEXBIU_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUEXBIU_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUEXBIU_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUEXBIU_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUEXBIU_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUEXBIU_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUEXBIU_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUEXBIU_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUEXBIU_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU.Reg, volatile.LoadUint16(&o.SMPUEXBIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUEXBIU_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUEXBIU.Reg) & 0x1
}

// SMPU.SMPUEXBIU2: Access Control Register for EXBIU2
func (o *SMPU_Type) SetSMPUEXBIU2_WP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x80)|value<<7)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x80) >> 7
}
func (o *SMPU_Type) SetSMPUEXBIU2_RP_GRPC(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x40)|value<<6)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RP_GRPC() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x40) >> 6
}
func (o *SMPU_Type) SetSMPUEXBIU2_WP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x20)|value<<5)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x20) >> 5
}
func (o *SMPU_Type) SetSMPUEXBIU2_RP_GRPB(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x10)|value<<4)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RP_GRPB() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x10) >> 4
}
func (o *SMPU_Type) SetSMPUEXBIU2_WP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUEXBIU2_RP_GRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RP_GRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUEXBIU2_WP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUEXBIU2_WP_CPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUEXBIU2_RP_CPU(value uint16) {
	volatile.StoreUint16(&o.SMPUEXBIU2.Reg, volatile.LoadUint16(&o.SMPUEXBIU2.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUEXBIU2_RP_CPU() uint16 {
	return volatile.LoadUint16(&o.SMPUEXBIU2.Reg) & 0x1
}

// CPU Stack Pointer Monitor
type SPMON_Type struct {
	MSPMPUOAD volatile.Register16 // 0x0
	_         [2]byte
	MSPMPUCTL volatile.Register16 // 0x4
	MSPMPUPT  volatile.Register16 // 0x6
	MSPMPUSA  volatile.Register32 // 0x8
	MSPMPUEA  volatile.Register32 // 0xC
	PSPMPUOAD volatile.Register16 // 0x10
	_         [2]byte
	PSPMPUCTL volatile.Register16 // 0x14
	PSPMPUPT  volatile.Register16 // 0x16
	PSPMPUSA  volatile.Register32 // 0x18
	PSPMPUEA  volatile.Register32 // 0x1C
}

// SPMON.MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetMSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0x1
}

// SPMON.MSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetMSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetMSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x1
}

// SPMON.MSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetMSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0x1
}

// SPMON.MSPMPUSA: Main Stack Pointer Monitor Start Address Register
func (o *SPMON_Type) SetMSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUSA.Reg, volatile.LoadUint32(&o.MSPMPUSA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SPMON_Type) GetMSPMPUSA() uint32 {
	return (volatile.LoadUint32(&o.MSPMPUSA.Reg) & 0xfffffffc) >> 2
}

// SPMON.MSPMPUEA: Main Stack Pointer Monitor End Address Register
func (o *SPMON_Type) SetMSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUEA.Reg, volatile.LoadUint32(&o.MSPMPUEA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SPMON_Type) GetMSPMPUEA() uint32 {
	return (volatile.LoadUint32(&o.MSPMPUEA.Reg) & 0xfffffffc) >> 2
}

// SPMON.PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetPSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0x1
}

// SPMON.PSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetPSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetPSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x1
}

// SPMON.PSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetPSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0x1
}

// SPMON.PSPMPUSA: Process Stack Pointer Monitor Start Address Register
func (o *SPMON_Type) SetPSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUSA.Reg, volatile.LoadUint32(&o.PSPMPUSA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SPMON_Type) GetPSPMPUSA() uint32 {
	return (volatile.LoadUint32(&o.PSPMPUSA.Reg) & 0xfffffffc) >> 2
}

// SPMON.PSPMPUEA: Process Stack Pointer Monitor End Address Register
func (o *SPMON_Type) SetPSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUEA.Reg, volatile.LoadUint32(&o.PSPMPUEA.Reg)&^(0xfffffffc)|value<<2)
}
func (o *SPMON_Type) GetPSPMPUEA() uint32 {
	return (volatile.LoadUint32(&o.PSPMPUEA.Reg) & 0xfffffffc) >> 2
}

// 12bit A/D Converter 0
type ADC120_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	ADANSA1    volatile.Register16 // 0x6
	ADADS0     volatile.Register16 // 0x8
	ADADS1     volatile.Register16 // 0xA
	ADADC      volatile.Register8  // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	ADANSB1    volatile.Register16 // 0x16
	ADDBLDR    volatile.Register16 // 0x18
	ADTSDR     volatile.Register16 // 0x1A
	ADOCDR     volatile.Register16 // 0x1C
	ADRD       volatile.Register16 // 0x1E
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	ADDR4      volatile.Register16 // 0x28
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	_          [16]byte
	ADDR16     volatile.Register16 // 0x40
	ADDR17     volatile.Register16 // 0x42
	ADDR18     volatile.Register16 // 0x44
	ADDR19     volatile.Register16 // 0x46
	ADDR20     volatile.Register16 // 0x48
	_          [28]byte
	ADSHCR     volatile.Register16 // 0x66
	_          [18]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          byte
	ADSHMSR    volatile.Register8 // 0x7C
	_          [3]byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [4]byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	ADCMPANSR1 volatile.Register16 // 0x96
	ADCMPLR0   volatile.Register16 // 0x98
	ADCMPLR1   volatile.Register16 // 0x9A
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	ADCMPSR1   volatile.Register16 // 0xA2
	ADCMPSER   volatile.Register8  // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [48]byte
	ADSSTRL    volatile.Register8 // 0xDD
	ADSSTRT    volatile.Register8 // 0xDE
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR00   volatile.Register8 // 0xE0
	ADSSTR01   volatile.Register8 // 0xE1
	ADSSTR02   volatile.Register8 // 0xE2
	ADSSTR03   volatile.Register8 // 0xE3
	ADSSTR04   volatile.Register8 // 0xE4
	ADSSTR05   volatile.Register8 // 0xE5
	ADSSTR06   volatile.Register8 // 0xE6
	ADSSTR07   volatile.Register8 // 0xE7
	_          [184]byte
	ADPGACR    volatile.Register16 // 0x1A0
	ADPGAGS0   volatile.Register16 // 0x1A2
	_          [12]byte
	ADPGADCR0  volatile.Register16 // 0x1B0
}

// ADC120.ADCSR: A/D Control Register
func (o *ADC120_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}
func (o *ADC120_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC120_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC120_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC120_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}

// ADC120.ADANSA0: A/D Channel Select Register A0
func (o *ADC120_Type) SetADANSA0_ANSA07(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSA0_ANSA07() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSA0_ANSA06(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSA0_ANSA06() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSA0_ANSA05(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSA0_ANSA05() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSA0_ANSA04(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSA0_ANSA04() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSA0_ANSA03(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSA0_ANSA03() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSA0_ANSA02(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSA0_ANSA02() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSA0_ANSA01(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSA0_ANSA01() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSA0_ANSA00(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSA0_ANSA00() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}

// ADC120.ADANSA1: A/D Channel Select Register A1
func (o *ADC120_Type) SetADANSA1_ANSA20(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSA1_ANSA20() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSA1_ANSA19(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSA1_ANSA19() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSA1_ANSA18(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSA1_ANSA18() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSA1_ANSA17(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSA1_ANSA17() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSA1_ANSA16(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSA1_ANSA16() uint16 {
	return volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1
}

// ADC120.ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
func (o *ADC120_Type) SetADADS0_ADS07(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADS0_ADS07() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADADS0_ADS06(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADADS0_ADS06() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADADS0_ADS05(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADADS0_ADS05() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADADS0_ADS04(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADADS0_ADS04() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADADS0_ADS03(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADADS0_ADS03() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADADS0_ADS02(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADADS0_ADS02() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADADS0_ADS01(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADADS0_ADS01() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADADS0_ADS00(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADADS0_ADS00() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}

// ADC120.ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
func (o *ADC120_Type) SetADADS1_ADS20(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADADS1_ADS20() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADADS1_ADS19(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADADS1_ADS19() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADADS1_ADS18(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADADS1_ADS18() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADADS1_ADS17(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADADS1_ADS17() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADADS1_ADS16(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADADS1_ADS16() uint16 {
	return volatile.LoadUint16(&o.ADADS1.Reg) & 0x1
}

// ADC120.ADADC: A/D-Converted Value Addition/Average Count Select Register
func (o *ADC120_Type) SetADADC_AVEE(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADADC_AVEE() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC120_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}

// ADC120.ADCER: A/D Control Extended Register
func (o *ADC120_Type) SetADCER_ADRFMT(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCER_ADRFMT() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}
func (o *ADC120_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC120_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC120_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCER_ADPRC(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x6)|value<<1)
}
func (o *ADC120_Type) GetADCER_ADPRC() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x6) >> 1
}

// ADC120.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC120_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC120_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}
func (o *ADC120_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}

// ADC120.ADEXICR: A/D Conversion Extended Input Control Register
func (o *ADC120_Type) SetADEXICR_OCSB(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADEXICR_OCSB() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADEXICR_TSSB(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADEXICR_TSSB() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADEXICR_TSSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADEXICR_TSSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADEXICR_TSSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADEXICR_TSSAD() uint16 {
	return volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1
}

// ADC120.ADANSB0: A/D Channel Select Register B0
func (o *ADC120_Type) SetADANSB0_ANSB07(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADANSB0_ANSB07() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADANSB0_ANSB06(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADANSB0_ANSB06() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADANSB0_ANSB05(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADANSB0_ANSB05() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADANSB0_ANSB04(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSB0_ANSB04() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSB0_ANSB03(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSB0_ANSB03() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSB0_ANSB02(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSB0_ANSB02() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSB0_ANSB01(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSB0_ANSB01() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSB0_ANSB00(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSB0_ANSB00() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}

// ADC120.ADANSB1: A/D Channel Select Register B1
func (o *ADC120_Type) SetADANSB1_ANSB20(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADANSB1_ANSB20() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADANSB1_ANSB19(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADANSB1_ANSB19() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADANSB1_ANSB18(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADANSB1_ANSB18() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADANSB1_ANSB17(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADANSB1_ANSB17() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADANSB1_ANSB16(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADANSB1_ANSB16() uint16 {
	return volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1
}

// ADC120.ADDBLDR: A/D Data Duplication Register
func (o *ADC120_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC120_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC120.ADTSDR: A/D Temperature Sensor Data Register
func (o *ADC120_Type) SetADTSDR(value uint16) {
	volatile.StoreUint16(&o.ADTSDR.Reg, value)
}
func (o *ADC120_Type) GetADTSDR() uint16 {
	return volatile.LoadUint16(&o.ADTSDR.Reg)
}

// ADC120.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC120_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC120_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC120.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC120_Type) SetADRD_DIAGST(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xc000)|value<<14)
}
func (o *ADC120_Type) GetADRD_DIAGST() uint16 {
	return (volatile.LoadUint16(&o.ADRD.Reg) & 0xc000) >> 14
}
func (o *ADC120_Type) SetADRD_AD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xfff)|value)
}
func (o *ADC120_Type) GetADRD_AD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg) & 0xfff
}

// ADC120.ADDR0: A/D Data Register %s
func (o *ADC120_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC120_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC120.ADDR1: A/D Data Register %s
func (o *ADC120_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC120_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC120.ADDR2: A/D Data Register %s
func (o *ADC120_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC120_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC120.ADDR3: A/D Data Register %s
func (o *ADC120_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC120_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC120.ADDR4: A/D Data Register %s
func (o *ADC120_Type) SetADDR4(value uint16) {
	volatile.StoreUint16(&o.ADDR4.Reg, value)
}
func (o *ADC120_Type) GetADDR4() uint16 {
	return volatile.LoadUint16(&o.ADDR4.Reg)
}

// ADC120.ADDR5: A/D Data Register %s
func (o *ADC120_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC120_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC120.ADDR6: A/D Data Register %s
func (o *ADC120_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC120_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC120.ADDR7: A/D Data Register %s
func (o *ADC120_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC120_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC120.ADDR16: A/D Data Register %s
func (o *ADC120_Type) SetADDR16(value uint16) {
	volatile.StoreUint16(&o.ADDR16.Reg, value)
}
func (o *ADC120_Type) GetADDR16() uint16 {
	return volatile.LoadUint16(&o.ADDR16.Reg)
}

// ADC120.ADDR17: A/D Data Register %s
func (o *ADC120_Type) SetADDR17(value uint16) {
	volatile.StoreUint16(&o.ADDR17.Reg, value)
}
func (o *ADC120_Type) GetADDR17() uint16 {
	return volatile.LoadUint16(&o.ADDR17.Reg)
}

// ADC120.ADDR18: A/D Data Register %s
func (o *ADC120_Type) SetADDR18(value uint16) {
	volatile.StoreUint16(&o.ADDR18.Reg, value)
}
func (o *ADC120_Type) GetADDR18() uint16 {
	return volatile.LoadUint16(&o.ADDR18.Reg)
}

// ADC120.ADDR19: A/D Data Register %s
func (o *ADC120_Type) SetADDR19(value uint16) {
	volatile.StoreUint16(&o.ADDR19.Reg, value)
}
func (o *ADC120_Type) GetADDR19() uint16 {
	return volatile.LoadUint16(&o.ADDR19.Reg)
}

// ADC120.ADDR20: A/D Data Register %s
func (o *ADC120_Type) SetADDR20(value uint16) {
	volatile.StoreUint16(&o.ADDR20.Reg, value)
}
func (o *ADC120_Type) GetADDR20() uint16 {
	return volatile.LoadUint16(&o.ADDR20.Reg)
}

// ADC120.ADSHCR: A/D Sample and Hold Circuit Control Register
func (o *ADC120_Type) SetADSHCR_SHANS2(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADSHCR_SHANS2() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADSHCR_SHANS1(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADSHCR_SHANS1() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADSHCR_SHANS0(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADSHCR_SHANS0() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADSHCR_SSTSH(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0xff)|value)
}
func (o *ADC120_Type) GetADSHCR_SSTSH() uint16 {
	return volatile.LoadUint16(&o.ADSHCR.Reg) & 0xff
}

// ADC120.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC120_Type) SetADDISCR_CHARGE(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADDISCR_CHARGE() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xf)|value)
}
func (o *ADC120_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0xf
}

// ADC120.ADSHMSR: A/D Sample and Hold Operation Mode Select Register
func (o *ADC120_Type) SetADSHMSR_SHMD(value uint8) {
	volatile.StoreUint8(&o.ADSHMSR.Reg, volatile.LoadUint8(&o.ADSHMSR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADSHMSR_SHMD() uint8 {
	return volatile.LoadUint8(&o.ADSHMSR.Reg) & 0x1
}

// ADC120.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC120_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}
func (o *ADC120_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}

// ADC120.ADDBLDRA: A/D Data Duplication Register A
func (o *ADC120_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC120.ADDBLDRB: A/D Data Duplication Register B
func (o *ADC120_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC120_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC120.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC120_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}

// ADC120.ADCMPCR: A/D Compare Function Control Register
func (o *ADC120_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC120_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}
func (o *ADC120_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC120_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC120_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC120_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC120_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC120_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}

// ADC120.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC120_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSER_CMPTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSER_CMPTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x1
}

// ADC120.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC120_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLER_CMPLTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLER_CMPLTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x1
}

// ADC120.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSR0_CMPCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSR0_CMPCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}

// ADC120.ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPANSR1_CMPCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPANSR1_CMPCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1
}

// ADC120.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLR0_CMPLCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLR0_CMPLCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}

// ADC120.ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPLR1_CMPLCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPLR1_CMPLCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1
}

// ADC120.ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
func (o *ADC120_Type) SetADCMPDR0(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR0.Reg, value)
}
func (o *ADC120_Type) GetADCMPDR0() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR0.Reg)
}

// ADC120.ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
func (o *ADC120_Type) SetADCMPDR1(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR1.Reg, value)
}
func (o *ADC120_Type) GetADCMPDR1() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR1.Reg)
}

// ADC120.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSR0_CMPSTCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSR0_CMPSTCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}

// ADC120.ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSR1_CMPSTCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSR1_CMPSTCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1
}

// ADC120.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC120_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADCMPSER_CMPSTTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPSER_CMPSTTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x1
}

// ADC120.ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
func (o *ADC120_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC120_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}

// ADC120.ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
func (o *ADC120_Type) SetADWINLLB(value uint16) {
	volatile.StoreUint16(&o.ADWINLLB.Reg, value)
}
func (o *ADC120_Type) GetADWINLLB() uint16 {
	return volatile.LoadUint16(&o.ADWINLLB.Reg)
}

// ADC120.ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
func (o *ADC120_Type) SetADWINULB(value uint16) {
	volatile.StoreUint16(&o.ADWINULB.Reg, value)
}
func (o *ADC120_Type) GetADWINULB() uint16 {
	return volatile.LoadUint16(&o.ADWINULB.Reg)
}

// ADC120.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC120_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC120.ADSSTRL: A/D Sampling State Register L
func (o *ADC120_Type) SetADSSTRL(value uint8) {
	volatile.StoreUint8(&o.ADSSTRL.Reg, value)
}
func (o *ADC120_Type) GetADSSTRL() uint8 {
	return volatile.LoadUint8(&o.ADSSTRL.Reg)
}

// ADC120.ADSSTRT: A/D Sampling State Register T
func (o *ADC120_Type) SetADSSTRT(value uint8) {
	volatile.StoreUint8(&o.ADSSTRT.Reg, value)
}
func (o *ADC120_Type) GetADSSTRT() uint8 {
	return volatile.LoadUint8(&o.ADSSTRT.Reg)
}

// ADC120.ADSSTRO: A/D Sampling State Register O
func (o *ADC120_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC120_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC120.ADSSTR00: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR00(value uint8) {
	volatile.StoreUint8(&o.ADSSTR00.Reg, value)
}
func (o *ADC120_Type) GetADSSTR00() uint8 {
	return volatile.LoadUint8(&o.ADSSTR00.Reg)
}

// ADC120.ADSSTR01: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR01(value uint8) {
	volatile.StoreUint8(&o.ADSSTR01.Reg, value)
}
func (o *ADC120_Type) GetADSSTR01() uint8 {
	return volatile.LoadUint8(&o.ADSSTR01.Reg)
}

// ADC120.ADSSTR02: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR02(value uint8) {
	volatile.StoreUint8(&o.ADSSTR02.Reg, value)
}
func (o *ADC120_Type) GetADSSTR02() uint8 {
	return volatile.LoadUint8(&o.ADSSTR02.Reg)
}

// ADC120.ADSSTR03: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR03(value uint8) {
	volatile.StoreUint8(&o.ADSSTR03.Reg, value)
}
func (o *ADC120_Type) GetADSSTR03() uint8 {
	return volatile.LoadUint8(&o.ADSSTR03.Reg)
}

// ADC120.ADSSTR04: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR04(value uint8) {
	volatile.StoreUint8(&o.ADSSTR04.Reg, value)
}
func (o *ADC120_Type) GetADSSTR04() uint8 {
	return volatile.LoadUint8(&o.ADSSTR04.Reg)
}

// ADC120.ADSSTR05: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR05(value uint8) {
	volatile.StoreUint8(&o.ADSSTR05.Reg, value)
}
func (o *ADC120_Type) GetADSSTR05() uint8 {
	return volatile.LoadUint8(&o.ADSSTR05.Reg)
}

// ADC120.ADSSTR06: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR06(value uint8) {
	volatile.StoreUint8(&o.ADSSTR06.Reg, value)
}
func (o *ADC120_Type) GetADSSTR06() uint8 {
	return volatile.LoadUint8(&o.ADSSTR06.Reg)
}

// ADC120.ADSSTR07: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
func (o *ADC120_Type) SetADSSTR07(value uint8) {
	volatile.StoreUint8(&o.ADSSTR07.Reg, value)
}
func (o *ADC120_Type) GetADSSTR07() uint8 {
	return volatile.LoadUint8(&o.ADSSTR07.Reg)
}

// ADC120.ADPGACR: A/D Programmable Gain Amplifier Control Register
func (o *ADC120_Type) SetADPGACR_P002GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADPGACR_P002GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADPGACR_P002ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x400)|value<<10)
}
func (o *ADC120_Type) GetADPGACR_P002ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x400) >> 10
}
func (o *ADC120_Type) SetADPGACR_P002SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x200)|value<<9)
}
func (o *ADC120_Type) GetADPGACR_P002SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x200) >> 9
}
func (o *ADC120_Type) SetADPGACR_P002SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x100)|value<<8)
}
func (o *ADC120_Type) GetADPGACR_P002SEL0() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x100) >> 8
}
func (o *ADC120_Type) SetADPGACR_P001GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADPGACR_P001GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADPGACR_P001ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x40)|value<<6)
}
func (o *ADC120_Type) GetADPGACR_P001ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x40) >> 6
}
func (o *ADC120_Type) SetADPGACR_P001SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x20)|value<<5)
}
func (o *ADC120_Type) GetADPGACR_P001SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x20) >> 5
}
func (o *ADC120_Type) SetADPGACR_P001SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x10)|value<<4)
}
func (o *ADC120_Type) GetADPGACR_P001SEL0() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x10) >> 4
}
func (o *ADC120_Type) SetADPGACR_P000GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADPGACR_P000GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADPGACR_P000ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x4)|value<<2)
}
func (o *ADC120_Type) GetADPGACR_P000ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x4) >> 2
}
func (o *ADC120_Type) SetADPGACR_P000SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x2)|value<<1)
}
func (o *ADC120_Type) GetADPGACR_P000SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x2) >> 1
}
func (o *ADC120_Type) SetADPGACR_P000SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x1)|value)
}
func (o *ADC120_Type) GetADPGACR_P000SEL0() uint16 {
	return volatile.LoadUint16(&o.ADPGACR.Reg) & 0x1
}

// ADC120.ADPGAGS0: A/D Programmable Gain Amplifier Gain Setting Register 0
func (o *ADC120_Type) SetADPGAGS0_P002GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf00)|value<<8)
}
func (o *ADC120_Type) GetADPGAGS0_P002GAIN() uint16 {
	return (volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf00) >> 8
}
func (o *ADC120_Type) SetADPGAGS0_P001GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf0)|value<<4)
}
func (o *ADC120_Type) GetADPGAGS0_P001GAIN() uint16 {
	return (volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf0) >> 4
}
func (o *ADC120_Type) SetADPGAGS0_P000GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf)|value)
}
func (o *ADC120_Type) GetADPGAGS0_P000GAIN() uint16 {
	return volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf
}

// ADC120.ADPGADCR0: A/D Programmable Gain Amplifier Differential Input Control Register
func (o *ADC120_Type) SetADPGADCR0_P003DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x3000)|value<<12)
}
func (o *ADC120_Type) GetADPGADCR0_P003DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x3000) >> 12
}
func (o *ADC120_Type) SetADPGADCR0_P002DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC120_Type) GetADPGADCR0_P002DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x800) >> 11
}
func (o *ADC120_Type) SetADPGADCR0_P002DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x300)|value<<8)
}
func (o *ADC120_Type) GetADPGADCR0_P002DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x300) >> 8
}
func (o *ADC120_Type) SetADPGADCR0_P001DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC120_Type) GetADPGADCR0_P001DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x80) >> 7
}
func (o *ADC120_Type) SetADPGADCR0_P001DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x30)|value<<4)
}
func (o *ADC120_Type) GetADPGADCR0_P001DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x30) >> 4
}
func (o *ADC120_Type) SetADPGADCR0_P000DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC120_Type) GetADPGADCR0_P000DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x8) >> 3
}
func (o *ADC120_Type) SetADPGADCR0_P000DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x3)|value)
}
func (o *ADC120_Type) GetADPGADCR0_P000DG() uint16 {
	return volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x3
}

// 12bit A/D Converter 1
type ADC121_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	ADANSA1    volatile.Register16 // 0x6
	ADADS0     volatile.Register16 // 0x8
	ADADS1     volatile.Register16 // 0xA
	ADADC      volatile.Register8  // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	ADANSB1    volatile.Register16 // 0x16
	ADDBLDR    volatile.Register16 // 0x18
	ADTSDR     volatile.Register16 // 0x1A
	ADOCDR     volatile.Register16 // 0x1C
	ADRD       volatile.Register16 // 0x1E
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	_          [2]byte
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	_          [16]byte
	ADDR16     volatile.Register16 // 0x40
	ADDR17     volatile.Register16 // 0x42
	ADDR18     volatile.Register16 // 0x44
	ADDR19     volatile.Register16 // 0x46
	_          [30]byte
	ADSHCR     volatile.Register16 // 0x66
	_          [18]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          byte
	ADSHMSR    volatile.Register8 // 0x7C
	_          [3]byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [4]byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	ADCMPANSR1 volatile.Register16 // 0x96
	ADCMPLR0   volatile.Register16 // 0x98
	ADCMPLR1   volatile.Register16 // 0x9A
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	ADCMPSR1   volatile.Register16 // 0xA2
	ADCMPSER   volatile.Register8  // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [48]byte
	ADSSTRL    volatile.Register8 // 0xDD
	ADSSTRT    volatile.Register8 // 0xDE
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR00   volatile.Register8 // 0xE0
	ADSSTR01   volatile.Register8 // 0xE1
	ADSSTR02   volatile.Register8 // 0xE2
	ADSSTR03   volatile.Register8 // 0xE3
	_          byte
	ADSSTR05   volatile.Register8 // 0xE5
	ADSSTR06   volatile.Register8 // 0xE6
	ADSSTR07   volatile.Register8 // 0xE7
	_          [184]byte
	ADPGACR    volatile.Register16 // 0x1A0
	ADPGAGS0   volatile.Register16 // 0x1A2
	_          [12]byte
	ADPGADCR0  volatile.Register16 // 0x1B0
}

// ADC121.ADCSR: A/D Control Register
func (o *ADC121_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC121_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}
func (o *ADC121_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC121_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC121_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC121_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC121_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC121_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC121_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC121_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}

// ADC121.ADANSA0: A/D Channel Select Register A0
func (o *ADC121_Type) SetADANSA0_ANSA07(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADANSA0_ANSA07() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADANSA0_ANSA06(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADANSA0_ANSA06() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADANSA0_ANSA05(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADANSA0_ANSA05() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADANSA0_ANSA03(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADANSA0_ANSA03() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADANSA0_ANSA02(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADANSA0_ANSA02() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADANSA0_ANSA01(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADANSA0_ANSA01() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADANSA0_ANSA00(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADANSA0_ANSA00() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}

// ADC121.ADANSA1: A/D Channel Select Register A1
func (o *ADC121_Type) SetADANSA1_ANSA19(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADANSA1_ANSA19() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADANSA1_ANSA18(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADANSA1_ANSA18() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADANSA1_ANSA17(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADANSA1_ANSA17() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADANSA1_ANSA16(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADANSA1_ANSA16() uint16 {
	return volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1
}

// ADC121.ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
func (o *ADC121_Type) SetADADS0_ADS07(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADADS0_ADS07() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADADS0_ADS06(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADADS0_ADS06() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADADS0_ADS05(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADADS0_ADS05() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADADS0_ADS03(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADADS0_ADS03() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADADS0_ADS02(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADADS0_ADS02() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADADS0_ADS01(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADADS0_ADS01() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADADS0_ADS00(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADADS0_ADS00() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}

// ADC121.ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
func (o *ADC121_Type) SetADADS1_ADS19(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADADS1_ADS19() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADADS1_ADS18(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADADS1_ADS18() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADADS1_ADS17(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADADS1_ADS17() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADADS1_ADS16(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADADS1_ADS16() uint16 {
	return volatile.LoadUint16(&o.ADADS1.Reg) & 0x1
}

// ADC121.ADADC: A/D-Converted Value Addition/Average Count Select Register
func (o *ADC121_Type) SetADADC_AVEE(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADADC_AVEE() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC121_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}

// ADC121.ADCER: A/D Control Extended Register
func (o *ADC121_Type) SetADCER_ADRFMT(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC121_Type) GetADCER_ADRFMT() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}
func (o *ADC121_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC121_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC121_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC121_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC121_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC121_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC121_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADCER_ADPRC(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x6)|value<<1)
}
func (o *ADC121_Type) GetADCER_ADPRC() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x6) >> 1
}

// ADC121.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC121_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC121_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}
func (o *ADC121_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC121_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}

// ADC121.ADEXICR: A/D Conversion Extended Input Control Register
func (o *ADC121_Type) SetADEXICR_OCSB(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x800)|value<<11)
}
func (o *ADC121_Type) GetADEXICR_OCSB() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x800) >> 11
}
func (o *ADC121_Type) SetADEXICR_TSSB(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x400)|value<<10)
}
func (o *ADC121_Type) GetADEXICR_TSSB() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x400) >> 10
}
func (o *ADC121_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC121_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}
func (o *ADC121_Type) SetADEXICR_TSSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x100)|value<<8)
}
func (o *ADC121_Type) GetADEXICR_TSSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x100) >> 8
}
func (o *ADC121_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADEXICR_TSSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADEXICR_TSSAD() uint16 {
	return volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1
}

// ADC121.ADANSB0: A/D Channel Select Register B0
func (o *ADC121_Type) SetADANSB0_ANSB07(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADANSB0_ANSB07() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADANSB0_ANSB06(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADANSB0_ANSB06() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADANSB0_ANSB05(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADANSB0_ANSB05() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADANSB0_ANSB03(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADANSB0_ANSB03() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADANSB0_ANSB02(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADANSB0_ANSB02() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADANSB0_ANSB01(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADANSB0_ANSB01() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADANSB0_ANSB00(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADANSB0_ANSB00() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}

// ADC121.ADANSB1: A/D Channel Select Register B1
func (o *ADC121_Type) SetADANSB1_ANSB19(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADANSB1_ANSB19() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADANSB1_ANSB18(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADANSB1_ANSB18() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADANSB1_ANSB17(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADANSB1_ANSB17() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADANSB1_ANSB16(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADANSB1_ANSB16() uint16 {
	return volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1
}

// ADC121.ADDBLDR: A/D Data Duplication Register
func (o *ADC121_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC121_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC121.ADTSDR: A/D Temperature Sensor Data Register
func (o *ADC121_Type) SetADTSDR(value uint16) {
	volatile.StoreUint16(&o.ADTSDR.Reg, value)
}
func (o *ADC121_Type) GetADTSDR() uint16 {
	return volatile.LoadUint16(&o.ADTSDR.Reg)
}

// ADC121.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC121_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC121_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC121.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC121_Type) SetADRD_DIAGST(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xc000)|value<<14)
}
func (o *ADC121_Type) GetADRD_DIAGST() uint16 {
	return (volatile.LoadUint16(&o.ADRD.Reg) & 0xc000) >> 14
}
func (o *ADC121_Type) SetADRD_AD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, volatile.LoadUint16(&o.ADRD.Reg)&^(0xfff)|value)
}
func (o *ADC121_Type) GetADRD_AD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg) & 0xfff
}

// ADC121.ADDR0: A/D Data Register %s
func (o *ADC121_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC121_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC121.ADDR1: A/D Data Register %s
func (o *ADC121_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC121_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC121.ADDR2: A/D Data Register %s
func (o *ADC121_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC121_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC121.ADDR3: A/D Data Register %s
func (o *ADC121_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC121_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC121.ADDR5: A/D Data Register %s
func (o *ADC121_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC121_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC121.ADDR6: A/D Data Register %s
func (o *ADC121_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC121_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC121.ADDR7: A/D Data Register %s
func (o *ADC121_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC121_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC121.ADDR16: A/D Data Register %s
func (o *ADC121_Type) SetADDR16(value uint16) {
	volatile.StoreUint16(&o.ADDR16.Reg, value)
}
func (o *ADC121_Type) GetADDR16() uint16 {
	return volatile.LoadUint16(&o.ADDR16.Reg)
}

// ADC121.ADDR17: A/D Data Register %s
func (o *ADC121_Type) SetADDR17(value uint16) {
	volatile.StoreUint16(&o.ADDR17.Reg, value)
}
func (o *ADC121_Type) GetADDR17() uint16 {
	return volatile.LoadUint16(&o.ADDR17.Reg)
}

// ADC121.ADDR18: A/D Data Register %s
func (o *ADC121_Type) SetADDR18(value uint16) {
	volatile.StoreUint16(&o.ADDR18.Reg, value)
}
func (o *ADC121_Type) GetADDR18() uint16 {
	return volatile.LoadUint16(&o.ADDR18.Reg)
}

// ADC121.ADDR19: A/D Data Register %s
func (o *ADC121_Type) SetADDR19(value uint16) {
	volatile.StoreUint16(&o.ADDR19.Reg, value)
}
func (o *ADC121_Type) GetADDR19() uint16 {
	return volatile.LoadUint16(&o.ADDR19.Reg)
}

// ADC121.ADSHCR: A/D Sample and Hold Circuit Control Register
func (o *ADC121_Type) SetADSHCR_SHANS2(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x400)|value<<10)
}
func (o *ADC121_Type) GetADSHCR_SHANS2() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x400) >> 10
}
func (o *ADC121_Type) SetADSHCR_SHANS1(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC121_Type) GetADSHCR_SHANS1() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x200) >> 9
}
func (o *ADC121_Type) SetADSHCR_SHANS0(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0x100)|value<<8)
}
func (o *ADC121_Type) GetADSHCR_SHANS0() uint16 {
	return (volatile.LoadUint16(&o.ADSHCR.Reg) & 0x100) >> 8
}
func (o *ADC121_Type) SetADSHCR_SSTSH(value uint16) {
	volatile.StoreUint16(&o.ADSHCR.Reg, volatile.LoadUint16(&o.ADSHCR.Reg)&^(0xff)|value)
}
func (o *ADC121_Type) GetADSHCR_SSTSH() uint16 {
	return volatile.LoadUint16(&o.ADSHCR.Reg) & 0xff
}

// ADC121.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC121_Type) SetADDISCR_CHARGE(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x10)|value<<4)
}
func (o *ADC121_Type) GetADDISCR_CHARGE() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x10) >> 4
}
func (o *ADC121_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xf)|value)
}
func (o *ADC121_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0xf
}

// ADC121.ADSHMSR: A/D Sample and Hold Operation Mode Select Register
func (o *ADC121_Type) SetADSHMSR_SHMD(value uint8) {
	volatile.StoreUint8(&o.ADSHMSR.Reg, volatile.LoadUint8(&o.ADSHMSR.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADSHMSR_SHMD() uint8 {
	return volatile.LoadUint8(&o.ADSHMSR.Reg) & 0x1
}

// ADC121.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC121_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC121_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}
func (o *ADC121_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}

// ADC121.ADDBLDRA: A/D Data Duplication Register A
func (o *ADC121_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC121_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC121.ADDBLDRB: A/D Data Duplication Register B
func (o *ADC121_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC121_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC121.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC121_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC121_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC121_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}

// ADC121.ADCMPCR: A/D Compare Function Control Register
func (o *ADC121_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC121_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}
func (o *ADC121_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC121_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC121_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC121_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC121_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC121_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC121_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC121_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC121_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC121_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}

// ADC121.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC121_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPANSER_CMPTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPANSER_CMPTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x1
}

// ADC121.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC121_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPLER_CMPLTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPLER_CMPLTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x1
}

// ADC121.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC121_Type) SetADCMPANSR0_CMPCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADCMPANSR0_CMPCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADCMPANSR0_CMPCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPANSR0_CMPCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPANSR0_CMPCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPANSR0_CMPCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPANSR0_CMPCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPANSR0_CMPCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPANSR0_CMPCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPANSR0_CMPCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}

// ADC121.ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
func (o *ADC121_Type) SetADCMPANSR1_CMPCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC121_Type) GetADCMPANSR1_CMPCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x10) >> 4
}
func (o *ADC121_Type) SetADCMPANSR1_CMPCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPANSR1_CMPCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPANSR1_CMPCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPANSR1_CMPCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPANSR1_CMPCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPANSR1_CMPCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPANSR1_CMPCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPANSR1_CMPCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1
}

// ADC121.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPLR0_CMPLCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPLR0_CMPLCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}

// ADC121.ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
func (o *ADC121_Type) SetADCMPLR1_CMPLCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPLR1_CMPLCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPLR1_CMPLCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPLR1_CMPLCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPLR1_CMPLCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPLR1_CMPLCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPLR1_CMPLCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPLR1_CMPLCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1
}

// ADC121.ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
func (o *ADC121_Type) SetADCMPDR0(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR0.Reg, value)
}
func (o *ADC121_Type) GetADCMPDR0() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR0.Reg)
}

// ADC121.ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
func (o *ADC121_Type) SetADCMPDR1(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR1.Reg, value)
}
func (o *ADC121_Type) GetADCMPDR1() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR1.Reg)
}

// ADC121.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPSR0_CMPSTCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPSR0_CMPSTCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}

// ADC121.ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
func (o *ADC121_Type) SetADCMPSR1_CMPSTCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADCMPSR1_CMPSTCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADCMPSR1_CMPSTCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADCMPSR1_CMPSTCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADCMPSR1_CMPSTCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPSR1_CMPSTCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPSR1_CMPSTCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPSR1_CMPSTCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1
}

// ADC121.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC121_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADCMPSER_CMPSTTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPSER_CMPSTTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x1
}

// ADC121.ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
func (o *ADC121_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC121_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}

// ADC121.ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
func (o *ADC121_Type) SetADWINLLB(value uint16) {
	volatile.StoreUint16(&o.ADWINLLB.Reg, value)
}
func (o *ADC121_Type) GetADWINLLB() uint16 {
	return volatile.LoadUint16(&o.ADWINLLB.Reg)
}

// ADC121.ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
func (o *ADC121_Type) SetADWINULB(value uint16) {
	volatile.StoreUint16(&o.ADWINULB.Reg, value)
}
func (o *ADC121_Type) GetADWINULB() uint16 {
	return volatile.LoadUint16(&o.ADWINULB.Reg)
}

// ADC121.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC121_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC121.ADSSTRL: A/D Sampling State Register L
func (o *ADC121_Type) SetADSSTRL(value uint8) {
	volatile.StoreUint8(&o.ADSSTRL.Reg, value)
}
func (o *ADC121_Type) GetADSSTRL() uint8 {
	return volatile.LoadUint8(&o.ADSSTRL.Reg)
}

// ADC121.ADSSTRT: A/D Sampling State Register T
func (o *ADC121_Type) SetADSSTRT(value uint8) {
	volatile.StoreUint8(&o.ADSSTRT.Reg, value)
}
func (o *ADC121_Type) GetADSSTRT() uint8 {
	return volatile.LoadUint8(&o.ADSSTRT.Reg)
}

// ADC121.ADSSTRO: A/D Sampling State Register O
func (o *ADC121_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC121_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC121.ADSSTR00: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR00(value uint8) {
	volatile.StoreUint8(&o.ADSSTR00.Reg, value)
}
func (o *ADC121_Type) GetADSSTR00() uint8 {
	return volatile.LoadUint8(&o.ADSSTR00.Reg)
}

// ADC121.ADSSTR01: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR01(value uint8) {
	volatile.StoreUint8(&o.ADSSTR01.Reg, value)
}
func (o *ADC121_Type) GetADSSTR01() uint8 {
	return volatile.LoadUint8(&o.ADSSTR01.Reg)
}

// ADC121.ADSSTR02: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR02(value uint8) {
	volatile.StoreUint8(&o.ADSSTR02.Reg, value)
}
func (o *ADC121_Type) GetADSSTR02() uint8 {
	return volatile.LoadUint8(&o.ADSSTR02.Reg)
}

// ADC121.ADSSTR03: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR03(value uint8) {
	volatile.StoreUint8(&o.ADSSTR03.Reg, value)
}
func (o *ADC121_Type) GetADSSTR03() uint8 {
	return volatile.LoadUint8(&o.ADSSTR03.Reg)
}

// ADC121.ADSSTR05: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR05(value uint8) {
	volatile.StoreUint8(&o.ADSSTR05.Reg, value)
}
func (o *ADC121_Type) GetADSSTR05() uint8 {
	return volatile.LoadUint8(&o.ADSSTR05.Reg)
}

// ADC121.ADSSTR06: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR06(value uint8) {
	volatile.StoreUint8(&o.ADSSTR06.Reg, value)
}
func (o *ADC121_Type) GetADSSTR06() uint8 {
	return volatile.LoadUint8(&o.ADSSTR06.Reg)
}

// ADC121.ADSSTR07: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
func (o *ADC121_Type) SetADSSTR07(value uint8) {
	volatile.StoreUint8(&o.ADSSTR07.Reg, value)
}
func (o *ADC121_Type) GetADSSTR07() uint8 {
	return volatile.LoadUint8(&o.ADSSTR07.Reg)
}

// ADC121.ADPGACR: A/D Programmable Gain Amplifier Control Register
func (o *ADC121_Type) SetADPGACR_P002GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x800)|value<<11)
}
func (o *ADC121_Type) GetADPGACR_P002GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x800) >> 11
}
func (o *ADC121_Type) SetADPGACR_P002ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x400)|value<<10)
}
func (o *ADC121_Type) GetADPGACR_P002ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x400) >> 10
}
func (o *ADC121_Type) SetADPGACR_P002SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x200)|value<<9)
}
func (o *ADC121_Type) GetADPGACR_P002SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x200) >> 9
}
func (o *ADC121_Type) SetADPGACR_P002SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x100)|value<<8)
}
func (o *ADC121_Type) GetADPGACR_P002SEL0() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x100) >> 8
}
func (o *ADC121_Type) SetADPGACR_P001GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADPGACR_P001GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADPGACR_P001ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x40)|value<<6)
}
func (o *ADC121_Type) GetADPGACR_P001ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x40) >> 6
}
func (o *ADC121_Type) SetADPGACR_P001SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x20)|value<<5)
}
func (o *ADC121_Type) GetADPGACR_P001SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x20) >> 5
}
func (o *ADC121_Type) SetADPGACR_P001SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x10)|value<<4)
}
func (o *ADC121_Type) GetADPGACR_P001SEL0() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x10) >> 4
}
func (o *ADC121_Type) SetADPGACR_P000GEN(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADPGACR_P000GEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADPGACR_P000ENAMP(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x4)|value<<2)
}
func (o *ADC121_Type) GetADPGACR_P000ENAMP() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x4) >> 2
}
func (o *ADC121_Type) SetADPGACR_P000SEL1(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x2)|value<<1)
}
func (o *ADC121_Type) GetADPGACR_P000SEL1() uint16 {
	return (volatile.LoadUint16(&o.ADPGACR.Reg) & 0x2) >> 1
}
func (o *ADC121_Type) SetADPGACR_P000SEL0(value uint16) {
	volatile.StoreUint16(&o.ADPGACR.Reg, volatile.LoadUint16(&o.ADPGACR.Reg)&^(0x1)|value)
}
func (o *ADC121_Type) GetADPGACR_P000SEL0() uint16 {
	return volatile.LoadUint16(&o.ADPGACR.Reg) & 0x1
}

// ADC121.ADPGAGS0: A/D Programmable Gain Amplifier Gain Setting Register 0
func (o *ADC121_Type) SetADPGAGS0_P002GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf00)|value<<8)
}
func (o *ADC121_Type) GetADPGAGS0_P002GAIN() uint16 {
	return (volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf00) >> 8
}
func (o *ADC121_Type) SetADPGAGS0_P001GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf0)|value<<4)
}
func (o *ADC121_Type) GetADPGAGS0_P001GAIN() uint16 {
	return (volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf0) >> 4
}
func (o *ADC121_Type) SetADPGAGS0_P000GAIN(value uint16) {
	volatile.StoreUint16(&o.ADPGAGS0.Reg, volatile.LoadUint16(&o.ADPGAGS0.Reg)&^(0xf)|value)
}
func (o *ADC121_Type) GetADPGAGS0_P000GAIN() uint16 {
	return volatile.LoadUint16(&o.ADPGAGS0.Reg) & 0xf
}

// ADC121.ADPGADCR0: A/D Programmable Gain Amplifier Differential Input Control Register
func (o *ADC121_Type) SetADPGADCR0_P003DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x3000)|value<<12)
}
func (o *ADC121_Type) GetADPGADCR0_P003DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x3000) >> 12
}
func (o *ADC121_Type) SetADPGADCR0_P002DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x800)|value<<11)
}
func (o *ADC121_Type) GetADPGADCR0_P002DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x800) >> 11
}
func (o *ADC121_Type) SetADPGADCR0_P002DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x300)|value<<8)
}
func (o *ADC121_Type) GetADPGADCR0_P002DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x300) >> 8
}
func (o *ADC121_Type) SetADPGADCR0_P001DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC121_Type) GetADPGADCR0_P001DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x80) >> 7
}
func (o *ADC121_Type) SetADPGADCR0_P001DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x30)|value<<4)
}
func (o *ADC121_Type) GetADPGADCR0_P001DG() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x30) >> 4
}
func (o *ADC121_Type) SetADPGADCR0_P000DEN(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC121_Type) GetADPGADCR0_P000DEN() uint16 {
	return (volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x8) >> 3
}
func (o *ADC121_Type) SetADPGADCR0_P000DG(value uint16) {
	volatile.StoreUint16(&o.ADPGADCR0.Reg, volatile.LoadUint16(&o.ADPGADCR0.Reg)&^(0x3)|value)
}
func (o *ADC121_Type) GetADPGADCR0_P000DG() uint16 {
	return volatile.LoadUint16(&o.ADPGADCR0.Reg) & 0x3
}

// Module Stop Control B,C,D
type MSTP_Type struct {
	MSTPCRB volatile.Register32 // 0x0
	MSTPCRC volatile.Register32 // 0x4
	MSTPCRD volatile.Register32 // 0x8
}

// MSTP.MSTPCRB: Module Stop Control Register B
func (o *MSTP_Type) SetMSTPCRB_MSTPB31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB27(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x8000000)|value<<27)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB27() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x8000000) >> 27
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB26(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4000000)|value<<26)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB26() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4000000) >> 26
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB25(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x2000000)|value<<25)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB25() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x2000000) >> 25
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB24(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x1000000)|value<<24)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB24() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x1000000) >> 24
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB23(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x800000)|value<<23)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB23() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x800000) >> 23
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB18(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB18() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB15(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB15() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB12(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x1000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB12() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x1000) >> 12
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB7(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB7() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80) >> 7
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x2) >> 1
}

// MSTP.MSTPCRC: Module Stop Control Register C
func (o *MSTP_Type) SetMSTPCRC_MSTPC31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC12(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC12() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1000) >> 12
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC7(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC7() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80) >> 7
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC4(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x10)|value<<4)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC4() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x10) >> 4
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1
}

// MSTP.MSTPCRD: Module Stop Control Register D
func (o *MSTP_Type) SetMSTPCRD_MSTPD28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD27(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8000000)|value<<27)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD27() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8000000) >> 27
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD26(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000000)|value<<26)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD26() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000000) >> 26
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD25(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x2000000)|value<<25)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD25() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x2000000) >> 25
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD24(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x1000000)|value<<24)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD24() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x1000000) >> 24
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD23(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x800000)|value<<23)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD23() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x800000) >> 23
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD20(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x100000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD20() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x100000) >> 20
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD16(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000)|value<<16)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD16() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000) >> 16
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD15(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD15() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4) >> 2
}

// General PWM Timer 8 (32-bit Enhanced)
type GPT328_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT328.GTWP: General PWM Timer Write-Protection Register
func (o *GPT328_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT328_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT328_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT328.GTSTR: General PWM Timer Software Start Register
func (o *GPT328_Type) SetGTSTR_CSTRT13(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTSTR_CSTRT13() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTSTR_CSTRT12(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTSTR_CSTRT12() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTSTR_CSTRT11(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTSTR_CSTRT11() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTSTR_CSTRT10(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTSTR_CSTRT10() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTSTR_CSTRT9(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTSTR_CSTRT9() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTSTR_CSTRT8(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTSTR_CSTRT8() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTSTR_CSTRT7(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTSTR_CSTRT7() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT328.GTSTP: General PWM Timer Software Stop Register
func (o *GPT328_Type) SetGTSTP_CSTOP13(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTSTP_CSTOP13() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTSTP_CSTOP12(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTSTP_CSTOP12() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTSTP_CSTOP11(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTSTP_CSTOP11() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTSTP_CSTOP10(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTSTP_CSTOP10() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTSTP_CSTOP9(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTSTP_CSTOP9() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTSTP_CSTOP8(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTSTP_CSTOP8() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTSTP_CSTOP7(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTSTP_CSTOP7() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT328.GTCLR: General PWM Timer Software Clear Register
func (o *GPT328_Type) SetGTCLR_CCLR13(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTCLR_CCLR13() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTCLR_CCLR12(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTCLR_CCLR12() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTCLR_CCLR11(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTCLR_CCLR11() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTCLR_CCLR10(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTCLR_CCLR10() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTCLR_CCLR9(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTCLR_CCLR9() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTCLR_CCLR8(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTCLR_CCLR8() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTCLR_CCLR7(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTCLR_CCLR7() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT328.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT328_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT328_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT328_Type) SetGTSSR_SSELCH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTSSR_SSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTSSR_SSELCG(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTSSR_SSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTSSR_SSELCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTSSR_SSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTSSR_SSELCE(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTSSR_SSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTSSR_SSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTSSR_SSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTSSR_SSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTSSR_SSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT328.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT328_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT328_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT328_Type) SetGTPSR_PSELCH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTPSR_PSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTPSR_PSELCG(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTPSR_PSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTPSR_PSELCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTPSR_PSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTPSR_PSELCE(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTPSR_PSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTPSR_PSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTPSR_PSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTPSR_PSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTPSR_PSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT328.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT328_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT328_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT328_Type) SetGTCSR_CSELCH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTCSR_CSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTCSR_CSELCG(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTCSR_CSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTCSR_CSELCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTCSR_CSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTCSR_CSELCE(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTCSR_CSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTCSR_CSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTCSR_CSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTCSR_CSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTCSR_CSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT328.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT328_Type) SetGTUPSR_USELCH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTUPSR_USELCH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTUPSR_USELCG(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTUPSR_USELCG() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTUPSR_USELCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTUPSR_USELCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTUPSR_USELCE(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTUPSR_USELCE() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTUPSR_USGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTUPSR_USGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTUPSR_USGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTUPSR_USGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT328.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT328_Type) SetGTDNSR_DSELCH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTDNSR_DSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTDNSR_DSELCG(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTDNSR_DSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTDNSR_DSELCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTDNSR_DSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTDNSR_DSELCE(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTDNSR_DSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT328.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT328_Type) SetGTICASR_ASELCH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTICASR_ASELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTICASR_ASELCG(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTICASR_ASELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTICASR_ASELCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTICASR_ASELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTICASR_ASELCE(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTICASR_ASELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTICASR_ASGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTICASR_ASGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTICASR_ASGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTICASR_ASGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT328.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT328_Type) SetGTICBSR_BSELCH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTICBSR_BSELCH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTICBSR_BSELCG(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTICBSR_BSELCG() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTICBSR_BSELCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT328_Type) GetGTICBSR_BSELCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200000) >> 21
}
func (o *GPT328_Type) SetGTICBSR_BSELCE(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT328_Type) GetGTICBSR_BSELCE() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100000) >> 20
}
func (o *GPT328_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT328_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT328_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT328_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT328_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT328_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT328_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT328_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT328_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT328_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT328_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT328_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT328_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT328_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT328_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGDF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGDF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGDR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGDR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGCF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGCF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGCR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGCR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT328.GTCR: General PWM Timer Control Register
func (o *GPT328_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT328_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT328_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT328_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT328_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT328.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT328_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT328_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT328_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT328_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT328_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT328_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT328_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT328_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT328_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT328_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT328_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT328_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT328_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT328.GTIOR: General PWM Timer I/O Control Register
func (o *GPT328_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT328_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT328_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT328_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT328_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT328_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT328_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT328_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT328_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT328_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT328_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT328_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT328_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT328_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT328_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT328_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT328_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT328_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT328_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT328_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT328_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT328_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT328.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT328_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT328_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT328_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT328_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT328_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT328_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}

// GPT328.GTST: General PWM Timer Status Register
func (o *GPT328_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT328_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT328_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT328_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT328_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT328_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT328_Type) SetGTST_TUCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT328_Type) GetGTST_TUCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT328_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT328_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT328_Type) SetGTST_TCPFO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT328_Type) GetGTST_TCPFO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT328_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT328_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT328_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT328_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT328_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT328_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT328_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT328_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT328_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT328.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT328_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT328_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT328_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT328_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT328_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT328_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT328_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT328_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT328_Type) SetGTBER_BD1(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x2)|value<<1)
}
func (o *GPT328_Type) GetGTBER_BD1() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x2) >> 1
}
func (o *GPT328_Type) SetGTBER_BD2(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTBER_BD2() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x1
}

// GPT328.GTCNT: General PWM Timer Counter
func (o *GPT328_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT328_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT328.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT328_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, value)
}
func (o *GPT328_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg)
}

// GPT328.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT328_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, value)
}
func (o *GPT328_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg)
}

// GPT328.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT328_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, value)
}
func (o *GPT328_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg)
}

// GPT328.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT328_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, value)
}
func (o *GPT328_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg)
}

// GPT328.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT328_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, value)
}
func (o *GPT328_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg)
}

// GPT328.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT328_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, value)
}
func (o *GPT328_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg)
}

// GPT328.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT328_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, value)
}
func (o *GPT328_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg)
}

// GPT328.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT328_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, value)
}
func (o *GPT328_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg)
}

// GPT328.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT328_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT328_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT328.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT328_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, value)
}
func (o *GPT328_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg)
}

// Realtime Clock
type RTC_Type struct {
	R64CNT  volatile.Register8 // 0x0
	_       byte
	RSECCNT volatile.Register8 // 0x2
	_       byte
	RMINCNT volatile.Register8 // 0x4
	_       byte
	RHRCNT  volatile.Register8 // 0x6
	_       byte
	RWKCNT  volatile.Register8 // 0x8
	_       byte
	RDAYCNT volatile.Register8 // 0xA
	_       byte
	RMONCNT volatile.Register8 // 0xC
	_       byte
	RYRCNT  volatile.Register16 // 0xE
	RSECAR  volatile.Register8  // 0x10
	_       byte
	RMINAR  volatile.Register8 // 0x12
	_       byte
	RHRAR   volatile.Register8 // 0x14
	_       byte
	RWKAR   volatile.Register8 // 0x16
	_       byte
	RDAYAR  volatile.Register8 // 0x18
	_       byte
	RMONAR  volatile.Register8 // 0x1A
	_       byte
	RYRAR   volatile.Register16 // 0x1C
	RYRAREN volatile.Register8  // 0x1E
	_       [3]byte
	RCR1    volatile.Register8 // 0x22
	_       byte
	RCR2    volatile.Register8 // 0x24
	_       [3]byte
	RCR4    volatile.Register8 // 0x28
	_       byte
	RFRH    volatile.Register16 // 0x2A
	RFRL    volatile.Register16 // 0x2C
	RADJ    volatile.Register8  // 0x2E
	_       [17]byte
	RTCCR0  volatile.Register8 // 0x40
	_       byte
	RTCCR1  volatile.Register8 // 0x42
	_       byte
	RTCCR2  volatile.Register8 // 0x44
	_       [13]byte
	RSECCP0 volatile.Register8 // 0x52
	_       byte
	RMINCP0 volatile.Register8 // 0x54
	_       byte
	RHRCP0  volatile.Register8 // 0x56
	_       [3]byte
	RDAYCP0 volatile.Register8 // 0x5A
	_       byte
	RMONCP0 volatile.Register8 // 0x5C
	_       [5]byte
	RSECCP1 volatile.Register8 // 0x62
	_       byte
	RMINCP1 volatile.Register8 // 0x64
	_       byte
	RHRCP1  volatile.Register8 // 0x66
	_       [3]byte
	RDAYCP1 volatile.Register8 // 0x6A
	_       byte
	RMONCP1 volatile.Register8 // 0x6C
	_       [5]byte
	RSECCP2 volatile.Register8 // 0x72
	_       byte
	RMINCP2 volatile.Register8 // 0x74
	_       byte
	RHRCP2  volatile.Register8 // 0x76
	_       [3]byte
	RDAYCP2 volatile.Register8 // 0x7A
	_       byte
	RMONCP2 volatile.Register8 // 0x7C
}

// RTC.R64CNT: 64-Hz Counter
func (o *RTC_Type) SetR64CNT_F1HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetR64CNT_F1HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetR64CNT_F2HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetR64CNT_F2HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetR64CNT_F4HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetR64CNT_F4HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetR64CNT_F8HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetR64CNT_F8HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetR64CNT_F16HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetR64CNT_F16HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetR64CNT_F32HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetR64CNT_F32HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetR64CNT_F64HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetR64CNT_F64HZ() uint8 {
	return volatile.LoadUint8(&o.R64CNT.Reg) & 0x1
}

// RTC.RSECCNT: Second Counter
func (o *RTC_Type) SetRSECCNT_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCNT_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCNT_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCNT_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCNT.Reg) & 0xf
}

// RTC.RMINCNT: Minute Counter
func (o *RTC_Type) SetRMINCNT_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCNT_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCNT_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCNT_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCNT.Reg) & 0xf
}

// RTC.RHRCNT: Hour Counter
func (o *RTC_Type) SetRHRCNT_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCNT_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCNT_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCNT_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCNT_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCNT_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCNT.Reg) & 0xf
}

// RTC.RWKCNT: Day-of-Week Counter
func (o *RTC_Type) SetRWKCNT_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKCNT.Reg, volatile.LoadUint8(&o.RWKCNT.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKCNT_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKCNT.Reg) & 0x7
}

// RTC.RDAYCNT: Day Counter
func (o *RTC_Type) SetRDAYCNT_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCNT_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCNT_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCNT_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCNT.Reg) & 0xf
}

// RTC.RMONCNT: Month Counter
func (o *RTC_Type) SetRMONCNT_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCNT_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCNT_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCNT_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCNT.Reg) & 0xf
}

// RTC.RYRCNT: Year Counter
func (o *RTC_Type) SetRYRCNT_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRCNT_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRCNT_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRCNT_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf
}

// RTC.RSECAR: Second Alarm Register
func (o *RTC_Type) SetRSECAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECAR_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECAR_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECAR_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECAR_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECAR.Reg) & 0xf
}

// RTC.RMINAR: Minute Alarm Register
func (o *RTC_Type) SetRMINAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINAR_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINAR_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINAR_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINAR_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINAR.Reg) & 0xf
}

// RTC.RHRAR: Hour Alarm Register
func (o *RTC_Type) SetRHRAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRAR_PM(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRAR_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRAR_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRAR_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRAR_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRAR_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRAR.Reg) & 0xf
}

// RTC.RWKAR: Day-of-Week Alarm Register
func (o *RTC_Type) SetRWKAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRWKAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RWKAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRWKAR_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKAR_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKAR.Reg) & 0x7
}

// RTC.RDAYAR: Date Alarm Register
func (o *RTC_Type) SetRDAYAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRDAYAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRDAYAR_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYAR_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYAR_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYAR_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYAR.Reg) & 0xf
}

// RTC.RMONAR: Month Alarm Register
func (o *RTC_Type) SetRMONAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMONAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMONAR_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONAR_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONAR_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONAR_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONAR.Reg) & 0xf
}

// RTC.RYRAR: Year Alarm Register
func (o *RTC_Type) SetRYRAR_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRAR_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRAR.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRAR_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRAR_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRAR.Reg) & 0xf
}

// RTC.RYRAREN: Year Alarm Enable Register
func (o *RTC_Type) SetRYRAREN_ENB(value uint8) {
	volatile.StoreUint8(&o.RYRAREN.Reg, volatile.LoadUint8(&o.RYRAREN.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRYRAREN_ENB() uint8 {
	return (volatile.LoadUint8(&o.RYRAREN.Reg) & 0x80) >> 7
}

// RTC.RCR1: RTC Control Register 1
func (o *RTC_Type) SetRCR1_PES(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRCR1_PES() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRCR1_RTCOS(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR1_RTCOS() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR1_PIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR1_PIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR1_CIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR1_CIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR1_AIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR1_AIE() uint8 {
	return volatile.LoadUint8(&o.RCR1.Reg) & 0x1
}

// RTC.RCR2: RTC Control Register 2
func (o *RTC_Type) SetRCR2_CNTMD(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR2_CNTMD() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRCR2_HR24(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRCR2_HR24() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRCR2_AADJP(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRCR2_AADJP() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRCR2_AADJE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRCR2_AADJE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRCR2_RTCOE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR2_RTCOE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR2_ADJ30(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR2_ADJ30() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR2_RESET(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR2_RESET() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR2_START(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR2_START() uint8 {
	return volatile.LoadUint8(&o.RCR2.Reg) & 0x1
}

// RTC.RCR4: RTC Control Register 4
func (o *RTC_Type) SetRCR4_RCKSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR4_RCKSEL() uint8 {
	return volatile.LoadUint8(&o.RCR4.Reg) & 0x1
}

// RTC.RFRH: Frequency Register H
func (o *RTC_Type) SetRFRH_RFC16(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRFRH_RFC16() uint16 {
	return volatile.LoadUint16(&o.RFRH.Reg) & 0x1
}

// RTC.RFRL: Frequency Register L
func (o *RTC_Type) SetRFRL(value uint16) {
	volatile.StoreUint16(&o.RFRL.Reg, value)
}
func (o *RTC_Type) GetRFRL() uint16 {
	return volatile.LoadUint16(&o.RFRL.Reg)
}

// RTC.RADJ: Time Error Adjustment Register
func (o *RTC_Type) SetRADJ_PMADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRADJ_PMADJ() uint8 {
	return (volatile.LoadUint8(&o.RADJ.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRADJ_ADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRADJ_ADJ() uint8 {
	return volatile.LoadUint8(&o.RADJ.Reg) & 0x3f
}

// RTC.RTCCR0: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR0_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR0_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR0_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR0_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR0.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR0_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR0.Reg, volatile.LoadUint8(&o.RTCCR0.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR0_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR0.Reg) & 0x3
}

// RTC.RTCCR1: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR1_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR1_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR1_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR1_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR1_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR1.Reg, volatile.LoadUint8(&o.RTCCR1.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR1_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR1.Reg) & 0x3
}

// RTC.RTCCR2: Time Capture Control Register %s
func (o *RTC_Type) SetRTCCR2_TCNF(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRTCCR2_TCNF() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRTCCR2_TCST(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRTCCR2_TCST() uint8 {
	return (volatile.LoadUint8(&o.RTCCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRTCCR2_TCCT(value uint8) {
	volatile.StoreUint8(&o.RTCCR2.Reg, volatile.LoadUint8(&o.RTCCR2.Reg)&^(0x3)|value)
}
func (o *RTC_Type) GetRTCCR2_TCCT() uint8 {
	return volatile.LoadUint8(&o.RTCCR2.Reg) & 0x3
}

// RTC.RSECCP0: Second Capture Register %s
func (o *RTC_Type) SetRSECCP0_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP0.Reg, volatile.LoadUint8(&o.RSECCP0.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP0_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP0.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP0_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP0.Reg, volatile.LoadUint8(&o.RSECCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP0_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP0.Reg) & 0xf
}

// RTC.RMINCP0: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP0_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP0.Reg, volatile.LoadUint8(&o.RMINCP0.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP0_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP0.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP0_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP0.Reg, volatile.LoadUint8(&o.RMINCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP0_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP0.Reg) & 0xf
}

// RTC.RHRCP0: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP0_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP0_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP0.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP0_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP0_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP0_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP0.Reg, volatile.LoadUint8(&o.RHRCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP0_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP0.Reg) & 0xf
}

// RTC.RDAYCP0: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP0_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP0.Reg, volatile.LoadUint8(&o.RDAYCP0.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP0_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP0.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP0_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP0.Reg, volatile.LoadUint8(&o.RDAYCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP0_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP0.Reg) & 0xf
}

// RTC.RMONCP0: Month Capture Register %s
func (o *RTC_Type) SetRMONCP0_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP0_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP0.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP0_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP0.Reg, volatile.LoadUint8(&o.RMONCP0.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP0_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP0.Reg) & 0xf
}

// RTC.RSECCP1: Second Capture Register %s
func (o *RTC_Type) SetRSECCP1_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP1.Reg, volatile.LoadUint8(&o.RSECCP1.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP1_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP1.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP1_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP1.Reg, volatile.LoadUint8(&o.RSECCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP1_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP1.Reg) & 0xf
}

// RTC.RMINCP1: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP1_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP1.Reg, volatile.LoadUint8(&o.RMINCP1.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP1_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP1.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP1_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP1.Reg, volatile.LoadUint8(&o.RMINCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP1_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP1.Reg) & 0xf
}

// RTC.RHRCP1: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP1_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP1_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP1.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP1_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP1_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP1_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP1.Reg, volatile.LoadUint8(&o.RHRCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP1_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP1.Reg) & 0xf
}

// RTC.RDAYCP1: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP1_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP1.Reg, volatile.LoadUint8(&o.RDAYCP1.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP1_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP1.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP1_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP1.Reg, volatile.LoadUint8(&o.RDAYCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP1_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP1.Reg) & 0xf
}

// RTC.RMONCP1: Month Capture Register %s
func (o *RTC_Type) SetRMONCP1_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP1_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP1.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP1_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP1.Reg, volatile.LoadUint8(&o.RMONCP1.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP1_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP1.Reg) & 0xf
}

// RTC.RSECCP2: Second Capture Register %s
func (o *RTC_Type) SetRSECCP2_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCP2.Reg, volatile.LoadUint8(&o.RSECCP2.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCP2_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCP2.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCP2_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCP2.Reg, volatile.LoadUint8(&o.RSECCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCP2_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCP2.Reg) & 0xf
}

// RTC.RMINCP2: Minute Capture Register %s
func (o *RTC_Type) SetRMINCP2_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCP2.Reg, volatile.LoadUint8(&o.RMINCP2.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCP2_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCP2.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCP2_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCP2.Reg, volatile.LoadUint8(&o.RMINCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCP2_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCP2.Reg) & 0xf
}

// RTC.RHRCP2: Hour Capture Register %s
func (o *RTC_Type) SetRHRCP2_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCP2_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCP2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCP2_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCP2_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCP2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCP2_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCP2.Reg, volatile.LoadUint8(&o.RHRCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCP2_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCP2.Reg) & 0xf
}

// RTC.RDAYCP2: Date Capture Register %s
func (o *RTC_Type) SetRDAYCP2_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCP2.Reg, volatile.LoadUint8(&o.RDAYCP2.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCP2_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCP2.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCP2_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCP2.Reg, volatile.LoadUint8(&o.RDAYCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCP2_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCP2.Reg) & 0xf
}

// RTC.RMONCP2: Month Capture Register %s
func (o *RTC_Type) SetRMONCP2_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCP2_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCP2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCP2_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCP2.Reg, volatile.LoadUint8(&o.RMONCP2.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCP2_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCP2.Reg) & 0xf
}

// Serial Sound Interface Enhanced (SSIE)
type SSIE0_Type struct {
	SSICR   volatile.Register32 // 0x0
	SSISR   volatile.Register32 // 0x4
	_       [8]byte
	SSIFCR  volatile.Register32 // 0x10
	SSIFSR  volatile.Register32 // 0x14
	SSIFTDR volatile.Register32 // 0x18
	SSIFRDR volatile.Register32 // 0x1C
	SSIOFR  volatile.Register32 // 0x20
	SSISCR  volatile.Register32 // 0x24
}

// SSIE0.SSICR: Control Register
func (o *SSIE0_Type) SetSSICR_CKS(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x40000000)|value<<30)
}
func (o *SSIE0_Type) GetSSICR_CKS() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x40000000) >> 30
}
func (o *SSIE0_Type) SetSSICR_TUIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x20000000)|value<<29)
}
func (o *SSIE0_Type) GetSSICR_TUIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x20000000) >> 29
}
func (o *SSIE0_Type) SetSSICR_TOIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x10000000)|value<<28)
}
func (o *SSIE0_Type) GetSSICR_TOIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x10000000) >> 28
}
func (o *SSIE0_Type) SetSSICR_RUIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x8000000)|value<<27)
}
func (o *SSIE0_Type) GetSSICR_RUIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x8000000) >> 27
}
func (o *SSIE0_Type) SetSSICR_ROIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x4000000)|value<<26)
}
func (o *SSIE0_Type) GetSSICR_ROIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x4000000) >> 26
}
func (o *SSIE0_Type) SetSSICR_IIEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2000000)|value<<25)
}
func (o *SSIE0_Type) GetSSICR_IIEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2000000) >> 25
}
func (o *SSIE0_Type) SetSSICR_CHNL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0xc00000)|value<<22)
}
func (o *SSIE0_Type) GetSSICR_CHNL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0xc00000) >> 22
}
func (o *SSIE0_Type) SetSSICR_DWL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x380000)|value<<19)
}
func (o *SSIE0_Type) GetSSICR_DWL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x380000) >> 19
}
func (o *SSIE0_Type) SetSSICR_SWL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x70000)|value<<16)
}
func (o *SSIE0_Type) GetSSICR_SWL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x70000) >> 16
}
func (o *SSIE0_Type) SetSSICR_SWSD(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x4000)|value<<14)
}
func (o *SSIE0_Type) GetSSICR_SWSD() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x4000) >> 14
}
func (o *SSIE0_Type) SetSSICR_SCKP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2000)|value<<13)
}
func (o *SSIE0_Type) GetSSICR_SCKP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2000) >> 13
}
func (o *SSIE0_Type) SetSSICR_SWSP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x1000)|value<<12)
}
func (o *SSIE0_Type) GetSSICR_SWSP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x1000) >> 12
}
func (o *SSIE0_Type) SetSSICR_SPDP(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x800)|value<<11)
}
func (o *SSIE0_Type) GetSSICR_SPDP() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x800) >> 11
}
func (o *SSIE0_Type) SetSSICR_SDTA(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x400)|value<<10)
}
func (o *SSIE0_Type) GetSSICR_SDTA() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x400) >> 10
}
func (o *SSIE0_Type) SetSSICR_PDTA(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x200)|value<<9)
}
func (o *SSIE0_Type) GetSSICR_PDTA() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x200) >> 9
}
func (o *SSIE0_Type) SetSSICR_DEL(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x100)|value<<8)
}
func (o *SSIE0_Type) GetSSICR_DEL() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x100) >> 8
}
func (o *SSIE0_Type) SetSSICR_CKDV(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0xf0)|value<<4)
}
func (o *SSIE0_Type) GetSSICR_CKDV() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0xf0) >> 4
}
func (o *SSIE0_Type) SetSSICR_MUEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x8)|value<<3)
}
func (o *SSIE0_Type) GetSSICR_MUEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x8) >> 3
}
func (o *SSIE0_Type) SetSSICR_TEN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x2)|value<<1)
}
func (o *SSIE0_Type) GetSSICR_TEN() uint32 {
	return (volatile.LoadUint32(&o.SSICR.Reg) & 0x2) >> 1
}
func (o *SSIE0_Type) SetSSICR_REN(value uint32) {
	volatile.StoreUint32(&o.SSICR.Reg, volatile.LoadUint32(&o.SSICR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSICR_REN() uint32 {
	return volatile.LoadUint32(&o.SSICR.Reg) & 0x1
}

// SSIE0.SSISR: Status Register
func (o *SSIE0_Type) SetSSISR_TUIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x20000000)|value<<29)
}
func (o *SSIE0_Type) GetSSISR_TUIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x20000000) >> 29
}
func (o *SSIE0_Type) SetSSISR_TOIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x10000000)|value<<28)
}
func (o *SSIE0_Type) GetSSISR_TOIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x10000000) >> 28
}
func (o *SSIE0_Type) SetSSISR_RUIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x8000000)|value<<27)
}
func (o *SSIE0_Type) GetSSISR_RUIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x8000000) >> 27
}
func (o *SSIE0_Type) SetSSISR_ROIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x4000000)|value<<26)
}
func (o *SSIE0_Type) GetSSISR_ROIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x4000000) >> 26
}
func (o *SSIE0_Type) SetSSISR_IIRQ(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x2000000)|value<<25)
}
func (o *SSIE0_Type) GetSSISR_IIRQ() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x2000000) >> 25
}
func (o *SSIE0_Type) SetSSISR_TCHNO(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x60)|value<<5)
}
func (o *SSIE0_Type) GetSSISR_TCHNO() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x60) >> 5
}
func (o *SSIE0_Type) SetSSISR_TSWNO(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x10)|value<<4)
}
func (o *SSIE0_Type) GetSSISR_TSWNO() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x10) >> 4
}
func (o *SSIE0_Type) SetSSISR_RCHNO(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0xc)|value<<2)
}
func (o *SSIE0_Type) GetSSISR_RCHNO() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0xc) >> 2
}
func (o *SSIE0_Type) SetSSISR_RSWNO(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x2)|value<<1)
}
func (o *SSIE0_Type) GetSSISR_RSWNO() uint32 {
	return (volatile.LoadUint32(&o.SSISR.Reg) & 0x2) >> 1
}
func (o *SSIE0_Type) SetSSISR_IDST(value uint32) {
	volatile.StoreUint32(&o.SSISR.Reg, volatile.LoadUint32(&o.SSISR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSISR_IDST() uint32 {
	return volatile.LoadUint32(&o.SSISR.Reg) & 0x1
}

// SSIE0.SSIFCR: FIFO Control Register
func (o *SSIE0_Type) SetSSIFCR_AUCKE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SSIE0_Type) GetSSIFCR_AUCKE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x80000000) >> 31
}
func (o *SSIE0_Type) SetSSIFCR_SSIRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x10000)|value<<16)
}
func (o *SSIE0_Type) GetSSIFCR_SSIRST() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x10000) >> 16
}
func (o *SSIE0_Type) SetSSIFCR_TTRG(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0xc0)|value<<6)
}
func (o *SSIE0_Type) GetSSIFCR_TTRG() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0xc0) >> 6
}
func (o *SSIE0_Type) SetSSIFCR_RTRG(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x30)|value<<4)
}
func (o *SSIE0_Type) GetSSIFCR_RTRG() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x30) >> 4
}
func (o *SSIE0_Type) SetSSIFCR_TIE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x8)|value<<3)
}
func (o *SSIE0_Type) GetSSIFCR_TIE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x8) >> 3
}
func (o *SSIE0_Type) SetSSIFCR_RIE(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x4)|value<<2)
}
func (o *SSIE0_Type) GetSSIFCR_RIE() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x4) >> 2
}
func (o *SSIE0_Type) SetSSIFCR_TFRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x2)|value<<1)
}
func (o *SSIE0_Type) GetSSIFCR_TFRST() uint32 {
	return (volatile.LoadUint32(&o.SSIFCR.Reg) & 0x2) >> 1
}
func (o *SSIE0_Type) SetSSIFCR_RFRST(value uint32) {
	volatile.StoreUint32(&o.SSIFCR.Reg, volatile.LoadUint32(&o.SSIFCR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSIFCR_RFRST() uint32 {
	return volatile.LoadUint32(&o.SSIFCR.Reg) & 0x1
}

// SSIE0.SSIFSR: FIFO Status Register
func (o *SSIE0_Type) SetSSIFSR_TDC(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0xf000000)|value<<24)
}
func (o *SSIE0_Type) GetSSIFSR_TDC() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0xf000000) >> 24
}
func (o *SSIE0_Type) SetSSIFSR_TDE(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x10000)|value<<16)
}
func (o *SSIE0_Type) GetSSIFSR_TDE() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0x10000) >> 16
}
func (o *SSIE0_Type) SetSSIFSR_RDC(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0xf00)|value<<8)
}
func (o *SSIE0_Type) GetSSIFSR_RDC() uint32 {
	return (volatile.LoadUint32(&o.SSIFSR.Reg) & 0xf00) >> 8
}
func (o *SSIE0_Type) SetSSIFSR_RDF(value uint32) {
	volatile.StoreUint32(&o.SSIFSR.Reg, volatile.LoadUint32(&o.SSIFSR.Reg)&^(0x1)|value)
}
func (o *SSIE0_Type) GetSSIFSR_RDF() uint32 {
	return volatile.LoadUint32(&o.SSIFSR.Reg) & 0x1
}

// SSIE0.SSIFTDR: Transmit FIFO Data Register
func (o *SSIE0_Type) SetSSIFTDR(value uint32) {
	volatile.StoreUint32(&o.SSIFTDR.Reg, value)
}
func (o *SSIE0_Type) GetSSIFTDR() uint32 {
	return volatile.LoadUint32(&o.SSIFTDR.Reg)
}

// SSIE0.SSIFRDR: Receive FIFO Data Register
func (o *SSIE0_Type) SetSSIFRDR(value uint32) {
	volatile.StoreUint32(&o.SSIFRDR.Reg, value)
}
func (o *SSIE0_Type) GetSSIFRDR() uint32 {
	return volatile.LoadUint32(&o.SSIFRDR.Reg)
}

// SSIE0.SSIOFR: Audio Format Register
func (o *SSIE0_Type) SetSSIOFR_BCKASTP(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x200)|value<<9)
}
func (o *SSIE0_Type) GetSSIOFR_BCKASTP() uint32 {
	return (volatile.LoadUint32(&o.SSIOFR.Reg) & 0x200) >> 9
}
func (o *SSIE0_Type) SetSSIOFR_LRCONT(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x100)|value<<8)
}
func (o *SSIE0_Type) GetSSIOFR_LRCONT() uint32 {
	return (volatile.LoadUint32(&o.SSIOFR.Reg) & 0x100) >> 8
}
func (o *SSIE0_Type) SetSSIOFR_OMOD(value uint32) {
	volatile.StoreUint32(&o.SSIOFR.Reg, volatile.LoadUint32(&o.SSIOFR.Reg)&^(0x3)|value)
}
func (o *SSIE0_Type) GetSSIOFR_OMOD() uint32 {
	return volatile.LoadUint32(&o.SSIOFR.Reg) & 0x3
}

// SSIE0.SSISCR: Status Control Register
func (o *SSIE0_Type) SetSSISCR_TDES(value uint32) {
	volatile.StoreUint32(&o.SSISCR.Reg, volatile.LoadUint32(&o.SSISCR.Reg)&^(0x1f00)|value<<8)
}
func (o *SSIE0_Type) GetSSISCR_TDES() uint32 {
	return (volatile.LoadUint32(&o.SSISCR.Reg) & 0x1f00) >> 8
}
func (o *SSIE0_Type) SetSSISCR_RDFS(value uint32) {
	volatile.StoreUint32(&o.SSISCR.Reg, volatile.LoadUint32(&o.SSISCR.Reg)&^(0x1f)|value)
}
func (o *SSIE0_Type) GetSSISCR_RDFS() uint32 {
	return volatile.LoadUint32(&o.SSISCR.Reg) & 0x1f
}

// USB 2.0 FS Module
type USBFS_Type struct {
	SYSCFG    volatile.Register16 // 0x0
	_         [2]byte
	SYSSTS0   volatile.Register16 // 0x4
	_         [2]byte
	DVSTCTR0  volatile.Register16 // 0x8
	_         [10]byte
	CFIFO     volatile.Register16 // 0x14
	_         [2]byte
	D0FIFO    volatile.Register16 // 0x18
	_         [2]byte
	D1FIFO    volatile.Register16 // 0x1C
	_         [2]byte
	CFIFOSEL  volatile.Register16 // 0x20
	CFIFOCTR  volatile.Register16 // 0x22
	_         [4]byte
	D0FIFOSEL volatile.Register16 // 0x28
	D0FIFOCTR volatile.Register16 // 0x2A
	D1FIFOSEL volatile.Register16 // 0x2C
	D1FIFOCTR volatile.Register16 // 0x2E
	INTENB0   volatile.Register16 // 0x30
	INTENB1   volatile.Register16 // 0x32
	_         [2]byte
	BRDYENB   volatile.Register16 // 0x36
	NRDYENB   volatile.Register16 // 0x38
	BEMPENB   volatile.Register16 // 0x3A
	SOFCFG    volatile.Register16 // 0x3C
	_         [2]byte
	INTSTS0   volatile.Register16 // 0x40
	INTSTS1   volatile.Register16 // 0x42
	_         [2]byte
	BRDYSTS   volatile.Register16 // 0x46
	NRDYSTS   volatile.Register16 // 0x48
	BEMPSTS   volatile.Register16 // 0x4A
	FRMNUM    volatile.Register16 // 0x4C
	DVCHGR    volatile.Register16 // 0x4E
	USBADDR   volatile.Register16 // 0x50
	_         [2]byte
	USBREQ    volatile.Register16 // 0x54
	USBVAL    volatile.Register16 // 0x56
	USBINDX   volatile.Register16 // 0x58
	USBLENG   volatile.Register16 // 0x5A
	DCPCFG    volatile.Register16 // 0x5C
	DCPMAXP   volatile.Register16 // 0x5E
	DCPCTR    volatile.Register16 // 0x60
	_         [2]byte
	PIPESEL   volatile.Register16 // 0x64
	_         [2]byte
	PIPECFG   volatile.Register16 // 0x68
	_         [2]byte
	PIPEMAXP  volatile.Register16 // 0x6C
	PIPEPERI  volatile.Register16 // 0x6E
	PIPE1CTR  volatile.Register16 // 0x70
	PIPE2CTR  volatile.Register16 // 0x72
	PIPE3CTR  volatile.Register16 // 0x74
	PIPE4CTR  volatile.Register16 // 0x76
	PIPE5CTR  volatile.Register16 // 0x78
	PIPE6CTR  volatile.Register16 // 0x7A
	PIPE7CTR  volatile.Register16 // 0x7C
	PIPE8CTR  volatile.Register16 // 0x7E
	PIPE9CTR  volatile.Register16 // 0x80
	_         [14]byte
	PIPE1TRE  volatile.Register16 // 0x90
	PIPE1TRN  volatile.Register16 // 0x92
	PIPE2TRE  volatile.Register16 // 0x94
	PIPE2TRN  volatile.Register16 // 0x96
	PIPE3TRE  volatile.Register16 // 0x98
	PIPE3TRN  volatile.Register16 // 0x9A
	PIPE4TRE  volatile.Register16 // 0x9C
	PIPE4TRN  volatile.Register16 // 0x9E
	PIPE5TRE  volatile.Register16 // 0xA0
	PIPE5TRN  volatile.Register16 // 0xA2
	_         [44]byte
	DEVADD0   volatile.Register16 // 0xD0
	DEVADD1   volatile.Register16 // 0xD2
	DEVADD2   volatile.Register16 // 0xD4
	DEVADD3   volatile.Register16 // 0xD6
	DEVADD4   volatile.Register16 // 0xD8
	DEVADD5   volatile.Register16 // 0xDA
	_         [20]byte
	PHYSLEW   volatile.Register32 // 0xF0
	_         [780]byte
	DPUSR0R   volatile.Register32 // 0x400
	DPUSR1R   volatile.Register32 // 0x404
}

// USBFS.SYSCFG: System Configuration Control Register
func (o *USBFS_Type) SetSYSCFG_SCKE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetSYSCFG_SCKE() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetSYSCFG_DCFM(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSCFG_DCFM() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSCFG_DRPD(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSYSCFG_DRPD() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSYSCFG_DPRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSYSCFG_DPRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSYSCFG_USBE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetSYSCFG_USBE() uint16 {
	return volatile.LoadUint16(&o.SYSCFG.Reg) & 0x1
}

// USBFS.SYSSTS0: System Configuration Status Register 0
func (o *USBFS_Type) SetSYSSTS0_OVCMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetSYSSTS0_OVCMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0xc000) >> 14
}
func (o *USBFS_Type) SetSYSSTS0_HTACT(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSYSSTS0_HTACT() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSYSSTS0_SOFEA(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSYSSTS0_SOFEA() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSYSSTS0_IDMON(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetSYSSTS0_IDMON() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetSYSSTS0_LNST(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetSYSSTS0_LNST() uint16 {
	return volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3
}

// USBFS.DVSTCTR0: Device State Control Register 0
func (o *USBFS_Type) SetDVSTCTR0_HNPBTOA(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDVSTCTR0_HNPBTOA() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDVSTCTR0_EXICEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetDVSTCTR0_EXICEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetDVSTCTR0_VBUSEN(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetDVSTCTR0_VBUSEN() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetDVSTCTR0_WKUP(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDVSTCTR0_WKUP() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDVSTCTR0_RWUPE(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDVSTCTR0_RWUPE() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDVSTCTR0_USBRST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDVSTCTR0_USBRST() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDVSTCTR0_RESUME(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDVSTCTR0_RESUME() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDVSTCTR0_UACT(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDVSTCTR0_UACT() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDVSTCTR0_RHST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetDVSTCTR0_RHST() uint16 {
	return volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x7
}

// USBFS.CFIFO: CFIFO Port Register
func (o *USBFS_Type) SetCFIFO(value uint16) {
	volatile.StoreUint16(&o.CFIFO.Reg, value)
}
func (o *USBFS_Type) GetCFIFO() uint16 {
	return volatile.LoadUint16(&o.CFIFO.Reg)
}

// USBFS.D0FIFO: D0FIFO Port Register
func (o *USBFS_Type) SetD0FIFO(value uint16) {
	volatile.StoreUint16(&o.D0FIFO.Reg, value)
}
func (o *USBFS_Type) GetD0FIFO() uint16 {
	return volatile.LoadUint16(&o.D0FIFO.Reg)
}

// USBFS.D1FIFO: D1FIFO Port Register
func (o *USBFS_Type) SetD1FIFO(value uint16) {
	volatile.StoreUint16(&o.D1FIFO.Reg, value)
}
func (o *USBFS_Type) GetD1FIFO() uint16 {
	return volatile.LoadUint16(&o.D1FIFO.Reg)
}

// USBFS.CFIFOSEL: CFIFO Port Select Register
func (o *USBFS_Type) SetCFIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetCFIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetCFIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetCFIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetCFIFOSEL_ISEL(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetCFIFOSEL_ISEL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetCFIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetCFIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xf
}

// USBFS.CFIFOCTR: CFIFO Port Control Register
func (o *USBFS_Type) SetCFIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetCFIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetCFIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetCFIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1ff
}

// USBFS.D0FIFOSEL: D0FIFO Port Select Register
func (o *USBFS_Type) SetD0FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD0FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD0FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD0FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD0FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD0FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD0FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD0FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D0FIFOSEL.Reg, volatile.LoadUint16(&o.D0FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD0FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D0FIFOSEL.Reg) & 0xf
}

// USBFS.D0FIFOCTR: D0FIFO Port Control Register
func (o *USBFS_Type) SetD0FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD0FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD0FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD0FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD0FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD0FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD0FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D0FIFOCTR.Reg, volatile.LoadUint16(&o.D0FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD0FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D0FIFOCTR.Reg) & 0x1ff
}

// USBFS.D1FIFOSEL: D1FIFO Port Select Register
func (o *USBFS_Type) SetD1FIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD1FIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOSEL_DCLRM(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOSEL_DCLRM() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOSEL_DREQE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetD1FIFOSEL_DREQE() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetD1FIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetD1FIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetD1FIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetD1FIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetD1FIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.D1FIFOSEL.Reg, volatile.LoadUint16(&o.D1FIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetD1FIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.D1FIFOSEL.Reg) & 0xf
}

// USBFS.D1FIFOCTR: D1FIFO Port Control Register
func (o *USBFS_Type) SetD1FIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetD1FIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetD1FIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetD1FIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetD1FIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetD1FIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetD1FIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.D1FIFOCTR.Reg, volatile.LoadUint16(&o.D1FIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetD1FIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.D1FIFOCTR.Reg) & 0x1ff
}

// USBFS.INTENB0: Interrupt Enable Register 0
func (o *USBFS_Type) SetINTENB0_VBSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB0_VBSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTENB0_RSME(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB0_RSME() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB0_SOFE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTENB0_SOFE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTENB0_DVSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB0_DVSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB0_CTRE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB0_CTRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB0_BEMPE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTENB0_BEMPE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTENB0_NRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTENB0_NRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTENB0_BRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTENB0_BRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x100) >> 8
}

// USBFS.INTENB1: Interrupt Enable Register 1
func (o *USBFS_Type) SetINTENB1_OVRCRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB1_OVRCRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTENB1_BCHGE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB1_BCHGE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB1_DTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB1_DTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB1_ATTCHE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB1_ATTCHE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB1_EOFERRE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTENB1_EOFERRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTENB1_SIGNE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTENB1_SIGNE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTENB1_SACKE(value uint16) {
	volatile.StoreUint16(&o.INTENB1.Reg, volatile.LoadUint16(&o.INTENB1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTENB1_SACKE() uint16 {
	return (volatile.LoadUint16(&o.INTENB1.Reg) & 0x10) >> 4
}

// USBFS.BRDYENB: BRDY Interrupt Enable Register
func (o *USBFS_Type) SetBRDYENB_PIPE9BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYENB_PIPE9BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYENB_PIPE8BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYENB_PIPE8BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYENB_PIPE7BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYENB_PIPE7BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYENB_PIPE6BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYENB_PIPE6BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYENB_PIPE5BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYENB_PIPE5BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYENB_PIPE4BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYENB_PIPE4BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYENB_PIPE3BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYENB_PIPE3BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYENB_PIPE2BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYENB_PIPE2BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYENB_PIPE1BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYENB_PIPE1BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYENB_PIPE0BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYENB_PIPE0BRDYE() uint16 {
	return volatile.LoadUint16(&o.BRDYENB.Reg) & 0x1
}

// USBFS.NRDYENB: NRDY Interrupt Enable Register
func (o *USBFS_Type) SetNRDYENB_PIPE9NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYENB_PIPE9NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYENB_PIPE8NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYENB_PIPE8NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYENB_PIPE7NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYENB_PIPE7NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYENB_PIPE6NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYENB_PIPE6NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYENB_PIPE5NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYENB_PIPE5NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYENB_PIPE4NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYENB_PIPE4NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYENB_PIPE3NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYENB_PIPE3NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYENB_PIPE2NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYENB_PIPE2NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYENB_PIPE1NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYENB_PIPE1NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYENB_PIPE0NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYENB_PIPE0NRDYE() uint16 {
	return volatile.LoadUint16(&o.NRDYENB.Reg) & 0x1
}

// USBFS.BEMPENB: BEMP Interrupt Enable Register
func (o *USBFS_Type) SetBEMPENB_PIPE9BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPENB_PIPE9BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPENB_PIPE8BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPENB_PIPE8BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPENB_PIPE7BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPENB_PIPE7BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPENB_PIPE6BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPENB_PIPE6BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPENB_PIPE5BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPENB_PIPE5BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPENB_PIPE4BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPENB_PIPE4BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPENB_PIPE3BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPENB_PIPE3BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPENB_PIPE2BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPENB_PIPE2BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPENB_PIPE1BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPENB_PIPE1BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPENB_PIPE0BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPENB_PIPE0BEMPE() uint16 {
	return volatile.LoadUint16(&o.BEMPENB.Reg) & 0x1
}

// USBFS.SOFCFG: SOF Output Configuration Register
func (o *USBFS_Type) SetSOFCFG_TRNENSEL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSOFCFG_TRNENSEL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetSOFCFG_BRDYM(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSOFCFG_BRDYM() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSOFCFG_EDGESTS(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSOFCFG_EDGESTS() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x10) >> 4
}

// USBFS.INTSTS0: Interrupt Status Register 0
func (o *USBFS_Type) SetINTSTS0_VBINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS0_VBINT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTSTS0_RESM(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS0_RESM() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS0_SOFR(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTSTS0_SOFR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTSTS0_DVST(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS0_DVST() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS0_CTRT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS0_CTRT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS0_BEMP(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTSTS0_BEMP() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTSTS0_NRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTSTS0_NRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTSTS0_BRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTSTS0_BRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTSTS0_VBSTS(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetINTSTS0_VBSTS() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetINTSTS0_DVSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x70)|value<<4)
}
func (o *USBFS_Type) GetINTSTS0_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x70) >> 4
}
func (o *USBFS_Type) SetINTSTS0_VALID(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetINTSTS0_VALID() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetINTSTS0_CTSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetINTSTS0_CTSQ() uint16 {
	return volatile.LoadUint16(&o.INTSTS0.Reg) & 0x7
}

// USBFS.INTSTS1: Interrupt Status Register 1
func (o *USBFS_Type) SetINTSTS1_OVRCR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS1_OVRCR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTSTS1_BCHG(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS1_BCHG() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS1_DTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS1_DTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS1_ATTCH(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS1_ATTCH() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS1_EOFERR(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetINTSTS1_EOFERR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetINTSTS1_SIGN(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetINTSTS1_SIGN() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetINTSTS1_SACK(value uint16) {
	volatile.StoreUint16(&o.INTSTS1.Reg, volatile.LoadUint16(&o.INTSTS1.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetINTSTS1_SACK() uint16 {
	return (volatile.LoadUint16(&o.INTSTS1.Reg) & 0x10) >> 4
}

// USBFS.BRDYSTS: BRDY Interrupt Status Register
func (o *USBFS_Type) SetBRDYSTS_PIPE9BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE9BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYSTS_PIPE8BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE8BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYSTS_PIPE7BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE7BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYSTS_PIPE6BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE6BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYSTS_PIPE5BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE5BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYSTS_PIPE4BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE4BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYSTS_PIPE3BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE3BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYSTS_PIPE2BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE2BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYSTS_PIPE1BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE1BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYSTS_PIPE0BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE0BRDY() uint16 {
	return volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x1
}

// USBFS.NRDYSTS: NRDY Interrupt Status Register
func (o *USBFS_Type) SetNRDYSTS_PIPE9NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE9NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYSTS_PIPE8NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE8NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYSTS_PIPE7NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE7NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYSTS_PIPE6NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE6NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYSTS_PIPE5NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE5NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYSTS_PIPE4NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE4NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYSTS_PIPE3NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE3NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYSTS_PIPE2NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE2NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYSTS_PIPE1NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE1NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYSTS_PIPE0NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE0NRDY() uint16 {
	return volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x1
}

// USBFS.BEMPSTS: BEMP Interrupt Status Register
func (o *USBFS_Type) SetBEMPSTS_PIPE9BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE9BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPSTS_PIPE8BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE8BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPSTS_PIPE7BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE7BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPSTS_PIPE6BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE6BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPSTS_PIPE5BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE5BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPSTS_PIPE4BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE4BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPSTS_PIPE3BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE3BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPSTS_PIPE2BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE2BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPSTS_PIPE1BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE1BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPSTS_PIPE0BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE0BEMP() uint16 {
	return volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x1
}

// USBFS.FRMNUM: Frame Number Register
func (o *USBFS_Type) SetFRMNUM_OVRN(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetFRMNUM_OVRN() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetFRMNUM_CRCE(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetFRMNUM_CRCE() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetFRMNUM_FRNM(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x7ff)|value)
}
func (o *USBFS_Type) GetFRMNUM_FRNM() uint16 {
	return volatile.LoadUint16(&o.FRMNUM.Reg) & 0x7ff
}

// USBFS.DVCHGR: Device State Change Register
func (o *USBFS_Type) SetDVCHGR_DVCHG(value uint16) {
	volatile.StoreUint16(&o.DVCHGR.Reg, volatile.LoadUint16(&o.DVCHGR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDVCHGR_DVCHG() uint16 {
	return (volatile.LoadUint16(&o.DVCHGR.Reg) & 0x8000) >> 15
}

// USBFS.USBADDR: USB Address Register
func (o *USBFS_Type) SetUSBADDR_STSRECOV(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0xf00)|value<<8)
}
func (o *USBFS_Type) GetUSBADDR_STSRECOV() uint16 {
	return (volatile.LoadUint16(&o.USBADDR.Reg) & 0xf00) >> 8
}
func (o *USBFS_Type) SetUSBADDR(value uint16) {
	volatile.StoreUint16(&o.USBADDR.Reg, volatile.LoadUint16(&o.USBADDR.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetUSBADDR() uint16 {
	return volatile.LoadUint16(&o.USBADDR.Reg) & 0x7f
}

// USBFS.USBREQ: USB Request Type Register
func (o *USBFS_Type) SetUSBREQ_BREQUEST(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBREQ_BREQUEST() uint16 {
	return (volatile.LoadUint16(&o.USBREQ.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetUSBREQ_BMREQUESTTYPE(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetUSBREQ_BMREQUESTTYPE() uint16 {
	return volatile.LoadUint16(&o.USBREQ.Reg) & 0xff
}

// USBFS.USBVAL: USB Request Value Register
func (o *USBFS_Type) SetUSBVAL(value uint16) {
	volatile.StoreUint16(&o.USBVAL.Reg, value)
}
func (o *USBFS_Type) GetUSBVAL() uint16 {
	return volatile.LoadUint16(&o.USBVAL.Reg)
}

// USBFS.USBINDX: USB Request Index Register
func (o *USBFS_Type) SetUSBINDX(value uint16) {
	volatile.StoreUint16(&o.USBINDX.Reg, value)
}
func (o *USBFS_Type) GetUSBINDX() uint16 {
	return volatile.LoadUint16(&o.USBINDX.Reg)
}

// USBFS.USBLENG: USB Request Length Register
func (o *USBFS_Type) SetUSBLENG(value uint16) {
	volatile.StoreUint16(&o.USBLENG.Reg, value)
}
func (o *USBFS_Type) GetUSBLENG() uint16 {
	return volatile.LoadUint16(&o.USBLENG.Reg)
}

// USBFS.DCPCFG: DCP Configuration Register
func (o *USBFS_Type) SetDCPCFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCFG_DIR(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDCPCFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x10) >> 4
}

// USBFS.DCPMAXP: DCP Maximum Packet Size Register
func (o *USBFS_Type) SetDCPMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetDCPMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetDCPMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetDCPMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.DCPMAXP.Reg) & 0x7f
}

// USBFS.DCPCTR: DCP Control Register
func (o *USBFS_Type) SetDCPCTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDCPCTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetDCPCTR_SUREQ(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetDCPCTR_SUREQ() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetDCPCTR_SUREQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDCPCTR_SUREQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDCPCTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDCPCTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDCPCTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDCPCTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDCPCTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDCPCTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDCPCTR_CCPL(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetDCPCTR_CCPL() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetDCPCTR_PID(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetDCPCTR_PID() uint16 {
	return volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3
}

// USBFS.PIPESEL: Pipe Window Select Register
func (o *USBFS_Type) SetPIPESEL(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPESEL() uint16 {
	return volatile.LoadUint16(&o.PIPESEL.Reg) & 0xf
}

// USBFS.PIPECFG: Pipe Configuration Register
func (o *USBFS_Type) SetPIPECFG_TYPE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetPIPECFG_TYPE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0xc000) >> 14
}
func (o *USBFS_Type) SetPIPECFG_BFRE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPECFG_BFRE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPECFG_DBLB(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPECFG_DBLB() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPECFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPECFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPECFG_DIR(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetPIPECFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetPIPECFG_EPNUM(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPECFG_EPNUM() uint16 {
	return volatile.LoadUint16(&o.PIPECFG.Reg) & 0xf
}

// USBFS.PIPEMAXP: Pipe Maximum Packet Size Register
func (o *USBFS_Type) SetPIPEMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetPIPEMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetPIPEMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetPIPEMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0x1ff
}

// USBFS.PIPEPERI: Pipe Cycle Control Register
func (o *USBFS_Type) SetPIPEPERI_IFIS(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetPIPEPERI_IFIS() uint16 {
	return (volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetPIPEPERI_IITV(value uint16) {
	volatile.StoreUint16(&o.PIPEPERI.Reg, volatile.LoadUint16(&o.PIPEPERI.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetPIPEPERI_IITV() uint16 {
	return volatile.LoadUint16(&o.PIPEPERI.Reg) & 0x7
}

// USBFS.PIPE1CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE1CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE1CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE1CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE1CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE1CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE1CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE1CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE1CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE1CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE1CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE1CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE1CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE1CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE1CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE1CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE1CTR.Reg, volatile.LoadUint16(&o.PIPE1CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE1CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE1CTR.Reg) & 0x3
}

// USBFS.PIPE2CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE2CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE2CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE2CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE2CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE2CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE2CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE2CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE2CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE2CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE2CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE2CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE2CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE2CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE2CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE2CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE2CTR.Reg, volatile.LoadUint16(&o.PIPE2CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE2CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE2CTR.Reg) & 0x3
}

// USBFS.PIPE3CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE3CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE3CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE3CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE3CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE3CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE3CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE3CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE3CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE3CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE3CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE3CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE3CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE3CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE3CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE3CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE3CTR.Reg, volatile.LoadUint16(&o.PIPE3CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE3CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE3CTR.Reg) & 0x3
}

// USBFS.PIPE4CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE4CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE4CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE4CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE4CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE4CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE4CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE4CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE4CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE4CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE4CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE4CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE4CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE4CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE4CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3
}

// USBFS.PIPE5CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE5CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE5CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE5CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE5CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE5CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE5CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE5CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE5CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE5CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE5CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE5CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE5CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE5CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE5CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3
}

// USBFS.PIPE6CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE6CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE6CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE6CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE6CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE6CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE6CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE6CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE6CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE6CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE6CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE6CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE6CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE6CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE6CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x3
}

// USBFS.PIPE7CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE7CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE7CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE7CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE7CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE7CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE7CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE7CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE7CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE7CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE7CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE7CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE7CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE7CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE7CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x3
}

// USBFS.PIPE8CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE8CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE8CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE8CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE8CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE8CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE8CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE8CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE8CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE8CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE8CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE8CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE8CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE8CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE8CTR.Reg, volatile.LoadUint16(&o.PIPE8CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE8CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE8CTR.Reg) & 0x3
}

// USBFS.PIPE9CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE9CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE9CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE9CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE9CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE9CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE9CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE9CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE9CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE9CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE9CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE9CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE9CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE9CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE9CTR.Reg, volatile.LoadUint16(&o.PIPE9CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE9CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE9CTR.Reg) & 0x3
}

// USBFS.PIPE1TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE1TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE1TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE1TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRE.Reg, volatile.LoadUint16(&o.PIPE1TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE1TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE1TRE.Reg) & 0x100) >> 8
}

// USBFS.PIPE1TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE1TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE1TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE1TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE1TRN.Reg)
}

// USBFS.PIPE2TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE2TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE2TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE2TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRE.Reg, volatile.LoadUint16(&o.PIPE2TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE2TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE2TRE.Reg) & 0x100) >> 8
}

// USBFS.PIPE2TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE2TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE2TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE2TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE2TRN.Reg)
}

// USBFS.PIPE3TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE3TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE3TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE3TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRE.Reg, volatile.LoadUint16(&o.PIPE3TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE3TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE3TRE.Reg) & 0x100) >> 8
}

// USBFS.PIPE3TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE3TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE3TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE3TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE3TRN.Reg)
}

// USBFS.PIPE4TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE4TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x100) >> 8
}

// USBFS.PIPE4TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE4TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE4TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRN.Reg)
}

// USBFS.PIPE5TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE5TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x100) >> 8
}

// USBFS.PIPE5TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE5TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE5TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRN.Reg)
}

// USBFS.DEVADD0: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD0_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD0.Reg, volatile.LoadUint16(&o.DEVADD0.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD0_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD0.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD1: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD1_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD1.Reg, volatile.LoadUint16(&o.DEVADD1.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD1_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD1.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD2: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD2_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD2.Reg, volatile.LoadUint16(&o.DEVADD2.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD2_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD2.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD3: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD3_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD3.Reg, volatile.LoadUint16(&o.DEVADD3.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD3_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD3.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD4: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD4_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD4.Reg, volatile.LoadUint16(&o.DEVADD4.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD4_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD4.Reg) & 0xc0) >> 6
}

// USBFS.DEVADD5: Device Address %s Configuration Register
func (o *USBFS_Type) SetDEVADD5_USBSPD(value uint16) {
	volatile.StoreUint16(&o.DEVADD5.Reg, volatile.LoadUint16(&o.DEVADD5.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetDEVADD5_USBSPD() uint16 {
	return (volatile.LoadUint16(&o.DEVADD5.Reg) & 0xc0) >> 6
}

// USBFS.PHYSLEW: PHY Cross Point Adjustment Register
func (o *USBFS_Type) SetPHYSLEW_SLEWF01(value uint32) {
	volatile.StoreUint32(&o.PHYSLEW.Reg, volatile.LoadUint32(&o.PHYSLEW.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetPHYSLEW_SLEWF01() uint32 {
	return (volatile.LoadUint32(&o.PHYSLEW.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetPHYSLEW_SLEWF00(value uint32) {
	volatile.StoreUint32(&o.PHYSLEW.Reg, volatile.LoadUint32(&o.PHYSLEW.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetPHYSLEW_SLEWF00() uint32 {
	return (volatile.LoadUint32(&o.PHYSLEW.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetPHYSLEW_SLEWR01(value uint32) {
	volatile.StoreUint32(&o.PHYSLEW.Reg, volatile.LoadUint32(&o.PHYSLEW.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetPHYSLEW_SLEWR01() uint32 {
	return (volatile.LoadUint32(&o.PHYSLEW.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetPHYSLEW_SLEWR00(value uint32) {
	volatile.StoreUint32(&o.PHYSLEW.Reg, volatile.LoadUint32(&o.PHYSLEW.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetPHYSLEW_SLEWR00() uint32 {
	return volatile.LoadUint32(&o.PHYSLEW.Reg) & 0x1
}

// USBFS.DPUSR0R: Deep Software Standby USB Transceiver Control/Pin Monitor Register
func (o *USBFS_Type) SetDPUSR0R_DVBSTS0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x800000)|value<<23)
}
func (o *USBFS_Type) GetDPUSR0R_DVBSTS0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x800000) >> 23
}
func (o *USBFS_Type) SetDPUSR0R_DOVCB0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x200000)|value<<21)
}
func (o *USBFS_Type) GetDPUSR0R_DOVCB0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x200000) >> 21
}
func (o *USBFS_Type) SetDPUSR0R_DOVCA0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x100000)|value<<20)
}
func (o *USBFS_Type) GetDPUSR0R_DOVCA0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x100000) >> 20
}
func (o *USBFS_Type) SetDPUSR0R_DM0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x20000)|value<<17)
}
func (o *USBFS_Type) GetDPUSR0R_DM0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x20000) >> 17
}
func (o *USBFS_Type) SetDPUSR0R_DP0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x10000)|value<<16)
}
func (o *USBFS_Type) GetDPUSR0R_DP0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x10000) >> 16
}
func (o *USBFS_Type) SetDPUSR0R_FIXPHY0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDPUSR0R_FIXPHY0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDPUSR0R_DRPD0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetDPUSR0R_DRPD0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetDPUSR0R_RPUE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetDPUSR0R_RPUE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetDPUSR0R_SRPC0(value uint32) {
	volatile.StoreUint32(&o.DPUSR0R.Reg, volatile.LoadUint32(&o.DPUSR0R.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetDPUSR0R_SRPC0() uint32 {
	return volatile.LoadUint32(&o.DPUSR0R.Reg) & 0x1
}

// USBFS.DPUSR1R: Deep Software Standby USB Suspend/Resume Interrupt Register
func (o *USBFS_Type) SetDPUSR1R_DVBINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x800000)|value<<23)
}
func (o *USBFS_Type) GetDPUSR1R_DVBINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x800000) >> 23
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRB0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x200000)|value<<21)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRB0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x200000) >> 21
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRA0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x100000)|value<<20)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRA0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x100000) >> 20
}
func (o *USBFS_Type) SetDPUSR1R_DMINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x20000)|value<<17)
}
func (o *USBFS_Type) GetDPUSR1R_DMINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x20000) >> 17
}
func (o *USBFS_Type) SetDPUSR1R_DPINT0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x10000)|value<<16)
}
func (o *USBFS_Type) GetDPUSR1R_DPINT0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x10000) >> 16
}
func (o *USBFS_Type) SetDPUSR1R_DVBSE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDPUSR1R_DVBSE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRBE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRBE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDPUSR1R_DOVRCRAE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDPUSR1R_DOVRCRAE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDPUSR1R_DMINTE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetDPUSR1R_DMINTE0() uint32 {
	return (volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetDPUSR1R_DPINTE0(value uint32) {
	volatile.StoreUint32(&o.DPUSR1R.Reg, volatile.LoadUint32(&o.DPUSR1R.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetDPUSR1R_DPINTE0() uint32 {
	return volatile.LoadUint32(&o.DPUSR1R.Reg) & 0x1
}

// Sampling Rate Converter RAM
type SRCRAM_Type struct {
	SRCFCTR [5552]volatile.Register32 // 0x0
}

// SRCRAM.SRCFCTR: Filter Coefficient Table [%s]
func (o *SRCRAM_Type) SetSRCFCTR_SRCFCOE(idx int, value uint32) {
	volatile.StoreUint32(&o.SRCFCTR[idx].Reg, volatile.LoadUint32(&o.SRCFCTR[idx].Reg)&^(0x3fffff)|value)
}
func (o *SRCRAM_Type) GetSRCFCTR_SRCFCOE(idx int) uint32 {
	return volatile.LoadUint32(&o.SRCFCTR[idx].Reg) & 0x3fffff
}

// Sampling Rate Converter
type SRC_Type struct {
	SRCID     volatile.Register32 // 0x0
	SRCOD     volatile.Register32 // 0x4
	SRCIDCTRL volatile.Register16 // 0x8
	SRCODCTRL volatile.Register16 // 0xA
	SRCCTRL   volatile.Register16 // 0xC
	SRCSTAT   volatile.Register16 // 0xE
}

// SRC.SRCID: Input Data Register
func (o *SRC_Type) SetSRCID(value uint32) {
	volatile.StoreUint32(&o.SRCID.Reg, value)
}
func (o *SRC_Type) GetSRCID() uint32 {
	return volatile.LoadUint32(&o.SRCID.Reg)
}

// SRC.SRCOD: Output Data Register
func (o *SRC_Type) SetSRCOD(value uint32) {
	volatile.StoreUint32(&o.SRCOD.Reg, value)
}
func (o *SRC_Type) GetSRCOD() uint32 {
	return volatile.LoadUint32(&o.SRCOD.Reg)
}

// SRC.SRCIDCTRL: Input Data Control Register
func (o *SRC_Type) SetSRCIDCTRL_IED(value uint16) {
	volatile.StoreUint16(&o.SRCIDCTRL.Reg, volatile.LoadUint16(&o.SRCIDCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SRC_Type) GetSRCIDCTRL_IED() uint16 {
	return (volatile.LoadUint16(&o.SRCIDCTRL.Reg) & 0x200) >> 9
}
func (o *SRC_Type) SetSRCIDCTRL_IEN(value uint16) {
	volatile.StoreUint16(&o.SRCIDCTRL.Reg, volatile.LoadUint16(&o.SRCIDCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SRC_Type) GetSRCIDCTRL_IEN() uint16 {
	return (volatile.LoadUint16(&o.SRCIDCTRL.Reg) & 0x100) >> 8
}
func (o *SRC_Type) SetSRCIDCTRL_IFTRG(value uint16) {
	volatile.StoreUint16(&o.SRCIDCTRL.Reg, volatile.LoadUint16(&o.SRCIDCTRL.Reg)&^(0x3)|value)
}
func (o *SRC_Type) GetSRCIDCTRL_IFTRG() uint16 {
	return volatile.LoadUint16(&o.SRCIDCTRL.Reg) & 0x3
}

// SRC.SRCODCTRL: Output Data Control Register
func (o *SRC_Type) SetSRCODCTRL_OCH(value uint16) {
	volatile.StoreUint16(&o.SRCODCTRL.Reg, volatile.LoadUint16(&o.SRCODCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SRC_Type) GetSRCODCTRL_OCH() uint16 {
	return (volatile.LoadUint16(&o.SRCODCTRL.Reg) & 0x400) >> 10
}
func (o *SRC_Type) SetSRCODCTRL_OED(value uint16) {
	volatile.StoreUint16(&o.SRCODCTRL.Reg, volatile.LoadUint16(&o.SRCODCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SRC_Type) GetSRCODCTRL_OED() uint16 {
	return (volatile.LoadUint16(&o.SRCODCTRL.Reg) & 0x200) >> 9
}
func (o *SRC_Type) SetSRCODCTRL_OEN(value uint16) {
	volatile.StoreUint16(&o.SRCODCTRL.Reg, volatile.LoadUint16(&o.SRCODCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SRC_Type) GetSRCODCTRL_OEN() uint16 {
	return (volatile.LoadUint16(&o.SRCODCTRL.Reg) & 0x100) >> 8
}
func (o *SRC_Type) SetSRCODCTRL_OFTRG(value uint16) {
	volatile.StoreUint16(&o.SRCODCTRL.Reg, volatile.LoadUint16(&o.SRCODCTRL.Reg)&^(0x3)|value)
}
func (o *SRC_Type) GetSRCODCTRL_OFTRG() uint16 {
	return volatile.LoadUint16(&o.SRCODCTRL.Reg) & 0x3
}

// SRC.SRCCTRL: Control Register
func (o *SRC_Type) SetSRCCTRL_FICRAE(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x8000)|value<<15)
}
func (o *SRC_Type) GetSRCCTRL_FICRAE() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x8000) >> 15
}
func (o *SRC_Type) SetSRCCTRL_CEEN(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x2000)|value<<13)
}
func (o *SRC_Type) GetSRCCTRL_CEEN() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x2000) >> 13
}
func (o *SRC_Type) SetSRCCTRL_SRCEN(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x1000)|value<<12)
}
func (o *SRC_Type) GetSRCCTRL_SRCEN() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x1000) >> 12
}
func (o *SRC_Type) SetSRCCTRL_UDEN(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x800)|value<<11)
}
func (o *SRC_Type) GetSRCCTRL_UDEN() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x800) >> 11
}
func (o *SRC_Type) SetSRCCTRL_OVEN(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x400)|value<<10)
}
func (o *SRC_Type) GetSRCCTRL_OVEN() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x400) >> 10
}
func (o *SRC_Type) SetSRCCTRL_FL(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x200)|value<<9)
}
func (o *SRC_Type) GetSRCCTRL_FL() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x200) >> 9
}
func (o *SRC_Type) SetSRCCTRL_CL(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x100)|value<<8)
}
func (o *SRC_Type) GetSRCCTRL_CL() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x100) >> 8
}
func (o *SRC_Type) SetSRCCTRL_IFS(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0xf0)|value<<4)
}
func (o *SRC_Type) GetSRCCTRL_IFS() uint16 {
	return (volatile.LoadUint16(&o.SRCCTRL.Reg) & 0xf0) >> 4
}
func (o *SRC_Type) SetSRCCTRL_OFS(value uint16) {
	volatile.StoreUint16(&o.SRCCTRL.Reg, volatile.LoadUint16(&o.SRCCTRL.Reg)&^(0x7)|value)
}
func (o *SRC_Type) GetSRCCTRL_OFS() uint16 {
	return volatile.LoadUint16(&o.SRCCTRL.Reg) & 0x7
}

// SRC.SRCSTAT: Status Register
func (o *SRC_Type) SetSRCSTAT_OFDN(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0xf800)|value<<11)
}
func (o *SRC_Type) GetSRCSTAT_OFDN() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0xf800) >> 11
}
func (o *SRC_Type) SetSRCSTAT_IFDN(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x780)|value<<7)
}
func (o *SRC_Type) GetSRCSTAT_IFDN() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x780) >> 7
}
func (o *SRC_Type) SetSRCSTAT_CEF(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x20)|value<<5)
}
func (o *SRC_Type) GetSRCSTAT_CEF() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x20) >> 5
}
func (o *SRC_Type) SetSRCSTAT_FLF(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x10)|value<<4)
}
func (o *SRC_Type) GetSRCSTAT_FLF() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x10) >> 4
}
func (o *SRC_Type) SetSRCSTAT_UDF(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x8)|value<<3)
}
func (o *SRC_Type) GetSRCSTAT_UDF() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x8) >> 3
}
func (o *SRC_Type) SetSRCSTAT_OVF(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x4)|value<<2)
}
func (o *SRC_Type) GetSRCSTAT_OVF() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x4) >> 2
}
func (o *SRC_Type) SetSRCSTAT_IINT(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x2)|value<<1)
}
func (o *SRC_Type) GetSRCSTAT_IINT() uint16 {
	return (volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x2) >> 1
}
func (o *SRC_Type) SetSRCSTAT_OINT(value uint16) {
	volatile.StoreUint16(&o.SRCSTAT.Reg, volatile.LoadUint16(&o.SRCSTAT.Reg)&^(0x1)|value)
}
func (o *SRC_Type) GetSRCSTAT_OINT() uint16 {
	return volatile.LoadUint16(&o.SRCSTAT.Reg) & 0x1
}

// Interrupt Controller
type ICU_Type struct {
	IRQCR0  volatile.Register8 // 0x0
	IRQCR1  volatile.Register8 // 0x1
	IRQCR2  volatile.Register8 // 0x2
	IRQCR3  volatile.Register8 // 0x3
	IRQCR4  volatile.Register8 // 0x4
	IRQCR5  volatile.Register8 // 0x5
	IRQCR6  volatile.Register8 // 0x6
	IRQCR7  volatile.Register8 // 0x7
	IRQCR8  volatile.Register8 // 0x8
	IRQCR9  volatile.Register8 // 0x9
	IRQCR10 volatile.Register8 // 0xA
	IRQCR11 volatile.Register8 // 0xB
	IRQCR12 volatile.Register8 // 0xC
	IRQCR13 volatile.Register8 // 0xD
	IRQCR14 volatile.Register8 // 0xE
	IRQCR15 volatile.Register8 // 0xF
	_       [240]byte
	NMICR   volatile.Register8 // 0x100
	_       [31]byte
	NMIER   volatile.Register16 // 0x120
	_       [14]byte
	NMICLR  volatile.Register16 // 0x130
	_       [14]byte
	NMISR   volatile.Register16 // 0x140
	_       [94]byte
	WUPEN   volatile.Register32 // 0x1A0
	_       [92]byte
	SELSR0  volatile.Register16 // 0x200
	_       [126]byte
	DELSR0  volatile.Register32 // 0x280
	DELSR1  volatile.Register32 // 0x284
	DELSR2  volatile.Register32 // 0x288
	DELSR3  volatile.Register32 // 0x28C
	DELSR4  volatile.Register32 // 0x290
	DELSR5  volatile.Register32 // 0x294
	DELSR6  volatile.Register32 // 0x298
	DELSR7  volatile.Register32 // 0x29C
	_       [96]byte
	IELSR0  volatile.Register32 // 0x300
	IELSR1  volatile.Register32 // 0x304
	IELSR2  volatile.Register32 // 0x308
	IELSR3  volatile.Register32 // 0x30C
	IELSR4  volatile.Register32 // 0x310
	IELSR5  volatile.Register32 // 0x314
	IELSR6  volatile.Register32 // 0x318
	IELSR7  volatile.Register32 // 0x31C
	IELSR8  volatile.Register32 // 0x320
	IELSR9  volatile.Register32 // 0x324
	IELSR10 volatile.Register32 // 0x328
	IELSR11 volatile.Register32 // 0x32C
	IELSR12 volatile.Register32 // 0x330
	IELSR13 volatile.Register32 // 0x334
	IELSR14 volatile.Register32 // 0x338
	IELSR15 volatile.Register32 // 0x33C
	IELSR16 volatile.Register32 // 0x340
	IELSR17 volatile.Register32 // 0x344
	IELSR18 volatile.Register32 // 0x348
	IELSR19 volatile.Register32 // 0x34C
	IELSR20 volatile.Register32 // 0x350
	IELSR21 volatile.Register32 // 0x354
	IELSR22 volatile.Register32 // 0x358
	IELSR23 volatile.Register32 // 0x35C
	IELSR24 volatile.Register32 // 0x360
	IELSR25 volatile.Register32 // 0x364
	IELSR26 volatile.Register32 // 0x368
	IELSR27 volatile.Register32 // 0x36C
	IELSR28 volatile.Register32 // 0x370
	IELSR29 volatile.Register32 // 0x374
	IELSR30 volatile.Register32 // 0x378
	IELSR31 volatile.Register32 // 0x37C
	IELSR32 volatile.Register32 // 0x380
	IELSR33 volatile.Register32 // 0x384
	IELSR34 volatile.Register32 // 0x388
	IELSR35 volatile.Register32 // 0x38C
	IELSR36 volatile.Register32 // 0x390
	IELSR37 volatile.Register32 // 0x394
	IELSR38 volatile.Register32 // 0x398
	IELSR39 volatile.Register32 // 0x39C
	IELSR40 volatile.Register32 // 0x3A0
	IELSR41 volatile.Register32 // 0x3A4
	IELSR42 volatile.Register32 // 0x3A8
	IELSR43 volatile.Register32 // 0x3AC
	IELSR44 volatile.Register32 // 0x3B0
	IELSR45 volatile.Register32 // 0x3B4
	IELSR46 volatile.Register32 // 0x3B8
	IELSR47 volatile.Register32 // 0x3BC
	IELSR48 volatile.Register32 // 0x3C0
	IELSR49 volatile.Register32 // 0x3C4
	IELSR50 volatile.Register32 // 0x3C8
	IELSR51 volatile.Register32 // 0x3CC
	IELSR52 volatile.Register32 // 0x3D0
	IELSR53 volatile.Register32 // 0x3D4
	IELSR54 volatile.Register32 // 0x3D8
	IELSR55 volatile.Register32 // 0x3DC
	IELSR56 volatile.Register32 // 0x3E0
	IELSR57 volatile.Register32 // 0x3E4
	IELSR58 volatile.Register32 // 0x3E8
	IELSR59 volatile.Register32 // 0x3EC
	IELSR60 volatile.Register32 // 0x3F0
	IELSR61 volatile.Register32 // 0x3F4
	IELSR62 volatile.Register32 // 0x3F8
	IELSR63 volatile.Register32 // 0x3FC
	IELSR64 volatile.Register32 // 0x400
	IELSR65 volatile.Register32 // 0x404
	IELSR66 volatile.Register32 // 0x408
	IELSR67 volatile.Register32 // 0x40C
	IELSR68 volatile.Register32 // 0x410
	IELSR69 volatile.Register32 // 0x414
	IELSR70 volatile.Register32 // 0x418
	IELSR71 volatile.Register32 // 0x41C
	IELSR72 volatile.Register32 // 0x420
	IELSR73 volatile.Register32 // 0x424
	IELSR74 volatile.Register32 // 0x428
	IELSR75 volatile.Register32 // 0x42C
	IELSR76 volatile.Register32 // 0x430
	IELSR77 volatile.Register32 // 0x434
	IELSR78 volatile.Register32 // 0x438
	IELSR79 volatile.Register32 // 0x43C
	IELSR80 volatile.Register32 // 0x440
	IELSR81 volatile.Register32 // 0x444
	IELSR82 volatile.Register32 // 0x448
	IELSR83 volatile.Register32 // 0x44C
	IELSR84 volatile.Register32 // 0x450
	IELSR85 volatile.Register32 // 0x454
	IELSR86 volatile.Register32 // 0x458
	IELSR87 volatile.Register32 // 0x45C
	IELSR88 volatile.Register32 // 0x460
	IELSR89 volatile.Register32 // 0x464
	IELSR90 volatile.Register32 // 0x468
	IELSR91 volatile.Register32 // 0x46C
	IELSR92 volatile.Register32 // 0x470
	IELSR93 volatile.Register32 // 0x474
	IELSR94 volatile.Register32 // 0x478
	IELSR95 volatile.Register32 // 0x47C
}

// ICU.IRQCR0: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR0_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR0_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR0_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR0_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR0_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR0_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR0.Reg) & 0x3
}

// ICU.IRQCR1: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR1_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR1_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR1_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR1_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR1_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR1_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR1.Reg) & 0x3
}

// ICU.IRQCR2: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR2_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR2_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR2_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR2_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR2_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR2_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR2.Reg) & 0x3
}

// ICU.IRQCR3: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR3_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR3_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR3_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR3_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR3_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR3_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR3.Reg) & 0x3
}

// ICU.IRQCR4: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR4_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR4_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR4_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR4_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR4_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR4_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR4.Reg) & 0x3
}

// ICU.IRQCR5: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR5_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR5_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR5_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR5_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR5_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR5_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR5.Reg) & 0x3
}

// ICU.IRQCR6: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR6_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR6_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR6_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR6_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR6_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR6_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR6.Reg) & 0x3
}

// ICU.IRQCR7: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR7_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR7_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR7_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR7_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR7_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR7_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR7.Reg) & 0x3
}

// ICU.IRQCR8: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR8_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR8_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR8_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR8_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR8.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR8_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR8.Reg, volatile.LoadUint8(&o.IRQCR8.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR8_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR8.Reg) & 0x3
}

// ICU.IRQCR9: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR9_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR9_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR9_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR9_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR9.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR9_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR9.Reg, volatile.LoadUint8(&o.IRQCR9.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR9_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR9.Reg) & 0x3
}

// ICU.IRQCR10: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR10_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR10_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR10_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR10_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR10.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR10_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR10.Reg, volatile.LoadUint8(&o.IRQCR10.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR10_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR10.Reg) & 0x3
}

// ICU.IRQCR11: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR11_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR11_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR11_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR11_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR11.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR11_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR11.Reg, volatile.LoadUint8(&o.IRQCR11.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR11_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR11.Reg) & 0x3
}

// ICU.IRQCR12: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR12_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR12_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR12_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR12_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR12.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR12_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR12.Reg, volatile.LoadUint8(&o.IRQCR12.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR12_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR12.Reg) & 0x3
}

// ICU.IRQCR13: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR13_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR13_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR13_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR13_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR13.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR13_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR13.Reg, volatile.LoadUint8(&o.IRQCR13.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR13_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR13.Reg) & 0x3
}

// ICU.IRQCR14: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR14_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR14_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR14_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR14_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR14.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR14_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR14.Reg, volatile.LoadUint8(&o.IRQCR14.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR14_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR14.Reg) & 0x3
}

// ICU.IRQCR15: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR15_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR15_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR15_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR15_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR15.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR15_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR15.Reg, volatile.LoadUint8(&o.IRQCR15.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR15_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR15.Reg) & 0x3
}

// ICU.NMICR: NMI Pin Interrupt Control Register
func (o *ICU_Type) SetNMICR_NFLTEN(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICR_NFLTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICR_NFCLKSEL(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICR_NFCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICR_NMIMD(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICR_NMIMD() uint8 {
	return volatile.LoadUint8(&o.NMICR.Reg) & 0x1
}

// ICU.NMIER: Non-Maskable Interrupt Enable Register
func (o *ICU_Type) SetNMIER_SPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMIER_SPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMIER_BUSMEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMIER_BUSMEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMIER_BUSSEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMIER_BUSSEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMIER_RECCEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMIER_RECCEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMIER_RPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMIER_RPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMIER_NMIEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMIER_NMIEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMIER_OSTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMIER_OSTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMIER_LVD2EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMIER_LVD2EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMIER_LVD1EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMIER_LVD1EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMIER_WDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMIER_WDTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMIER_IWDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMIER_IWDTEN() uint16 {
	return volatile.LoadUint16(&o.NMIER.Reg) & 0x1
}

// ICU.NMICLR: Non-Maskable Interrupt Status Clear Register
func (o *ICU_Type) SetNMICLR_SPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMICLR_SPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMICLR_BUSMCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMICLR_BUSMCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMICLR_BUSSCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMICLR_BUSSCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMICLR_RECCCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMICLR_RECCCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMICLR_RPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMICLR_RPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMICLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICLR_OSTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICLR_OSTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICLR_LVD2CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMICLR_LVD2CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMICLR_LVD1CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMICLR_LVD1CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMICLR_WDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMICLR_WDTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMICLR_IWDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICLR_IWDTCLR() uint16 {
	return volatile.LoadUint16(&o.NMICLR.Reg) & 0x1
}

// ICU.NMISR: Non-Maskable Interrupt Status Register
func (o *ICU_Type) SetNMISR_SPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMISR_SPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMISR_BUSMST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMISR_BUSMST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMISR_BUSSST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMISR_BUSSST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMISR_RECCST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMISR_RECCST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMISR_RPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMISR_RPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMISR_NMIST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMISR_NMIST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMISR_OSTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMISR_OSTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMISR_LVD2ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMISR_LVD2ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMISR_LVD1ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMISR_LVD1ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMISR_WDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMISR_WDTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMISR_IWDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMISR_IWDTST() uint16 {
	return volatile.LoadUint16(&o.NMISR.Reg) & 0x1
}

// ICU.WUPEN: Wake Up interrupt enable register
func (o *ICU_Type) SetWUPEN_IIC0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000000)|value<<31)
}
func (o *ICU_Type) GetWUPEN_IIC0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000000) >> 31
}
func (o *ICU_Type) SetWUPEN_AGT1CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000000)|value<<30)
}
func (o *ICU_Type) GetWUPEN_AGT1CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000000) >> 30
}
func (o *ICU_Type) SetWUPEN_AGT1CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000000)|value<<29)
}
func (o *ICU_Type) GetWUPEN_AGT1CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000000) >> 29
}
func (o *ICU_Type) SetWUPEN_AGT1UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000000)|value<<28)
}
func (o *ICU_Type) GetWUPEN_AGT1UDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000000) >> 28
}
func (o *ICU_Type) SetWUPEN_USBFSWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8000000)|value<<27)
}
func (o *ICU_Type) GetWUPEN_USBFSWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8000000) >> 27
}
func (o *ICU_Type) SetWUPEN_USBHSWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4000000)|value<<26)
}
func (o *ICU_Type) GetWUPEN_USBHSWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4000000) >> 26
}
func (o *ICU_Type) SetWUPEN_RTCPRDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000000)|value<<25)
}
func (o *ICU_Type) GetWUPEN_RTCPRDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000000) >> 25
}
func (o *ICU_Type) SetWUPEN_RTCALMWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetWUPEN_RTCALMWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetWUPEN_ACMPHS0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x400000)|value<<22)
}
func (o *ICU_Type) GetWUPEN_ACMPHS0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x400000) >> 22
}
func (o *ICU_Type) SetWUPEN_LVD2WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000)|value<<19)
}
func (o *ICU_Type) GetWUPEN_LVD2WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000) >> 19
}
func (o *ICU_Type) SetWUPEN_LVD1WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000)|value<<18)
}
func (o *ICU_Type) GetWUPEN_LVD1WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000) >> 18
}
func (o *ICU_Type) SetWUPEN_KEYWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000)|value<<17)
}
func (o *ICU_Type) GetWUPEN_KEYWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000) >> 17
}
func (o *ICU_Type) SetWUPEN_IWDTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetWUPEN_IWDTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN15(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8000)|value<<15)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN15() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8000) >> 15
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN14(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4000)|value<<14)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN14() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4000) >> 14
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN13(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000)|value<<13)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN13() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000) >> 13
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN12(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN12() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN11(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN11() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN10(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN10() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN9(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN9() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN8(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN8() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN7(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN7() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN6(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN6() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN5(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN5() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN4(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN4() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN3(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN3() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN2(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN2() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN1(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN1() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN0(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN0() uint32 {
	return volatile.LoadUint32(&o.WUPEN.Reg) & 0x1
}

// ICU.SELSR0: SYS Event Link Setting Register
func (o *ICU_Type) SetSELSR0_SELS(value uint16) {
	volatile.StoreUint16(&o.SELSR0.Reg, volatile.LoadUint16(&o.SELSR0.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetSELSR0_SELS() uint16 {
	return volatile.LoadUint16(&o.SELSR0.Reg) & 0x1ff
}

// ICU.DELSR0: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR0_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR0.Reg, volatile.LoadUint32(&o.DELSR0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR0_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR0.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR0_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR0.Reg, volatile.LoadUint32(&o.DELSR0.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR0_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR0.Reg) & 0x1ff
}

// ICU.DELSR1: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR1_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR1.Reg, volatile.LoadUint32(&o.DELSR1.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR1_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR1.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR1_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR1.Reg, volatile.LoadUint32(&o.DELSR1.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR1_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR1.Reg) & 0x1ff
}

// ICU.DELSR2: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR2_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR2.Reg, volatile.LoadUint32(&o.DELSR2.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR2_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR2.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR2_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR2.Reg, volatile.LoadUint32(&o.DELSR2.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR2_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR2.Reg) & 0x1ff
}

// ICU.DELSR3: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR3_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR3.Reg, volatile.LoadUint32(&o.DELSR3.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR3_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR3.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR3_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR3.Reg, volatile.LoadUint32(&o.DELSR3.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR3_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR3.Reg) & 0x1ff
}

// ICU.DELSR4: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR4_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR4.Reg, volatile.LoadUint32(&o.DELSR4.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR4_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR4.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR4_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR4.Reg, volatile.LoadUint32(&o.DELSR4.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR4_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR4.Reg) & 0x1ff
}

// ICU.DELSR5: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR5_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR5.Reg, volatile.LoadUint32(&o.DELSR5.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR5_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR5.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR5_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR5.Reg, volatile.LoadUint32(&o.DELSR5.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR5_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR5.Reg) & 0x1ff
}

// ICU.DELSR6: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR6_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR6.Reg, volatile.LoadUint32(&o.DELSR6.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR6_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR6.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR6_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR6.Reg, volatile.LoadUint32(&o.DELSR6.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR6_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR6.Reg) & 0x1ff
}

// ICU.DELSR7: DMAC Event Link Setting Register %s
func (o *ICU_Type) SetDELSR7_IR(value uint32) {
	volatile.StoreUint32(&o.DELSR7.Reg, volatile.LoadUint32(&o.DELSR7.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetDELSR7_IR() uint32 {
	return (volatile.LoadUint32(&o.DELSR7.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetDELSR7_DELS(value uint32) {
	volatile.StoreUint32(&o.DELSR7.Reg, volatile.LoadUint32(&o.DELSR7.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetDELSR7_DELS() uint32 {
	return volatile.LoadUint32(&o.DELSR7.Reg) & 0x1ff
}

// ICU.IELSR0: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR0_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR0_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR0_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR0_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR0_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR0_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR0.Reg) & 0x1ff
}

// ICU.IELSR1: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR1_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR1_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR1_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR1_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR1_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR1_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR1.Reg) & 0x1ff
}

// ICU.IELSR2: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR2_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR2_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR2_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR2_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR2_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR2_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR2.Reg) & 0x1ff
}

// ICU.IELSR3: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR3_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR3_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR3_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR3_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR3_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR3_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR3.Reg) & 0x1ff
}

// ICU.IELSR4: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR4_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR4_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR4_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR4_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR4_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR4_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR4.Reg) & 0x1ff
}

// ICU.IELSR5: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR5_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR5_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR5_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR5_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR5_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR5_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR5.Reg) & 0x1ff
}

// ICU.IELSR6: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR6_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR6_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR6_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR6_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR6_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR6_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR6.Reg) & 0x1ff
}

// ICU.IELSR7: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR7_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR7_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR7_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR7_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR7_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR7_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR7.Reg) & 0x1ff
}

// ICU.IELSR8: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR8_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR8_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR8_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR8_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR8_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR8_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR8.Reg) & 0x1ff
}

// ICU.IELSR9: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR9_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR9_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR9_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR9_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR9_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR9_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR9.Reg) & 0x1ff
}

// ICU.IELSR10: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR10_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR10_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR10_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR10_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR10_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR10_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR10.Reg) & 0x1ff
}

// ICU.IELSR11: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR11_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR11_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR11_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR11_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR11_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR11_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR11.Reg) & 0x1ff
}

// ICU.IELSR12: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR12_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR12_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR12_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR12_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR12_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR12_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR12.Reg) & 0x1ff
}

// ICU.IELSR13: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR13_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR13_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR13_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR13_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR13_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR13_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR13.Reg) & 0x1ff
}

// ICU.IELSR14: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR14_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR14_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR14_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR14_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR14_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR14_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR14.Reg) & 0x1ff
}

// ICU.IELSR15: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR15_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR15_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR15_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR15_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR15_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR15_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR15.Reg) & 0x1ff
}

// ICU.IELSR16: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR16_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR16_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR16_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR16_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR16_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR16_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR16.Reg) & 0x1ff
}

// ICU.IELSR17: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR17_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR17_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR17_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR17_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR17_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR17_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR17.Reg) & 0x1ff
}

// ICU.IELSR18: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR18_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR18_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR18_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR18_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR18_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR18_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR18.Reg) & 0x1ff
}

// ICU.IELSR19: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR19_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR19_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR19_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR19_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR19_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR19_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR19.Reg) & 0x1ff
}

// ICU.IELSR20: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR20_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR20_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR20_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR20_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR20_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR20_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR20.Reg) & 0x1ff
}

// ICU.IELSR21: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR21_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR21_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR21_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR21_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR21_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR21_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR21.Reg) & 0x1ff
}

// ICU.IELSR22: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR22_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR22_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR22_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR22_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR22_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR22_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR22.Reg) & 0x1ff
}

// ICU.IELSR23: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR23_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR23_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR23_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR23_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR23_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR23_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR23.Reg) & 0x1ff
}

// ICU.IELSR24: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR24_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR24_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR24_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR24_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR24_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR24_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR24.Reg) & 0x1ff
}

// ICU.IELSR25: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR25_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR25_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR25_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR25_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR25_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR25_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR25.Reg) & 0x1ff
}

// ICU.IELSR26: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR26_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR26_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR26_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR26_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR26_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR26_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR26.Reg) & 0x1ff
}

// ICU.IELSR27: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR27_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR27_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR27_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR27_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR27_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR27_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR27.Reg) & 0x1ff
}

// ICU.IELSR28: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR28_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR28_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR28_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR28_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR28_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR28_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR28.Reg) & 0x1ff
}

// ICU.IELSR29: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR29_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR29_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR29_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR29_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR29_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR29_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR29.Reg) & 0x1ff
}

// ICU.IELSR30: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR30_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR30_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR30_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR30_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR30_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR30_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR30.Reg) & 0x1ff
}

// ICU.IELSR31: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR31_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR31_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR31_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR31_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR31_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR31_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR31.Reg) & 0x1ff
}

// ICU.IELSR32: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR32_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR32.Reg, volatile.LoadUint32(&o.IELSR32.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR32_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR32.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR32_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR32.Reg, volatile.LoadUint32(&o.IELSR32.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR32_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR32.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR32_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR32.Reg, volatile.LoadUint32(&o.IELSR32.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR32_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR32.Reg) & 0x1ff
}

// ICU.IELSR33: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR33_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR33.Reg, volatile.LoadUint32(&o.IELSR33.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR33_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR33.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR33_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR33.Reg, volatile.LoadUint32(&o.IELSR33.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR33_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR33.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR33_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR33.Reg, volatile.LoadUint32(&o.IELSR33.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR33_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR33.Reg) & 0x1ff
}

// ICU.IELSR34: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR34_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR34.Reg, volatile.LoadUint32(&o.IELSR34.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR34_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR34.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR34_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR34.Reg, volatile.LoadUint32(&o.IELSR34.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR34_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR34.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR34_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR34.Reg, volatile.LoadUint32(&o.IELSR34.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR34_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR34.Reg) & 0x1ff
}

// ICU.IELSR35: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR35_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR35.Reg, volatile.LoadUint32(&o.IELSR35.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR35_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR35.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR35_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR35.Reg, volatile.LoadUint32(&o.IELSR35.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR35_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR35.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR35_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR35.Reg, volatile.LoadUint32(&o.IELSR35.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR35_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR35.Reg) & 0x1ff
}

// ICU.IELSR36: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR36_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR36.Reg, volatile.LoadUint32(&o.IELSR36.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR36_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR36.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR36_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR36.Reg, volatile.LoadUint32(&o.IELSR36.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR36_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR36.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR36_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR36.Reg, volatile.LoadUint32(&o.IELSR36.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR36_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR36.Reg) & 0x1ff
}

// ICU.IELSR37: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR37_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR37.Reg, volatile.LoadUint32(&o.IELSR37.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR37_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR37.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR37_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR37.Reg, volatile.LoadUint32(&o.IELSR37.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR37_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR37.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR37_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR37.Reg, volatile.LoadUint32(&o.IELSR37.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR37_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR37.Reg) & 0x1ff
}

// ICU.IELSR38: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR38_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR38.Reg, volatile.LoadUint32(&o.IELSR38.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR38_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR38.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR38_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR38.Reg, volatile.LoadUint32(&o.IELSR38.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR38_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR38.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR38_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR38.Reg, volatile.LoadUint32(&o.IELSR38.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR38_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR38.Reg) & 0x1ff
}

// ICU.IELSR39: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR39_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR39.Reg, volatile.LoadUint32(&o.IELSR39.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR39_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR39.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR39_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR39.Reg, volatile.LoadUint32(&o.IELSR39.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR39_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR39.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR39_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR39.Reg, volatile.LoadUint32(&o.IELSR39.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR39_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR39.Reg) & 0x1ff
}

// ICU.IELSR40: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR40_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR40.Reg, volatile.LoadUint32(&o.IELSR40.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR40_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR40.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR40_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR40.Reg, volatile.LoadUint32(&o.IELSR40.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR40_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR40.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR40_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR40.Reg, volatile.LoadUint32(&o.IELSR40.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR40_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR40.Reg) & 0x1ff
}

// ICU.IELSR41: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR41_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR41.Reg, volatile.LoadUint32(&o.IELSR41.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR41_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR41.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR41_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR41.Reg, volatile.LoadUint32(&o.IELSR41.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR41_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR41.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR41_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR41.Reg, volatile.LoadUint32(&o.IELSR41.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR41_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR41.Reg) & 0x1ff
}

// ICU.IELSR42: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR42_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR42.Reg, volatile.LoadUint32(&o.IELSR42.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR42_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR42.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR42_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR42.Reg, volatile.LoadUint32(&o.IELSR42.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR42_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR42.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR42_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR42.Reg, volatile.LoadUint32(&o.IELSR42.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR42_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR42.Reg) & 0x1ff
}

// ICU.IELSR43: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR43_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR43.Reg, volatile.LoadUint32(&o.IELSR43.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR43_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR43.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR43_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR43.Reg, volatile.LoadUint32(&o.IELSR43.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR43_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR43.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR43_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR43.Reg, volatile.LoadUint32(&o.IELSR43.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR43_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR43.Reg) & 0x1ff
}

// ICU.IELSR44: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR44_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR44.Reg, volatile.LoadUint32(&o.IELSR44.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR44_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR44.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR44_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR44.Reg, volatile.LoadUint32(&o.IELSR44.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR44_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR44.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR44_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR44.Reg, volatile.LoadUint32(&o.IELSR44.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR44_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR44.Reg) & 0x1ff
}

// ICU.IELSR45: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR45_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR45.Reg, volatile.LoadUint32(&o.IELSR45.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR45_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR45.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR45_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR45.Reg, volatile.LoadUint32(&o.IELSR45.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR45_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR45.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR45_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR45.Reg, volatile.LoadUint32(&o.IELSR45.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR45_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR45.Reg) & 0x1ff
}

// ICU.IELSR46: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR46_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR46.Reg, volatile.LoadUint32(&o.IELSR46.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR46_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR46.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR46_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR46.Reg, volatile.LoadUint32(&o.IELSR46.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR46_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR46.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR46_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR46.Reg, volatile.LoadUint32(&o.IELSR46.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR46_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR46.Reg) & 0x1ff
}

// ICU.IELSR47: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR47_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR47.Reg, volatile.LoadUint32(&o.IELSR47.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR47_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR47.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR47_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR47.Reg, volatile.LoadUint32(&o.IELSR47.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR47_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR47.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR47_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR47.Reg, volatile.LoadUint32(&o.IELSR47.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR47_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR47.Reg) & 0x1ff
}

// ICU.IELSR48: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR48_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR48.Reg, volatile.LoadUint32(&o.IELSR48.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR48_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR48.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR48_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR48.Reg, volatile.LoadUint32(&o.IELSR48.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR48_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR48.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR48_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR48.Reg, volatile.LoadUint32(&o.IELSR48.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR48_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR48.Reg) & 0x1ff
}

// ICU.IELSR49: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR49_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR49.Reg, volatile.LoadUint32(&o.IELSR49.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR49_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR49.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR49_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR49.Reg, volatile.LoadUint32(&o.IELSR49.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR49_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR49.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR49_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR49.Reg, volatile.LoadUint32(&o.IELSR49.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR49_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR49.Reg) & 0x1ff
}

// ICU.IELSR50: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR50_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR50.Reg, volatile.LoadUint32(&o.IELSR50.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR50_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR50.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR50_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR50.Reg, volatile.LoadUint32(&o.IELSR50.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR50_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR50.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR50_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR50.Reg, volatile.LoadUint32(&o.IELSR50.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR50_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR50.Reg) & 0x1ff
}

// ICU.IELSR51: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR51_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR51.Reg, volatile.LoadUint32(&o.IELSR51.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR51_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR51.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR51_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR51.Reg, volatile.LoadUint32(&o.IELSR51.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR51_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR51.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR51_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR51.Reg, volatile.LoadUint32(&o.IELSR51.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR51_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR51.Reg) & 0x1ff
}

// ICU.IELSR52: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR52_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR52.Reg, volatile.LoadUint32(&o.IELSR52.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR52_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR52.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR52_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR52.Reg, volatile.LoadUint32(&o.IELSR52.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR52_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR52.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR52_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR52.Reg, volatile.LoadUint32(&o.IELSR52.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR52_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR52.Reg) & 0x1ff
}

// ICU.IELSR53: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR53_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR53.Reg, volatile.LoadUint32(&o.IELSR53.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR53_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR53.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR53_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR53.Reg, volatile.LoadUint32(&o.IELSR53.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR53_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR53.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR53_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR53.Reg, volatile.LoadUint32(&o.IELSR53.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR53_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR53.Reg) & 0x1ff
}

// ICU.IELSR54: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR54_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR54.Reg, volatile.LoadUint32(&o.IELSR54.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR54_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR54.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR54_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR54.Reg, volatile.LoadUint32(&o.IELSR54.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR54_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR54.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR54_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR54.Reg, volatile.LoadUint32(&o.IELSR54.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR54_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR54.Reg) & 0x1ff
}

// ICU.IELSR55: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR55_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR55.Reg, volatile.LoadUint32(&o.IELSR55.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR55_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR55.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR55_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR55.Reg, volatile.LoadUint32(&o.IELSR55.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR55_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR55.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR55_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR55.Reg, volatile.LoadUint32(&o.IELSR55.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR55_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR55.Reg) & 0x1ff
}

// ICU.IELSR56: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR56_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR56.Reg, volatile.LoadUint32(&o.IELSR56.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR56_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR56.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR56_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR56.Reg, volatile.LoadUint32(&o.IELSR56.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR56_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR56.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR56_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR56.Reg, volatile.LoadUint32(&o.IELSR56.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR56_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR56.Reg) & 0x1ff
}

// ICU.IELSR57: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR57_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR57.Reg, volatile.LoadUint32(&o.IELSR57.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR57_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR57.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR57_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR57.Reg, volatile.LoadUint32(&o.IELSR57.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR57_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR57.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR57_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR57.Reg, volatile.LoadUint32(&o.IELSR57.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR57_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR57.Reg) & 0x1ff
}

// ICU.IELSR58: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR58_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR58.Reg, volatile.LoadUint32(&o.IELSR58.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR58_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR58.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR58_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR58.Reg, volatile.LoadUint32(&o.IELSR58.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR58_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR58.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR58_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR58.Reg, volatile.LoadUint32(&o.IELSR58.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR58_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR58.Reg) & 0x1ff
}

// ICU.IELSR59: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR59_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR59.Reg, volatile.LoadUint32(&o.IELSR59.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR59_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR59.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR59_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR59.Reg, volatile.LoadUint32(&o.IELSR59.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR59_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR59.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR59_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR59.Reg, volatile.LoadUint32(&o.IELSR59.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR59_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR59.Reg) & 0x1ff
}

// ICU.IELSR60: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR60_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR60.Reg, volatile.LoadUint32(&o.IELSR60.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR60_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR60.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR60_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR60.Reg, volatile.LoadUint32(&o.IELSR60.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR60_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR60.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR60_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR60.Reg, volatile.LoadUint32(&o.IELSR60.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR60_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR60.Reg) & 0x1ff
}

// ICU.IELSR61: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR61_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR61.Reg, volatile.LoadUint32(&o.IELSR61.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR61_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR61.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR61_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR61.Reg, volatile.LoadUint32(&o.IELSR61.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR61_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR61.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR61_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR61.Reg, volatile.LoadUint32(&o.IELSR61.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR61_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR61.Reg) & 0x1ff
}

// ICU.IELSR62: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR62_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR62.Reg, volatile.LoadUint32(&o.IELSR62.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR62_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR62.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR62_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR62.Reg, volatile.LoadUint32(&o.IELSR62.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR62_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR62.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR62_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR62.Reg, volatile.LoadUint32(&o.IELSR62.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR62_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR62.Reg) & 0x1ff
}

// ICU.IELSR63: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR63_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR63.Reg, volatile.LoadUint32(&o.IELSR63.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR63_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR63.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR63_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR63.Reg, volatile.LoadUint32(&o.IELSR63.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR63_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR63.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR63_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR63.Reg, volatile.LoadUint32(&o.IELSR63.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR63_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR63.Reg) & 0x1ff
}

// ICU.IELSR64: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR64_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR64.Reg, volatile.LoadUint32(&o.IELSR64.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR64_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR64.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR64_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR64.Reg, volatile.LoadUint32(&o.IELSR64.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR64_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR64.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR64_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR64.Reg, volatile.LoadUint32(&o.IELSR64.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR64_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR64.Reg) & 0x1ff
}

// ICU.IELSR65: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR65_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR65.Reg, volatile.LoadUint32(&o.IELSR65.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR65_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR65.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR65_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR65.Reg, volatile.LoadUint32(&o.IELSR65.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR65_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR65.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR65_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR65.Reg, volatile.LoadUint32(&o.IELSR65.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR65_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR65.Reg) & 0x1ff
}

// ICU.IELSR66: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR66_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR66.Reg, volatile.LoadUint32(&o.IELSR66.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR66_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR66.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR66_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR66.Reg, volatile.LoadUint32(&o.IELSR66.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR66_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR66.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR66_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR66.Reg, volatile.LoadUint32(&o.IELSR66.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR66_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR66.Reg) & 0x1ff
}

// ICU.IELSR67: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR67_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR67.Reg, volatile.LoadUint32(&o.IELSR67.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR67_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR67.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR67_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR67.Reg, volatile.LoadUint32(&o.IELSR67.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR67_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR67.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR67_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR67.Reg, volatile.LoadUint32(&o.IELSR67.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR67_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR67.Reg) & 0x1ff
}

// ICU.IELSR68: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR68_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR68.Reg, volatile.LoadUint32(&o.IELSR68.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR68_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR68.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR68_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR68.Reg, volatile.LoadUint32(&o.IELSR68.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR68_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR68.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR68_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR68.Reg, volatile.LoadUint32(&o.IELSR68.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR68_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR68.Reg) & 0x1ff
}

// ICU.IELSR69: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR69_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR69.Reg, volatile.LoadUint32(&o.IELSR69.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR69_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR69.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR69_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR69.Reg, volatile.LoadUint32(&o.IELSR69.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR69_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR69.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR69_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR69.Reg, volatile.LoadUint32(&o.IELSR69.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR69_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR69.Reg) & 0x1ff
}

// ICU.IELSR70: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR70_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR70.Reg, volatile.LoadUint32(&o.IELSR70.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR70_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR70.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR70_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR70.Reg, volatile.LoadUint32(&o.IELSR70.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR70_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR70.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR70_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR70.Reg, volatile.LoadUint32(&o.IELSR70.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR70_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR70.Reg) & 0x1ff
}

// ICU.IELSR71: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR71_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR71.Reg, volatile.LoadUint32(&o.IELSR71.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR71_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR71.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR71_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR71.Reg, volatile.LoadUint32(&o.IELSR71.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR71_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR71.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR71_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR71.Reg, volatile.LoadUint32(&o.IELSR71.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR71_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR71.Reg) & 0x1ff
}

// ICU.IELSR72: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR72_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR72.Reg, volatile.LoadUint32(&o.IELSR72.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR72_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR72.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR72_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR72.Reg, volatile.LoadUint32(&o.IELSR72.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR72_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR72.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR72_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR72.Reg, volatile.LoadUint32(&o.IELSR72.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR72_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR72.Reg) & 0x1ff
}

// ICU.IELSR73: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR73_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR73.Reg, volatile.LoadUint32(&o.IELSR73.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR73_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR73.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR73_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR73.Reg, volatile.LoadUint32(&o.IELSR73.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR73_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR73.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR73_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR73.Reg, volatile.LoadUint32(&o.IELSR73.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR73_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR73.Reg) & 0x1ff
}

// ICU.IELSR74: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR74_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR74.Reg, volatile.LoadUint32(&o.IELSR74.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR74_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR74.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR74_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR74.Reg, volatile.LoadUint32(&o.IELSR74.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR74_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR74.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR74_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR74.Reg, volatile.LoadUint32(&o.IELSR74.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR74_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR74.Reg) & 0x1ff
}

// ICU.IELSR75: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR75_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR75.Reg, volatile.LoadUint32(&o.IELSR75.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR75_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR75.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR75_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR75.Reg, volatile.LoadUint32(&o.IELSR75.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR75_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR75.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR75_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR75.Reg, volatile.LoadUint32(&o.IELSR75.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR75_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR75.Reg) & 0x1ff
}

// ICU.IELSR76: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR76_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR76.Reg, volatile.LoadUint32(&o.IELSR76.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR76_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR76.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR76_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR76.Reg, volatile.LoadUint32(&o.IELSR76.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR76_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR76.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR76_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR76.Reg, volatile.LoadUint32(&o.IELSR76.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR76_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR76.Reg) & 0x1ff
}

// ICU.IELSR77: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR77_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR77.Reg, volatile.LoadUint32(&o.IELSR77.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR77_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR77.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR77_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR77.Reg, volatile.LoadUint32(&o.IELSR77.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR77_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR77.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR77_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR77.Reg, volatile.LoadUint32(&o.IELSR77.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR77_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR77.Reg) & 0x1ff
}

// ICU.IELSR78: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR78_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR78.Reg, volatile.LoadUint32(&o.IELSR78.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR78_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR78.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR78_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR78.Reg, volatile.LoadUint32(&o.IELSR78.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR78_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR78.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR78_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR78.Reg, volatile.LoadUint32(&o.IELSR78.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR78_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR78.Reg) & 0x1ff
}

// ICU.IELSR79: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR79_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR79.Reg, volatile.LoadUint32(&o.IELSR79.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR79_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR79.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR79_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR79.Reg, volatile.LoadUint32(&o.IELSR79.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR79_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR79.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR79_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR79.Reg, volatile.LoadUint32(&o.IELSR79.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR79_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR79.Reg) & 0x1ff
}

// ICU.IELSR80: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR80_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR80.Reg, volatile.LoadUint32(&o.IELSR80.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR80_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR80.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR80_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR80.Reg, volatile.LoadUint32(&o.IELSR80.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR80_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR80.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR80_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR80.Reg, volatile.LoadUint32(&o.IELSR80.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR80_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR80.Reg) & 0x1ff
}

// ICU.IELSR81: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR81_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR81.Reg, volatile.LoadUint32(&o.IELSR81.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR81_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR81.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR81_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR81.Reg, volatile.LoadUint32(&o.IELSR81.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR81_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR81.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR81_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR81.Reg, volatile.LoadUint32(&o.IELSR81.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR81_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR81.Reg) & 0x1ff
}

// ICU.IELSR82: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR82_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR82.Reg, volatile.LoadUint32(&o.IELSR82.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR82_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR82.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR82_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR82.Reg, volatile.LoadUint32(&o.IELSR82.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR82_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR82.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR82_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR82.Reg, volatile.LoadUint32(&o.IELSR82.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR82_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR82.Reg) & 0x1ff
}

// ICU.IELSR83: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR83_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR83.Reg, volatile.LoadUint32(&o.IELSR83.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR83_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR83.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR83_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR83.Reg, volatile.LoadUint32(&o.IELSR83.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR83_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR83.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR83_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR83.Reg, volatile.LoadUint32(&o.IELSR83.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR83_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR83.Reg) & 0x1ff
}

// ICU.IELSR84: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR84_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR84.Reg, volatile.LoadUint32(&o.IELSR84.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR84_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR84.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR84_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR84.Reg, volatile.LoadUint32(&o.IELSR84.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR84_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR84.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR84_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR84.Reg, volatile.LoadUint32(&o.IELSR84.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR84_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR84.Reg) & 0x1ff
}

// ICU.IELSR85: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR85_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR85.Reg, volatile.LoadUint32(&o.IELSR85.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR85_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR85.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR85_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR85.Reg, volatile.LoadUint32(&o.IELSR85.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR85_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR85.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR85_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR85.Reg, volatile.LoadUint32(&o.IELSR85.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR85_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR85.Reg) & 0x1ff
}

// ICU.IELSR86: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR86_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR86.Reg, volatile.LoadUint32(&o.IELSR86.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR86_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR86.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR86_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR86.Reg, volatile.LoadUint32(&o.IELSR86.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR86_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR86.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR86_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR86.Reg, volatile.LoadUint32(&o.IELSR86.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR86_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR86.Reg) & 0x1ff
}

// ICU.IELSR87: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR87_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR87.Reg, volatile.LoadUint32(&o.IELSR87.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR87_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR87.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR87_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR87.Reg, volatile.LoadUint32(&o.IELSR87.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR87_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR87.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR87_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR87.Reg, volatile.LoadUint32(&o.IELSR87.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR87_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR87.Reg) & 0x1ff
}

// ICU.IELSR88: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR88_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR88.Reg, volatile.LoadUint32(&o.IELSR88.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR88_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR88.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR88_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR88.Reg, volatile.LoadUint32(&o.IELSR88.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR88_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR88.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR88_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR88.Reg, volatile.LoadUint32(&o.IELSR88.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR88_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR88.Reg) & 0x1ff
}

// ICU.IELSR89: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR89_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR89.Reg, volatile.LoadUint32(&o.IELSR89.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR89_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR89.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR89_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR89.Reg, volatile.LoadUint32(&o.IELSR89.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR89_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR89.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR89_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR89.Reg, volatile.LoadUint32(&o.IELSR89.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR89_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR89.Reg) & 0x1ff
}

// ICU.IELSR90: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR90_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR90.Reg, volatile.LoadUint32(&o.IELSR90.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR90_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR90.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR90_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR90.Reg, volatile.LoadUint32(&o.IELSR90.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR90_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR90.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR90_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR90.Reg, volatile.LoadUint32(&o.IELSR90.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR90_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR90.Reg) & 0x1ff
}

// ICU.IELSR91: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR91_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR91.Reg, volatile.LoadUint32(&o.IELSR91.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR91_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR91.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR91_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR91.Reg, volatile.LoadUint32(&o.IELSR91.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR91_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR91.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR91_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR91.Reg, volatile.LoadUint32(&o.IELSR91.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR91_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR91.Reg) & 0x1ff
}

// ICU.IELSR92: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR92_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR92.Reg, volatile.LoadUint32(&o.IELSR92.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR92_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR92.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR92_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR92.Reg, volatile.LoadUint32(&o.IELSR92.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR92_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR92.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR92_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR92.Reg, volatile.LoadUint32(&o.IELSR92.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR92_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR92.Reg) & 0x1ff
}

// ICU.IELSR93: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR93_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR93.Reg, volatile.LoadUint32(&o.IELSR93.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR93_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR93.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR93_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR93.Reg, volatile.LoadUint32(&o.IELSR93.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR93_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR93.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR93_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR93.Reg, volatile.LoadUint32(&o.IELSR93.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR93_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR93.Reg) & 0x1ff
}

// ICU.IELSR94: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR94_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR94.Reg, volatile.LoadUint32(&o.IELSR94.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR94_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR94.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR94_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR94.Reg, volatile.LoadUint32(&o.IELSR94.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR94_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR94.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR94_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR94.Reg, volatile.LoadUint32(&o.IELSR94.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR94_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR94.Reg) & 0x1ff
}

// ICU.IELSR95: INT Event Link Setting Register %s
func (o *ICU_Type) SetIELSR95_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR95.Reg, volatile.LoadUint32(&o.IELSR95.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR95_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR95.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR95_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR95.Reg, volatile.LoadUint32(&o.IELSR95.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR95_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR95.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR95_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR95.Reg, volatile.LoadUint32(&o.IELSR95.Reg)&^(0x1ff)|value)
}
func (o *ICU_Type) GetIELSR95_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR95.Reg) & 0x1ff
}

// SRAM Control
type SRAM_Type struct {
	PARIOAD   volatile.Register8 // 0x0
	_         [3]byte
	SRAMPRCR  volatile.Register8 // 0x4
	_         [3]byte
	SRAMWTSC  volatile.Register8 // 0x8
	_         [183]byte
	ECCMODE   volatile.Register8 // 0xC0
	ECC2STS   volatile.Register8 // 0xC1
	ECC1STSEN volatile.Register8 // 0xC2
	ECC1STS   volatile.Register8 // 0xC3
	ECCPRCR   volatile.Register8 // 0xC4
	_         [15]byte
	ECCETST   volatile.Register8 // 0xD4
	_         [3]byte
	ECCOAD    volatile.Register8 // 0xD8
}

// SRAM.PARIOAD: SRAM Parity Error Operation After Detection Register
func (o *SRAM_Type) SetPARIOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetPARIOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.PARIOAD.Reg) & 0x1
}

// SRAM.SRAMPRCR: SRAM Protection Register
func (o *SRAM_Type) SetSRAMPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetSRAMPRCR(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0x1
}

// SRAM.SRAMWTSC: RAM Wait State Control Register
func (o *SRAM_Type) SetSRAMWTSC_SRAM1WTEN(value uint8) {
	volatile.StoreUint8(&o.SRAMWTSC.Reg, volatile.LoadUint8(&o.SRAMWTSC.Reg)&^(0x8)|value<<3)
}
func (o *SRAM_Type) GetSRAMWTSC_SRAM1WTEN() uint8 {
	return (volatile.LoadUint8(&o.SRAMWTSC.Reg) & 0x8) >> 3
}
func (o *SRAM_Type) SetSRAMWTSC_SRAM0WTEN(value uint8) {
	volatile.StoreUint8(&o.SRAMWTSC.Reg, volatile.LoadUint8(&o.SRAMWTSC.Reg)&^(0x4)|value<<2)
}
func (o *SRAM_Type) GetSRAMWTSC_SRAM0WTEN() uint8 {
	return (volatile.LoadUint8(&o.SRAMWTSC.Reg) & 0x4) >> 2
}
func (o *SRAM_Type) SetSRAMWTSC_ECCRAMRDWTEN(value uint8) {
	volatile.StoreUint8(&o.SRAMWTSC.Reg, volatile.LoadUint8(&o.SRAMWTSC.Reg)&^(0x2)|value<<1)
}
func (o *SRAM_Type) GetSRAMWTSC_ECCRAMRDWTEN() uint8 {
	return (volatile.LoadUint8(&o.SRAMWTSC.Reg) & 0x2) >> 1
}

// SRAM.ECCMODE: ECCRAM Operating Mode Control Register
func (o *SRAM_Type) SetECCMODE_ECCMOD(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0x3)|value)
}
func (o *SRAM_Type) GetECCMODE_ECCMOD() uint8 {
	return volatile.LoadUint8(&o.ECCMODE.Reg) & 0x3
}

// SRAM.ECC2STS: ECCRAM 2-Bit Error Status Register
func (o *SRAM_Type) SetECC2STS_ECC2ERR(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC2STS_ECC2ERR() uint8 {
	return volatile.LoadUint8(&o.ECC2STS.Reg) & 0x1
}

// SRAM.ECC1STSEN: ECCRAM 1-Bit Error Information Update Enable Register
func (o *SRAM_Type) SetECC1STSEN_E1STSEN(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STSEN_E1STSEN() uint8 {
	return volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0x1
}

// SRAM.ECC1STS: ECCRAM 1-Bit Error Status Register
func (o *SRAM_Type) SetECC1STS_ECC1ERR(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STS_ECC1ERR() uint8 {
	return volatile.LoadUint8(&o.ECC1STS.Reg) & 0x1
}

// SRAM.ECCPRCR: ECCRAM Protection Register
func (o *SRAM_Type) SetECCPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCPRCR(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR.Reg) & 0x1
}

// SRAM.ECCETST: ECC Test Control Register
func (o *SRAM_Type) SetECCETST_TSTBYP(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCETST_TSTBYP() uint8 {
	return volatile.LoadUint8(&o.ECCETST.Reg) & 0x1
}

// SRAM.ECCOAD: RAM ECC Error Operation After Detection Register
func (o *SRAM_Type) SetECCOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.ECCOAD.Reg) & 0x1
}

// PWM Delay Generation Circuit
type GPT_ODC_Type struct {
	GTDLYCR  volatile.Register16 // 0x0
	GTDLYCR2 volatile.Register16 // 0x2
	_        [20]byte
	GTDLYR0A volatile.Register16 // 0x18
	GTDLYR0B volatile.Register16 // 0x1A
	GTDLYR1A volatile.Register16 // 0x1C
	GTDLYR1B volatile.Register16 // 0x1E
	GTDLYR2A volatile.Register16 // 0x20
	GTDLYR2B volatile.Register16 // 0x22
	GTDLYR3A volatile.Register16 // 0x24
	GTDLYR3B volatile.Register16 // 0x26
	GTDLYF0A volatile.Register16 // 0x28
	GTDLYF0B volatile.Register16 // 0x2A
	GTDLYF1A volatile.Register16 // 0x2C
	GTDLYF1B volatile.Register16 // 0x2E
	GTDLYF2A volatile.Register16 // 0x30
	GTDLYF2B volatile.Register16 // 0x32
	GTDLYF3A volatile.Register16 // 0x34
	GTDLYF3B volatile.Register16 // 0x36
}

// GPT_ODC.GTDLYCR: PWM Output Delay Control Register
func (o *GPT_ODC_Type) SetGTDLYCR_DLYRST(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR.Reg, volatile.LoadUint16(&o.GTDLYCR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_ODC_Type) GetGTDLYCR_DLYRST() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR.Reg) & 0x2) >> 1
}
func (o *GPT_ODC_Type) SetGTDLYCR_DLLEN(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR.Reg, volatile.LoadUint16(&o.GTDLYCR.Reg)&^(0x1)|value)
}
func (o *GPT_ODC_Type) GetGTDLYCR_DLLEN() uint16 {
	return volatile.LoadUint16(&o.GTDLYCR.Reg) & 0x1
}

// GPT_ODC.GTDLYCR2: PWM Output Delay Control Register2
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYEN3(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x800)|value<<11)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYEN3() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x800) >> 11
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYEN2(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x400)|value<<10)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYEN2() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x400) >> 10
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYEN1(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x200)|value<<9)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYEN1() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x200) >> 9
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYEN0(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x100)|value<<8)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYEN0() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x100) >> 8
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYBS3(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x8)|value<<3)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYBS3() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x8) >> 3
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYBS2(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x4)|value<<2)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYBS2() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x4) >> 2
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYBS1(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x2)|value<<1)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYBS1() uint16 {
	return (volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x2) >> 1
}
func (o *GPT_ODC_Type) SetGTDLYCR2_DLYBS0(value uint16) {
	volatile.StoreUint16(&o.GTDLYCR2.Reg, volatile.LoadUint16(&o.GTDLYCR2.Reg)&^(0x1)|value)
}
func (o *GPT_ODC_Type) GetGTDLYCR2_DLYBS0() uint16 {
	return volatile.LoadUint16(&o.GTDLYCR2.Reg) & 0x1
}

// GPT_ODC.GTDLYR0A: GTIOC%sA Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR0A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR0A.Reg, volatile.LoadUint16(&o.GTDLYR0A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR0A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR0A.Reg) & 0x1f
}

// GPT_ODC.GTDLYR0B: GTIOC%sB Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR0B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR0B.Reg, volatile.LoadUint16(&o.GTDLYR0B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR0B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR0B.Reg) & 0x1f
}

// GPT_ODC.GTDLYR1A: GTIOC%sA Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR1A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR1A.Reg, volatile.LoadUint16(&o.GTDLYR1A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR1A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR1A.Reg) & 0x1f
}

// GPT_ODC.GTDLYR1B: GTIOC%sB Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR1B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR1B.Reg, volatile.LoadUint16(&o.GTDLYR1B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR1B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR1B.Reg) & 0x1f
}

// GPT_ODC.GTDLYR2A: GTIOC%sA Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR2A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR2A.Reg, volatile.LoadUint16(&o.GTDLYR2A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR2A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR2A.Reg) & 0x1f
}

// GPT_ODC.GTDLYR2B: GTIOC%sB Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR2B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR2B.Reg, volatile.LoadUint16(&o.GTDLYR2B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR2B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR2B.Reg) & 0x1f
}

// GPT_ODC.GTDLYR3A: GTIOC%sA Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR3A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR3A.Reg, volatile.LoadUint16(&o.GTDLYR3A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR3A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR3A.Reg) & 0x1f
}

// GPT_ODC.GTDLYR3B: GTIOC%sB Rising Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYR3B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYR3B.Reg, volatile.LoadUint16(&o.GTDLYR3B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYR3B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYR3B.Reg) & 0x1f
}

// GPT_ODC.GTDLYF0A: GTIOC%sA Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF0A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF0A.Reg, volatile.LoadUint16(&o.GTDLYF0A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF0A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF0A.Reg) & 0x1f
}

// GPT_ODC.GTDLYF0B: GTIOC%sB Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF0B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF0B.Reg, volatile.LoadUint16(&o.GTDLYF0B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF0B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF0B.Reg) & 0x1f
}

// GPT_ODC.GTDLYF1A: GTIOC%sA Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF1A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF1A.Reg, volatile.LoadUint16(&o.GTDLYF1A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF1A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF1A.Reg) & 0x1f
}

// GPT_ODC.GTDLYF1B: GTIOC%sB Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF1B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF1B.Reg, volatile.LoadUint16(&o.GTDLYF1B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF1B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF1B.Reg) & 0x1f
}

// GPT_ODC.GTDLYF2A: GTIOC%sA Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF2A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF2A.Reg, volatile.LoadUint16(&o.GTDLYF2A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF2A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF2A.Reg) & 0x1f
}

// GPT_ODC.GTDLYF2B: GTIOC%sB Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF2B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF2B.Reg, volatile.LoadUint16(&o.GTDLYF2B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF2B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF2B.Reg) & 0x1f
}

// GPT_ODC.GTDLYF3A: GTIOC%sA Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF3A_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF3A.Reg, volatile.LoadUint16(&o.GTDLYF3A.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF3A_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF3A.Reg) & 0x1f
}

// GPT_ODC.GTDLYF3B: GTIOC%sB Falling Output Delay Register
func (o *GPT_ODC_Type) SetGTDLYF3B_DLY(value uint16) {
	volatile.StoreUint16(&o.GTDLYF3B.Reg, volatile.LoadUint16(&o.GTDLYF3B.Reg)&^(0x1f)|value)
}
func (o *GPT_ODC_Type) GetGTDLYF3B_DLY() uint16 {
	return volatile.LoadUint16(&o.GTDLYF3B.Reg) & 0x1f
}

// Asynchronous General purpose Timer 0
type AGT0_Type struct {
	AGT      volatile.Register16 // 0x0
	AGTCMA   volatile.Register16 // 0x2
	AGTCMB   volatile.Register16 // 0x4
	_        [2]byte
	AGTCR    volatile.Register8 // 0x8
	AGTMR1   volatile.Register8 // 0x9
	AGTMR2   volatile.Register8 // 0xA
	_        byte
	AGTIOC   volatile.Register8 // 0xC
	AGTISR   volatile.Register8 // 0xD
	AGTCMSR  volatile.Register8 // 0xE
	AGTIOSEL volatile.Register8 // 0xF
}

// AGT0.AGT: AGT Counter Register
func (o *AGT0_Type) SetAGT(value uint16) {
	volatile.StoreUint16(&o.AGT.Reg, value)
}
func (o *AGT0_Type) GetAGT() uint16 {
	return volatile.LoadUint16(&o.AGT.Reg)
}

// AGT0.AGTCMA: AGT Compare Match A Register
func (o *AGT0_Type) SetAGTCMA(value uint16) {
	volatile.StoreUint16(&o.AGTCMA.Reg, value)
}
func (o *AGT0_Type) GetAGTCMA() uint16 {
	return volatile.LoadUint16(&o.AGTCMA.Reg)
}

// AGT0.AGTCMB: AGT Compare Match B Register
func (o *AGT0_Type) SetAGTCMB(value uint16) {
	volatile.StoreUint16(&o.AGTCMB.Reg, value)
}
func (o *AGT0_Type) GetAGTCMB() uint16 {
	return volatile.LoadUint16(&o.AGTCMB.Reg)
}

// AGT0.AGTCR: AGT Control Register
func (o *AGT0_Type) SetAGTCR_TCMBF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCR_TCMBF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTCR_TCMAF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCR_TCMAF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCR_TUNDF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCR_TUNDF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCR_TEDGF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCR_TEDGF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCR_TSTOP(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCR_TSTOP() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCR_TCSTF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCR_TCSTF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCR_TSTART(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCR_TSTART() uint8 {
	return volatile.LoadUint8(&o.AGTCR.Reg) & 0x1
}

// AGT0.AGTMR1: AGT Mode Register 1
func (o *AGT0_Type) SetAGTMR1_TCK(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x70)|value<<4)
}
func (o *AGT0_Type) GetAGTMR1_TCK() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x70) >> 4
}
func (o *AGT0_Type) SetAGTMR1_TEDGPL(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTMR1_TEDGPL() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTMR1_TMOD(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR1_TMOD() uint8 {
	return volatile.LoadUint8(&o.AGTMR1.Reg) & 0x7
}

// AGT0.AGTMR2: AGT Mode Register 2
func (o *AGT0_Type) SetAGTMR2_LPM(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR2_LPM() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTMR2_CKS(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR2_CKS() uint8 {
	return volatile.LoadUint8(&o.AGTMR2.Reg) & 0x7
}

// AGT0.AGTIOC: AGT I/O Control Register
func (o *AGT0_Type) SetAGTIOC_TIOGT(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0xc0)|value<<6)
}
func (o *AGT0_Type) GetAGTIOC_TIOGT() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0xc0) >> 6
}
func (o *AGT0_Type) SetAGTIOC_TIPF(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x30)|value<<4)
}
func (o *AGT0_Type) GetAGTIOC_TIPF() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x30) >> 4
}
func (o *AGT0_Type) SetAGTIOC_TOE(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTIOC_TOE() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTIOC_TEDGSEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTIOC_TEDGSEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOC.Reg) & 0x1
}

// AGT0.AGTISR: AGT Event Pin Select Register
func (o *AGT0_Type) SetAGTISR_EEPS(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTISR_EEPS() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0x4) >> 2
}

// AGT0.AGTCMSR: AGT Compare Match Function Select Register
func (o *AGT0_Type) SetAGTCMSR_TOPOLB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCMSR_TOEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCMSR_TOEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCMSR_TCMEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCMSR_TOEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCMSR_TOEA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCMSR_TCMEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEA() uint8 {
	return volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x1
}

// AGT0.AGTIOSEL: AGT Pin Select Register
func (o *AGT0_Type) SetAGTIOSEL_TIES(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTIOSEL_TIES() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTIOSEL_SEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTIOSEL_SEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x3
}

// Flash Cache
type FCACHE_Type struct {
	_        [256]byte
	FCACHEE  volatile.Register16 // 0x100
	_        [2]byte
	FCACHEIV volatile.Register16 // 0x104
	_        [22]byte
	FLWT     volatile.Register8 // 0x11C
}

// FCACHE.FCACHEE: Flash Cache Enable Register
func (o *FCACHE_Type) SetFCACHEE_FCACHEEN(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEE_FCACHEEN() uint16 {
	return volatile.LoadUint16(&o.FCACHEE.Reg) & 0x1
}

// FCACHE.FCACHEIV: Flash Cache Invalidate Register
func (o *FCACHE_Type) SetFCACHEIV(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEIV() uint16 {
	return volatile.LoadUint16(&o.FCACHEIV.Reg) & 0x1
}

// FCACHE.FLWT: Flash Wait Cycle Register
func (o *FCACHE_Type) SetFLWT(value uint8) {
	volatile.StoreUint8(&o.FLWT.Reg, volatile.LoadUint8(&o.FLWT.Reg)&^(0x7)|value)
}
func (o *FCACHE_Type) GetFLWT() uint8 {
	return volatile.LoadUint8(&o.FLWT.Reg) & 0x7
}

// BUS Control
type BUS_Type struct {
	_            [2]byte
	CS0MOD       volatile.Register16 // 0x2
	CS0WCR1      volatile.Register32 // 0x4
	CS0WCR2      volatile.Register32 // 0x8
	_            [6]byte
	CS1MOD       volatile.Register16 // 0x12
	CS1WCR1      volatile.Register32 // 0x14
	CS1WCR2      volatile.Register32 // 0x18
	_            [6]byte
	CS2MOD       volatile.Register16 // 0x22
	CS2WCR1      volatile.Register32 // 0x24
	CS2WCR2      volatile.Register32 // 0x28
	_            [6]byte
	CS3MOD       volatile.Register16 // 0x32
	CS3WCR1      volatile.Register32 // 0x34
	CS3WCR2      volatile.Register32 // 0x38
	_            [6]byte
	CS4MOD       volatile.Register16 // 0x42
	CS4WCR1      volatile.Register32 // 0x44
	CS4WCR2      volatile.Register32 // 0x48
	_            [6]byte
	CS5MOD       volatile.Register16 // 0x52
	CS5WCR1      volatile.Register32 // 0x54
	CS5WCR2      volatile.Register32 // 0x58
	_            [6]byte
	CS6MOD       volatile.Register16 // 0x62
	CS6WCR1      volatile.Register32 // 0x64
	CS6WCR2      volatile.Register32 // 0x68
	_            [6]byte
	CS7MOD       volatile.Register16 // 0x72
	CS7WCR1      volatile.Register32 // 0x74
	CS7WCR2      volatile.Register32 // 0x78
	_            [1926]byte
	CS0CR        volatile.Register16 // 0x802
	_            [6]byte
	CS0REC       volatile.Register16 // 0x80A
	_            [6]byte
	CS1CR        volatile.Register16 // 0x812
	_            [6]byte
	CS1REC       volatile.Register16 // 0x81A
	_            [6]byte
	CS2CR        volatile.Register16 // 0x822
	_            [6]byte
	CS2REC       volatile.Register16 // 0x82A
	_            [6]byte
	CS3CR        volatile.Register16 // 0x832
	_            [6]byte
	CS3REC       volatile.Register16 // 0x83A
	_            [6]byte
	CS4CR        volatile.Register16 // 0x842
	_            [6]byte
	CS4REC       volatile.Register16 // 0x84A
	_            [6]byte
	CS5CR        volatile.Register16 // 0x852
	_            [6]byte
	CS5REC       volatile.Register16 // 0x85A
	_            [6]byte
	CS6CR        volatile.Register16 // 0x862
	_            [6]byte
	CS6REC       volatile.Register16 // 0x86A
	_            [6]byte
	CS7CR        volatile.Register16 // 0x872
	_            [6]byte
	CS7REC       volatile.Register16 // 0x87A
	_            [4]byte
	CSRECEN      volatile.Register16 // 0x880
	_            [894]byte
	SDCCR        volatile.Register8 // 0xC00
	SDCMOD       volatile.Register8 // 0xC01
	SDAMOD       volatile.Register8 // 0xC02
	_            [13]byte
	SDSELF       volatile.Register8 // 0xC10
	_            [3]byte
	SDRFCR       volatile.Register16 // 0xC14
	SDRFEN       volatile.Register8  // 0xC16
	_            [9]byte
	SDICR        volatile.Register8 // 0xC20
	_            [3]byte
	SDIR         volatile.Register16 // 0xC24
	_            [26]byte
	SDADR        volatile.Register8 // 0xC40
	_            [3]byte
	SDTR         volatile.Register32 // 0xC44
	SDMOD        volatile.Register16 // 0xC48
	_            [6]byte
	SDSR         volatile.Register8 // 0xC50
	_            [943]byte
	BUSMCNTM4I   volatile.Register16 // 0x1000
	_            [2]byte
	BUSMCNTM4D   volatile.Register16 // 0x1004
	_            [2]byte
	BUSMCNTSYS   volatile.Register16 // 0x1008
	_            [2]byte
	BUSMCNTDMA   volatile.Register16 // 0x100C
	_            [2]byte
	BUSMCNTEDM   volatile.Register16 // 0x1010
	_            [2]byte
	BUSMCNTGPX   volatile.Register16 // 0x1014
	_            [234]byte
	BUSSCNTFLI   volatile.Register16 // 0x1100
	_            [2]byte
	BUSSCNTRAMH  volatile.Register16 // 0x1104
	_            [2]byte
	BUSSCNTMBIU  volatile.Register16 // 0x1108
	_            [2]byte
	BUSSCNTRAM0  volatile.Register16 // 0x110C
	_            [2]byte
	BUSSCNTRAM1  volatile.Register16 // 0x1110
	_            [2]byte
	BUSSCNTP0B   volatile.Register16 // 0x1114
	_            [2]byte
	BUSSCNTP2B   volatile.Register16 // 0x1118
	_            [2]byte
	BUSSCNTP3B   volatile.Register16 // 0x111C
	_            [2]byte
	BUSSCNTP4B   volatile.Register16 // 0x1120
	_            [6]byte
	BUSSCNTP6B   volatile.Register16 // 0x1128
	_            [2]byte
	BUSSCNTP7B   volatile.Register16 // 0x112C
	_            [2]byte
	BUSSCNTFBU   volatile.Register16 // 0x1130
	_            [2]byte
	BUSSCNTEXT   volatile.Register16 // 0x1134
	_            [2]byte
	BUSSCNTEXT2  volatile.Register16 // 0x1138
	_            [2]byte
	BUSSCNTGPX   volatile.Register16 // 0x113C
	_            [1730]byte
	BUS1ERRADD   volatile.Register32 // 0x1800
	BUS1ERRSTAT  volatile.Register8  // 0x1804
	_            [11]byte
	BUS2ERRADD   volatile.Register32 // 0x1810
	BUS2ERRSTAT  volatile.Register8  // 0x1814
	_            [11]byte
	BUS3ERRADD   volatile.Register32 // 0x1820
	BUS3ERRSTAT  volatile.Register8  // 0x1824
	_            [11]byte
	BUS4ERRADD   volatile.Register32 // 0x1830
	BUS4ERRSTAT  volatile.Register8  // 0x1834
	_            [11]byte
	BUS5ERRADD   volatile.Register32 // 0x1840
	BUS5ERRSTAT  volatile.Register8  // 0x1844
	_            [11]byte
	BUS6ERRADD   volatile.Register32 // 0x1850
	BUS6ERRSTAT  volatile.Register8  // 0x1854
	_            [11]byte
	BUS7ERRADD   volatile.Register32 // 0x1860
	BUS7ERRSTAT  volatile.Register8  // 0x1864
	_            [11]byte
	BUS8ERRADD   volatile.Register32 // 0x1870
	BUS8ERRSTAT  volatile.Register8  // 0x1874
	_            [11]byte
	BUS9ERRADD   volatile.Register32 // 0x1880
	BUS9ERRSTAT  volatile.Register8  // 0x1884
	_            [11]byte
	BUS10ERRADD  volatile.Register32 // 0x1890
	BUS10ERRSTAT volatile.Register8  // 0x1894
	_            [11]byte
	BUS11ERRADD  volatile.Register32 // 0x18A0
	BUS11ERRSTAT volatile.Register8  // 0x18A4
}

// BUS.CS0MOD: CS%s Mode Register
func (o *BUS_Type) SetCS0MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS0MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS0MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS0MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS0MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS0MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS0MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS0MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS0MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS0MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS0MOD.Reg, volatile.LoadUint16(&o.CS0MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS0MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS0MOD.Reg) & 0x1
}

// BUS.CS0WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS0WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS0WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS0WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS0WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS0WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS0WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS0WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR1.Reg, volatile.LoadUint32(&o.CS0WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS0WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS0WCR1.Reg) & 0x7
}

// BUS.CS0WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS0WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS0WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS0WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS0WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS0WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS0WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS0WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS0WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS0WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS0WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS0WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS0WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS0WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS0WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS0WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS0WCR2.Reg, volatile.LoadUint32(&o.CS0WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS0WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS0WCR2.Reg) & 0x7
}

// BUS.CS1MOD: CS%s Mode Register
func (o *BUS_Type) SetCS1MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS1MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS1MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS1MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS1MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS1MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS1MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS1MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS1MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS1MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS1MOD.Reg, volatile.LoadUint16(&o.CS1MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS1MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS1MOD.Reg) & 0x1
}

// BUS.CS1WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS1WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS1WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS1WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS1WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS1WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS1WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS1WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR1.Reg, volatile.LoadUint32(&o.CS1WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS1WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS1WCR1.Reg) & 0x7
}

// BUS.CS1WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS1WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS1WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS1WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS1WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS1WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS1WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS1WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS1WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS1WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS1WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS1WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS1WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS1WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS1WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS1WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS1WCR2.Reg, volatile.LoadUint32(&o.CS1WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS1WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS1WCR2.Reg) & 0x7
}

// BUS.CS2MOD: CS%s Mode Register
func (o *BUS_Type) SetCS2MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS2MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS2MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS2MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS2MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS2MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS2MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS2MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS2MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS2MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS2MOD.Reg, volatile.LoadUint16(&o.CS2MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS2MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS2MOD.Reg) & 0x1
}

// BUS.CS2WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS2WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS2WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS2WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS2WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS2WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS2WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS2WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR1.Reg, volatile.LoadUint32(&o.CS2WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS2WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS2WCR1.Reg) & 0x7
}

// BUS.CS2WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS2WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS2WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS2WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS2WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS2WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS2WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS2WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS2WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS2WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS2WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS2WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS2WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS2WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS2WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS2WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS2WCR2.Reg, volatile.LoadUint32(&o.CS2WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS2WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS2WCR2.Reg) & 0x7
}

// BUS.CS3MOD: CS%s Mode Register
func (o *BUS_Type) SetCS3MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS3MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS3MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS3MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS3MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS3MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS3MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS3MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS3MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS3MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS3MOD.Reg, volatile.LoadUint16(&o.CS3MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS3MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS3MOD.Reg) & 0x1
}

// BUS.CS3WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS3WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS3WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS3WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS3WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS3WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS3WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS3WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR1.Reg, volatile.LoadUint32(&o.CS3WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS3WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS3WCR1.Reg) & 0x7
}

// BUS.CS3WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS3WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS3WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS3WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS3WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS3WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS3WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS3WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS3WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS3WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS3WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS3WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS3WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS3WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS3WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS3WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS3WCR2.Reg, volatile.LoadUint32(&o.CS3WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS3WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS3WCR2.Reg) & 0x7
}

// BUS.CS4MOD: CS%s Mode Register
func (o *BUS_Type) SetCS4MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS4MOD.Reg, volatile.LoadUint16(&o.CS4MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS4MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS4MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS4MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS4MOD.Reg, volatile.LoadUint16(&o.CS4MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS4MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS4MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS4MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS4MOD.Reg, volatile.LoadUint16(&o.CS4MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS4MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS4MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS4MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS4MOD.Reg, volatile.LoadUint16(&o.CS4MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS4MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS4MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS4MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS4MOD.Reg, volatile.LoadUint16(&o.CS4MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS4MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS4MOD.Reg) & 0x1
}

// BUS.CS4WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS4WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS4WCR1.Reg, volatile.LoadUint32(&o.CS4WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS4WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS4WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS4WCR1.Reg, volatile.LoadUint32(&o.CS4WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS4WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS4WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS4WCR1.Reg, volatile.LoadUint32(&o.CS4WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS4WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS4WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS4WCR1.Reg, volatile.LoadUint32(&o.CS4WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS4WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS4WCR1.Reg) & 0x7
}

// BUS.CS4WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS4WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS4WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS4WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS4WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS4WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS4WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS4WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS4WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS4WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS4WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS4WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS4WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS4WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS4WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS4WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS4WCR2.Reg, volatile.LoadUint32(&o.CS4WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS4WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS4WCR2.Reg) & 0x7
}

// BUS.CS5MOD: CS%s Mode Register
func (o *BUS_Type) SetCS5MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS5MOD.Reg, volatile.LoadUint16(&o.CS5MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS5MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS5MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS5MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS5MOD.Reg, volatile.LoadUint16(&o.CS5MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS5MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS5MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS5MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS5MOD.Reg, volatile.LoadUint16(&o.CS5MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS5MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS5MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS5MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS5MOD.Reg, volatile.LoadUint16(&o.CS5MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS5MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS5MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS5MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS5MOD.Reg, volatile.LoadUint16(&o.CS5MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS5MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS5MOD.Reg) & 0x1
}

// BUS.CS5WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS5WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS5WCR1.Reg, volatile.LoadUint32(&o.CS5WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS5WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS5WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS5WCR1.Reg, volatile.LoadUint32(&o.CS5WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS5WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS5WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS5WCR1.Reg, volatile.LoadUint32(&o.CS5WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS5WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS5WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS5WCR1.Reg, volatile.LoadUint32(&o.CS5WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS5WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS5WCR1.Reg) & 0x7
}

// BUS.CS5WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS5WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS5WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS5WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS5WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS5WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS5WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS5WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS5WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS5WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS5WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS5WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS5WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS5WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS5WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS5WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS5WCR2.Reg, volatile.LoadUint32(&o.CS5WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS5WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS5WCR2.Reg) & 0x7
}

// BUS.CS6MOD: CS%s Mode Register
func (o *BUS_Type) SetCS6MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS6MOD.Reg, volatile.LoadUint16(&o.CS6MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS6MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS6MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS6MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS6MOD.Reg, volatile.LoadUint16(&o.CS6MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS6MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS6MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS6MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS6MOD.Reg, volatile.LoadUint16(&o.CS6MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS6MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS6MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS6MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS6MOD.Reg, volatile.LoadUint16(&o.CS6MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS6MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS6MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS6MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS6MOD.Reg, volatile.LoadUint16(&o.CS6MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS6MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS6MOD.Reg) & 0x1
}

// BUS.CS6WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS6WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS6WCR1.Reg, volatile.LoadUint32(&o.CS6WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS6WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS6WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS6WCR1.Reg, volatile.LoadUint32(&o.CS6WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS6WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS6WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS6WCR1.Reg, volatile.LoadUint32(&o.CS6WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS6WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS6WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS6WCR1.Reg, volatile.LoadUint32(&o.CS6WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS6WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS6WCR1.Reg) & 0x7
}

// BUS.CS6WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS6WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS6WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS6WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS6WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS6WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS6WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS6WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS6WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS6WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS6WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS6WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS6WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS6WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS6WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS6WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS6WCR2.Reg, volatile.LoadUint32(&o.CS6WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS6WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS6WCR2.Reg) & 0x7
}

// BUS.CS7MOD: CS%s Mode Register
func (o *BUS_Type) SetCS7MOD_PRMOD(value uint16) {
	volatile.StoreUint16(&o.CS7MOD.Reg, volatile.LoadUint16(&o.CS7MOD.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCS7MOD_PRMOD() uint16 {
	return (volatile.LoadUint16(&o.CS7MOD.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCS7MOD_PWENB(value uint16) {
	volatile.StoreUint16(&o.CS7MOD.Reg, volatile.LoadUint16(&o.CS7MOD.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCS7MOD_PWENB() uint16 {
	return (volatile.LoadUint16(&o.CS7MOD.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCS7MOD_PRENB(value uint16) {
	volatile.StoreUint16(&o.CS7MOD.Reg, volatile.LoadUint16(&o.CS7MOD.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS7MOD_PRENB() uint16 {
	return (volatile.LoadUint16(&o.CS7MOD.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS7MOD_EWENB(value uint16) {
	volatile.StoreUint16(&o.CS7MOD.Reg, volatile.LoadUint16(&o.CS7MOD.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCS7MOD_EWENB() uint16 {
	return (volatile.LoadUint16(&o.CS7MOD.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCS7MOD_WRMOD(value uint16) {
	volatile.StoreUint16(&o.CS7MOD.Reg, volatile.LoadUint16(&o.CS7MOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS7MOD_WRMOD() uint16 {
	return volatile.LoadUint16(&o.CS7MOD.Reg) & 0x1
}

// BUS.CS7WCR1: CS%s Wait Control Register 1
func (o *BUS_Type) SetCS7WCR1_CSRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS7WCR1.Reg, volatile.LoadUint32(&o.CS7WCR1.Reg)&^(0x1f000000)|value<<24)
}
func (o *BUS_Type) GetCS7WCR1_CSRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR1.Reg) & 0x1f000000) >> 24
}
func (o *BUS_Type) SetCS7WCR1_CSWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS7WCR1.Reg, volatile.LoadUint32(&o.CS7WCR1.Reg)&^(0x1f0000)|value<<16)
}
func (o *BUS_Type) GetCS7WCR1_CSWWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR1.Reg) & 0x1f0000) >> 16
}
func (o *BUS_Type) SetCS7WCR1_CSPRWAIT(value uint32) {
	volatile.StoreUint32(&o.CS7WCR1.Reg, volatile.LoadUint32(&o.CS7WCR1.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS7WCR1_CSPRWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR1.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS7WCR1_CSPWWAIT(value uint32) {
	volatile.StoreUint32(&o.CS7WCR1.Reg, volatile.LoadUint32(&o.CS7WCR1.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS7WCR1_CSPWWAIT() uint32 {
	return volatile.LoadUint32(&o.CS7WCR1.Reg) & 0x7
}

// BUS.CS7WCR2: CS%s Wait Control Register 2
func (o *BUS_Type) SetCS7WCR2_CSON(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x70000000)|value<<28)
}
func (o *BUS_Type) GetCS7WCR2_CSON() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x70000000) >> 28
}
func (o *BUS_Type) SetCS7WCR2_WDON(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x7000000)|value<<24)
}
func (o *BUS_Type) GetCS7WCR2_WDON() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x7000000) >> 24
}
func (o *BUS_Type) SetCS7WCR2_WRON(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x700000)|value<<20)
}
func (o *BUS_Type) GetCS7WCR2_WRON() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x700000) >> 20
}
func (o *BUS_Type) SetCS7WCR2_RDON(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetCS7WCR2_RDON() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetCS7WCR2_AWAIT(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetCS7WCR2_AWAIT() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetCS7WCR2_WDOFF(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetCS7WCR2_WDOFF() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetCS7WCR2_CSWOFF(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x70)|value<<4)
}
func (o *BUS_Type) GetCS7WCR2_CSWOFF() uint32 {
	return (volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x70) >> 4
}
func (o *BUS_Type) SetCS7WCR2_CSROFF(value uint32) {
	volatile.StoreUint32(&o.CS7WCR2.Reg, volatile.LoadUint32(&o.CS7WCR2.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetCS7WCR2_CSROFF() uint32 {
	return volatile.LoadUint32(&o.CS7WCR2.Reg) & 0x7
}

// BUS.CS0CR: CS0 Control Register
func (o *BUS_Type) SetCS0CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS0CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS0CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS0CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS0CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS0CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS0CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS0CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS0CR.Reg, volatile.LoadUint16(&o.CS0CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS0CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS0CR.Reg) & 0x1
}

// BUS.CS0REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS0REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS0REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS0REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS0REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS0REC.Reg, volatile.LoadUint16(&o.CS0REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS0REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS0REC.Reg) & 0xf
}

// BUS.CS1CR: CS%s Control Register
func (o *BUS_Type) SetCS1CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS1CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS1CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS1CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS1CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS1CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS1CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS1CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS1CR.Reg, volatile.LoadUint16(&o.CS1CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS1CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS1CR.Reg) & 0x1
}

// BUS.CS1REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS1REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS1REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS1REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS1REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS1REC.Reg, volatile.LoadUint16(&o.CS1REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS1REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS1REC.Reg) & 0xf
}

// BUS.CS2CR: CS%s Control Register
func (o *BUS_Type) SetCS2CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS2CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS2CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS2CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS2CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS2CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS2CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS2CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS2CR.Reg, volatile.LoadUint16(&o.CS2CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS2CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS2CR.Reg) & 0x1
}

// BUS.CS2REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS2REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS2REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS2REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS2REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS2REC.Reg, volatile.LoadUint16(&o.CS2REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS2REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS2REC.Reg) & 0xf
}

// BUS.CS3CR: CS%s Control Register
func (o *BUS_Type) SetCS3CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS3CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS3CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS3CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS3CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS3CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS3CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS3CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS3CR.Reg, volatile.LoadUint16(&o.CS3CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS3CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS3CR.Reg) & 0x1
}

// BUS.CS3REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS3REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS3REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS3REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS3REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS3REC.Reg, volatile.LoadUint16(&o.CS3REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS3REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS3REC.Reg) & 0xf
}

// BUS.CS4CR: CS%s Control Register
func (o *BUS_Type) SetCS4CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS4CR.Reg, volatile.LoadUint16(&o.CS4CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS4CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS4CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS4CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS4CR.Reg, volatile.LoadUint16(&o.CS4CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS4CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS4CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS4CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS4CR.Reg, volatile.LoadUint16(&o.CS4CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS4CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS4CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS4CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS4CR.Reg, volatile.LoadUint16(&o.CS4CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS4CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS4CR.Reg) & 0x1
}

// BUS.CS4REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS4REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS4REC.Reg, volatile.LoadUint16(&o.CS4REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS4REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS4REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS4REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS4REC.Reg, volatile.LoadUint16(&o.CS4REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS4REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS4REC.Reg) & 0xf
}

// BUS.CS5CR: CS%s Control Register
func (o *BUS_Type) SetCS5CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS5CR.Reg, volatile.LoadUint16(&o.CS5CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS5CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS5CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS5CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS5CR.Reg, volatile.LoadUint16(&o.CS5CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS5CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS5CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS5CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS5CR.Reg, volatile.LoadUint16(&o.CS5CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS5CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS5CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS5CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS5CR.Reg, volatile.LoadUint16(&o.CS5CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS5CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS5CR.Reg) & 0x1
}

// BUS.CS5REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS5REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS5REC.Reg, volatile.LoadUint16(&o.CS5REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS5REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS5REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS5REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS5REC.Reg, volatile.LoadUint16(&o.CS5REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS5REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS5REC.Reg) & 0xf
}

// BUS.CS6CR: CS%s Control Register
func (o *BUS_Type) SetCS6CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS6CR.Reg, volatile.LoadUint16(&o.CS6CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS6CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS6CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS6CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS6CR.Reg, volatile.LoadUint16(&o.CS6CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS6CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS6CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS6CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS6CR.Reg, volatile.LoadUint16(&o.CS6CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS6CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS6CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS6CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS6CR.Reg, volatile.LoadUint16(&o.CS6CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS6CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS6CR.Reg) & 0x1
}

// BUS.CS6REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS6REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS6REC.Reg, volatile.LoadUint16(&o.CS6REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS6REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS6REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS6REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS6REC.Reg, volatile.LoadUint16(&o.CS6REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS6REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS6REC.Reg) & 0xf
}

// BUS.CS7CR: CS%s Control Register
func (o *BUS_Type) SetCS7CR_MPXEN(value uint16) {
	volatile.StoreUint16(&o.CS7CR.Reg, volatile.LoadUint16(&o.CS7CR.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCS7CR_MPXEN() uint16 {
	return (volatile.LoadUint16(&o.CS7CR.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCS7CR_EMODE(value uint16) {
	volatile.StoreUint16(&o.CS7CR.Reg, volatile.LoadUint16(&o.CS7CR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCS7CR_EMODE() uint16 {
	return (volatile.LoadUint16(&o.CS7CR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCS7CR_BSIZE(value uint16) {
	volatile.StoreUint16(&o.CS7CR.Reg, volatile.LoadUint16(&o.CS7CR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetCS7CR_BSIZE() uint16 {
	return (volatile.LoadUint16(&o.CS7CR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetCS7CR_EXENB(value uint16) {
	volatile.StoreUint16(&o.CS7CR.Reg, volatile.LoadUint16(&o.CS7CR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCS7CR_EXENB() uint16 {
	return volatile.LoadUint16(&o.CS7CR.Reg) & 0x1
}

// BUS.CS7REC: CS%s Recovery Cycle Register
func (o *BUS_Type) SetCS7REC_WRCV(value uint16) {
	volatile.StoreUint16(&o.CS7REC.Reg, volatile.LoadUint16(&o.CS7REC.Reg)&^(0xf00)|value<<8)
}
func (o *BUS_Type) GetCS7REC_WRCV() uint16 {
	return (volatile.LoadUint16(&o.CS7REC.Reg) & 0xf00) >> 8
}
func (o *BUS_Type) SetCS7REC_RRCV(value uint16) {
	volatile.StoreUint16(&o.CS7REC.Reg, volatile.LoadUint16(&o.CS7REC.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetCS7REC_RRCV() uint16 {
	return volatile.LoadUint16(&o.CS7REC.Reg) & 0xf
}

// BUS.CSRECEN: CS Recovery Cycle Insertion Enable Register
func (o *BUS_Type) SetCSRECEN_RCVENM7(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetCSRECEN_RCVENM7() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetCSRECEN_RCVENM6(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x4000)|value<<14)
}
func (o *BUS_Type) GetCSRECEN_RCVENM6() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x4000) >> 14
}
func (o *BUS_Type) SetCSRECEN_RCVENM5(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x2000)|value<<13)
}
func (o *BUS_Type) GetCSRECEN_RCVENM5() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x2000) >> 13
}
func (o *BUS_Type) SetCSRECEN_RCVENM4(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x1000)|value<<12)
}
func (o *BUS_Type) GetCSRECEN_RCVENM4() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x1000) >> 12
}
func (o *BUS_Type) SetCSRECEN_RCVENM3(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x800)|value<<11)
}
func (o *BUS_Type) GetCSRECEN_RCVENM3() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x800) >> 11
}
func (o *BUS_Type) SetCSRECEN_RCVENM2(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x400)|value<<10)
}
func (o *BUS_Type) GetCSRECEN_RCVENM2() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x400) >> 10
}
func (o *BUS_Type) SetCSRECEN_RCVENM1(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x200)|value<<9)
}
func (o *BUS_Type) GetCSRECEN_RCVENM1() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x200) >> 9
}
func (o *BUS_Type) SetCSRECEN_RCVENM0(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetCSRECEN_RCVENM0() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetCSRECEN_RCVEN7(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetCSRECEN_RCVEN7() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetCSRECEN_RCVEN6(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x40)|value<<6)
}
func (o *BUS_Type) GetCSRECEN_RCVEN6() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x40) >> 6
}
func (o *BUS_Type) SetCSRECEN_RCVEN5(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x20)|value<<5)
}
func (o *BUS_Type) GetCSRECEN_RCVEN5() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x20) >> 5
}
func (o *BUS_Type) SetCSRECEN_RCVEN4(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetCSRECEN_RCVEN4() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x10) >> 4
}
func (o *BUS_Type) SetCSRECEN_RCVEN3(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetCSRECEN_RCVEN3() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetCSRECEN_RCVEN2(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x4)|value<<2)
}
func (o *BUS_Type) GetCSRECEN_RCVEN2() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x4) >> 2
}
func (o *BUS_Type) SetCSRECEN_RCVEN1(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x2)|value<<1)
}
func (o *BUS_Type) GetCSRECEN_RCVEN1() uint16 {
	return (volatile.LoadUint16(&o.CSRECEN.Reg) & 0x2) >> 1
}
func (o *BUS_Type) SetCSRECEN_RCVEN0(value uint16) {
	volatile.StoreUint16(&o.CSRECEN.Reg, volatile.LoadUint16(&o.CSRECEN.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetCSRECEN_RCVEN0() uint16 {
	return volatile.LoadUint16(&o.CSRECEN.Reg) & 0x1
}

// BUS.SDCCR: SDC Control Register
func (o *BUS_Type) SetSDCCR_BSIZE(value uint8) {
	volatile.StoreUint8(&o.SDCCR.Reg, volatile.LoadUint8(&o.SDCCR.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetSDCCR_BSIZE() uint8 {
	return (volatile.LoadUint8(&o.SDCCR.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetSDCCR_EXENB(value uint8) {
	volatile.StoreUint8(&o.SDCCR.Reg, volatile.LoadUint8(&o.SDCCR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDCCR_EXENB() uint8 {
	return volatile.LoadUint8(&o.SDCCR.Reg) & 0x1
}

// BUS.SDCMOD: SDC Mode Register
func (o *BUS_Type) SetSDCMOD_EMODE(value uint8) {
	volatile.StoreUint8(&o.SDCMOD.Reg, volatile.LoadUint8(&o.SDCMOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDCMOD_EMODE() uint8 {
	return volatile.LoadUint8(&o.SDCMOD.Reg) & 0x1
}

// BUS.SDAMOD: SDRAM Access Mode Register
func (o *BUS_Type) SetSDAMOD_BE(value uint8) {
	volatile.StoreUint8(&o.SDAMOD.Reg, volatile.LoadUint8(&o.SDAMOD.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDAMOD_BE() uint8 {
	return volatile.LoadUint8(&o.SDAMOD.Reg) & 0x1
}

// BUS.SDSELF: SDRAM Self-Refresh Control Register
func (o *BUS_Type) SetSDSELF_SFEN(value uint8) {
	volatile.StoreUint8(&o.SDSELF.Reg, volatile.LoadUint8(&o.SDSELF.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDSELF_SFEN() uint8 {
	return volatile.LoadUint8(&o.SDSELF.Reg) & 0x1
}

// BUS.SDRFCR: SDRAM Refresh Control Register
func (o *BUS_Type) SetSDRFCR_REFW(value uint16) {
	volatile.StoreUint16(&o.SDRFCR.Reg, volatile.LoadUint16(&o.SDRFCR.Reg)&^(0xf000)|value<<12)
}
func (o *BUS_Type) GetSDRFCR_REFW() uint16 {
	return (volatile.LoadUint16(&o.SDRFCR.Reg) & 0xf000) >> 12
}
func (o *BUS_Type) SetSDRFCR_RFC(value uint16) {
	volatile.StoreUint16(&o.SDRFCR.Reg, volatile.LoadUint16(&o.SDRFCR.Reg)&^(0xfff)|value)
}
func (o *BUS_Type) GetSDRFCR_RFC() uint16 {
	return volatile.LoadUint16(&o.SDRFCR.Reg) & 0xfff
}

// BUS.SDRFEN: SDRAM Auto-Refresh Control Register
func (o *BUS_Type) SetSDRFEN_RFEN(value uint8) {
	volatile.StoreUint8(&o.SDRFEN.Reg, volatile.LoadUint8(&o.SDRFEN.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDRFEN_RFEN() uint8 {
	return volatile.LoadUint8(&o.SDRFEN.Reg) & 0x1
}

// BUS.SDICR: SDRAM Initialization Sequence Control Register
func (o *BUS_Type) SetSDICR_INIRQ(value uint8) {
	volatile.StoreUint8(&o.SDICR.Reg, volatile.LoadUint8(&o.SDICR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDICR_INIRQ() uint8 {
	return volatile.LoadUint8(&o.SDICR.Reg) & 0x1
}

// BUS.SDIR: SDRAM Initialization Register
func (o *BUS_Type) SetSDIR_PRC(value uint16) {
	volatile.StoreUint16(&o.SDIR.Reg, volatile.LoadUint16(&o.SDIR.Reg)&^(0x700)|value<<8)
}
func (o *BUS_Type) GetSDIR_PRC() uint16 {
	return (volatile.LoadUint16(&o.SDIR.Reg) & 0x700) >> 8
}
func (o *BUS_Type) SetSDIR_ARFC(value uint16) {
	volatile.StoreUint16(&o.SDIR.Reg, volatile.LoadUint16(&o.SDIR.Reg)&^(0xf0)|value<<4)
}
func (o *BUS_Type) GetSDIR_ARFC() uint16 {
	return (volatile.LoadUint16(&o.SDIR.Reg) & 0xf0) >> 4
}
func (o *BUS_Type) SetSDIR_ARFI(value uint16) {
	volatile.StoreUint16(&o.SDIR.Reg, volatile.LoadUint16(&o.SDIR.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetSDIR_ARFI() uint16 {
	return volatile.LoadUint16(&o.SDIR.Reg) & 0xf
}

// BUS.SDADR: SDRAM Address Register
func (o *BUS_Type) SetSDADR_MXC(value uint8) {
	volatile.StoreUint8(&o.SDADR.Reg, volatile.LoadUint8(&o.SDADR.Reg)&^(0x3)|value)
}
func (o *BUS_Type) GetSDADR_MXC() uint8 {
	return volatile.LoadUint8(&o.SDADR.Reg) & 0x3
}

// BUS.SDTR: SDRAM Timing Register
func (o *BUS_Type) SetSDTR_RAS(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0x70000)|value<<16)
}
func (o *BUS_Type) GetSDTR_RAS() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0x70000) >> 16
}
func (o *BUS_Type) SetSDTR_RCD(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0x3000)|value<<12)
}
func (o *BUS_Type) GetSDTR_RCD() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0x3000) >> 12
}
func (o *BUS_Type) SetSDTR_RP(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0xe00)|value<<9)
}
func (o *BUS_Type) GetSDTR_RP() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0xe00) >> 9
}
func (o *BUS_Type) SetSDTR_WR(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetSDTR_WR() uint32 {
	return (volatile.LoadUint32(&o.SDTR.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetSDTR_CL(value uint32) {
	volatile.StoreUint32(&o.SDTR.Reg, volatile.LoadUint32(&o.SDTR.Reg)&^(0x7)|value)
}
func (o *BUS_Type) GetSDTR_CL() uint32 {
	return volatile.LoadUint32(&o.SDTR.Reg) & 0x7
}

// BUS.SDMOD: SDRAM Mode Register
func (o *BUS_Type) SetSDMOD_MR(value uint16) {
	volatile.StoreUint16(&o.SDMOD.Reg, volatile.LoadUint16(&o.SDMOD.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetSDMOD_MR() uint16 {
	return volatile.LoadUint16(&o.SDMOD.Reg) & 0x7fff
}

// BUS.SDSR: SDRAM Status Register
func (o *BUS_Type) SetSDSR_SRFST(value uint8) {
	volatile.StoreUint8(&o.SDSR.Reg, volatile.LoadUint8(&o.SDSR.Reg)&^(0x10)|value<<4)
}
func (o *BUS_Type) GetSDSR_SRFST() uint8 {
	return (volatile.LoadUint8(&o.SDSR.Reg) & 0x10) >> 4
}
func (o *BUS_Type) SetSDSR_INIST(value uint8) {
	volatile.StoreUint8(&o.SDSR.Reg, volatile.LoadUint8(&o.SDSR.Reg)&^(0x8)|value<<3)
}
func (o *BUS_Type) GetSDSR_INIST() uint8 {
	return (volatile.LoadUint8(&o.SDSR.Reg) & 0x8) >> 3
}
func (o *BUS_Type) SetSDSR_MRSST(value uint8) {
	volatile.StoreUint8(&o.SDSR.Reg, volatile.LoadUint8(&o.SDSR.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetSDSR_MRSST() uint8 {
	return volatile.LoadUint8(&o.SDSR.Reg) & 0x1
}

// BUS.BUSMCNTM4I: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTM4I_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4I.Reg, volatile.LoadUint16(&o.BUSMCNTM4I.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTM4I_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTM4I.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTM4D: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTM4D_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTM4D.Reg, volatile.LoadUint16(&o.BUSMCNTM4D.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTM4D_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTM4D.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTSYS: Master Bus Control Register SYS
func (o *BUS_Type) SetBUSMCNTSYS_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTSYS_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTDMA: Master Bus Control Register DMA
func (o *BUS_Type) SetBUSMCNTDMA_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTDMA_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTEDM: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTEDM_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTEDM.Reg, volatile.LoadUint16(&o.BUSMCNTEDM.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTEDM_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTEDM.Reg) & 0x8000) >> 15
}

// BUS.BUSMCNTGPX: Master Bus Control Register %s
func (o *BUS_Type) SetBUSMCNTGPX_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTGPX.Reg, volatile.LoadUint16(&o.BUSMCNTGPX.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTGPX_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTGPX.Reg) & 0x8000) >> 15
}

// BUS.BUSSCNTFLI: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTFLI_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTFLI_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTFLI_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFLI_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTRAMH: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTRAMH_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAMH.Reg, volatile.LoadUint16(&o.BUSSCNTRAMH.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTRAMH_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAMH.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTRAMH_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAMH.Reg, volatile.LoadUint16(&o.BUSSCNTRAMH.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTRAMH_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAMH.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTMBIU: Slave Bus Control Register MBIU
func (o *BUS_Type) SetBUSSCNTMBIU_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTMBIU.Reg, volatile.LoadUint16(&o.BUSSCNTMBIU.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTMBIU_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTMBIU.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTMBIU_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTMBIU.Reg, volatile.LoadUint16(&o.BUSSCNTMBIU.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTMBIU_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTMBIU.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTRAM0: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTRAM0_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTRAM0_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTRAM0_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTRAM0_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTRAM1: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTRAM1_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM1.Reg, volatile.LoadUint16(&o.BUSSCNTRAM1.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTRAM1_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM1.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTRAM1_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM1.Reg, volatile.LoadUint16(&o.BUSSCNTRAM1.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTRAM1_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM1.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP0B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP0B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP0B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP0B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP0B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP2B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP2B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP2B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP2B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP2B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP3B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP3B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP3B.Reg, volatile.LoadUint16(&o.BUSSCNTP3B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP3B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP3B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP3B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP3B.Reg, volatile.LoadUint16(&o.BUSSCNTP3B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP3B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP3B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP4B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP4B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP4B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP4B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP4B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP6B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP6B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP6B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP6B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP6B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTP7B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP7B_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP7B.Reg, volatile.LoadUint16(&o.BUSSCNTP7B.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTP7B_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP7B.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTP7B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP7B.Reg, volatile.LoadUint16(&o.BUSSCNTP7B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP7B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP7B.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTFBU: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTFBU_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTFBU_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTFBU_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFBU_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTEXT: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTEXT_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT.Reg, volatile.LoadUint16(&o.BUSSCNTEXT.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTEXT_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTEXT_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT.Reg, volatile.LoadUint16(&o.BUSSCNTEXT.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTEXT_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTEXT2: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTEXT2_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT2.Reg, volatile.LoadUint16(&o.BUSSCNTEXT2.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTEXT2_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT2.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTEXT2_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTEXT2.Reg, volatile.LoadUint16(&o.BUSSCNTEXT2.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTEXT2_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTEXT2.Reg) & 0x30) >> 4
}

// BUS.BUSSCNTGPX: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTGPX_EWRES(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTGPX.Reg, volatile.LoadUint16(&o.BUSSCNTGPX.Reg)&^(0x100)|value<<8)
}
func (o *BUS_Type) GetBUSSCNTGPX_EWRES() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTGPX.Reg) & 0x100) >> 8
}
func (o *BUS_Type) SetBUSSCNTGPX_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTGPX.Reg, volatile.LoadUint16(&o.BUSSCNTGPX.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTGPX_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTGPX.Reg) & 0x30) >> 4
}

// BUS.BUS1ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS1ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS1ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS1ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS1ERRADD.Reg)
}

// BUS.BUS1ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS1ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS1ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS1ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS1ERRSTAT.Reg, volatile.LoadUint8(&o.BUS1ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS1ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS1ERRSTAT.Reg) & 0x1
}

// BUS.BUS2ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS2ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS2ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS2ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS2ERRADD.Reg)
}

// BUS.BUS2ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS2ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS2ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS2ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS2ERRSTAT.Reg, volatile.LoadUint8(&o.BUS2ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS2ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS2ERRSTAT.Reg) & 0x1
}

// BUS.BUS3ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS3ERRADD.Reg)
}

// BUS.BUS3ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS3ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS3ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x1
}

// BUS.BUS4ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS4ERRADD.Reg)
}

// BUS.BUS4ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS4ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS4ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x1
}

// BUS.BUS5ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS5ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS5ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS5ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS5ERRADD.Reg)
}

// BUS.BUS5ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS5ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS5ERRSTAT.Reg, volatile.LoadUint8(&o.BUS5ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS5ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS5ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS5ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS5ERRSTAT.Reg, volatile.LoadUint8(&o.BUS5ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS5ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS5ERRSTAT.Reg) & 0x1
}

// BUS.BUS6ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS6ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS6ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS6ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS6ERRADD.Reg)
}

// BUS.BUS6ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS6ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS6ERRSTAT.Reg, volatile.LoadUint8(&o.BUS6ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS6ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS6ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS6ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS6ERRSTAT.Reg, volatile.LoadUint8(&o.BUS6ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS6ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS6ERRSTAT.Reg) & 0x1
}

// BUS.BUS7ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS7ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS7ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS7ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS7ERRADD.Reg)
}

// BUS.BUS7ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS7ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS7ERRSTAT.Reg, volatile.LoadUint8(&o.BUS7ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS7ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS7ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS7ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS7ERRSTAT.Reg, volatile.LoadUint8(&o.BUS7ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS7ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS7ERRSTAT.Reg) & 0x1
}

// BUS.BUS8ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS8ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS8ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS8ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS8ERRADD.Reg)
}

// BUS.BUS8ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS8ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS8ERRSTAT.Reg, volatile.LoadUint8(&o.BUS8ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS8ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS8ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS8ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS8ERRSTAT.Reg, volatile.LoadUint8(&o.BUS8ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS8ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS8ERRSTAT.Reg) & 0x1
}

// BUS.BUS9ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS9ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS9ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS9ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS9ERRADD.Reg)
}

// BUS.BUS9ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS9ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS9ERRSTAT.Reg, volatile.LoadUint8(&o.BUS9ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS9ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS9ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS9ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS9ERRSTAT.Reg, volatile.LoadUint8(&o.BUS9ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS9ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS9ERRSTAT.Reg) & 0x1
}

// BUS.BUS10ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS10ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS10ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS10ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS10ERRADD.Reg)
}

// BUS.BUS10ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS10ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS10ERRSTAT.Reg, volatile.LoadUint8(&o.BUS10ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS10ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS10ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS10ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS10ERRSTAT.Reg, volatile.LoadUint8(&o.BUS10ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS10ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS10ERRSTAT.Reg) & 0x1
}

// BUS.BUS11ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS11ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS11ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS11ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS11ERRADD.Reg)
}

// BUS.BUS11ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS11ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS11ERRSTAT.Reg, volatile.LoadUint8(&o.BUS11ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS11ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS11ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS11ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS11ERRSTAT.Reg, volatile.LoadUint8(&o.BUS11ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS11ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS11ERRSTAT.Reg) & 0x1
}

// 12-bit D/A converter
type DAC12_Type struct {
	DADR0   volatile.Register16 // 0x0
	DADR1   volatile.Register16 // 0x2
	DACR    volatile.Register8  // 0x4
	DADPR   volatile.Register8  // 0x5
	DAADSCR volatile.Register8  // 0x6
	_       byte
	DAAMPCR volatile.Register8 // 0x8
	_       [4115]byte
	DAASWCR volatile.Register8 // 0x101C
}

// DAC12.DADR0: D/A Data Register %s
func (o *DAC12_Type) SetDADR0(value uint16) {
	volatile.StoreUint16(&o.DADR0.Reg, value)
}
func (o *DAC12_Type) GetDADR0() uint16 {
	return volatile.LoadUint16(&o.DADR0.Reg)
}

// DAC12.DADR1: D/A Data Register %s
func (o *DAC12_Type) SetDADR1(value uint16) {
	volatile.StoreUint16(&o.DADR1.Reg, value)
}
func (o *DAC12_Type) GetDADR1() uint16 {
	return volatile.LoadUint16(&o.DADR1.Reg)
}

// DAC12.DACR: D/A Control Register
func (o *DAC12_Type) SetDACR_DAOE1(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDACR_DAOE1() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDACR_DAOE0(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDACR_DAOE0() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x40) >> 6
}
func (o *DAC12_Type) SetDACR_DAE(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x20)|value<<5)
}
func (o *DAC12_Type) GetDACR_DAE() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x20) >> 5
}

// DAC12.DADPR: DADRm Format Select Register
func (o *DAC12_Type) SetDADPR_DPSEL(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDADPR_DPSEL() uint8 {
	return (volatile.LoadUint8(&o.DADPR.Reg) & 0x80) >> 7
}

// DAC12.DAADSCR: D/A-A/D Synchronous Start Control Register
func (o *DAC12_Type) SetDAADSCR_DAADST(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAADSCR_DAADST() uint8 {
	return (volatile.LoadUint8(&o.DAADSCR.Reg) & 0x80) >> 7
}

// DAC12.DAAMPCR: D/A Output Amplifier Control Register
func (o *DAC12_Type) SetDAAMPCR_DAAMP1(value uint8) {
	volatile.StoreUint8(&o.DAAMPCR.Reg, volatile.LoadUint8(&o.DAAMPCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAAMPCR_DAAMP1() uint8 {
	return (volatile.LoadUint8(&o.DAAMPCR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDAAMPCR_DAAMP0(value uint8) {
	volatile.StoreUint8(&o.DAAMPCR.Reg, volatile.LoadUint8(&o.DAAMPCR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDAAMPCR_DAAMP0() uint8 {
	return (volatile.LoadUint8(&o.DAAMPCR.Reg) & 0x40) >> 6
}

// DAC12.DAASWCR: D/A Amplifier Stabilization Wait Control Register
func (o *DAC12_Type) SetDAASWCR_DAASW1(value uint8) {
	volatile.StoreUint8(&o.DAASWCR.Reg, volatile.LoadUint8(&o.DAASWCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAASWCR_DAASW1() uint8 {
	return (volatile.LoadUint8(&o.DAASWCR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDAASWCR_DAASW0(value uint8) {
	volatile.StoreUint8(&o.DAASWCR.Reg, volatile.LoadUint8(&o.DAASWCR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDAASWCR_DAASW0() uint8 {
	return (volatile.LoadUint8(&o.DAASWCR.Reg) & 0x40) >> 6
}

// ADC-DAC Interface
type AMI_Type struct {
	_       [192]byte
	DAADUSR volatile.Register8 // 0xC0
}

// AMI.DAADUSR: D/A A/D Synchronous Unit Select Register
func (o *AMI_Type) SetDAADUSR_AMADSEL1(value uint8) {
	volatile.StoreUint8(&o.DAADUSR.Reg, volatile.LoadUint8(&o.DAADUSR.Reg)&^(0x2)|value<<1)
}
func (o *AMI_Type) GetDAADUSR_AMADSEL1() uint8 {
	return (volatile.LoadUint8(&o.DAADUSR.Reg) & 0x2) >> 1
}

// Port Output Enable Module for GPT
type POEG_Type struct {
	POEGGA volatile.Register32 // 0x0
	_      [252]byte
	POEGGB volatile.Register32 // 0x100
	_      [252]byte
	POEGGC volatile.Register32 // 0x200
	_      [252]byte
	POEGGD volatile.Register32 // 0x300
}

// POEG.POEGGA: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGA_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGA_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGA_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGA_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGA_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGA_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGA_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGA_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGA_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGA_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGA_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGA_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGA_CDRE3(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x800)|value<<11)
}
func (o *POEG_Type) GetPOEGGA_CDRE3() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x800) >> 11
}
func (o *POEG_Type) SetPOEGGA_CDRE2(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x400)|value<<10)
}
func (o *POEG_Type) GetPOEGGA_CDRE2() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x400) >> 10
}
func (o *POEG_Type) SetPOEGGA_CDRE1(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x200)|value<<9)
}
func (o *POEG_Type) GetPOEGGA_CDRE1() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x200) >> 9
}
func (o *POEG_Type) SetPOEGGA_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGA_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGA_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGA_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGA_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGA_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGA_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGA_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGA_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGA_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGA_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGA_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGA_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGA_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGA_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGA_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGA.Reg) & 0x1
}

// POEG.POEGGB: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGB_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGB_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGB_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGB_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGB_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGB_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGB_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGB_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGB_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGB_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGB_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGB_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGB_CDRE3(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x800)|value<<11)
}
func (o *POEG_Type) GetPOEGGB_CDRE3() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x800) >> 11
}
func (o *POEG_Type) SetPOEGGB_CDRE2(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x400)|value<<10)
}
func (o *POEG_Type) GetPOEGGB_CDRE2() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x400) >> 10
}
func (o *POEG_Type) SetPOEGGB_CDRE1(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x200)|value<<9)
}
func (o *POEG_Type) GetPOEGGB_CDRE1() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x200) >> 9
}
func (o *POEG_Type) SetPOEGGB_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGB_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGB_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGB_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGB_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGB_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGB_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGB_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGB_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGB_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGB_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGB_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGB_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGB_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGB_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGB_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGB.Reg) & 0x1
}

// POEG.POEGGC: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGC_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGC_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGC_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGC_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGC_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGC_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGC_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGC_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGC_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGC_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGC_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGC_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGC_CDRE3(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x800)|value<<11)
}
func (o *POEG_Type) GetPOEGGC_CDRE3() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x800) >> 11
}
func (o *POEG_Type) SetPOEGGC_CDRE2(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x400)|value<<10)
}
func (o *POEG_Type) GetPOEGGC_CDRE2() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x400) >> 10
}
func (o *POEG_Type) SetPOEGGC_CDRE1(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x200)|value<<9)
}
func (o *POEG_Type) GetPOEGGC_CDRE1() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x200) >> 9
}
func (o *POEG_Type) SetPOEGGC_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGC_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGC_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGC_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGC_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGC_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGC_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGC_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGC_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGC_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGC_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGC_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGC_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGC_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGC.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGC_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGC.Reg, volatile.LoadUint32(&o.POEGGC.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGC_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGC.Reg) & 0x1
}

// POEG.POEGGD: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGD_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGD_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGD_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGD_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGD_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGD_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGD_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGD_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGD_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGD_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGD_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGD_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGD_CDRE3(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x800)|value<<11)
}
func (o *POEG_Type) GetPOEGGD_CDRE3() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x800) >> 11
}
func (o *POEG_Type) SetPOEGGD_CDRE2(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x400)|value<<10)
}
func (o *POEG_Type) GetPOEGGD_CDRE2() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x400) >> 10
}
func (o *POEG_Type) SetPOEGGD_CDRE1(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x200)|value<<9)
}
func (o *POEG_Type) GetPOEGGD_CDRE1() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x200) >> 9
}
func (o *POEG_Type) SetPOEGGD_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGD_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGD_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGD_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGD_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGD_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGD_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGD_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGD_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGD_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGD_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGD_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGD_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGD_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGD.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGD_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGD.Reg, volatile.LoadUint32(&o.POEGGD.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGD_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGD.Reg) & 0x1
}

// Infrared Data Association
type IRDA_Type struct {
	IRCR volatile.Register8 // 0x0
}

// IRDA.IRCR: IrDA Control Register
func (o *IRDA_Type) SetIRCR_IRE(value uint8) {
	volatile.StoreUint8(&o.IRCR.Reg, volatile.LoadUint8(&o.IRCR.Reg)&^(0x80)|value<<7)
}
func (o *IRDA_Type) GetIRCR_IRE() uint8 {
	return (volatile.LoadUint8(&o.IRCR.Reg) & 0x80) >> 7
}
func (o *IRDA_Type) SetIRCR_IRTXINV(value uint8) {
	volatile.StoreUint8(&o.IRCR.Reg, volatile.LoadUint8(&o.IRCR.Reg)&^(0x8)|value<<3)
}
func (o *IRDA_Type) GetIRCR_IRTXINV() uint8 {
	return (volatile.LoadUint8(&o.IRCR.Reg) & 0x8) >> 3
}
func (o *IRDA_Type) SetIRCR_IRRXINV(value uint8) {
	volatile.StoreUint8(&o.IRCR.Reg, volatile.LoadUint8(&o.IRCR.Reg)&^(0x4)|value<<2)
}
func (o *IRDA_Type) GetIRCR_IRRXINV() uint8 {
	return (volatile.LoadUint8(&o.IRCR.Reg) & 0x4) >> 2
}

// CAN0 Module
type CAN0_Type struct {
	_       [512]byte
	MB0_ID  volatile.Register32    // 0x200
	MB0_DL  volatile.Register16    // 0x204
	MB0_D0  volatile.Register8     // 0x206
	MB0_D1  volatile.Register8     // 0x207
	MB0_D2  volatile.Register8     // 0x208
	MB0_D3  volatile.Register8     // 0x209
	MB0_D4  volatile.Register8     // 0x20A
	MB0_D5  volatile.Register8     // 0x20B
	MB0_D6  volatile.Register8     // 0x20C
	MB0_D7  volatile.Register8     // 0x20D
	MB0_TS  volatile.Register16    // 0x20E
	MB1_ID  volatile.Register32    // 0x210
	MB1_DL  volatile.Register16    // 0x214
	MB1_D0  volatile.Register8     // 0x216
	MB1_D1  volatile.Register8     // 0x217
	MB1_D2  volatile.Register8     // 0x218
	MB1_D3  volatile.Register8     // 0x219
	MB1_D4  volatile.Register8     // 0x21A
	MB1_D5  volatile.Register8     // 0x21B
	MB1_D6  volatile.Register8     // 0x21C
	MB1_D7  volatile.Register8     // 0x21D
	MB1_TS  volatile.Register16    // 0x21E
	MB2_ID  volatile.Register32    // 0x220
	MB2_DL  volatile.Register16    // 0x224
	MB2_D0  volatile.Register8     // 0x226
	MB2_D1  volatile.Register8     // 0x227
	MB2_D2  volatile.Register8     // 0x228
	MB2_D3  volatile.Register8     // 0x229
	MB2_D4  volatile.Register8     // 0x22A
	MB2_D5  volatile.Register8     // 0x22B
	MB2_D6  volatile.Register8     // 0x22C
	MB2_D7  volatile.Register8     // 0x22D
	MB2_TS  volatile.Register16    // 0x22E
	MB3_ID  volatile.Register32    // 0x230
	MB3_DL  volatile.Register16    // 0x234
	MB3_D0  volatile.Register8     // 0x236
	MB3_D1  volatile.Register8     // 0x237
	MB3_D2  volatile.Register8     // 0x238
	MB3_D3  volatile.Register8     // 0x239
	MB3_D4  volatile.Register8     // 0x23A
	MB3_D5  volatile.Register8     // 0x23B
	MB3_D6  volatile.Register8     // 0x23C
	MB3_D7  volatile.Register8     // 0x23D
	MB3_TS  volatile.Register16    // 0x23E
	MB4_ID  volatile.Register32    // 0x240
	MB4_DL  volatile.Register16    // 0x244
	MB4_D0  volatile.Register8     // 0x246
	MB4_D1  volatile.Register8     // 0x247
	MB4_D2  volatile.Register8     // 0x248
	MB4_D3  volatile.Register8     // 0x249
	MB4_D4  volatile.Register8     // 0x24A
	MB4_D5  volatile.Register8     // 0x24B
	MB4_D6  volatile.Register8     // 0x24C
	MB4_D7  volatile.Register8     // 0x24D
	MB4_TS  volatile.Register16    // 0x24E
	MB5_ID  volatile.Register32    // 0x250
	MB5_DL  volatile.Register16    // 0x254
	MB5_D0  volatile.Register8     // 0x256
	MB5_D1  volatile.Register8     // 0x257
	MB5_D2  volatile.Register8     // 0x258
	MB5_D3  volatile.Register8     // 0x259
	MB5_D4  volatile.Register8     // 0x25A
	MB5_D5  volatile.Register8     // 0x25B
	MB5_D6  volatile.Register8     // 0x25C
	MB5_D7  volatile.Register8     // 0x25D
	MB5_TS  volatile.Register16    // 0x25E
	MB6_ID  volatile.Register32    // 0x260
	MB6_DL  volatile.Register16    // 0x264
	MB6_D0  volatile.Register8     // 0x266
	MB6_D1  volatile.Register8     // 0x267
	MB6_D2  volatile.Register8     // 0x268
	MB6_D3  volatile.Register8     // 0x269
	MB6_D4  volatile.Register8     // 0x26A
	MB6_D5  volatile.Register8     // 0x26B
	MB6_D6  volatile.Register8     // 0x26C
	MB6_D7  volatile.Register8     // 0x26D
	MB6_TS  volatile.Register16    // 0x26E
	MB7_ID  volatile.Register32    // 0x270
	MB7_DL  volatile.Register16    // 0x274
	MB7_D0  volatile.Register8     // 0x276
	MB7_D1  volatile.Register8     // 0x277
	MB7_D2  volatile.Register8     // 0x278
	MB7_D3  volatile.Register8     // 0x279
	MB7_D4  volatile.Register8     // 0x27A
	MB7_D5  volatile.Register8     // 0x27B
	MB7_D6  volatile.Register8     // 0x27C
	MB7_D7  volatile.Register8     // 0x27D
	MB7_TS  volatile.Register16    // 0x27E
	MB8_ID  volatile.Register32    // 0x280
	MB8_DL  volatile.Register16    // 0x284
	MB8_D0  volatile.Register8     // 0x286
	MB8_D1  volatile.Register8     // 0x287
	MB8_D2  volatile.Register8     // 0x288
	MB8_D3  volatile.Register8     // 0x289
	MB8_D4  volatile.Register8     // 0x28A
	MB8_D5  volatile.Register8     // 0x28B
	MB8_D6  volatile.Register8     // 0x28C
	MB8_D7  volatile.Register8     // 0x28D
	MB8_TS  volatile.Register16    // 0x28E
	MB9_ID  volatile.Register32    // 0x290
	MB9_DL  volatile.Register16    // 0x294
	MB9_D0  volatile.Register8     // 0x296
	MB9_D1  volatile.Register8     // 0x297
	MB9_D2  volatile.Register8     // 0x298
	MB9_D3  volatile.Register8     // 0x299
	MB9_D4  volatile.Register8     // 0x29A
	MB9_D5  volatile.Register8     // 0x29B
	MB9_D6  volatile.Register8     // 0x29C
	MB9_D7  volatile.Register8     // 0x29D
	MB9_TS  volatile.Register16    // 0x29E
	MB10_ID volatile.Register32    // 0x2A0
	MB10_DL volatile.Register16    // 0x2A4
	MB10_D0 volatile.Register8     // 0x2A6
	MB10_D1 volatile.Register8     // 0x2A7
	MB10_D2 volatile.Register8     // 0x2A8
	MB10_D3 volatile.Register8     // 0x2A9
	MB10_D4 volatile.Register8     // 0x2AA
	MB10_D5 volatile.Register8     // 0x2AB
	MB10_D6 volatile.Register8     // 0x2AC
	MB10_D7 volatile.Register8     // 0x2AD
	MB10_TS volatile.Register16    // 0x2AE
	MB11_ID volatile.Register32    // 0x2B0
	MB11_DL volatile.Register16    // 0x2B4
	MB11_D0 volatile.Register8     // 0x2B6
	MB11_D1 volatile.Register8     // 0x2B7
	MB11_D2 volatile.Register8     // 0x2B8
	MB11_D3 volatile.Register8     // 0x2B9
	MB11_D4 volatile.Register8     // 0x2BA
	MB11_D5 volatile.Register8     // 0x2BB
	MB11_D6 volatile.Register8     // 0x2BC
	MB11_D7 volatile.Register8     // 0x2BD
	MB11_TS volatile.Register16    // 0x2BE
	MB12_ID volatile.Register32    // 0x2C0
	MB12_DL volatile.Register16    // 0x2C4
	MB12_D0 volatile.Register8     // 0x2C6
	MB12_D1 volatile.Register8     // 0x2C7
	MB12_D2 volatile.Register8     // 0x2C8
	MB12_D3 volatile.Register8     // 0x2C9
	MB12_D4 volatile.Register8     // 0x2CA
	MB12_D5 volatile.Register8     // 0x2CB
	MB12_D6 volatile.Register8     // 0x2CC
	MB12_D7 volatile.Register8     // 0x2CD
	MB12_TS volatile.Register16    // 0x2CE
	MB13_ID volatile.Register32    // 0x2D0
	MB13_DL volatile.Register16    // 0x2D4
	MB13_D0 volatile.Register8     // 0x2D6
	MB13_D1 volatile.Register8     // 0x2D7
	MB13_D2 volatile.Register8     // 0x2D8
	MB13_D3 volatile.Register8     // 0x2D9
	MB13_D4 volatile.Register8     // 0x2DA
	MB13_D5 volatile.Register8     // 0x2DB
	MB13_D6 volatile.Register8     // 0x2DC
	MB13_D7 volatile.Register8     // 0x2DD
	MB13_TS volatile.Register16    // 0x2DE
	MB14_ID volatile.Register32    // 0x2E0
	MB14_DL volatile.Register16    // 0x2E4
	MB14_D0 volatile.Register8     // 0x2E6
	MB14_D1 volatile.Register8     // 0x2E7
	MB14_D2 volatile.Register8     // 0x2E8
	MB14_D3 volatile.Register8     // 0x2E9
	MB14_D4 volatile.Register8     // 0x2EA
	MB14_D5 volatile.Register8     // 0x2EB
	MB14_D6 volatile.Register8     // 0x2EC
	MB14_D7 volatile.Register8     // 0x2ED
	MB14_TS volatile.Register16    // 0x2EE
	MB15_ID volatile.Register32    // 0x2F0
	MB15_DL volatile.Register16    // 0x2F4
	MB15_D0 volatile.Register8     // 0x2F6
	MB15_D1 volatile.Register8     // 0x2F7
	MB15_D2 volatile.Register8     // 0x2F8
	MB15_D3 volatile.Register8     // 0x2F9
	MB15_D4 volatile.Register8     // 0x2FA
	MB15_D5 volatile.Register8     // 0x2FB
	MB15_D6 volatile.Register8     // 0x2FC
	MB15_D7 volatile.Register8     // 0x2FD
	MB15_TS volatile.Register16    // 0x2FE
	MB16_ID volatile.Register32    // 0x300
	MB16_DL volatile.Register16    // 0x304
	MB16_D0 volatile.Register8     // 0x306
	MB16_D1 volatile.Register8     // 0x307
	MB16_D2 volatile.Register8     // 0x308
	MB16_D3 volatile.Register8     // 0x309
	MB16_D4 volatile.Register8     // 0x30A
	MB16_D5 volatile.Register8     // 0x30B
	MB16_D6 volatile.Register8     // 0x30C
	MB16_D7 volatile.Register8     // 0x30D
	MB16_TS volatile.Register16    // 0x30E
	MB17_ID volatile.Register32    // 0x310
	MB17_DL volatile.Register16    // 0x314
	MB17_D0 volatile.Register8     // 0x316
	MB17_D1 volatile.Register8     // 0x317
	MB17_D2 volatile.Register8     // 0x318
	MB17_D3 volatile.Register8     // 0x319
	MB17_D4 volatile.Register8     // 0x31A
	MB17_D5 volatile.Register8     // 0x31B
	MB17_D6 volatile.Register8     // 0x31C
	MB17_D7 volatile.Register8     // 0x31D
	MB17_TS volatile.Register16    // 0x31E
	MB18_ID volatile.Register32    // 0x320
	MB18_DL volatile.Register16    // 0x324
	MB18_D0 volatile.Register8     // 0x326
	MB18_D1 volatile.Register8     // 0x327
	MB18_D2 volatile.Register8     // 0x328
	MB18_D3 volatile.Register8     // 0x329
	MB18_D4 volatile.Register8     // 0x32A
	MB18_D5 volatile.Register8     // 0x32B
	MB18_D6 volatile.Register8     // 0x32C
	MB18_D7 volatile.Register8     // 0x32D
	MB18_TS volatile.Register16    // 0x32E
	MB19_ID volatile.Register32    // 0x330
	MB19_DL volatile.Register16    // 0x334
	MB19_D0 volatile.Register8     // 0x336
	MB19_D1 volatile.Register8     // 0x337
	MB19_D2 volatile.Register8     // 0x338
	MB19_D3 volatile.Register8     // 0x339
	MB19_D4 volatile.Register8     // 0x33A
	MB19_D5 volatile.Register8     // 0x33B
	MB19_D6 volatile.Register8     // 0x33C
	MB19_D7 volatile.Register8     // 0x33D
	MB19_TS volatile.Register16    // 0x33E
	MB20_ID volatile.Register32    // 0x340
	MB20_DL volatile.Register16    // 0x344
	MB20_D0 volatile.Register8     // 0x346
	MB20_D1 volatile.Register8     // 0x347
	MB20_D2 volatile.Register8     // 0x348
	MB20_D3 volatile.Register8     // 0x349
	MB20_D4 volatile.Register8     // 0x34A
	MB20_D5 volatile.Register8     // 0x34B
	MB20_D6 volatile.Register8     // 0x34C
	MB20_D7 volatile.Register8     // 0x34D
	MB20_TS volatile.Register16    // 0x34E
	MB21_ID volatile.Register32    // 0x350
	MB21_DL volatile.Register16    // 0x354
	MB21_D0 volatile.Register8     // 0x356
	MB21_D1 volatile.Register8     // 0x357
	MB21_D2 volatile.Register8     // 0x358
	MB21_D3 volatile.Register8     // 0x359
	MB21_D4 volatile.Register8     // 0x35A
	MB21_D5 volatile.Register8     // 0x35B
	MB21_D6 volatile.Register8     // 0x35C
	MB21_D7 volatile.Register8     // 0x35D
	MB21_TS volatile.Register16    // 0x35E
	MB22_ID volatile.Register32    // 0x360
	MB22_DL volatile.Register16    // 0x364
	MB22_D0 volatile.Register8     // 0x366
	MB22_D1 volatile.Register8     // 0x367
	MB22_D2 volatile.Register8     // 0x368
	MB22_D3 volatile.Register8     // 0x369
	MB22_D4 volatile.Register8     // 0x36A
	MB22_D5 volatile.Register8     // 0x36B
	MB22_D6 volatile.Register8     // 0x36C
	MB22_D7 volatile.Register8     // 0x36D
	MB22_TS volatile.Register16    // 0x36E
	MB23_ID volatile.Register32    // 0x370
	MB23_DL volatile.Register16    // 0x374
	MB23_D0 volatile.Register8     // 0x376
	MB23_D1 volatile.Register8     // 0x377
	MB23_D2 volatile.Register8     // 0x378
	MB23_D3 volatile.Register8     // 0x379
	MB23_D4 volatile.Register8     // 0x37A
	MB23_D5 volatile.Register8     // 0x37B
	MB23_D6 volatile.Register8     // 0x37C
	MB23_D7 volatile.Register8     // 0x37D
	MB23_TS volatile.Register16    // 0x37E
	MB24_ID volatile.Register32    // 0x380
	MB24_DL volatile.Register16    // 0x384
	MB24_D0 volatile.Register8     // 0x386
	MB24_D1 volatile.Register8     // 0x387
	MB24_D2 volatile.Register8     // 0x388
	MB24_D3 volatile.Register8     // 0x389
	MB24_D4 volatile.Register8     // 0x38A
	MB24_D5 volatile.Register8     // 0x38B
	MB24_D6 volatile.Register8     // 0x38C
	MB24_D7 volatile.Register8     // 0x38D
	MB24_TS volatile.Register16    // 0x38E
	MB25_ID volatile.Register32    // 0x390
	MB25_DL volatile.Register16    // 0x394
	MB25_D0 volatile.Register8     // 0x396
	MB25_D1 volatile.Register8     // 0x397
	MB25_D2 volatile.Register8     // 0x398
	MB25_D3 volatile.Register8     // 0x399
	MB25_D4 volatile.Register8     // 0x39A
	MB25_D5 volatile.Register8     // 0x39B
	MB25_D6 volatile.Register8     // 0x39C
	MB25_D7 volatile.Register8     // 0x39D
	MB25_TS volatile.Register16    // 0x39E
	MB26_ID volatile.Register32    // 0x3A0
	MB26_DL volatile.Register16    // 0x3A4
	MB26_D0 volatile.Register8     // 0x3A6
	MB26_D1 volatile.Register8     // 0x3A7
	MB26_D2 volatile.Register8     // 0x3A8
	MB26_D3 volatile.Register8     // 0x3A9
	MB26_D4 volatile.Register8     // 0x3AA
	MB26_D5 volatile.Register8     // 0x3AB
	MB26_D6 volatile.Register8     // 0x3AC
	MB26_D7 volatile.Register8     // 0x3AD
	MB26_TS volatile.Register16    // 0x3AE
	MB27_ID volatile.Register32    // 0x3B0
	MB27_DL volatile.Register16    // 0x3B4
	MB27_D0 volatile.Register8     // 0x3B6
	MB27_D1 volatile.Register8     // 0x3B7
	MB27_D2 volatile.Register8     // 0x3B8
	MB27_D3 volatile.Register8     // 0x3B9
	MB27_D4 volatile.Register8     // 0x3BA
	MB27_D5 volatile.Register8     // 0x3BB
	MB27_D6 volatile.Register8     // 0x3BC
	MB27_D7 volatile.Register8     // 0x3BD
	MB27_TS volatile.Register16    // 0x3BE
	MB28_ID volatile.Register32    // 0x3C0
	MB28_DL volatile.Register16    // 0x3C4
	MB28_D0 volatile.Register8     // 0x3C6
	MB28_D1 volatile.Register8     // 0x3C7
	MB28_D2 volatile.Register8     // 0x3C8
	MB28_D3 volatile.Register8     // 0x3C9
	MB28_D4 volatile.Register8     // 0x3CA
	MB28_D5 volatile.Register8     // 0x3CB
	MB28_D6 volatile.Register8     // 0x3CC
	MB28_D7 volatile.Register8     // 0x3CD
	MB28_TS volatile.Register16    // 0x3CE
	MB29_ID volatile.Register32    // 0x3D0
	MB29_DL volatile.Register16    // 0x3D4
	MB29_D0 volatile.Register8     // 0x3D6
	MB29_D1 volatile.Register8     // 0x3D7
	MB29_D2 volatile.Register8     // 0x3D8
	MB29_D3 volatile.Register8     // 0x3D9
	MB29_D4 volatile.Register8     // 0x3DA
	MB29_D5 volatile.Register8     // 0x3DB
	MB29_D6 volatile.Register8     // 0x3DC
	MB29_D7 volatile.Register8     // 0x3DD
	MB29_TS volatile.Register16    // 0x3DE
	MB30_ID volatile.Register32    // 0x3E0
	MB30_DL volatile.Register16    // 0x3E4
	MB30_D0 volatile.Register8     // 0x3E6
	MB30_D1 volatile.Register8     // 0x3E7
	MB30_D2 volatile.Register8     // 0x3E8
	MB30_D3 volatile.Register8     // 0x3E9
	MB30_D4 volatile.Register8     // 0x3EA
	MB30_D5 volatile.Register8     // 0x3EB
	MB30_D6 volatile.Register8     // 0x3EC
	MB30_D7 volatile.Register8     // 0x3ED
	MB30_TS volatile.Register16    // 0x3EE
	MB31_ID volatile.Register32    // 0x3F0
	MB31_DL volatile.Register16    // 0x3F4
	MB31_D0 volatile.Register8     // 0x3F6
	MB31_D1 volatile.Register8     // 0x3F7
	MB31_D2 volatile.Register8     // 0x3F8
	MB31_D3 volatile.Register8     // 0x3F9
	MB31_D4 volatile.Register8     // 0x3FA
	MB31_D5 volatile.Register8     // 0x3FB
	MB31_D6 volatile.Register8     // 0x3FC
	MB31_D7 volatile.Register8     // 0x3FD
	MB31_TS volatile.Register16    // 0x3FE
	MKR     [8]volatile.Register32 // 0x400
	FIDCR0  volatile.Register32    // 0x420
	FIDCR1  volatile.Register32    // 0x424
	MKIVLR  volatile.Register32    // 0x428
	MIER    volatile.Register32    // 0x42C
	_       [1008]byte
	MCTL_TX [32]volatile.Register8 // 0x820
	CTLR    volatile.Register16    // 0x840
	STR     volatile.Register16    // 0x842
	BCR     volatile.Register32    // 0x844
	RFCR    volatile.Register8     // 0x848
	RFPCR   volatile.Register8     // 0x849
	TFCR    volatile.Register8     // 0x84A
	TFPCR   volatile.Register8     // 0x84B
	EIER    volatile.Register8     // 0x84C
	EIFR    volatile.Register8     // 0x84D
	RECR    volatile.Register8     // 0x84E
	TECR    volatile.Register8     // 0x84F
	ECSR    volatile.Register8     // 0x850
	CSSR    volatile.Register8     // 0x851
	MSSR    volatile.Register8     // 0x852
	MSMR    volatile.Register8     // 0x853
	TSR     volatile.Register16    // 0x854
	AFSR    volatile.Register16    // 0x856
	TCR     volatile.Register8     // 0x858
}

// CAN0.MB0_ID: Mailbox Register
func (o *CAN0_Type) SetMB0_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB0_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB0_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB0_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB0_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB0_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB0_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB0_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB0_ID.Reg) & 0x3ffff
}

// CAN0.MB0_DL: Mailbox Register
func (o *CAN0_Type) SetMB0_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB0_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB0_DL.Reg) & 0xf
}

// CAN0.MB0_D0: Mailbox Register
func (o *CAN0_Type) SetMB0_D0(value uint8) {
	volatile.StoreUint8(&o.MB0_D0.Reg, value)
}
func (o *CAN0_Type) GetMB0_D0() uint8 {
	return volatile.LoadUint8(&o.MB0_D0.Reg)
}

// CAN0.MB0_D1: Mailbox Register
func (o *CAN0_Type) SetMB0_D1(value uint8) {
	volatile.StoreUint8(&o.MB0_D1.Reg, value)
}
func (o *CAN0_Type) GetMB0_D1() uint8 {
	return volatile.LoadUint8(&o.MB0_D1.Reg)
}

// CAN0.MB0_D2: Mailbox Register
func (o *CAN0_Type) SetMB0_D2(value uint8) {
	volatile.StoreUint8(&o.MB0_D2.Reg, value)
}
func (o *CAN0_Type) GetMB0_D2() uint8 {
	return volatile.LoadUint8(&o.MB0_D2.Reg)
}

// CAN0.MB0_D3: Mailbox Register
func (o *CAN0_Type) SetMB0_D3(value uint8) {
	volatile.StoreUint8(&o.MB0_D3.Reg, value)
}
func (o *CAN0_Type) GetMB0_D3() uint8 {
	return volatile.LoadUint8(&o.MB0_D3.Reg)
}

// CAN0.MB0_D4: Mailbox Register
func (o *CAN0_Type) SetMB0_D4(value uint8) {
	volatile.StoreUint8(&o.MB0_D4.Reg, value)
}
func (o *CAN0_Type) GetMB0_D4() uint8 {
	return volatile.LoadUint8(&o.MB0_D4.Reg)
}

// CAN0.MB0_D5: Mailbox Register
func (o *CAN0_Type) SetMB0_D5(value uint8) {
	volatile.StoreUint8(&o.MB0_D5.Reg, value)
}
func (o *CAN0_Type) GetMB0_D5() uint8 {
	return volatile.LoadUint8(&o.MB0_D5.Reg)
}

// CAN0.MB0_D6: Mailbox Register
func (o *CAN0_Type) SetMB0_D6(value uint8) {
	volatile.StoreUint8(&o.MB0_D6.Reg, value)
}
func (o *CAN0_Type) GetMB0_D6() uint8 {
	return volatile.LoadUint8(&o.MB0_D6.Reg)
}

// CAN0.MB0_D7: Mailbox Register
func (o *CAN0_Type) SetMB0_D7(value uint8) {
	volatile.StoreUint8(&o.MB0_D7.Reg, value)
}
func (o *CAN0_Type) GetMB0_D7() uint8 {
	return volatile.LoadUint8(&o.MB0_D7.Reg)
}

// CAN0.MB0_TS: Mailbox Register
func (o *CAN0_Type) SetMB0_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB0_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB0_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB0_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff
}

// CAN0.MB1_ID: Mailbox Register
func (o *CAN0_Type) SetMB1_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB1_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB1_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB1_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB1_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB1_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB1_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB1_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB1_ID.Reg) & 0x3ffff
}

// CAN0.MB1_DL: Mailbox Register
func (o *CAN0_Type) SetMB1_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB1_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB1_DL.Reg) & 0xf
}

// CAN0.MB1_D0: Mailbox Register
func (o *CAN0_Type) SetMB1_D0(value uint8) {
	volatile.StoreUint8(&o.MB1_D0.Reg, value)
}
func (o *CAN0_Type) GetMB1_D0() uint8 {
	return volatile.LoadUint8(&o.MB1_D0.Reg)
}

// CAN0.MB1_D1: Mailbox Register
func (o *CAN0_Type) SetMB1_D1(value uint8) {
	volatile.StoreUint8(&o.MB1_D1.Reg, value)
}
func (o *CAN0_Type) GetMB1_D1() uint8 {
	return volatile.LoadUint8(&o.MB1_D1.Reg)
}

// CAN0.MB1_D2: Mailbox Register
func (o *CAN0_Type) SetMB1_D2(value uint8) {
	volatile.StoreUint8(&o.MB1_D2.Reg, value)
}
func (o *CAN0_Type) GetMB1_D2() uint8 {
	return volatile.LoadUint8(&o.MB1_D2.Reg)
}

// CAN0.MB1_D3: Mailbox Register
func (o *CAN0_Type) SetMB1_D3(value uint8) {
	volatile.StoreUint8(&o.MB1_D3.Reg, value)
}
func (o *CAN0_Type) GetMB1_D3() uint8 {
	return volatile.LoadUint8(&o.MB1_D3.Reg)
}

// CAN0.MB1_D4: Mailbox Register
func (o *CAN0_Type) SetMB1_D4(value uint8) {
	volatile.StoreUint8(&o.MB1_D4.Reg, value)
}
func (o *CAN0_Type) GetMB1_D4() uint8 {
	return volatile.LoadUint8(&o.MB1_D4.Reg)
}

// CAN0.MB1_D5: Mailbox Register
func (o *CAN0_Type) SetMB1_D5(value uint8) {
	volatile.StoreUint8(&o.MB1_D5.Reg, value)
}
func (o *CAN0_Type) GetMB1_D5() uint8 {
	return volatile.LoadUint8(&o.MB1_D5.Reg)
}

// CAN0.MB1_D6: Mailbox Register
func (o *CAN0_Type) SetMB1_D6(value uint8) {
	volatile.StoreUint8(&o.MB1_D6.Reg, value)
}
func (o *CAN0_Type) GetMB1_D6() uint8 {
	return volatile.LoadUint8(&o.MB1_D6.Reg)
}

// CAN0.MB1_D7: Mailbox Register
func (o *CAN0_Type) SetMB1_D7(value uint8) {
	volatile.StoreUint8(&o.MB1_D7.Reg, value)
}
func (o *CAN0_Type) GetMB1_D7() uint8 {
	return volatile.LoadUint8(&o.MB1_D7.Reg)
}

// CAN0.MB1_TS: Mailbox Register
func (o *CAN0_Type) SetMB1_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB1_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB1_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB1_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff
}

// CAN0.MB2_ID: Mailbox Register
func (o *CAN0_Type) SetMB2_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB2_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB2_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB2_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB2_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB2_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB2_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB2_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB2_ID.Reg) & 0x3ffff
}

// CAN0.MB2_DL: Mailbox Register
func (o *CAN0_Type) SetMB2_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB2_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB2_DL.Reg) & 0xf
}

// CAN0.MB2_D0: Mailbox Register
func (o *CAN0_Type) SetMB2_D0(value uint8) {
	volatile.StoreUint8(&o.MB2_D0.Reg, value)
}
func (o *CAN0_Type) GetMB2_D0() uint8 {
	return volatile.LoadUint8(&o.MB2_D0.Reg)
}

// CAN0.MB2_D1: Mailbox Register
func (o *CAN0_Type) SetMB2_D1(value uint8) {
	volatile.StoreUint8(&o.MB2_D1.Reg, value)
}
func (o *CAN0_Type) GetMB2_D1() uint8 {
	return volatile.LoadUint8(&o.MB2_D1.Reg)
}

// CAN0.MB2_D2: Mailbox Register
func (o *CAN0_Type) SetMB2_D2(value uint8) {
	volatile.StoreUint8(&o.MB2_D2.Reg, value)
}
func (o *CAN0_Type) GetMB2_D2() uint8 {
	return volatile.LoadUint8(&o.MB2_D2.Reg)
}

// CAN0.MB2_D3: Mailbox Register
func (o *CAN0_Type) SetMB2_D3(value uint8) {
	volatile.StoreUint8(&o.MB2_D3.Reg, value)
}
func (o *CAN0_Type) GetMB2_D3() uint8 {
	return volatile.LoadUint8(&o.MB2_D3.Reg)
}

// CAN0.MB2_D4: Mailbox Register
func (o *CAN0_Type) SetMB2_D4(value uint8) {
	volatile.StoreUint8(&o.MB2_D4.Reg, value)
}
func (o *CAN0_Type) GetMB2_D4() uint8 {
	return volatile.LoadUint8(&o.MB2_D4.Reg)
}

// CAN0.MB2_D5: Mailbox Register
func (o *CAN0_Type) SetMB2_D5(value uint8) {
	volatile.StoreUint8(&o.MB2_D5.Reg, value)
}
func (o *CAN0_Type) GetMB2_D5() uint8 {
	return volatile.LoadUint8(&o.MB2_D5.Reg)
}

// CAN0.MB2_D6: Mailbox Register
func (o *CAN0_Type) SetMB2_D6(value uint8) {
	volatile.StoreUint8(&o.MB2_D6.Reg, value)
}
func (o *CAN0_Type) GetMB2_D6() uint8 {
	return volatile.LoadUint8(&o.MB2_D6.Reg)
}

// CAN0.MB2_D7: Mailbox Register
func (o *CAN0_Type) SetMB2_D7(value uint8) {
	volatile.StoreUint8(&o.MB2_D7.Reg, value)
}
func (o *CAN0_Type) GetMB2_D7() uint8 {
	return volatile.LoadUint8(&o.MB2_D7.Reg)
}

// CAN0.MB2_TS: Mailbox Register
func (o *CAN0_Type) SetMB2_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB2_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB2_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB2_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff
}

// CAN0.MB3_ID: Mailbox Register
func (o *CAN0_Type) SetMB3_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB3_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB3_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB3_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB3_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB3_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB3_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB3_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB3_ID.Reg) & 0x3ffff
}

// CAN0.MB3_DL: Mailbox Register
func (o *CAN0_Type) SetMB3_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB3_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB3_DL.Reg) & 0xf
}

// CAN0.MB3_D0: Mailbox Register
func (o *CAN0_Type) SetMB3_D0(value uint8) {
	volatile.StoreUint8(&o.MB3_D0.Reg, value)
}
func (o *CAN0_Type) GetMB3_D0() uint8 {
	return volatile.LoadUint8(&o.MB3_D0.Reg)
}

// CAN0.MB3_D1: Mailbox Register
func (o *CAN0_Type) SetMB3_D1(value uint8) {
	volatile.StoreUint8(&o.MB3_D1.Reg, value)
}
func (o *CAN0_Type) GetMB3_D1() uint8 {
	return volatile.LoadUint8(&o.MB3_D1.Reg)
}

// CAN0.MB3_D2: Mailbox Register
func (o *CAN0_Type) SetMB3_D2(value uint8) {
	volatile.StoreUint8(&o.MB3_D2.Reg, value)
}
func (o *CAN0_Type) GetMB3_D2() uint8 {
	return volatile.LoadUint8(&o.MB3_D2.Reg)
}

// CAN0.MB3_D3: Mailbox Register
func (o *CAN0_Type) SetMB3_D3(value uint8) {
	volatile.StoreUint8(&o.MB3_D3.Reg, value)
}
func (o *CAN0_Type) GetMB3_D3() uint8 {
	return volatile.LoadUint8(&o.MB3_D3.Reg)
}

// CAN0.MB3_D4: Mailbox Register
func (o *CAN0_Type) SetMB3_D4(value uint8) {
	volatile.StoreUint8(&o.MB3_D4.Reg, value)
}
func (o *CAN0_Type) GetMB3_D4() uint8 {
	return volatile.LoadUint8(&o.MB3_D4.Reg)
}

// CAN0.MB3_D5: Mailbox Register
func (o *CAN0_Type) SetMB3_D5(value uint8) {
	volatile.StoreUint8(&o.MB3_D5.Reg, value)
}
func (o *CAN0_Type) GetMB3_D5() uint8 {
	return volatile.LoadUint8(&o.MB3_D5.Reg)
}

// CAN0.MB3_D6: Mailbox Register
func (o *CAN0_Type) SetMB3_D6(value uint8) {
	volatile.StoreUint8(&o.MB3_D6.Reg, value)
}
func (o *CAN0_Type) GetMB3_D6() uint8 {
	return volatile.LoadUint8(&o.MB3_D6.Reg)
}

// CAN0.MB3_D7: Mailbox Register
func (o *CAN0_Type) SetMB3_D7(value uint8) {
	volatile.StoreUint8(&o.MB3_D7.Reg, value)
}
func (o *CAN0_Type) GetMB3_D7() uint8 {
	return volatile.LoadUint8(&o.MB3_D7.Reg)
}

// CAN0.MB3_TS: Mailbox Register
func (o *CAN0_Type) SetMB3_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB3_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB3_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB3_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff
}

// CAN0.MB4_ID: Mailbox Register
func (o *CAN0_Type) SetMB4_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB4_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB4_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB4_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB4_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB4_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB4_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB4_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB4_ID.Reg) & 0x3ffff
}

// CAN0.MB4_DL: Mailbox Register
func (o *CAN0_Type) SetMB4_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB4_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB4_DL.Reg) & 0xf
}

// CAN0.MB4_D0: Mailbox Register
func (o *CAN0_Type) SetMB4_D0(value uint8) {
	volatile.StoreUint8(&o.MB4_D0.Reg, value)
}
func (o *CAN0_Type) GetMB4_D0() uint8 {
	return volatile.LoadUint8(&o.MB4_D0.Reg)
}

// CAN0.MB4_D1: Mailbox Register
func (o *CAN0_Type) SetMB4_D1(value uint8) {
	volatile.StoreUint8(&o.MB4_D1.Reg, value)
}
func (o *CAN0_Type) GetMB4_D1() uint8 {
	return volatile.LoadUint8(&o.MB4_D1.Reg)
}

// CAN0.MB4_D2: Mailbox Register
func (o *CAN0_Type) SetMB4_D2(value uint8) {
	volatile.StoreUint8(&o.MB4_D2.Reg, value)
}
func (o *CAN0_Type) GetMB4_D2() uint8 {
	return volatile.LoadUint8(&o.MB4_D2.Reg)
}

// CAN0.MB4_D3: Mailbox Register
func (o *CAN0_Type) SetMB4_D3(value uint8) {
	volatile.StoreUint8(&o.MB4_D3.Reg, value)
}
func (o *CAN0_Type) GetMB4_D3() uint8 {
	return volatile.LoadUint8(&o.MB4_D3.Reg)
}

// CAN0.MB4_D4: Mailbox Register
func (o *CAN0_Type) SetMB4_D4(value uint8) {
	volatile.StoreUint8(&o.MB4_D4.Reg, value)
}
func (o *CAN0_Type) GetMB4_D4() uint8 {
	return volatile.LoadUint8(&o.MB4_D4.Reg)
}

// CAN0.MB4_D5: Mailbox Register
func (o *CAN0_Type) SetMB4_D5(value uint8) {
	volatile.StoreUint8(&o.MB4_D5.Reg, value)
}
func (o *CAN0_Type) GetMB4_D5() uint8 {
	return volatile.LoadUint8(&o.MB4_D5.Reg)
}

// CAN0.MB4_D6: Mailbox Register
func (o *CAN0_Type) SetMB4_D6(value uint8) {
	volatile.StoreUint8(&o.MB4_D6.Reg, value)
}
func (o *CAN0_Type) GetMB4_D6() uint8 {
	return volatile.LoadUint8(&o.MB4_D6.Reg)
}

// CAN0.MB4_D7: Mailbox Register
func (o *CAN0_Type) SetMB4_D7(value uint8) {
	volatile.StoreUint8(&o.MB4_D7.Reg, value)
}
func (o *CAN0_Type) GetMB4_D7() uint8 {
	return volatile.LoadUint8(&o.MB4_D7.Reg)
}

// CAN0.MB4_TS: Mailbox Register
func (o *CAN0_Type) SetMB4_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB4_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB4_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB4_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff
}

// CAN0.MB5_ID: Mailbox Register
func (o *CAN0_Type) SetMB5_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB5_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB5_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB5_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB5_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB5_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB5_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB5_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB5_ID.Reg) & 0x3ffff
}

// CAN0.MB5_DL: Mailbox Register
func (o *CAN0_Type) SetMB5_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB5_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB5_DL.Reg) & 0xf
}

// CAN0.MB5_D0: Mailbox Register
func (o *CAN0_Type) SetMB5_D0(value uint8) {
	volatile.StoreUint8(&o.MB5_D0.Reg, value)
}
func (o *CAN0_Type) GetMB5_D0() uint8 {
	return volatile.LoadUint8(&o.MB5_D0.Reg)
}

// CAN0.MB5_D1: Mailbox Register
func (o *CAN0_Type) SetMB5_D1(value uint8) {
	volatile.StoreUint8(&o.MB5_D1.Reg, value)
}
func (o *CAN0_Type) GetMB5_D1() uint8 {
	return volatile.LoadUint8(&o.MB5_D1.Reg)
}

// CAN0.MB5_D2: Mailbox Register
func (o *CAN0_Type) SetMB5_D2(value uint8) {
	volatile.StoreUint8(&o.MB5_D2.Reg, value)
}
func (o *CAN0_Type) GetMB5_D2() uint8 {
	return volatile.LoadUint8(&o.MB5_D2.Reg)
}

// CAN0.MB5_D3: Mailbox Register
func (o *CAN0_Type) SetMB5_D3(value uint8) {
	volatile.StoreUint8(&o.MB5_D3.Reg, value)
}
func (o *CAN0_Type) GetMB5_D3() uint8 {
	return volatile.LoadUint8(&o.MB5_D3.Reg)
}

// CAN0.MB5_D4: Mailbox Register
func (o *CAN0_Type) SetMB5_D4(value uint8) {
	volatile.StoreUint8(&o.MB5_D4.Reg, value)
}
func (o *CAN0_Type) GetMB5_D4() uint8 {
	return volatile.LoadUint8(&o.MB5_D4.Reg)
}

// CAN0.MB5_D5: Mailbox Register
func (o *CAN0_Type) SetMB5_D5(value uint8) {
	volatile.StoreUint8(&o.MB5_D5.Reg, value)
}
func (o *CAN0_Type) GetMB5_D5() uint8 {
	return volatile.LoadUint8(&o.MB5_D5.Reg)
}

// CAN0.MB5_D6: Mailbox Register
func (o *CAN0_Type) SetMB5_D6(value uint8) {
	volatile.StoreUint8(&o.MB5_D6.Reg, value)
}
func (o *CAN0_Type) GetMB5_D6() uint8 {
	return volatile.LoadUint8(&o.MB5_D6.Reg)
}

// CAN0.MB5_D7: Mailbox Register
func (o *CAN0_Type) SetMB5_D7(value uint8) {
	volatile.StoreUint8(&o.MB5_D7.Reg, value)
}
func (o *CAN0_Type) GetMB5_D7() uint8 {
	return volatile.LoadUint8(&o.MB5_D7.Reg)
}

// CAN0.MB5_TS: Mailbox Register
func (o *CAN0_Type) SetMB5_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB5_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB5_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB5_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff
}

// CAN0.MB6_ID: Mailbox Register
func (o *CAN0_Type) SetMB6_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB6_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB6_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB6_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB6_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB6_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB6_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB6_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB6_ID.Reg) & 0x3ffff
}

// CAN0.MB6_DL: Mailbox Register
func (o *CAN0_Type) SetMB6_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB6_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB6_DL.Reg) & 0xf
}

// CAN0.MB6_D0: Mailbox Register
func (o *CAN0_Type) SetMB6_D0(value uint8) {
	volatile.StoreUint8(&o.MB6_D0.Reg, value)
}
func (o *CAN0_Type) GetMB6_D0() uint8 {
	return volatile.LoadUint8(&o.MB6_D0.Reg)
}

// CAN0.MB6_D1: Mailbox Register
func (o *CAN0_Type) SetMB6_D1(value uint8) {
	volatile.StoreUint8(&o.MB6_D1.Reg, value)
}
func (o *CAN0_Type) GetMB6_D1() uint8 {
	return volatile.LoadUint8(&o.MB6_D1.Reg)
}

// CAN0.MB6_D2: Mailbox Register
func (o *CAN0_Type) SetMB6_D2(value uint8) {
	volatile.StoreUint8(&o.MB6_D2.Reg, value)
}
func (o *CAN0_Type) GetMB6_D2() uint8 {
	return volatile.LoadUint8(&o.MB6_D2.Reg)
}

// CAN0.MB6_D3: Mailbox Register
func (o *CAN0_Type) SetMB6_D3(value uint8) {
	volatile.StoreUint8(&o.MB6_D3.Reg, value)
}
func (o *CAN0_Type) GetMB6_D3() uint8 {
	return volatile.LoadUint8(&o.MB6_D3.Reg)
}

// CAN0.MB6_D4: Mailbox Register
func (o *CAN0_Type) SetMB6_D4(value uint8) {
	volatile.StoreUint8(&o.MB6_D4.Reg, value)
}
func (o *CAN0_Type) GetMB6_D4() uint8 {
	return volatile.LoadUint8(&o.MB6_D4.Reg)
}

// CAN0.MB6_D5: Mailbox Register
func (o *CAN0_Type) SetMB6_D5(value uint8) {
	volatile.StoreUint8(&o.MB6_D5.Reg, value)
}
func (o *CAN0_Type) GetMB6_D5() uint8 {
	return volatile.LoadUint8(&o.MB6_D5.Reg)
}

// CAN0.MB6_D6: Mailbox Register
func (o *CAN0_Type) SetMB6_D6(value uint8) {
	volatile.StoreUint8(&o.MB6_D6.Reg, value)
}
func (o *CAN0_Type) GetMB6_D6() uint8 {
	return volatile.LoadUint8(&o.MB6_D6.Reg)
}

// CAN0.MB6_D7: Mailbox Register
func (o *CAN0_Type) SetMB6_D7(value uint8) {
	volatile.StoreUint8(&o.MB6_D7.Reg, value)
}
func (o *CAN0_Type) GetMB6_D7() uint8 {
	return volatile.LoadUint8(&o.MB6_D7.Reg)
}

// CAN0.MB6_TS: Mailbox Register
func (o *CAN0_Type) SetMB6_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB6_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB6_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB6_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff
}

// CAN0.MB7_ID: Mailbox Register
func (o *CAN0_Type) SetMB7_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB7_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB7_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB7_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB7_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB7_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB7_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB7_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB7_ID.Reg) & 0x3ffff
}

// CAN0.MB7_DL: Mailbox Register
func (o *CAN0_Type) SetMB7_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB7_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB7_DL.Reg) & 0xf
}

// CAN0.MB7_D0: Mailbox Register
func (o *CAN0_Type) SetMB7_D0(value uint8) {
	volatile.StoreUint8(&o.MB7_D0.Reg, value)
}
func (o *CAN0_Type) GetMB7_D0() uint8 {
	return volatile.LoadUint8(&o.MB7_D0.Reg)
}

// CAN0.MB7_D1: Mailbox Register
func (o *CAN0_Type) SetMB7_D1(value uint8) {
	volatile.StoreUint8(&o.MB7_D1.Reg, value)
}
func (o *CAN0_Type) GetMB7_D1() uint8 {
	return volatile.LoadUint8(&o.MB7_D1.Reg)
}

// CAN0.MB7_D2: Mailbox Register
func (o *CAN0_Type) SetMB7_D2(value uint8) {
	volatile.StoreUint8(&o.MB7_D2.Reg, value)
}
func (o *CAN0_Type) GetMB7_D2() uint8 {
	return volatile.LoadUint8(&o.MB7_D2.Reg)
}

// CAN0.MB7_D3: Mailbox Register
func (o *CAN0_Type) SetMB7_D3(value uint8) {
	volatile.StoreUint8(&o.MB7_D3.Reg, value)
}
func (o *CAN0_Type) GetMB7_D3() uint8 {
	return volatile.LoadUint8(&o.MB7_D3.Reg)
}

// CAN0.MB7_D4: Mailbox Register
func (o *CAN0_Type) SetMB7_D4(value uint8) {
	volatile.StoreUint8(&o.MB7_D4.Reg, value)
}
func (o *CAN0_Type) GetMB7_D4() uint8 {
	return volatile.LoadUint8(&o.MB7_D4.Reg)
}

// CAN0.MB7_D5: Mailbox Register
func (o *CAN0_Type) SetMB7_D5(value uint8) {
	volatile.StoreUint8(&o.MB7_D5.Reg, value)
}
func (o *CAN0_Type) GetMB7_D5() uint8 {
	return volatile.LoadUint8(&o.MB7_D5.Reg)
}

// CAN0.MB7_D6: Mailbox Register
func (o *CAN0_Type) SetMB7_D6(value uint8) {
	volatile.StoreUint8(&o.MB7_D6.Reg, value)
}
func (o *CAN0_Type) GetMB7_D6() uint8 {
	return volatile.LoadUint8(&o.MB7_D6.Reg)
}

// CAN0.MB7_D7: Mailbox Register
func (o *CAN0_Type) SetMB7_D7(value uint8) {
	volatile.StoreUint8(&o.MB7_D7.Reg, value)
}
func (o *CAN0_Type) GetMB7_D7() uint8 {
	return volatile.LoadUint8(&o.MB7_D7.Reg)
}

// CAN0.MB7_TS: Mailbox Register
func (o *CAN0_Type) SetMB7_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB7_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB7_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB7_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff
}

// CAN0.MB8_ID: Mailbox Register
func (o *CAN0_Type) SetMB8_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB8_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB8_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB8_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB8_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB8_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB8_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB8_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB8_ID.Reg) & 0x3ffff
}

// CAN0.MB8_DL: Mailbox Register
func (o *CAN0_Type) SetMB8_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB8_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB8_DL.Reg) & 0xf
}

// CAN0.MB8_D0: Mailbox Register
func (o *CAN0_Type) SetMB8_D0(value uint8) {
	volatile.StoreUint8(&o.MB8_D0.Reg, value)
}
func (o *CAN0_Type) GetMB8_D0() uint8 {
	return volatile.LoadUint8(&o.MB8_D0.Reg)
}

// CAN0.MB8_D1: Mailbox Register
func (o *CAN0_Type) SetMB8_D1(value uint8) {
	volatile.StoreUint8(&o.MB8_D1.Reg, value)
}
func (o *CAN0_Type) GetMB8_D1() uint8 {
	return volatile.LoadUint8(&o.MB8_D1.Reg)
}

// CAN0.MB8_D2: Mailbox Register
func (o *CAN0_Type) SetMB8_D2(value uint8) {
	volatile.StoreUint8(&o.MB8_D2.Reg, value)
}
func (o *CAN0_Type) GetMB8_D2() uint8 {
	return volatile.LoadUint8(&o.MB8_D2.Reg)
}

// CAN0.MB8_D3: Mailbox Register
func (o *CAN0_Type) SetMB8_D3(value uint8) {
	volatile.StoreUint8(&o.MB8_D3.Reg, value)
}
func (o *CAN0_Type) GetMB8_D3() uint8 {
	return volatile.LoadUint8(&o.MB8_D3.Reg)
}

// CAN0.MB8_D4: Mailbox Register
func (o *CAN0_Type) SetMB8_D4(value uint8) {
	volatile.StoreUint8(&o.MB8_D4.Reg, value)
}
func (o *CAN0_Type) GetMB8_D4() uint8 {
	return volatile.LoadUint8(&o.MB8_D4.Reg)
}

// CAN0.MB8_D5: Mailbox Register
func (o *CAN0_Type) SetMB8_D5(value uint8) {
	volatile.StoreUint8(&o.MB8_D5.Reg, value)
}
func (o *CAN0_Type) GetMB8_D5() uint8 {
	return volatile.LoadUint8(&o.MB8_D5.Reg)
}

// CAN0.MB8_D6: Mailbox Register
func (o *CAN0_Type) SetMB8_D6(value uint8) {
	volatile.StoreUint8(&o.MB8_D6.Reg, value)
}
func (o *CAN0_Type) GetMB8_D6() uint8 {
	return volatile.LoadUint8(&o.MB8_D6.Reg)
}

// CAN0.MB8_D7: Mailbox Register
func (o *CAN0_Type) SetMB8_D7(value uint8) {
	volatile.StoreUint8(&o.MB8_D7.Reg, value)
}
func (o *CAN0_Type) GetMB8_D7() uint8 {
	return volatile.LoadUint8(&o.MB8_D7.Reg)
}

// CAN0.MB8_TS: Mailbox Register
func (o *CAN0_Type) SetMB8_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB8_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB8_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB8_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff
}

// CAN0.MB9_ID: Mailbox Register
func (o *CAN0_Type) SetMB9_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB9_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB9_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB9_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB9_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB9_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB9_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB9_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB9_ID.Reg) & 0x3ffff
}

// CAN0.MB9_DL: Mailbox Register
func (o *CAN0_Type) SetMB9_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB9_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB9_DL.Reg) & 0xf
}

// CAN0.MB9_D0: Mailbox Register
func (o *CAN0_Type) SetMB9_D0(value uint8) {
	volatile.StoreUint8(&o.MB9_D0.Reg, value)
}
func (o *CAN0_Type) GetMB9_D0() uint8 {
	return volatile.LoadUint8(&o.MB9_D0.Reg)
}

// CAN0.MB9_D1: Mailbox Register
func (o *CAN0_Type) SetMB9_D1(value uint8) {
	volatile.StoreUint8(&o.MB9_D1.Reg, value)
}
func (o *CAN0_Type) GetMB9_D1() uint8 {
	return volatile.LoadUint8(&o.MB9_D1.Reg)
}

// CAN0.MB9_D2: Mailbox Register
func (o *CAN0_Type) SetMB9_D2(value uint8) {
	volatile.StoreUint8(&o.MB9_D2.Reg, value)
}
func (o *CAN0_Type) GetMB9_D2() uint8 {
	return volatile.LoadUint8(&o.MB9_D2.Reg)
}

// CAN0.MB9_D3: Mailbox Register
func (o *CAN0_Type) SetMB9_D3(value uint8) {
	volatile.StoreUint8(&o.MB9_D3.Reg, value)
}
func (o *CAN0_Type) GetMB9_D3() uint8 {
	return volatile.LoadUint8(&o.MB9_D3.Reg)
}

// CAN0.MB9_D4: Mailbox Register
func (o *CAN0_Type) SetMB9_D4(value uint8) {
	volatile.StoreUint8(&o.MB9_D4.Reg, value)
}
func (o *CAN0_Type) GetMB9_D4() uint8 {
	return volatile.LoadUint8(&o.MB9_D4.Reg)
}

// CAN0.MB9_D5: Mailbox Register
func (o *CAN0_Type) SetMB9_D5(value uint8) {
	volatile.StoreUint8(&o.MB9_D5.Reg, value)
}
func (o *CAN0_Type) GetMB9_D5() uint8 {
	return volatile.LoadUint8(&o.MB9_D5.Reg)
}

// CAN0.MB9_D6: Mailbox Register
func (o *CAN0_Type) SetMB9_D6(value uint8) {
	volatile.StoreUint8(&o.MB9_D6.Reg, value)
}
func (o *CAN0_Type) GetMB9_D6() uint8 {
	return volatile.LoadUint8(&o.MB9_D6.Reg)
}

// CAN0.MB9_D7: Mailbox Register
func (o *CAN0_Type) SetMB9_D7(value uint8) {
	volatile.StoreUint8(&o.MB9_D7.Reg, value)
}
func (o *CAN0_Type) GetMB9_D7() uint8 {
	return volatile.LoadUint8(&o.MB9_D7.Reg)
}

// CAN0.MB9_TS: Mailbox Register
func (o *CAN0_Type) SetMB9_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB9_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB9_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB9_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff
}

// CAN0.MB10_ID: Mailbox Register
func (o *CAN0_Type) SetMB10_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB10_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB10_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB10_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB10_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB10_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB10_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB10_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB10_ID.Reg) & 0x3ffff
}

// CAN0.MB10_DL: Mailbox Register
func (o *CAN0_Type) SetMB10_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB10_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB10_DL.Reg) & 0xf
}

// CAN0.MB10_D0: Mailbox Register
func (o *CAN0_Type) SetMB10_D0(value uint8) {
	volatile.StoreUint8(&o.MB10_D0.Reg, value)
}
func (o *CAN0_Type) GetMB10_D0() uint8 {
	return volatile.LoadUint8(&o.MB10_D0.Reg)
}

// CAN0.MB10_D1: Mailbox Register
func (o *CAN0_Type) SetMB10_D1(value uint8) {
	volatile.StoreUint8(&o.MB10_D1.Reg, value)
}
func (o *CAN0_Type) GetMB10_D1() uint8 {
	return volatile.LoadUint8(&o.MB10_D1.Reg)
}

// CAN0.MB10_D2: Mailbox Register
func (o *CAN0_Type) SetMB10_D2(value uint8) {
	volatile.StoreUint8(&o.MB10_D2.Reg, value)
}
func (o *CAN0_Type) GetMB10_D2() uint8 {
	return volatile.LoadUint8(&o.MB10_D2.Reg)
}

// CAN0.MB10_D3: Mailbox Register
func (o *CAN0_Type) SetMB10_D3(value uint8) {
	volatile.StoreUint8(&o.MB10_D3.Reg, value)
}
func (o *CAN0_Type) GetMB10_D3() uint8 {
	return volatile.LoadUint8(&o.MB10_D3.Reg)
}

// CAN0.MB10_D4: Mailbox Register
func (o *CAN0_Type) SetMB10_D4(value uint8) {
	volatile.StoreUint8(&o.MB10_D4.Reg, value)
}
func (o *CAN0_Type) GetMB10_D4() uint8 {
	return volatile.LoadUint8(&o.MB10_D4.Reg)
}

// CAN0.MB10_D5: Mailbox Register
func (o *CAN0_Type) SetMB10_D5(value uint8) {
	volatile.StoreUint8(&o.MB10_D5.Reg, value)
}
func (o *CAN0_Type) GetMB10_D5() uint8 {
	return volatile.LoadUint8(&o.MB10_D5.Reg)
}

// CAN0.MB10_D6: Mailbox Register
func (o *CAN0_Type) SetMB10_D6(value uint8) {
	volatile.StoreUint8(&o.MB10_D6.Reg, value)
}
func (o *CAN0_Type) GetMB10_D6() uint8 {
	return volatile.LoadUint8(&o.MB10_D6.Reg)
}

// CAN0.MB10_D7: Mailbox Register
func (o *CAN0_Type) SetMB10_D7(value uint8) {
	volatile.StoreUint8(&o.MB10_D7.Reg, value)
}
func (o *CAN0_Type) GetMB10_D7() uint8 {
	return volatile.LoadUint8(&o.MB10_D7.Reg)
}

// CAN0.MB10_TS: Mailbox Register
func (o *CAN0_Type) SetMB10_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB10_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB10_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB10_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff
}

// CAN0.MB11_ID: Mailbox Register
func (o *CAN0_Type) SetMB11_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB11_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB11_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB11_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB11_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB11_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB11_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB11_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB11_ID.Reg) & 0x3ffff
}

// CAN0.MB11_DL: Mailbox Register
func (o *CAN0_Type) SetMB11_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB11_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB11_DL.Reg) & 0xf
}

// CAN0.MB11_D0: Mailbox Register
func (o *CAN0_Type) SetMB11_D0(value uint8) {
	volatile.StoreUint8(&o.MB11_D0.Reg, value)
}
func (o *CAN0_Type) GetMB11_D0() uint8 {
	return volatile.LoadUint8(&o.MB11_D0.Reg)
}

// CAN0.MB11_D1: Mailbox Register
func (o *CAN0_Type) SetMB11_D1(value uint8) {
	volatile.StoreUint8(&o.MB11_D1.Reg, value)
}
func (o *CAN0_Type) GetMB11_D1() uint8 {
	return volatile.LoadUint8(&o.MB11_D1.Reg)
}

// CAN0.MB11_D2: Mailbox Register
func (o *CAN0_Type) SetMB11_D2(value uint8) {
	volatile.StoreUint8(&o.MB11_D2.Reg, value)
}
func (o *CAN0_Type) GetMB11_D2() uint8 {
	return volatile.LoadUint8(&o.MB11_D2.Reg)
}

// CAN0.MB11_D3: Mailbox Register
func (o *CAN0_Type) SetMB11_D3(value uint8) {
	volatile.StoreUint8(&o.MB11_D3.Reg, value)
}
func (o *CAN0_Type) GetMB11_D3() uint8 {
	return volatile.LoadUint8(&o.MB11_D3.Reg)
}

// CAN0.MB11_D4: Mailbox Register
func (o *CAN0_Type) SetMB11_D4(value uint8) {
	volatile.StoreUint8(&o.MB11_D4.Reg, value)
}
func (o *CAN0_Type) GetMB11_D4() uint8 {
	return volatile.LoadUint8(&o.MB11_D4.Reg)
}

// CAN0.MB11_D5: Mailbox Register
func (o *CAN0_Type) SetMB11_D5(value uint8) {
	volatile.StoreUint8(&o.MB11_D5.Reg, value)
}
func (o *CAN0_Type) GetMB11_D5() uint8 {
	return volatile.LoadUint8(&o.MB11_D5.Reg)
}

// CAN0.MB11_D6: Mailbox Register
func (o *CAN0_Type) SetMB11_D6(value uint8) {
	volatile.StoreUint8(&o.MB11_D6.Reg, value)
}
func (o *CAN0_Type) GetMB11_D6() uint8 {
	return volatile.LoadUint8(&o.MB11_D6.Reg)
}

// CAN0.MB11_D7: Mailbox Register
func (o *CAN0_Type) SetMB11_D7(value uint8) {
	volatile.StoreUint8(&o.MB11_D7.Reg, value)
}
func (o *CAN0_Type) GetMB11_D7() uint8 {
	return volatile.LoadUint8(&o.MB11_D7.Reg)
}

// CAN0.MB11_TS: Mailbox Register
func (o *CAN0_Type) SetMB11_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB11_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB11_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB11_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff
}

// CAN0.MB12_ID: Mailbox Register
func (o *CAN0_Type) SetMB12_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB12_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB12_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB12_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB12_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB12_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB12_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB12_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB12_ID.Reg) & 0x3ffff
}

// CAN0.MB12_DL: Mailbox Register
func (o *CAN0_Type) SetMB12_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB12_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB12_DL.Reg) & 0xf
}

// CAN0.MB12_D0: Mailbox Register
func (o *CAN0_Type) SetMB12_D0(value uint8) {
	volatile.StoreUint8(&o.MB12_D0.Reg, value)
}
func (o *CAN0_Type) GetMB12_D0() uint8 {
	return volatile.LoadUint8(&o.MB12_D0.Reg)
}

// CAN0.MB12_D1: Mailbox Register
func (o *CAN0_Type) SetMB12_D1(value uint8) {
	volatile.StoreUint8(&o.MB12_D1.Reg, value)
}
func (o *CAN0_Type) GetMB12_D1() uint8 {
	return volatile.LoadUint8(&o.MB12_D1.Reg)
}

// CAN0.MB12_D2: Mailbox Register
func (o *CAN0_Type) SetMB12_D2(value uint8) {
	volatile.StoreUint8(&o.MB12_D2.Reg, value)
}
func (o *CAN0_Type) GetMB12_D2() uint8 {
	return volatile.LoadUint8(&o.MB12_D2.Reg)
}

// CAN0.MB12_D3: Mailbox Register
func (o *CAN0_Type) SetMB12_D3(value uint8) {
	volatile.StoreUint8(&o.MB12_D3.Reg, value)
}
func (o *CAN0_Type) GetMB12_D3() uint8 {
	return volatile.LoadUint8(&o.MB12_D3.Reg)
}

// CAN0.MB12_D4: Mailbox Register
func (o *CAN0_Type) SetMB12_D4(value uint8) {
	volatile.StoreUint8(&o.MB12_D4.Reg, value)
}
func (o *CAN0_Type) GetMB12_D4() uint8 {
	return volatile.LoadUint8(&o.MB12_D4.Reg)
}

// CAN0.MB12_D5: Mailbox Register
func (o *CAN0_Type) SetMB12_D5(value uint8) {
	volatile.StoreUint8(&o.MB12_D5.Reg, value)
}
func (o *CAN0_Type) GetMB12_D5() uint8 {
	return volatile.LoadUint8(&o.MB12_D5.Reg)
}

// CAN0.MB12_D6: Mailbox Register
func (o *CAN0_Type) SetMB12_D6(value uint8) {
	volatile.StoreUint8(&o.MB12_D6.Reg, value)
}
func (o *CAN0_Type) GetMB12_D6() uint8 {
	return volatile.LoadUint8(&o.MB12_D6.Reg)
}

// CAN0.MB12_D7: Mailbox Register
func (o *CAN0_Type) SetMB12_D7(value uint8) {
	volatile.StoreUint8(&o.MB12_D7.Reg, value)
}
func (o *CAN0_Type) GetMB12_D7() uint8 {
	return volatile.LoadUint8(&o.MB12_D7.Reg)
}

// CAN0.MB12_TS: Mailbox Register
func (o *CAN0_Type) SetMB12_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB12_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB12_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB12_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff
}

// CAN0.MB13_ID: Mailbox Register
func (o *CAN0_Type) SetMB13_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB13_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB13_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB13_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB13_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB13_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB13_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB13_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB13_ID.Reg) & 0x3ffff
}

// CAN0.MB13_DL: Mailbox Register
func (o *CAN0_Type) SetMB13_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB13_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB13_DL.Reg) & 0xf
}

// CAN0.MB13_D0: Mailbox Register
func (o *CAN0_Type) SetMB13_D0(value uint8) {
	volatile.StoreUint8(&o.MB13_D0.Reg, value)
}
func (o *CAN0_Type) GetMB13_D0() uint8 {
	return volatile.LoadUint8(&o.MB13_D0.Reg)
}

// CAN0.MB13_D1: Mailbox Register
func (o *CAN0_Type) SetMB13_D1(value uint8) {
	volatile.StoreUint8(&o.MB13_D1.Reg, value)
}
func (o *CAN0_Type) GetMB13_D1() uint8 {
	return volatile.LoadUint8(&o.MB13_D1.Reg)
}

// CAN0.MB13_D2: Mailbox Register
func (o *CAN0_Type) SetMB13_D2(value uint8) {
	volatile.StoreUint8(&o.MB13_D2.Reg, value)
}
func (o *CAN0_Type) GetMB13_D2() uint8 {
	return volatile.LoadUint8(&o.MB13_D2.Reg)
}

// CAN0.MB13_D3: Mailbox Register
func (o *CAN0_Type) SetMB13_D3(value uint8) {
	volatile.StoreUint8(&o.MB13_D3.Reg, value)
}
func (o *CAN0_Type) GetMB13_D3() uint8 {
	return volatile.LoadUint8(&o.MB13_D3.Reg)
}

// CAN0.MB13_D4: Mailbox Register
func (o *CAN0_Type) SetMB13_D4(value uint8) {
	volatile.StoreUint8(&o.MB13_D4.Reg, value)
}
func (o *CAN0_Type) GetMB13_D4() uint8 {
	return volatile.LoadUint8(&o.MB13_D4.Reg)
}

// CAN0.MB13_D5: Mailbox Register
func (o *CAN0_Type) SetMB13_D5(value uint8) {
	volatile.StoreUint8(&o.MB13_D5.Reg, value)
}
func (o *CAN0_Type) GetMB13_D5() uint8 {
	return volatile.LoadUint8(&o.MB13_D5.Reg)
}

// CAN0.MB13_D6: Mailbox Register
func (o *CAN0_Type) SetMB13_D6(value uint8) {
	volatile.StoreUint8(&o.MB13_D6.Reg, value)
}
func (o *CAN0_Type) GetMB13_D6() uint8 {
	return volatile.LoadUint8(&o.MB13_D6.Reg)
}

// CAN0.MB13_D7: Mailbox Register
func (o *CAN0_Type) SetMB13_D7(value uint8) {
	volatile.StoreUint8(&o.MB13_D7.Reg, value)
}
func (o *CAN0_Type) GetMB13_D7() uint8 {
	return volatile.LoadUint8(&o.MB13_D7.Reg)
}

// CAN0.MB13_TS: Mailbox Register
func (o *CAN0_Type) SetMB13_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB13_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB13_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB13_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff
}

// CAN0.MB14_ID: Mailbox Register
func (o *CAN0_Type) SetMB14_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB14_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB14_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB14_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB14_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB14_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB14_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB14_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB14_ID.Reg) & 0x3ffff
}

// CAN0.MB14_DL: Mailbox Register
func (o *CAN0_Type) SetMB14_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB14_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB14_DL.Reg) & 0xf
}

// CAN0.MB14_D0: Mailbox Register
func (o *CAN0_Type) SetMB14_D0(value uint8) {
	volatile.StoreUint8(&o.MB14_D0.Reg, value)
}
func (o *CAN0_Type) GetMB14_D0() uint8 {
	return volatile.LoadUint8(&o.MB14_D0.Reg)
}

// CAN0.MB14_D1: Mailbox Register
func (o *CAN0_Type) SetMB14_D1(value uint8) {
	volatile.StoreUint8(&o.MB14_D1.Reg, value)
}
func (o *CAN0_Type) GetMB14_D1() uint8 {
	return volatile.LoadUint8(&o.MB14_D1.Reg)
}

// CAN0.MB14_D2: Mailbox Register
func (o *CAN0_Type) SetMB14_D2(value uint8) {
	volatile.StoreUint8(&o.MB14_D2.Reg, value)
}
func (o *CAN0_Type) GetMB14_D2() uint8 {
	return volatile.LoadUint8(&o.MB14_D2.Reg)
}

// CAN0.MB14_D3: Mailbox Register
func (o *CAN0_Type) SetMB14_D3(value uint8) {
	volatile.StoreUint8(&o.MB14_D3.Reg, value)
}
func (o *CAN0_Type) GetMB14_D3() uint8 {
	return volatile.LoadUint8(&o.MB14_D3.Reg)
}

// CAN0.MB14_D4: Mailbox Register
func (o *CAN0_Type) SetMB14_D4(value uint8) {
	volatile.StoreUint8(&o.MB14_D4.Reg, value)
}
func (o *CAN0_Type) GetMB14_D4() uint8 {
	return volatile.LoadUint8(&o.MB14_D4.Reg)
}

// CAN0.MB14_D5: Mailbox Register
func (o *CAN0_Type) SetMB14_D5(value uint8) {
	volatile.StoreUint8(&o.MB14_D5.Reg, value)
}
func (o *CAN0_Type) GetMB14_D5() uint8 {
	return volatile.LoadUint8(&o.MB14_D5.Reg)
}

// CAN0.MB14_D6: Mailbox Register
func (o *CAN0_Type) SetMB14_D6(value uint8) {
	volatile.StoreUint8(&o.MB14_D6.Reg, value)
}
func (o *CAN0_Type) GetMB14_D6() uint8 {
	return volatile.LoadUint8(&o.MB14_D6.Reg)
}

// CAN0.MB14_D7: Mailbox Register
func (o *CAN0_Type) SetMB14_D7(value uint8) {
	volatile.StoreUint8(&o.MB14_D7.Reg, value)
}
func (o *CAN0_Type) GetMB14_D7() uint8 {
	return volatile.LoadUint8(&o.MB14_D7.Reg)
}

// CAN0.MB14_TS: Mailbox Register
func (o *CAN0_Type) SetMB14_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB14_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB14_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB14_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff
}

// CAN0.MB15_ID: Mailbox Register
func (o *CAN0_Type) SetMB15_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB15_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB15_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB15_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB15_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB15_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB15_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB15_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB15_ID.Reg) & 0x3ffff
}

// CAN0.MB15_DL: Mailbox Register
func (o *CAN0_Type) SetMB15_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB15_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB15_DL.Reg) & 0xf
}

// CAN0.MB15_D0: Mailbox Register
func (o *CAN0_Type) SetMB15_D0(value uint8) {
	volatile.StoreUint8(&o.MB15_D0.Reg, value)
}
func (o *CAN0_Type) GetMB15_D0() uint8 {
	return volatile.LoadUint8(&o.MB15_D0.Reg)
}

// CAN0.MB15_D1: Mailbox Register
func (o *CAN0_Type) SetMB15_D1(value uint8) {
	volatile.StoreUint8(&o.MB15_D1.Reg, value)
}
func (o *CAN0_Type) GetMB15_D1() uint8 {
	return volatile.LoadUint8(&o.MB15_D1.Reg)
}

// CAN0.MB15_D2: Mailbox Register
func (o *CAN0_Type) SetMB15_D2(value uint8) {
	volatile.StoreUint8(&o.MB15_D2.Reg, value)
}
func (o *CAN0_Type) GetMB15_D2() uint8 {
	return volatile.LoadUint8(&o.MB15_D2.Reg)
}

// CAN0.MB15_D3: Mailbox Register
func (o *CAN0_Type) SetMB15_D3(value uint8) {
	volatile.StoreUint8(&o.MB15_D3.Reg, value)
}
func (o *CAN0_Type) GetMB15_D3() uint8 {
	return volatile.LoadUint8(&o.MB15_D3.Reg)
}

// CAN0.MB15_D4: Mailbox Register
func (o *CAN0_Type) SetMB15_D4(value uint8) {
	volatile.StoreUint8(&o.MB15_D4.Reg, value)
}
func (o *CAN0_Type) GetMB15_D4() uint8 {
	return volatile.LoadUint8(&o.MB15_D4.Reg)
}

// CAN0.MB15_D5: Mailbox Register
func (o *CAN0_Type) SetMB15_D5(value uint8) {
	volatile.StoreUint8(&o.MB15_D5.Reg, value)
}
func (o *CAN0_Type) GetMB15_D5() uint8 {
	return volatile.LoadUint8(&o.MB15_D5.Reg)
}

// CAN0.MB15_D6: Mailbox Register
func (o *CAN0_Type) SetMB15_D6(value uint8) {
	volatile.StoreUint8(&o.MB15_D6.Reg, value)
}
func (o *CAN0_Type) GetMB15_D6() uint8 {
	return volatile.LoadUint8(&o.MB15_D6.Reg)
}

// CAN0.MB15_D7: Mailbox Register
func (o *CAN0_Type) SetMB15_D7(value uint8) {
	volatile.StoreUint8(&o.MB15_D7.Reg, value)
}
func (o *CAN0_Type) GetMB15_D7() uint8 {
	return volatile.LoadUint8(&o.MB15_D7.Reg)
}

// CAN0.MB15_TS: Mailbox Register
func (o *CAN0_Type) SetMB15_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB15_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB15_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB15_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff
}

// CAN0.MB16_ID: Mailbox Register
func (o *CAN0_Type) SetMB16_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB16_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB16_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB16_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB16_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB16_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB16_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB16_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB16_ID.Reg) & 0x3ffff
}

// CAN0.MB16_DL: Mailbox Register
func (o *CAN0_Type) SetMB16_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB16_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB16_DL.Reg) & 0xf
}

// CAN0.MB16_D0: Mailbox Register
func (o *CAN0_Type) SetMB16_D0(value uint8) {
	volatile.StoreUint8(&o.MB16_D0.Reg, value)
}
func (o *CAN0_Type) GetMB16_D0() uint8 {
	return volatile.LoadUint8(&o.MB16_D0.Reg)
}

// CAN0.MB16_D1: Mailbox Register
func (o *CAN0_Type) SetMB16_D1(value uint8) {
	volatile.StoreUint8(&o.MB16_D1.Reg, value)
}
func (o *CAN0_Type) GetMB16_D1() uint8 {
	return volatile.LoadUint8(&o.MB16_D1.Reg)
}

// CAN0.MB16_D2: Mailbox Register
func (o *CAN0_Type) SetMB16_D2(value uint8) {
	volatile.StoreUint8(&o.MB16_D2.Reg, value)
}
func (o *CAN0_Type) GetMB16_D2() uint8 {
	return volatile.LoadUint8(&o.MB16_D2.Reg)
}

// CAN0.MB16_D3: Mailbox Register
func (o *CAN0_Type) SetMB16_D3(value uint8) {
	volatile.StoreUint8(&o.MB16_D3.Reg, value)
}
func (o *CAN0_Type) GetMB16_D3() uint8 {
	return volatile.LoadUint8(&o.MB16_D3.Reg)
}

// CAN0.MB16_D4: Mailbox Register
func (o *CAN0_Type) SetMB16_D4(value uint8) {
	volatile.StoreUint8(&o.MB16_D4.Reg, value)
}
func (o *CAN0_Type) GetMB16_D4() uint8 {
	return volatile.LoadUint8(&o.MB16_D4.Reg)
}

// CAN0.MB16_D5: Mailbox Register
func (o *CAN0_Type) SetMB16_D5(value uint8) {
	volatile.StoreUint8(&o.MB16_D5.Reg, value)
}
func (o *CAN0_Type) GetMB16_D5() uint8 {
	return volatile.LoadUint8(&o.MB16_D5.Reg)
}

// CAN0.MB16_D6: Mailbox Register
func (o *CAN0_Type) SetMB16_D6(value uint8) {
	volatile.StoreUint8(&o.MB16_D6.Reg, value)
}
func (o *CAN0_Type) GetMB16_D6() uint8 {
	return volatile.LoadUint8(&o.MB16_D6.Reg)
}

// CAN0.MB16_D7: Mailbox Register
func (o *CAN0_Type) SetMB16_D7(value uint8) {
	volatile.StoreUint8(&o.MB16_D7.Reg, value)
}
func (o *CAN0_Type) GetMB16_D7() uint8 {
	return volatile.LoadUint8(&o.MB16_D7.Reg)
}

// CAN0.MB16_TS: Mailbox Register
func (o *CAN0_Type) SetMB16_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB16_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB16_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB16_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff
}

// CAN0.MB17_ID: Mailbox Register
func (o *CAN0_Type) SetMB17_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB17_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB17_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB17_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB17_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB17_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB17_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB17_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB17_ID.Reg) & 0x3ffff
}

// CAN0.MB17_DL: Mailbox Register
func (o *CAN0_Type) SetMB17_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB17_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB17_DL.Reg) & 0xf
}

// CAN0.MB17_D0: Mailbox Register
func (o *CAN0_Type) SetMB17_D0(value uint8) {
	volatile.StoreUint8(&o.MB17_D0.Reg, value)
}
func (o *CAN0_Type) GetMB17_D0() uint8 {
	return volatile.LoadUint8(&o.MB17_D0.Reg)
}

// CAN0.MB17_D1: Mailbox Register
func (o *CAN0_Type) SetMB17_D1(value uint8) {
	volatile.StoreUint8(&o.MB17_D1.Reg, value)
}
func (o *CAN0_Type) GetMB17_D1() uint8 {
	return volatile.LoadUint8(&o.MB17_D1.Reg)
}

// CAN0.MB17_D2: Mailbox Register
func (o *CAN0_Type) SetMB17_D2(value uint8) {
	volatile.StoreUint8(&o.MB17_D2.Reg, value)
}
func (o *CAN0_Type) GetMB17_D2() uint8 {
	return volatile.LoadUint8(&o.MB17_D2.Reg)
}

// CAN0.MB17_D3: Mailbox Register
func (o *CAN0_Type) SetMB17_D3(value uint8) {
	volatile.StoreUint8(&o.MB17_D3.Reg, value)
}
func (o *CAN0_Type) GetMB17_D3() uint8 {
	return volatile.LoadUint8(&o.MB17_D3.Reg)
}

// CAN0.MB17_D4: Mailbox Register
func (o *CAN0_Type) SetMB17_D4(value uint8) {
	volatile.StoreUint8(&o.MB17_D4.Reg, value)
}
func (o *CAN0_Type) GetMB17_D4() uint8 {
	return volatile.LoadUint8(&o.MB17_D4.Reg)
}

// CAN0.MB17_D5: Mailbox Register
func (o *CAN0_Type) SetMB17_D5(value uint8) {
	volatile.StoreUint8(&o.MB17_D5.Reg, value)
}
func (o *CAN0_Type) GetMB17_D5() uint8 {
	return volatile.LoadUint8(&o.MB17_D5.Reg)
}

// CAN0.MB17_D6: Mailbox Register
func (o *CAN0_Type) SetMB17_D6(value uint8) {
	volatile.StoreUint8(&o.MB17_D6.Reg, value)
}
func (o *CAN0_Type) GetMB17_D6() uint8 {
	return volatile.LoadUint8(&o.MB17_D6.Reg)
}

// CAN0.MB17_D7: Mailbox Register
func (o *CAN0_Type) SetMB17_D7(value uint8) {
	volatile.StoreUint8(&o.MB17_D7.Reg, value)
}
func (o *CAN0_Type) GetMB17_D7() uint8 {
	return volatile.LoadUint8(&o.MB17_D7.Reg)
}

// CAN0.MB17_TS: Mailbox Register
func (o *CAN0_Type) SetMB17_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB17_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB17_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB17_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff
}

// CAN0.MB18_ID: Mailbox Register
func (o *CAN0_Type) SetMB18_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB18_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB18_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB18_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB18_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB18_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB18_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB18_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB18_ID.Reg) & 0x3ffff
}

// CAN0.MB18_DL: Mailbox Register
func (o *CAN0_Type) SetMB18_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB18_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB18_DL.Reg) & 0xf
}

// CAN0.MB18_D0: Mailbox Register
func (o *CAN0_Type) SetMB18_D0(value uint8) {
	volatile.StoreUint8(&o.MB18_D0.Reg, value)
}
func (o *CAN0_Type) GetMB18_D0() uint8 {
	return volatile.LoadUint8(&o.MB18_D0.Reg)
}

// CAN0.MB18_D1: Mailbox Register
func (o *CAN0_Type) SetMB18_D1(value uint8) {
	volatile.StoreUint8(&o.MB18_D1.Reg, value)
}
func (o *CAN0_Type) GetMB18_D1() uint8 {
	return volatile.LoadUint8(&o.MB18_D1.Reg)
}

// CAN0.MB18_D2: Mailbox Register
func (o *CAN0_Type) SetMB18_D2(value uint8) {
	volatile.StoreUint8(&o.MB18_D2.Reg, value)
}
func (o *CAN0_Type) GetMB18_D2() uint8 {
	return volatile.LoadUint8(&o.MB18_D2.Reg)
}

// CAN0.MB18_D3: Mailbox Register
func (o *CAN0_Type) SetMB18_D3(value uint8) {
	volatile.StoreUint8(&o.MB18_D3.Reg, value)
}
func (o *CAN0_Type) GetMB18_D3() uint8 {
	return volatile.LoadUint8(&o.MB18_D3.Reg)
}

// CAN0.MB18_D4: Mailbox Register
func (o *CAN0_Type) SetMB18_D4(value uint8) {
	volatile.StoreUint8(&o.MB18_D4.Reg, value)
}
func (o *CAN0_Type) GetMB18_D4() uint8 {
	return volatile.LoadUint8(&o.MB18_D4.Reg)
}

// CAN0.MB18_D5: Mailbox Register
func (o *CAN0_Type) SetMB18_D5(value uint8) {
	volatile.StoreUint8(&o.MB18_D5.Reg, value)
}
func (o *CAN0_Type) GetMB18_D5() uint8 {
	return volatile.LoadUint8(&o.MB18_D5.Reg)
}

// CAN0.MB18_D6: Mailbox Register
func (o *CAN0_Type) SetMB18_D6(value uint8) {
	volatile.StoreUint8(&o.MB18_D6.Reg, value)
}
func (o *CAN0_Type) GetMB18_D6() uint8 {
	return volatile.LoadUint8(&o.MB18_D6.Reg)
}

// CAN0.MB18_D7: Mailbox Register
func (o *CAN0_Type) SetMB18_D7(value uint8) {
	volatile.StoreUint8(&o.MB18_D7.Reg, value)
}
func (o *CAN0_Type) GetMB18_D7() uint8 {
	return volatile.LoadUint8(&o.MB18_D7.Reg)
}

// CAN0.MB18_TS: Mailbox Register
func (o *CAN0_Type) SetMB18_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB18_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB18_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB18_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff
}

// CAN0.MB19_ID: Mailbox Register
func (o *CAN0_Type) SetMB19_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB19_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB19_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB19_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB19_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB19_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB19_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB19_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB19_ID.Reg) & 0x3ffff
}

// CAN0.MB19_DL: Mailbox Register
func (o *CAN0_Type) SetMB19_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB19_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB19_DL.Reg) & 0xf
}

// CAN0.MB19_D0: Mailbox Register
func (o *CAN0_Type) SetMB19_D0(value uint8) {
	volatile.StoreUint8(&o.MB19_D0.Reg, value)
}
func (o *CAN0_Type) GetMB19_D0() uint8 {
	return volatile.LoadUint8(&o.MB19_D0.Reg)
}

// CAN0.MB19_D1: Mailbox Register
func (o *CAN0_Type) SetMB19_D1(value uint8) {
	volatile.StoreUint8(&o.MB19_D1.Reg, value)
}
func (o *CAN0_Type) GetMB19_D1() uint8 {
	return volatile.LoadUint8(&o.MB19_D1.Reg)
}

// CAN0.MB19_D2: Mailbox Register
func (o *CAN0_Type) SetMB19_D2(value uint8) {
	volatile.StoreUint8(&o.MB19_D2.Reg, value)
}
func (o *CAN0_Type) GetMB19_D2() uint8 {
	return volatile.LoadUint8(&o.MB19_D2.Reg)
}

// CAN0.MB19_D3: Mailbox Register
func (o *CAN0_Type) SetMB19_D3(value uint8) {
	volatile.StoreUint8(&o.MB19_D3.Reg, value)
}
func (o *CAN0_Type) GetMB19_D3() uint8 {
	return volatile.LoadUint8(&o.MB19_D3.Reg)
}

// CAN0.MB19_D4: Mailbox Register
func (o *CAN0_Type) SetMB19_D4(value uint8) {
	volatile.StoreUint8(&o.MB19_D4.Reg, value)
}
func (o *CAN0_Type) GetMB19_D4() uint8 {
	return volatile.LoadUint8(&o.MB19_D4.Reg)
}

// CAN0.MB19_D5: Mailbox Register
func (o *CAN0_Type) SetMB19_D5(value uint8) {
	volatile.StoreUint8(&o.MB19_D5.Reg, value)
}
func (o *CAN0_Type) GetMB19_D5() uint8 {
	return volatile.LoadUint8(&o.MB19_D5.Reg)
}

// CAN0.MB19_D6: Mailbox Register
func (o *CAN0_Type) SetMB19_D6(value uint8) {
	volatile.StoreUint8(&o.MB19_D6.Reg, value)
}
func (o *CAN0_Type) GetMB19_D6() uint8 {
	return volatile.LoadUint8(&o.MB19_D6.Reg)
}

// CAN0.MB19_D7: Mailbox Register
func (o *CAN0_Type) SetMB19_D7(value uint8) {
	volatile.StoreUint8(&o.MB19_D7.Reg, value)
}
func (o *CAN0_Type) GetMB19_D7() uint8 {
	return volatile.LoadUint8(&o.MB19_D7.Reg)
}

// CAN0.MB19_TS: Mailbox Register
func (o *CAN0_Type) SetMB19_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB19_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB19_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB19_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff
}

// CAN0.MB20_ID: Mailbox Register
func (o *CAN0_Type) SetMB20_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB20_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB20_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB20_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB20_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB20_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB20_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB20_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB20_ID.Reg) & 0x3ffff
}

// CAN0.MB20_DL: Mailbox Register
func (o *CAN0_Type) SetMB20_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB20_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB20_DL.Reg) & 0xf
}

// CAN0.MB20_D0: Mailbox Register
func (o *CAN0_Type) SetMB20_D0(value uint8) {
	volatile.StoreUint8(&o.MB20_D0.Reg, value)
}
func (o *CAN0_Type) GetMB20_D0() uint8 {
	return volatile.LoadUint8(&o.MB20_D0.Reg)
}

// CAN0.MB20_D1: Mailbox Register
func (o *CAN0_Type) SetMB20_D1(value uint8) {
	volatile.StoreUint8(&o.MB20_D1.Reg, value)
}
func (o *CAN0_Type) GetMB20_D1() uint8 {
	return volatile.LoadUint8(&o.MB20_D1.Reg)
}

// CAN0.MB20_D2: Mailbox Register
func (o *CAN0_Type) SetMB20_D2(value uint8) {
	volatile.StoreUint8(&o.MB20_D2.Reg, value)
}
func (o *CAN0_Type) GetMB20_D2() uint8 {
	return volatile.LoadUint8(&o.MB20_D2.Reg)
}

// CAN0.MB20_D3: Mailbox Register
func (o *CAN0_Type) SetMB20_D3(value uint8) {
	volatile.StoreUint8(&o.MB20_D3.Reg, value)
}
func (o *CAN0_Type) GetMB20_D3() uint8 {
	return volatile.LoadUint8(&o.MB20_D3.Reg)
}

// CAN0.MB20_D4: Mailbox Register
func (o *CAN0_Type) SetMB20_D4(value uint8) {
	volatile.StoreUint8(&o.MB20_D4.Reg, value)
}
func (o *CAN0_Type) GetMB20_D4() uint8 {
	return volatile.LoadUint8(&o.MB20_D4.Reg)
}

// CAN0.MB20_D5: Mailbox Register
func (o *CAN0_Type) SetMB20_D5(value uint8) {
	volatile.StoreUint8(&o.MB20_D5.Reg, value)
}
func (o *CAN0_Type) GetMB20_D5() uint8 {
	return volatile.LoadUint8(&o.MB20_D5.Reg)
}

// CAN0.MB20_D6: Mailbox Register
func (o *CAN0_Type) SetMB20_D6(value uint8) {
	volatile.StoreUint8(&o.MB20_D6.Reg, value)
}
func (o *CAN0_Type) GetMB20_D6() uint8 {
	return volatile.LoadUint8(&o.MB20_D6.Reg)
}

// CAN0.MB20_D7: Mailbox Register
func (o *CAN0_Type) SetMB20_D7(value uint8) {
	volatile.StoreUint8(&o.MB20_D7.Reg, value)
}
func (o *CAN0_Type) GetMB20_D7() uint8 {
	return volatile.LoadUint8(&o.MB20_D7.Reg)
}

// CAN0.MB20_TS: Mailbox Register
func (o *CAN0_Type) SetMB20_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB20_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB20_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB20_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff
}

// CAN0.MB21_ID: Mailbox Register
func (o *CAN0_Type) SetMB21_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB21_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB21_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB21_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB21_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB21_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB21_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB21_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB21_ID.Reg) & 0x3ffff
}

// CAN0.MB21_DL: Mailbox Register
func (o *CAN0_Type) SetMB21_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB21_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB21_DL.Reg) & 0xf
}

// CAN0.MB21_D0: Mailbox Register
func (o *CAN0_Type) SetMB21_D0(value uint8) {
	volatile.StoreUint8(&o.MB21_D0.Reg, value)
}
func (o *CAN0_Type) GetMB21_D0() uint8 {
	return volatile.LoadUint8(&o.MB21_D0.Reg)
}

// CAN0.MB21_D1: Mailbox Register
func (o *CAN0_Type) SetMB21_D1(value uint8) {
	volatile.StoreUint8(&o.MB21_D1.Reg, value)
}
func (o *CAN0_Type) GetMB21_D1() uint8 {
	return volatile.LoadUint8(&o.MB21_D1.Reg)
}

// CAN0.MB21_D2: Mailbox Register
func (o *CAN0_Type) SetMB21_D2(value uint8) {
	volatile.StoreUint8(&o.MB21_D2.Reg, value)
}
func (o *CAN0_Type) GetMB21_D2() uint8 {
	return volatile.LoadUint8(&o.MB21_D2.Reg)
}

// CAN0.MB21_D3: Mailbox Register
func (o *CAN0_Type) SetMB21_D3(value uint8) {
	volatile.StoreUint8(&o.MB21_D3.Reg, value)
}
func (o *CAN0_Type) GetMB21_D3() uint8 {
	return volatile.LoadUint8(&o.MB21_D3.Reg)
}

// CAN0.MB21_D4: Mailbox Register
func (o *CAN0_Type) SetMB21_D4(value uint8) {
	volatile.StoreUint8(&o.MB21_D4.Reg, value)
}
func (o *CAN0_Type) GetMB21_D4() uint8 {
	return volatile.LoadUint8(&o.MB21_D4.Reg)
}

// CAN0.MB21_D5: Mailbox Register
func (o *CAN0_Type) SetMB21_D5(value uint8) {
	volatile.StoreUint8(&o.MB21_D5.Reg, value)
}
func (o *CAN0_Type) GetMB21_D5() uint8 {
	return volatile.LoadUint8(&o.MB21_D5.Reg)
}

// CAN0.MB21_D6: Mailbox Register
func (o *CAN0_Type) SetMB21_D6(value uint8) {
	volatile.StoreUint8(&o.MB21_D6.Reg, value)
}
func (o *CAN0_Type) GetMB21_D6() uint8 {
	return volatile.LoadUint8(&o.MB21_D6.Reg)
}

// CAN0.MB21_D7: Mailbox Register
func (o *CAN0_Type) SetMB21_D7(value uint8) {
	volatile.StoreUint8(&o.MB21_D7.Reg, value)
}
func (o *CAN0_Type) GetMB21_D7() uint8 {
	return volatile.LoadUint8(&o.MB21_D7.Reg)
}

// CAN0.MB21_TS: Mailbox Register
func (o *CAN0_Type) SetMB21_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB21_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB21_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB21_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff
}

// CAN0.MB22_ID: Mailbox Register
func (o *CAN0_Type) SetMB22_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB22_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB22_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB22_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB22_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB22_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB22_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB22_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB22_ID.Reg) & 0x3ffff
}

// CAN0.MB22_DL: Mailbox Register
func (o *CAN0_Type) SetMB22_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB22_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB22_DL.Reg) & 0xf
}

// CAN0.MB22_D0: Mailbox Register
func (o *CAN0_Type) SetMB22_D0(value uint8) {
	volatile.StoreUint8(&o.MB22_D0.Reg, value)
}
func (o *CAN0_Type) GetMB22_D0() uint8 {
	return volatile.LoadUint8(&o.MB22_D0.Reg)
}

// CAN0.MB22_D1: Mailbox Register
func (o *CAN0_Type) SetMB22_D1(value uint8) {
	volatile.StoreUint8(&o.MB22_D1.Reg, value)
}
func (o *CAN0_Type) GetMB22_D1() uint8 {
	return volatile.LoadUint8(&o.MB22_D1.Reg)
}

// CAN0.MB22_D2: Mailbox Register
func (o *CAN0_Type) SetMB22_D2(value uint8) {
	volatile.StoreUint8(&o.MB22_D2.Reg, value)
}
func (o *CAN0_Type) GetMB22_D2() uint8 {
	return volatile.LoadUint8(&o.MB22_D2.Reg)
}

// CAN0.MB22_D3: Mailbox Register
func (o *CAN0_Type) SetMB22_D3(value uint8) {
	volatile.StoreUint8(&o.MB22_D3.Reg, value)
}
func (o *CAN0_Type) GetMB22_D3() uint8 {
	return volatile.LoadUint8(&o.MB22_D3.Reg)
}

// CAN0.MB22_D4: Mailbox Register
func (o *CAN0_Type) SetMB22_D4(value uint8) {
	volatile.StoreUint8(&o.MB22_D4.Reg, value)
}
func (o *CAN0_Type) GetMB22_D4() uint8 {
	return volatile.LoadUint8(&o.MB22_D4.Reg)
}

// CAN0.MB22_D5: Mailbox Register
func (o *CAN0_Type) SetMB22_D5(value uint8) {
	volatile.StoreUint8(&o.MB22_D5.Reg, value)
}
func (o *CAN0_Type) GetMB22_D5() uint8 {
	return volatile.LoadUint8(&o.MB22_D5.Reg)
}

// CAN0.MB22_D6: Mailbox Register
func (o *CAN0_Type) SetMB22_D6(value uint8) {
	volatile.StoreUint8(&o.MB22_D6.Reg, value)
}
func (o *CAN0_Type) GetMB22_D6() uint8 {
	return volatile.LoadUint8(&o.MB22_D6.Reg)
}

// CAN0.MB22_D7: Mailbox Register
func (o *CAN0_Type) SetMB22_D7(value uint8) {
	volatile.StoreUint8(&o.MB22_D7.Reg, value)
}
func (o *CAN0_Type) GetMB22_D7() uint8 {
	return volatile.LoadUint8(&o.MB22_D7.Reg)
}

// CAN0.MB22_TS: Mailbox Register
func (o *CAN0_Type) SetMB22_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB22_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB22_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB22_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff
}

// CAN0.MB23_ID: Mailbox Register
func (o *CAN0_Type) SetMB23_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB23_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB23_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB23_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB23_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB23_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB23_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB23_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB23_ID.Reg) & 0x3ffff
}

// CAN0.MB23_DL: Mailbox Register
func (o *CAN0_Type) SetMB23_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB23_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB23_DL.Reg) & 0xf
}

// CAN0.MB23_D0: Mailbox Register
func (o *CAN0_Type) SetMB23_D0(value uint8) {
	volatile.StoreUint8(&o.MB23_D0.Reg, value)
}
func (o *CAN0_Type) GetMB23_D0() uint8 {
	return volatile.LoadUint8(&o.MB23_D0.Reg)
}

// CAN0.MB23_D1: Mailbox Register
func (o *CAN0_Type) SetMB23_D1(value uint8) {
	volatile.StoreUint8(&o.MB23_D1.Reg, value)
}
func (o *CAN0_Type) GetMB23_D1() uint8 {
	return volatile.LoadUint8(&o.MB23_D1.Reg)
}

// CAN0.MB23_D2: Mailbox Register
func (o *CAN0_Type) SetMB23_D2(value uint8) {
	volatile.StoreUint8(&o.MB23_D2.Reg, value)
}
func (o *CAN0_Type) GetMB23_D2() uint8 {
	return volatile.LoadUint8(&o.MB23_D2.Reg)
}

// CAN0.MB23_D3: Mailbox Register
func (o *CAN0_Type) SetMB23_D3(value uint8) {
	volatile.StoreUint8(&o.MB23_D3.Reg, value)
}
func (o *CAN0_Type) GetMB23_D3() uint8 {
	return volatile.LoadUint8(&o.MB23_D3.Reg)
}

// CAN0.MB23_D4: Mailbox Register
func (o *CAN0_Type) SetMB23_D4(value uint8) {
	volatile.StoreUint8(&o.MB23_D4.Reg, value)
}
func (o *CAN0_Type) GetMB23_D4() uint8 {
	return volatile.LoadUint8(&o.MB23_D4.Reg)
}

// CAN0.MB23_D5: Mailbox Register
func (o *CAN0_Type) SetMB23_D5(value uint8) {
	volatile.StoreUint8(&o.MB23_D5.Reg, value)
}
func (o *CAN0_Type) GetMB23_D5() uint8 {
	return volatile.LoadUint8(&o.MB23_D5.Reg)
}

// CAN0.MB23_D6: Mailbox Register
func (o *CAN0_Type) SetMB23_D6(value uint8) {
	volatile.StoreUint8(&o.MB23_D6.Reg, value)
}
func (o *CAN0_Type) GetMB23_D6() uint8 {
	return volatile.LoadUint8(&o.MB23_D6.Reg)
}

// CAN0.MB23_D7: Mailbox Register
func (o *CAN0_Type) SetMB23_D7(value uint8) {
	volatile.StoreUint8(&o.MB23_D7.Reg, value)
}
func (o *CAN0_Type) GetMB23_D7() uint8 {
	return volatile.LoadUint8(&o.MB23_D7.Reg)
}

// CAN0.MB23_TS: Mailbox Register
func (o *CAN0_Type) SetMB23_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB23_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB23_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB23_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff
}

// CAN0.MB24_ID: Mailbox Register
func (o *CAN0_Type) SetMB24_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB24_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB24_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB24_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB24_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB24_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB24_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB24_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB24_ID.Reg) & 0x3ffff
}

// CAN0.MB24_DL: Mailbox Register
func (o *CAN0_Type) SetMB24_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB24_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB24_DL.Reg) & 0xf
}

// CAN0.MB24_D0: Mailbox Register
func (o *CAN0_Type) SetMB24_D0(value uint8) {
	volatile.StoreUint8(&o.MB24_D0.Reg, value)
}
func (o *CAN0_Type) GetMB24_D0() uint8 {
	return volatile.LoadUint8(&o.MB24_D0.Reg)
}

// CAN0.MB24_D1: Mailbox Register
func (o *CAN0_Type) SetMB24_D1(value uint8) {
	volatile.StoreUint8(&o.MB24_D1.Reg, value)
}
func (o *CAN0_Type) GetMB24_D1() uint8 {
	return volatile.LoadUint8(&o.MB24_D1.Reg)
}

// CAN0.MB24_D2: Mailbox Register
func (o *CAN0_Type) SetMB24_D2(value uint8) {
	volatile.StoreUint8(&o.MB24_D2.Reg, value)
}
func (o *CAN0_Type) GetMB24_D2() uint8 {
	return volatile.LoadUint8(&o.MB24_D2.Reg)
}

// CAN0.MB24_D3: Mailbox Register
func (o *CAN0_Type) SetMB24_D3(value uint8) {
	volatile.StoreUint8(&o.MB24_D3.Reg, value)
}
func (o *CAN0_Type) GetMB24_D3() uint8 {
	return volatile.LoadUint8(&o.MB24_D3.Reg)
}

// CAN0.MB24_D4: Mailbox Register
func (o *CAN0_Type) SetMB24_D4(value uint8) {
	volatile.StoreUint8(&o.MB24_D4.Reg, value)
}
func (o *CAN0_Type) GetMB24_D4() uint8 {
	return volatile.LoadUint8(&o.MB24_D4.Reg)
}

// CAN0.MB24_D5: Mailbox Register
func (o *CAN0_Type) SetMB24_D5(value uint8) {
	volatile.StoreUint8(&o.MB24_D5.Reg, value)
}
func (o *CAN0_Type) GetMB24_D5() uint8 {
	return volatile.LoadUint8(&o.MB24_D5.Reg)
}

// CAN0.MB24_D6: Mailbox Register
func (o *CAN0_Type) SetMB24_D6(value uint8) {
	volatile.StoreUint8(&o.MB24_D6.Reg, value)
}
func (o *CAN0_Type) GetMB24_D6() uint8 {
	return volatile.LoadUint8(&o.MB24_D6.Reg)
}

// CAN0.MB24_D7: Mailbox Register
func (o *CAN0_Type) SetMB24_D7(value uint8) {
	volatile.StoreUint8(&o.MB24_D7.Reg, value)
}
func (o *CAN0_Type) GetMB24_D7() uint8 {
	return volatile.LoadUint8(&o.MB24_D7.Reg)
}

// CAN0.MB24_TS: Mailbox Register
func (o *CAN0_Type) SetMB24_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB24_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB24_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB24_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff
}

// CAN0.MB25_ID: Mailbox Register
func (o *CAN0_Type) SetMB25_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB25_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB25_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB25_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB25_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB25_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB25_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB25_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB25_ID.Reg) & 0x3ffff
}

// CAN0.MB25_DL: Mailbox Register
func (o *CAN0_Type) SetMB25_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB25_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB25_DL.Reg) & 0xf
}

// CAN0.MB25_D0: Mailbox Register
func (o *CAN0_Type) SetMB25_D0(value uint8) {
	volatile.StoreUint8(&o.MB25_D0.Reg, value)
}
func (o *CAN0_Type) GetMB25_D0() uint8 {
	return volatile.LoadUint8(&o.MB25_D0.Reg)
}

// CAN0.MB25_D1: Mailbox Register
func (o *CAN0_Type) SetMB25_D1(value uint8) {
	volatile.StoreUint8(&o.MB25_D1.Reg, value)
}
func (o *CAN0_Type) GetMB25_D1() uint8 {
	return volatile.LoadUint8(&o.MB25_D1.Reg)
}

// CAN0.MB25_D2: Mailbox Register
func (o *CAN0_Type) SetMB25_D2(value uint8) {
	volatile.StoreUint8(&o.MB25_D2.Reg, value)
}
func (o *CAN0_Type) GetMB25_D2() uint8 {
	return volatile.LoadUint8(&o.MB25_D2.Reg)
}

// CAN0.MB25_D3: Mailbox Register
func (o *CAN0_Type) SetMB25_D3(value uint8) {
	volatile.StoreUint8(&o.MB25_D3.Reg, value)
}
func (o *CAN0_Type) GetMB25_D3() uint8 {
	return volatile.LoadUint8(&o.MB25_D3.Reg)
}

// CAN0.MB25_D4: Mailbox Register
func (o *CAN0_Type) SetMB25_D4(value uint8) {
	volatile.StoreUint8(&o.MB25_D4.Reg, value)
}
func (o *CAN0_Type) GetMB25_D4() uint8 {
	return volatile.LoadUint8(&o.MB25_D4.Reg)
}

// CAN0.MB25_D5: Mailbox Register
func (o *CAN0_Type) SetMB25_D5(value uint8) {
	volatile.StoreUint8(&o.MB25_D5.Reg, value)
}
func (o *CAN0_Type) GetMB25_D5() uint8 {
	return volatile.LoadUint8(&o.MB25_D5.Reg)
}

// CAN0.MB25_D6: Mailbox Register
func (o *CAN0_Type) SetMB25_D6(value uint8) {
	volatile.StoreUint8(&o.MB25_D6.Reg, value)
}
func (o *CAN0_Type) GetMB25_D6() uint8 {
	return volatile.LoadUint8(&o.MB25_D6.Reg)
}

// CAN0.MB25_D7: Mailbox Register
func (o *CAN0_Type) SetMB25_D7(value uint8) {
	volatile.StoreUint8(&o.MB25_D7.Reg, value)
}
func (o *CAN0_Type) GetMB25_D7() uint8 {
	return volatile.LoadUint8(&o.MB25_D7.Reg)
}

// CAN0.MB25_TS: Mailbox Register
func (o *CAN0_Type) SetMB25_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB25_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB25_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB25_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff
}

// CAN0.MB26_ID: Mailbox Register
func (o *CAN0_Type) SetMB26_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB26_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB26_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB26_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB26_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB26_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB26_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB26_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB26_ID.Reg) & 0x3ffff
}

// CAN0.MB26_DL: Mailbox Register
func (o *CAN0_Type) SetMB26_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB26_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB26_DL.Reg) & 0xf
}

// CAN0.MB26_D0: Mailbox Register
func (o *CAN0_Type) SetMB26_D0(value uint8) {
	volatile.StoreUint8(&o.MB26_D0.Reg, value)
}
func (o *CAN0_Type) GetMB26_D0() uint8 {
	return volatile.LoadUint8(&o.MB26_D0.Reg)
}

// CAN0.MB26_D1: Mailbox Register
func (o *CAN0_Type) SetMB26_D1(value uint8) {
	volatile.StoreUint8(&o.MB26_D1.Reg, value)
}
func (o *CAN0_Type) GetMB26_D1() uint8 {
	return volatile.LoadUint8(&o.MB26_D1.Reg)
}

// CAN0.MB26_D2: Mailbox Register
func (o *CAN0_Type) SetMB26_D2(value uint8) {
	volatile.StoreUint8(&o.MB26_D2.Reg, value)
}
func (o *CAN0_Type) GetMB26_D2() uint8 {
	return volatile.LoadUint8(&o.MB26_D2.Reg)
}

// CAN0.MB26_D3: Mailbox Register
func (o *CAN0_Type) SetMB26_D3(value uint8) {
	volatile.StoreUint8(&o.MB26_D3.Reg, value)
}
func (o *CAN0_Type) GetMB26_D3() uint8 {
	return volatile.LoadUint8(&o.MB26_D3.Reg)
}

// CAN0.MB26_D4: Mailbox Register
func (o *CAN0_Type) SetMB26_D4(value uint8) {
	volatile.StoreUint8(&o.MB26_D4.Reg, value)
}
func (o *CAN0_Type) GetMB26_D4() uint8 {
	return volatile.LoadUint8(&o.MB26_D4.Reg)
}

// CAN0.MB26_D5: Mailbox Register
func (o *CAN0_Type) SetMB26_D5(value uint8) {
	volatile.StoreUint8(&o.MB26_D5.Reg, value)
}
func (o *CAN0_Type) GetMB26_D5() uint8 {
	return volatile.LoadUint8(&o.MB26_D5.Reg)
}

// CAN0.MB26_D6: Mailbox Register
func (o *CAN0_Type) SetMB26_D6(value uint8) {
	volatile.StoreUint8(&o.MB26_D6.Reg, value)
}
func (o *CAN0_Type) GetMB26_D6() uint8 {
	return volatile.LoadUint8(&o.MB26_D6.Reg)
}

// CAN0.MB26_D7: Mailbox Register
func (o *CAN0_Type) SetMB26_D7(value uint8) {
	volatile.StoreUint8(&o.MB26_D7.Reg, value)
}
func (o *CAN0_Type) GetMB26_D7() uint8 {
	return volatile.LoadUint8(&o.MB26_D7.Reg)
}

// CAN0.MB26_TS: Mailbox Register
func (o *CAN0_Type) SetMB26_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB26_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB26_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB26_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff
}

// CAN0.MB27_ID: Mailbox Register
func (o *CAN0_Type) SetMB27_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB27_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB27_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB27_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB27_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB27_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB27_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB27_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB27_ID.Reg) & 0x3ffff
}

// CAN0.MB27_DL: Mailbox Register
func (o *CAN0_Type) SetMB27_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB27_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB27_DL.Reg) & 0xf
}

// CAN0.MB27_D0: Mailbox Register
func (o *CAN0_Type) SetMB27_D0(value uint8) {
	volatile.StoreUint8(&o.MB27_D0.Reg, value)
}
func (o *CAN0_Type) GetMB27_D0() uint8 {
	return volatile.LoadUint8(&o.MB27_D0.Reg)
}

// CAN0.MB27_D1: Mailbox Register
func (o *CAN0_Type) SetMB27_D1(value uint8) {
	volatile.StoreUint8(&o.MB27_D1.Reg, value)
}
func (o *CAN0_Type) GetMB27_D1() uint8 {
	return volatile.LoadUint8(&o.MB27_D1.Reg)
}

// CAN0.MB27_D2: Mailbox Register
func (o *CAN0_Type) SetMB27_D2(value uint8) {
	volatile.StoreUint8(&o.MB27_D2.Reg, value)
}
func (o *CAN0_Type) GetMB27_D2() uint8 {
	return volatile.LoadUint8(&o.MB27_D2.Reg)
}

// CAN0.MB27_D3: Mailbox Register
func (o *CAN0_Type) SetMB27_D3(value uint8) {
	volatile.StoreUint8(&o.MB27_D3.Reg, value)
}
func (o *CAN0_Type) GetMB27_D3() uint8 {
	return volatile.LoadUint8(&o.MB27_D3.Reg)
}

// CAN0.MB27_D4: Mailbox Register
func (o *CAN0_Type) SetMB27_D4(value uint8) {
	volatile.StoreUint8(&o.MB27_D4.Reg, value)
}
func (o *CAN0_Type) GetMB27_D4() uint8 {
	return volatile.LoadUint8(&o.MB27_D4.Reg)
}

// CAN0.MB27_D5: Mailbox Register
func (o *CAN0_Type) SetMB27_D5(value uint8) {
	volatile.StoreUint8(&o.MB27_D5.Reg, value)
}
func (o *CAN0_Type) GetMB27_D5() uint8 {
	return volatile.LoadUint8(&o.MB27_D5.Reg)
}

// CAN0.MB27_D6: Mailbox Register
func (o *CAN0_Type) SetMB27_D6(value uint8) {
	volatile.StoreUint8(&o.MB27_D6.Reg, value)
}
func (o *CAN0_Type) GetMB27_D6() uint8 {
	return volatile.LoadUint8(&o.MB27_D6.Reg)
}

// CAN0.MB27_D7: Mailbox Register
func (o *CAN0_Type) SetMB27_D7(value uint8) {
	volatile.StoreUint8(&o.MB27_D7.Reg, value)
}
func (o *CAN0_Type) GetMB27_D7() uint8 {
	return volatile.LoadUint8(&o.MB27_D7.Reg)
}

// CAN0.MB27_TS: Mailbox Register
func (o *CAN0_Type) SetMB27_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB27_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB27_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB27_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff
}

// CAN0.MB28_ID: Mailbox Register
func (o *CAN0_Type) SetMB28_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB28_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB28_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB28_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB28_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB28_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB28_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB28_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB28_ID.Reg) & 0x3ffff
}

// CAN0.MB28_DL: Mailbox Register
func (o *CAN0_Type) SetMB28_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB28_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB28_DL.Reg) & 0xf
}

// CAN0.MB28_D0: Mailbox Register
func (o *CAN0_Type) SetMB28_D0(value uint8) {
	volatile.StoreUint8(&o.MB28_D0.Reg, value)
}
func (o *CAN0_Type) GetMB28_D0() uint8 {
	return volatile.LoadUint8(&o.MB28_D0.Reg)
}

// CAN0.MB28_D1: Mailbox Register
func (o *CAN0_Type) SetMB28_D1(value uint8) {
	volatile.StoreUint8(&o.MB28_D1.Reg, value)
}
func (o *CAN0_Type) GetMB28_D1() uint8 {
	return volatile.LoadUint8(&o.MB28_D1.Reg)
}

// CAN0.MB28_D2: Mailbox Register
func (o *CAN0_Type) SetMB28_D2(value uint8) {
	volatile.StoreUint8(&o.MB28_D2.Reg, value)
}
func (o *CAN0_Type) GetMB28_D2() uint8 {
	return volatile.LoadUint8(&o.MB28_D2.Reg)
}

// CAN0.MB28_D3: Mailbox Register
func (o *CAN0_Type) SetMB28_D3(value uint8) {
	volatile.StoreUint8(&o.MB28_D3.Reg, value)
}
func (o *CAN0_Type) GetMB28_D3() uint8 {
	return volatile.LoadUint8(&o.MB28_D3.Reg)
}

// CAN0.MB28_D4: Mailbox Register
func (o *CAN0_Type) SetMB28_D4(value uint8) {
	volatile.StoreUint8(&o.MB28_D4.Reg, value)
}
func (o *CAN0_Type) GetMB28_D4() uint8 {
	return volatile.LoadUint8(&o.MB28_D4.Reg)
}

// CAN0.MB28_D5: Mailbox Register
func (o *CAN0_Type) SetMB28_D5(value uint8) {
	volatile.StoreUint8(&o.MB28_D5.Reg, value)
}
func (o *CAN0_Type) GetMB28_D5() uint8 {
	return volatile.LoadUint8(&o.MB28_D5.Reg)
}

// CAN0.MB28_D6: Mailbox Register
func (o *CAN0_Type) SetMB28_D6(value uint8) {
	volatile.StoreUint8(&o.MB28_D6.Reg, value)
}
func (o *CAN0_Type) GetMB28_D6() uint8 {
	return volatile.LoadUint8(&o.MB28_D6.Reg)
}

// CAN0.MB28_D7: Mailbox Register
func (o *CAN0_Type) SetMB28_D7(value uint8) {
	volatile.StoreUint8(&o.MB28_D7.Reg, value)
}
func (o *CAN0_Type) GetMB28_D7() uint8 {
	return volatile.LoadUint8(&o.MB28_D7.Reg)
}

// CAN0.MB28_TS: Mailbox Register
func (o *CAN0_Type) SetMB28_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB28_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB28_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB28_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff
}

// CAN0.MB29_ID: Mailbox Register
func (o *CAN0_Type) SetMB29_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB29_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB29_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB29_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB29_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB29_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB29_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB29_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB29_ID.Reg) & 0x3ffff
}

// CAN0.MB29_DL: Mailbox Register
func (o *CAN0_Type) SetMB29_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB29_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB29_DL.Reg) & 0xf
}

// CAN0.MB29_D0: Mailbox Register
func (o *CAN0_Type) SetMB29_D0(value uint8) {
	volatile.StoreUint8(&o.MB29_D0.Reg, value)
}
func (o *CAN0_Type) GetMB29_D0() uint8 {
	return volatile.LoadUint8(&o.MB29_D0.Reg)
}

// CAN0.MB29_D1: Mailbox Register
func (o *CAN0_Type) SetMB29_D1(value uint8) {
	volatile.StoreUint8(&o.MB29_D1.Reg, value)
}
func (o *CAN0_Type) GetMB29_D1() uint8 {
	return volatile.LoadUint8(&o.MB29_D1.Reg)
}

// CAN0.MB29_D2: Mailbox Register
func (o *CAN0_Type) SetMB29_D2(value uint8) {
	volatile.StoreUint8(&o.MB29_D2.Reg, value)
}
func (o *CAN0_Type) GetMB29_D2() uint8 {
	return volatile.LoadUint8(&o.MB29_D2.Reg)
}

// CAN0.MB29_D3: Mailbox Register
func (o *CAN0_Type) SetMB29_D3(value uint8) {
	volatile.StoreUint8(&o.MB29_D3.Reg, value)
}
func (o *CAN0_Type) GetMB29_D3() uint8 {
	return volatile.LoadUint8(&o.MB29_D3.Reg)
}

// CAN0.MB29_D4: Mailbox Register
func (o *CAN0_Type) SetMB29_D4(value uint8) {
	volatile.StoreUint8(&o.MB29_D4.Reg, value)
}
func (o *CAN0_Type) GetMB29_D4() uint8 {
	return volatile.LoadUint8(&o.MB29_D4.Reg)
}

// CAN0.MB29_D5: Mailbox Register
func (o *CAN0_Type) SetMB29_D5(value uint8) {
	volatile.StoreUint8(&o.MB29_D5.Reg, value)
}
func (o *CAN0_Type) GetMB29_D5() uint8 {
	return volatile.LoadUint8(&o.MB29_D5.Reg)
}

// CAN0.MB29_D6: Mailbox Register
func (o *CAN0_Type) SetMB29_D6(value uint8) {
	volatile.StoreUint8(&o.MB29_D6.Reg, value)
}
func (o *CAN0_Type) GetMB29_D6() uint8 {
	return volatile.LoadUint8(&o.MB29_D6.Reg)
}

// CAN0.MB29_D7: Mailbox Register
func (o *CAN0_Type) SetMB29_D7(value uint8) {
	volatile.StoreUint8(&o.MB29_D7.Reg, value)
}
func (o *CAN0_Type) GetMB29_D7() uint8 {
	return volatile.LoadUint8(&o.MB29_D7.Reg)
}

// CAN0.MB29_TS: Mailbox Register
func (o *CAN0_Type) SetMB29_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB29_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB29_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB29_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff
}

// CAN0.MB30_ID: Mailbox Register
func (o *CAN0_Type) SetMB30_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB30_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB30_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB30_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB30_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB30_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB30_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB30_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB30_ID.Reg) & 0x3ffff
}

// CAN0.MB30_DL: Mailbox Register
func (o *CAN0_Type) SetMB30_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB30_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB30_DL.Reg) & 0xf
}

// CAN0.MB30_D0: Mailbox Register
func (o *CAN0_Type) SetMB30_D0(value uint8) {
	volatile.StoreUint8(&o.MB30_D0.Reg, value)
}
func (o *CAN0_Type) GetMB30_D0() uint8 {
	return volatile.LoadUint8(&o.MB30_D0.Reg)
}

// CAN0.MB30_D1: Mailbox Register
func (o *CAN0_Type) SetMB30_D1(value uint8) {
	volatile.StoreUint8(&o.MB30_D1.Reg, value)
}
func (o *CAN0_Type) GetMB30_D1() uint8 {
	return volatile.LoadUint8(&o.MB30_D1.Reg)
}

// CAN0.MB30_D2: Mailbox Register
func (o *CAN0_Type) SetMB30_D2(value uint8) {
	volatile.StoreUint8(&o.MB30_D2.Reg, value)
}
func (o *CAN0_Type) GetMB30_D2() uint8 {
	return volatile.LoadUint8(&o.MB30_D2.Reg)
}

// CAN0.MB30_D3: Mailbox Register
func (o *CAN0_Type) SetMB30_D3(value uint8) {
	volatile.StoreUint8(&o.MB30_D3.Reg, value)
}
func (o *CAN0_Type) GetMB30_D3() uint8 {
	return volatile.LoadUint8(&o.MB30_D3.Reg)
}

// CAN0.MB30_D4: Mailbox Register
func (o *CAN0_Type) SetMB30_D4(value uint8) {
	volatile.StoreUint8(&o.MB30_D4.Reg, value)
}
func (o *CAN0_Type) GetMB30_D4() uint8 {
	return volatile.LoadUint8(&o.MB30_D4.Reg)
}

// CAN0.MB30_D5: Mailbox Register
func (o *CAN0_Type) SetMB30_D5(value uint8) {
	volatile.StoreUint8(&o.MB30_D5.Reg, value)
}
func (o *CAN0_Type) GetMB30_D5() uint8 {
	return volatile.LoadUint8(&o.MB30_D5.Reg)
}

// CAN0.MB30_D6: Mailbox Register
func (o *CAN0_Type) SetMB30_D6(value uint8) {
	volatile.StoreUint8(&o.MB30_D6.Reg, value)
}
func (o *CAN0_Type) GetMB30_D6() uint8 {
	return volatile.LoadUint8(&o.MB30_D6.Reg)
}

// CAN0.MB30_D7: Mailbox Register
func (o *CAN0_Type) SetMB30_D7(value uint8) {
	volatile.StoreUint8(&o.MB30_D7.Reg, value)
}
func (o *CAN0_Type) GetMB30_D7() uint8 {
	return volatile.LoadUint8(&o.MB30_D7.Reg)
}

// CAN0.MB30_TS: Mailbox Register
func (o *CAN0_Type) SetMB30_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB30_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB30_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB30_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff
}

// CAN0.MB31_ID: Mailbox Register
func (o *CAN0_Type) SetMB31_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB31_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB31_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB31_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB31_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB31_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB31_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB31_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB31_ID.Reg) & 0x3ffff
}

// CAN0.MB31_DL: Mailbox Register
func (o *CAN0_Type) SetMB31_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB31_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB31_DL.Reg) & 0xf
}

// CAN0.MB31_D0: Mailbox Register
func (o *CAN0_Type) SetMB31_D0(value uint8) {
	volatile.StoreUint8(&o.MB31_D0.Reg, value)
}
func (o *CAN0_Type) GetMB31_D0() uint8 {
	return volatile.LoadUint8(&o.MB31_D0.Reg)
}

// CAN0.MB31_D1: Mailbox Register
func (o *CAN0_Type) SetMB31_D1(value uint8) {
	volatile.StoreUint8(&o.MB31_D1.Reg, value)
}
func (o *CAN0_Type) GetMB31_D1() uint8 {
	return volatile.LoadUint8(&o.MB31_D1.Reg)
}

// CAN0.MB31_D2: Mailbox Register
func (o *CAN0_Type) SetMB31_D2(value uint8) {
	volatile.StoreUint8(&o.MB31_D2.Reg, value)
}
func (o *CAN0_Type) GetMB31_D2() uint8 {
	return volatile.LoadUint8(&o.MB31_D2.Reg)
}

// CAN0.MB31_D3: Mailbox Register
func (o *CAN0_Type) SetMB31_D3(value uint8) {
	volatile.StoreUint8(&o.MB31_D3.Reg, value)
}
func (o *CAN0_Type) GetMB31_D3() uint8 {
	return volatile.LoadUint8(&o.MB31_D3.Reg)
}

// CAN0.MB31_D4: Mailbox Register
func (o *CAN0_Type) SetMB31_D4(value uint8) {
	volatile.StoreUint8(&o.MB31_D4.Reg, value)
}
func (o *CAN0_Type) GetMB31_D4() uint8 {
	return volatile.LoadUint8(&o.MB31_D4.Reg)
}

// CAN0.MB31_D5: Mailbox Register
func (o *CAN0_Type) SetMB31_D5(value uint8) {
	volatile.StoreUint8(&o.MB31_D5.Reg, value)
}
func (o *CAN0_Type) GetMB31_D5() uint8 {
	return volatile.LoadUint8(&o.MB31_D5.Reg)
}

// CAN0.MB31_D6: Mailbox Register
func (o *CAN0_Type) SetMB31_D6(value uint8) {
	volatile.StoreUint8(&o.MB31_D6.Reg, value)
}
func (o *CAN0_Type) GetMB31_D6() uint8 {
	return volatile.LoadUint8(&o.MB31_D6.Reg)
}

// CAN0.MB31_D7: Mailbox Register
func (o *CAN0_Type) SetMB31_D7(value uint8) {
	volatile.StoreUint8(&o.MB31_D7.Reg, value)
}
func (o *CAN0_Type) GetMB31_D7() uint8 {
	return volatile.LoadUint8(&o.MB31_D7.Reg)
}

// CAN0.MB31_TS: Mailbox Register
func (o *CAN0_Type) SetMB31_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB31_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB31_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB31_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff
}

// CAN0.MKR: Mask Register
func (o *CAN0_Type) SetMKR_SID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMKR_SID(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMKR_EID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMKR_EID(idx int) uint32 {
	return volatile.LoadUint32(&o.MKR[idx].Reg) & 0x3ffff
}

// CAN0.FIDCR0: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR0_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR0_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR0_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR0_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR0_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR0_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR0_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR0_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR0.Reg) & 0x3ffff
}

// CAN0.FIDCR1: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR1_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR1_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR1_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR1_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR1_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR1_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR1_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR1_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR1.Reg) & 0x3ffff
}

// CAN0.MKIVLR: Mask Invalid Register
func (o *CAN0_Type) SetMKIVLR_MB31(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMKIVLR_MB31() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMKIVLR_MB30(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMKIVLR_MB30() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMKIVLR_MB29(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMKIVLR_MB29() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMKIVLR_MB28(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMKIVLR_MB28() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMKIVLR_MB27(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMKIVLR_MB27() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMKIVLR_MB26(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMKIVLR_MB26() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMKIVLR_MB25(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMKIVLR_MB25() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMKIVLR_MB24(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMKIVLR_MB24() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMKIVLR_MB23(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMKIVLR_MB23() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMKIVLR_MB22(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMKIVLR_MB22() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMKIVLR_MB21(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMKIVLR_MB21() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMKIVLR_MB20(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMKIVLR_MB20() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMKIVLR_MB19(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMKIVLR_MB19() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMKIVLR_MB18(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMKIVLR_MB18() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMKIVLR_MB17(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMKIVLR_MB17() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMKIVLR_MB16(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMKIVLR_MB16() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMKIVLR_MB15(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMKIVLR_MB15() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMKIVLR_MB14(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMKIVLR_MB14() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMKIVLR_MB13(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMKIVLR_MB13() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMKIVLR_MB12(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMKIVLR_MB12() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMKIVLR_MB11(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMKIVLR_MB11() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMKIVLR_MB10(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMKIVLR_MB10() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMKIVLR_MB9(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMKIVLR_MB9() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMKIVLR_MB8(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMKIVLR_MB8() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMKIVLR_MB7(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMKIVLR_MB7() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMKIVLR_MB6(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMKIVLR_MB6() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMKIVLR_MB5(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMKIVLR_MB5() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMKIVLR_MB4(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMKIVLR_MB4() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMKIVLR_MB3(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMKIVLR_MB3() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMKIVLR_MB2(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMKIVLR_MB2() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMKIVLR_MB1(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMKIVLR_MB1() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMKIVLR_MB0(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMKIVLR_MB0() uint32 {
	return volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1
}

// CAN0.MIER: Mailbox Interrupt Enable Register
func (o *CAN0_Type) SetMIER_MB31(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMIER_MB31() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMIER_MB30(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMIER_MB30() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMIER_MB29(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMIER_MB29() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMIER_MB28(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMIER_MB28() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMIER_MB27(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMIER_MB27() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMIER_MB26(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMIER_MB26() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMIER_MB25(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMIER_MB25() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMIER_MB24(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMIER_MB24() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMIER_MB23(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMIER_MB23() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMIER_MB22(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMIER_MB22() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMIER_MB21(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMIER_MB21() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMIER_MB20(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMIER_MB20() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMIER_MB19(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMIER_MB19() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMIER_MB18(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMIER_MB18() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMIER_MB17(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMIER_MB17() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMIER_MB16(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMIER_MB16() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMIER_MB15(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMIER_MB15() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMIER_MB14(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMIER_MB14() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMIER_MB13(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMIER_MB13() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMIER_MB12(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMIER_MB12() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMIER_MB11(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMIER_MB11() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMIER_MB10(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMIER_MB10() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMIER_MB9(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMIER_MB9() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMIER_MB8(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMIER_MB8() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMIER_MB7(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMIER_MB7() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMIER_MB6(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMIER_MB6() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMIER_MB5(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMIER_MB5() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMIER_MB4(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMIER_MB4() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMIER_MB3(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMIER_MB3() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMIER_MB2(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMIER_MB2() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMIER_MB1(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMIER_MB1() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMIER_MB0(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMIER_MB0() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}

// CAN0.MCTL_TX: Message Control Register for Transmit
func (o *CAN0_Type) SetMCTL_TX_TRMREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMCTL_TX_TRMREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMCTL_TX_RECREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMCTL_TX_RECREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMCTL_TX_ONESHOT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMCTL_TX_ONESHOT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMCTL_TX_TRMABT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMCTL_TX_TRMABT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMCTL_TX_TRMACTIVE(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMCTL_TX_TRMACTIVE(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMCTL_TX_SENTDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMCTL_TX_SENTDATA(idx int) uint8 {
	return volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x1
}

// CAN0.CTLR: Control Register
func (o *CAN0_Type) SetCTLR_RBOC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTLR_RBOC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetCTLR_BOM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1800)|value<<11)
}
func (o *CAN0_Type) GetCTLR_BOM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x1800) >> 11
}
func (o *CAN0_Type) SetCTLR_SLPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTLR_SLPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTLR_CANM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetCTLR_CANM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetCTLR_TSPS(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc0)|value<<6)
}
func (o *CAN0_Type) GetCTLR_TSPS() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc0) >> 6
}
func (o *CAN0_Type) SetCTLR_TSRC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTLR_TSRC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTLR_TPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTLR_TPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTLR_MLM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTLR_MLM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTLR_IDFM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetCTLR_IDFM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetCTLR_MBM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetCTLR_MBM() uint16 {
	return volatile.LoadUint16(&o.CTLR.Reg) & 0x1
}

// CAN0.STR: Status Register
func (o *CAN0_Type) SetSTR_RECST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetSTR_RECST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetSTR_TRMST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetSTR_TRMST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetSTR_BOST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetSTR_BOST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetSTR_EPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetSTR_EPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetSTR_SLPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetSTR_SLPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetSTR_HLTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetSTR_HLTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetSTR_RSTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetSTR_RSTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetSTR_EST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetSTR_EST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetSTR_TABST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetSTR_TABST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetSTR_FMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetSTR_FMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetSTR_NMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetSTR_NMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetSTR_TFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetSTR_TFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetSTR_RFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetSTR_RFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetSTR_SDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetSTR_SDST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetSTR_NDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetSTR_NDST() uint16 {
	return volatile.LoadUint16(&o.STR.Reg) & 0x1
}

// CAN0.BCR: Bit Configuration Register
func (o *CAN0_Type) SetBCR_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAN0_Type) GetBCR_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xf0000000) >> 28
}
func (o *CAN0_Type) SetBCR_BRP(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *CAN0_Type) GetBCR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3ff0000) >> 16
}
func (o *CAN0_Type) SetBCR_SJW(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN0_Type) GetBCR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3000) >> 12
}
func (o *CAN0_Type) SetBCR_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x700)|value<<8)
}
func (o *CAN0_Type) GetBCR_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x700) >> 8
}
func (o *CAN0_Type) SetBCR_CCLKS(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetBCR_CCLKS() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// CAN0.RFCR: Receive FIFO Control Register
func (o *CAN0_Type) SetRFCR_RFEST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRFCR_RFEST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRFCR_RFWST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRFCR_RFWST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRFCR_RFFST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRFCR_RFFST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRFCR_RFMLF(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRFCR_RFMLF() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRFCR_RFUST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetRFCR_RFUST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetRFCR_RFE(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRFCR_RFE() uint8 {
	return volatile.LoadUint8(&o.RFCR.Reg) & 0x1
}

// CAN0.RFPCR: Receive FIFO Pointer Control Register
func (o *CAN0_Type) SetRFPCR(value uint8) {
	volatile.StoreUint8(&o.RFPCR.Reg, value)
}
func (o *CAN0_Type) GetRFPCR() uint8 {
	return volatile.LoadUint8(&o.RFPCR.Reg)
}

// CAN0.TFCR: Transmit FIFO Control Register
func (o *CAN0_Type) SetTFCR_TFEST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetTFCR_TFEST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetTFCR_TFFST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetTFCR_TFFST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetTFCR_TFUST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetTFCR_TFUST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetTFCR_TFE(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTFCR_TFE() uint8 {
	return volatile.LoadUint8(&o.TFCR.Reg) & 0x1
}

// CAN0.TFPCR: Transmit FIFO Pointer Control Register
func (o *CAN0_Type) SetTFPCR(value uint8) {
	volatile.StoreUint8(&o.TFPCR.Reg, value)
}
func (o *CAN0_Type) GetTFPCR() uint8 {
	return volatile.LoadUint8(&o.TFPCR.Reg)
}

// CAN0.EIER: Error Interrupt Enable Register
func (o *CAN0_Type) SetEIER_BLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIER_BLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIER_OLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIER_OLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIER_ORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIER_ORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIER_BORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIER_BORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIER_BOEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIER_BOEIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIER_EPIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIER_EPIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIER_EWIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIER_EWIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIER_BEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIER_BEIE() uint8 {
	return volatile.LoadUint8(&o.EIER.Reg) & 0x1
}

// CAN0.EIFR: Error Interrupt Factor Judge Register
func (o *CAN0_Type) SetEIFR_BLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIFR_BLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIFR_OLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIFR_OLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIFR_ORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIFR_ORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIFR_BORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIFR_BORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIFR_BOEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIFR_BOEIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIFR_EPIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIFR_EPIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIFR_EWIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIFR_EWIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIFR_BEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIFR_BEIF() uint8 {
	return volatile.LoadUint8(&o.EIFR.Reg) & 0x1
}

// CAN0.RECR: Receive Error Count Register
func (o *CAN0_Type) SetRECR(value uint8) {
	volatile.StoreUint8(&o.RECR.Reg, value)
}
func (o *CAN0_Type) GetRECR() uint8 {
	return volatile.LoadUint8(&o.RECR.Reg)
}

// CAN0.TECR: Transmit Error Count Register
func (o *CAN0_Type) SetTECR(value uint8) {
	volatile.StoreUint8(&o.TECR.Reg, value)
}
func (o *CAN0_Type) GetTECR() uint8 {
	return volatile.LoadUint8(&o.TECR.Reg)
}

// CAN0.ECSR: Error Code Store Register
func (o *CAN0_Type) SetECSR_EDPM(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetECSR_EDPM() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetECSR_ADEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetECSR_ADEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetECSR_BE0F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetECSR_BE0F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetECSR_BE1F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetECSR_BE1F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetECSR_CEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetECSR_CEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetECSR_AEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetECSR_AEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetECSR_FEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetECSR_FEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetECSR_SEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetECSR_SEF() uint8 {
	return volatile.LoadUint8(&o.ECSR.Reg) & 0x1
}

// CAN0.CSSR: Channel Search Support Register
func (o *CAN0_Type) SetCSSR(value uint8) {
	volatile.StoreUint8(&o.CSSR.Reg, value)
}
func (o *CAN0_Type) GetCSSR() uint8 {
	return volatile.LoadUint8(&o.CSSR.Reg)
}

// CAN0.MSSR: Mailbox Search Status Register
func (o *CAN0_Type) SetMSSR_SEST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMSSR_SEST() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMSSR_MBNST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x1f)|value)
}
func (o *CAN0_Type) GetMSSR_MBNST() uint8 {
	return volatile.LoadUint8(&o.MSSR.Reg) & 0x1f
}

// CAN0.MSMR: Mailbox Search Mode Register
func (o *CAN0_Type) SetMSMR_MBSM(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0x3)|value)
}
func (o *CAN0_Type) GetMSMR_MBSM() uint8 {
	return volatile.LoadUint8(&o.MSMR.Reg) & 0x3
}

// CAN0.TSR: Time Stamp Register
func (o *CAN0_Type) SetTSR(value uint16) {
	volatile.StoreUint16(&o.TSR.Reg, value)
}
func (o *CAN0_Type) GetTSR() uint16 {
	return volatile.LoadUint16(&o.TSR.Reg)
}

// CAN0.AFSR: Acceptance Filter Support Register
func (o *CAN0_Type) SetAFSR(value uint16) {
	volatile.StoreUint16(&o.AFSR.Reg, value)
}
func (o *CAN0_Type) GetAFSR() uint16 {
	return volatile.LoadUint16(&o.AFSR.Reg)
}

// CAN0.TCR: Test Control Register
func (o *CAN0_Type) SetTCR_TSTM(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetTCR_TSTM() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetTCR_TSTE(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTCR_TSTE() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}

// Parallel Data Capture Unit
type PDC_Type struct {
	PCCR0  volatile.Register32 // 0x0
	PCCR1  volatile.Register32 // 0x4
	PCSR   volatile.Register32 // 0x8
	PCMONR volatile.Register32 // 0xC
	PCDR   volatile.Register32 // 0x10
	VCR    volatile.Register32 // 0x14
	HCR    volatile.Register32 // 0x18
}

// PDC.PCCR0: PDC Control Register 0
func (o *PDC_Type) SetPCCR0_EDS(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x4000)|value<<14)
}
func (o *PDC_Type) GetPCCR0_EDS() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x4000) >> 14
}
func (o *PDC_Type) SetPCCR0_PCKDIV(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x3800)|value<<11)
}
func (o *PDC_Type) GetPCCR0_PCKDIV() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x3800) >> 11
}
func (o *PDC_Type) SetPCCR0_PCKOE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x400)|value<<10)
}
func (o *PDC_Type) GetPCCR0_PCKOE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x400) >> 10
}
func (o *PDC_Type) SetPCCR0_HERIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x200)|value<<9)
}
func (o *PDC_Type) GetPCCR0_HERIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x200) >> 9
}
func (o *PDC_Type) SetPCCR0_VERIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x100)|value<<8)
}
func (o *PDC_Type) GetPCCR0_VERIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x100) >> 8
}
func (o *PDC_Type) SetPCCR0_UDRIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x80)|value<<7)
}
func (o *PDC_Type) GetPCCR0_UDRIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x80) >> 7
}
func (o *PDC_Type) SetPCCR0_OVIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x40)|value<<6)
}
func (o *PDC_Type) GetPCCR0_OVIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x40) >> 6
}
func (o *PDC_Type) SetPCCR0_FEIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x20)|value<<5)
}
func (o *PDC_Type) GetPCCR0_FEIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x20) >> 5
}
func (o *PDC_Type) SetPCCR0_DFIE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x10)|value<<4)
}
func (o *PDC_Type) GetPCCR0_DFIE() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x10) >> 4
}
func (o *PDC_Type) SetPCCR0_PRST(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x8)|value<<3)
}
func (o *PDC_Type) GetPCCR0_PRST() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x8) >> 3
}
func (o *PDC_Type) SetPCCR0_HPS(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x4)|value<<2)
}
func (o *PDC_Type) GetPCCR0_HPS() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x4) >> 2
}
func (o *PDC_Type) SetPCCR0_VPS(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x2)|value<<1)
}
func (o *PDC_Type) GetPCCR0_VPS() uint32 {
	return (volatile.LoadUint32(&o.PCCR0.Reg) & 0x2) >> 1
}
func (o *PDC_Type) SetPCCR0_PCKE(value uint32) {
	volatile.StoreUint32(&o.PCCR0.Reg, volatile.LoadUint32(&o.PCCR0.Reg)&^(0x1)|value)
}
func (o *PDC_Type) GetPCCR0_PCKE() uint32 {
	return volatile.LoadUint32(&o.PCCR0.Reg) & 0x1
}

// PDC.PCCR1: PDC Control Register 1
func (o *PDC_Type) SetPCCR1_PCE(value uint32) {
	volatile.StoreUint32(&o.PCCR1.Reg, volatile.LoadUint32(&o.PCCR1.Reg)&^(0x1)|value)
}
func (o *PDC_Type) GetPCCR1_PCE() uint32 {
	return volatile.LoadUint32(&o.PCCR1.Reg) & 0x1
}

// PDC.PCSR: PDC Status Register
func (o *PDC_Type) SetPCSR_HERF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x40)|value<<6)
}
func (o *PDC_Type) GetPCSR_HERF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x40) >> 6
}
func (o *PDC_Type) SetPCSR_VERF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x20)|value<<5)
}
func (o *PDC_Type) GetPCSR_VERF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x20) >> 5
}
func (o *PDC_Type) SetPCSR_UDRF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x10)|value<<4)
}
func (o *PDC_Type) GetPCSR_UDRF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x10) >> 4
}
func (o *PDC_Type) SetPCSR_OVRF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x8)|value<<3)
}
func (o *PDC_Type) GetPCSR_OVRF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x8) >> 3
}
func (o *PDC_Type) SetPCSR_FEF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x4)|value<<2)
}
func (o *PDC_Type) GetPCSR_FEF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x4) >> 2
}
func (o *PDC_Type) SetPCSR_FEMPF(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x2)|value<<1)
}
func (o *PDC_Type) GetPCSR_FEMPF() uint32 {
	return (volatile.LoadUint32(&o.PCSR.Reg) & 0x2) >> 1
}
func (o *PDC_Type) SetPCSR_FBSY(value uint32) {
	volatile.StoreUint32(&o.PCSR.Reg, volatile.LoadUint32(&o.PCSR.Reg)&^(0x1)|value)
}
func (o *PDC_Type) GetPCSR_FBSY() uint32 {
	return volatile.LoadUint32(&o.PCSR.Reg) & 0x1
}

// PDC.PCMONR: PDC Pin Monitor Register
func (o *PDC_Type) SetPCMONR_HSYNC(value uint32) {
	volatile.StoreUint32(&o.PCMONR.Reg, volatile.LoadUint32(&o.PCMONR.Reg)&^(0x2)|value<<1)
}
func (o *PDC_Type) GetPCMONR_HSYNC() uint32 {
	return (volatile.LoadUint32(&o.PCMONR.Reg) & 0x2) >> 1
}
func (o *PDC_Type) SetPCMONR_VSYNC(value uint32) {
	volatile.StoreUint32(&o.PCMONR.Reg, volatile.LoadUint32(&o.PCMONR.Reg)&^(0x1)|value)
}
func (o *PDC_Type) GetPCMONR_VSYNC() uint32 {
	return volatile.LoadUint32(&o.PCMONR.Reg) & 0x1
}

// PDC.PCDR: PDC Receive Data Register
func (o *PDC_Type) SetPCDR(value uint32) {
	volatile.StoreUint32(&o.PCDR.Reg, value)
}
func (o *PDC_Type) GetPCDR() uint32 {
	return volatile.LoadUint32(&o.PCDR.Reg)
}

// PDC.VCR: Vertical Capture Register
func (o *PDC_Type) SetVCR_VSZ(value uint32) {
	volatile.StoreUint32(&o.VCR.Reg, volatile.LoadUint32(&o.VCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *PDC_Type) GetVCR_VSZ() uint32 {
	return (volatile.LoadUint32(&o.VCR.Reg) & 0xfff0000) >> 16
}
func (o *PDC_Type) SetVCR_VST(value uint32) {
	volatile.StoreUint32(&o.VCR.Reg, volatile.LoadUint32(&o.VCR.Reg)&^(0xfff)|value)
}
func (o *PDC_Type) GetVCR_VST() uint32 {
	return volatile.LoadUint32(&o.VCR.Reg) & 0xfff
}

// PDC.HCR: Horizontal Capture Register
func (o *PDC_Type) SetHCR_HSZ(value uint32) {
	volatile.StoreUint32(&o.HCR.Reg, volatile.LoadUint32(&o.HCR.Reg)&^(0xfff0000)|value<<16)
}
func (o *PDC_Type) GetHCR_HSZ() uint32 {
	return (volatile.LoadUint32(&o.HCR.Reg) & 0xfff0000) >> 16
}
func (o *PDC_Type) SetHCR_HST(value uint32) {
	volatile.StoreUint32(&o.HCR.Reg, volatile.LoadUint32(&o.HCR.Reg)&^(0xfff)|value)
}
func (o *PDC_Type) GetHCR_HST() uint32 {
	return volatile.LoadUint32(&o.HCR.Reg) & 0xfff
}

// Quad-SPI
type QSPI_Type struct {
	SFMSMD  volatile.Register32 // 0x0
	SFMSSC  volatile.Register32 // 0x4
	SFMSKC  volatile.Register32 // 0x8
	SFMSST  volatile.Register32 // 0xC
	SFMCOM  volatile.Register32 // 0x10
	SFMCMD  volatile.Register32 // 0x14
	SFMCST  volatile.Register32 // 0x18
	_       [4]byte
	SFMSIC  volatile.Register32 // 0x20
	SFMSAC  volatile.Register32 // 0x24
	SFMSDC  volatile.Register32 // 0x28
	_       [4]byte
	SFMSPC  volatile.Register32 // 0x30
	SFMPMD  volatile.Register32 // 0x34
	_       [1996]byte
	SFMCNT1 volatile.Register32 // 0x804
}

// QSPI.SFMSMD: Transfer Mode Control Register
func (o *QSPI_Type) SetSFMSMD_SFMCCE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x8000)|value<<15)
}
func (o *QSPI_Type) GetSFMSMD_SFMCCE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x8000) >> 15
}
func (o *QSPI_Type) SetSFMSMD_SFMOSW(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x800)|value<<11)
}
func (o *QSPI_Type) GetSFMSMD_SFMOSW() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x800) >> 11
}
func (o *QSPI_Type) SetSFMSMD_SFMOHW(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x400)|value<<10)
}
func (o *QSPI_Type) GetSFMSMD_SFMOHW() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x400) >> 10
}
func (o *QSPI_Type) SetSFMSMD_SFMOEX(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x200)|value<<9)
}
func (o *QSPI_Type) GetSFMSMD_SFMOEX() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x200) >> 9
}
func (o *QSPI_Type) SetSFMSMD_SFMMD3(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x100)|value<<8)
}
func (o *QSPI_Type) GetSFMSMD_SFMMD3() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x100) >> 8
}
func (o *QSPI_Type) SetSFMSMD_SFMPAE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSMD_SFMPAE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMSMD_SFMPFE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSMD_SFMPFE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSMD_SFMSE(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x30)|value<<4)
}
func (o *QSPI_Type) GetSFMSMD_SFMSE() uint32 {
	return (volatile.LoadUint32(&o.SFMSMD.Reg) & 0x30) >> 4
}
func (o *QSPI_Type) SetSFMSMD_SFMRM(value uint32) {
	volatile.StoreUint32(&o.SFMSMD.Reg, volatile.LoadUint32(&o.SFMSMD.Reg)&^(0x7)|value)
}
func (o *QSPI_Type) GetSFMSMD_SFMRM() uint32 {
	return volatile.LoadUint32(&o.SFMSMD.Reg) & 0x7
}

// QSPI.SFMSSC: Chip Selection Control Register
func (o *QSPI_Type) SetSFMSSC_SFMSLD(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetSFMSSC_SFMSLD() uint32 {
	return (volatile.LoadUint32(&o.SFMSSC.Reg) & 0x20) >> 5
}
func (o *QSPI_Type) SetSFMSSC_SFMSHD(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSSC_SFMSHD() uint32 {
	return (volatile.LoadUint32(&o.SFMSSC.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetSFMSSC_SFMSW(value uint32) {
	volatile.StoreUint32(&o.SFMSSC.Reg, volatile.LoadUint32(&o.SFMSSC.Reg)&^(0xf)|value)
}
func (o *QSPI_Type) GetSFMSSC_SFMSW() uint32 {
	return volatile.LoadUint32(&o.SFMSSC.Reg) & 0xf
}

// QSPI.SFMSKC: Clock Control Register
func (o *QSPI_Type) SetSFMSKC_SFMDTY(value uint32) {
	volatile.StoreUint32(&o.SFMSKC.Reg, volatile.LoadUint32(&o.SFMSKC.Reg)&^(0x20)|value<<5)
}
func (o *QSPI_Type) GetSFMSKC_SFMDTY() uint32 {
	return (volatile.LoadUint32(&o.SFMSKC.Reg) & 0x20) >> 5
}
func (o *QSPI_Type) SetSFMSKC_SFMDV(value uint32) {
	volatile.StoreUint32(&o.SFMSKC.Reg, volatile.LoadUint32(&o.SFMSKC.Reg)&^(0x1f)|value)
}
func (o *QSPI_Type) GetSFMSKC_SFMDV() uint32 {
	return volatile.LoadUint32(&o.SFMSKC.Reg) & 0x1f
}

// QSPI.SFMSST: Status Register
func (o *QSPI_Type) SetSFMSST_PFOFF(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSST_PFOFF() uint32 {
	return (volatile.LoadUint32(&o.SFMSST.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMSST_PFFUL(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSST_PFFUL() uint32 {
	return (volatile.LoadUint32(&o.SFMSST.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSST_PFCNT(value uint32) {
	volatile.StoreUint32(&o.SFMSST.Reg, volatile.LoadUint32(&o.SFMSST.Reg)&^(0x1f)|value)
}
func (o *QSPI_Type) GetSFMSST_PFCNT() uint32 {
	return volatile.LoadUint32(&o.SFMSST.Reg) & 0x1f
}

// QSPI.SFMCOM: Communication Port Register
func (o *QSPI_Type) SetSFMCOM_SFMD(value uint32) {
	volatile.StoreUint32(&o.SFMCOM.Reg, volatile.LoadUint32(&o.SFMCOM.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSFMCOM_SFMD() uint32 {
	return volatile.LoadUint32(&o.SFMCOM.Reg) & 0xff
}

// QSPI.SFMCMD: Communication Mode Control Register
func (o *QSPI_Type) SetSFMCMD_DCOM(value uint32) {
	volatile.StoreUint32(&o.SFMCMD.Reg, volatile.LoadUint32(&o.SFMCMD.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSFMCMD_DCOM() uint32 {
	return volatile.LoadUint32(&o.SFMCMD.Reg) & 0x1
}

// QSPI.SFMCST: Communication Status Register
func (o *QSPI_Type) SetSFMCST_EROMR(value uint32) {
	volatile.StoreUint32(&o.SFMCST.Reg, volatile.LoadUint32(&o.SFMCST.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMCST_EROMR() uint32 {
	return (volatile.LoadUint32(&o.SFMCST.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMCST_COMBSY(value uint32) {
	volatile.StoreUint32(&o.SFMCST.Reg, volatile.LoadUint32(&o.SFMCST.Reg)&^(0x1)|value)
}
func (o *QSPI_Type) GetSFMCST_COMBSY() uint32 {
	return volatile.LoadUint32(&o.SFMCST.Reg) & 0x1
}

// QSPI.SFMSIC: Instruction Code Register
func (o *QSPI_Type) SetSFMSIC_SFMCIC(value uint32) {
	volatile.StoreUint32(&o.SFMSIC.Reg, volatile.LoadUint32(&o.SFMSIC.Reg)&^(0xff)|value)
}
func (o *QSPI_Type) GetSFMSIC_SFMCIC() uint32 {
	return volatile.LoadUint32(&o.SFMSIC.Reg) & 0xff
}

// QSPI.SFMSAC: Address Mode Control Register
func (o *QSPI_Type) SetSFMSAC_SFM4BC(value uint32) {
	volatile.StoreUint32(&o.SFMSAC.Reg, volatile.LoadUint32(&o.SFMSAC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSAC_SFM4BC() uint32 {
	return (volatile.LoadUint32(&o.SFMSAC.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetSFMSAC_SFMAS(value uint32) {
	volatile.StoreUint32(&o.SFMSAC.Reg, volatile.LoadUint32(&o.SFMSAC.Reg)&^(0x3)|value)
}
func (o *QSPI_Type) GetSFMSAC_SFMAS() uint32 {
	return volatile.LoadUint32(&o.SFMSAC.Reg) & 0x3
}

// QSPI.SFMSDC: Dummy Cycle Control Register
func (o *QSPI_Type) SetSFMSDC_SFMXD(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0xff00)|value<<8)
}
func (o *QSPI_Type) GetSFMSDC_SFMXD() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0xff00) >> 8
}
func (o *QSPI_Type) SetSFMSDC_SFMXEN(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0x80)|value<<7)
}
func (o *QSPI_Type) GetSFMSDC_SFMXEN() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0x80) >> 7
}
func (o *QSPI_Type) SetSFMSDC_SFMXST(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0x40)|value<<6)
}
func (o *QSPI_Type) GetSFMSDC_SFMXST() uint32 {
	return (volatile.LoadUint32(&o.SFMSDC.Reg) & 0x40) >> 6
}
func (o *QSPI_Type) SetSFMSDC_SFMDN(value uint32) {
	volatile.StoreUint32(&o.SFMSDC.Reg, volatile.LoadUint32(&o.SFMSDC.Reg)&^(0xf)|value)
}
func (o *QSPI_Type) GetSFMSDC_SFMDN() uint32 {
	return volatile.LoadUint32(&o.SFMSDC.Reg) & 0xf
}

// QSPI.SFMSPC: SPI Protocol Control Register
func (o *QSPI_Type) SetSFMSPC_SFMSDE(value uint32) {
	volatile.StoreUint32(&o.SFMSPC.Reg, volatile.LoadUint32(&o.SFMSPC.Reg)&^(0x10)|value<<4)
}
func (o *QSPI_Type) GetSFMSPC_SFMSDE() uint32 {
	return (volatile.LoadUint32(&o.SFMSPC.Reg) & 0x10) >> 4
}
func (o *QSPI_Type) SetSFMSPC_SFMSPI(value uint32) {
	volatile.StoreUint32(&o.SFMSPC.Reg, volatile.LoadUint32(&o.SFMSPC.Reg)&^(0x3)|value)
}
func (o *QSPI_Type) GetSFMSPC_SFMSPI() uint32 {
	return volatile.LoadUint32(&o.SFMSPC.Reg) & 0x3
}

// QSPI.SFMPMD: Port Control Register
func (o *QSPI_Type) SetSFMPMD_SFMWPL(value uint32) {
	volatile.StoreUint32(&o.SFMPMD.Reg, volatile.LoadUint32(&o.SFMPMD.Reg)&^(0x4)|value<<2)
}
func (o *QSPI_Type) GetSFMPMD_SFMWPL() uint32 {
	return (volatile.LoadUint32(&o.SFMPMD.Reg) & 0x4) >> 2
}

// QSPI.SFMCNT1: External QSPI Address Register 1
func (o *QSPI_Type) SetSFMCNT1_QSPI_EXT(value uint32) {
	volatile.StoreUint32(&o.SFMCNT1.Reg, volatile.LoadUint32(&o.SFMCNT1.Reg)&^(0xfc000000)|value<<26)
}
func (o *QSPI_Type) GetSFMCNT1_QSPI_EXT() uint32 {
	return (volatile.LoadUint32(&o.SFMCNT1.Reg) & 0xfc000000) >> 26
}

// Memory Mirror Function
type MMF_Type struct {
	MMSFR volatile.Register32 // 0x0
	MMEN  volatile.Register32 // 0x4
}

// MMF.MMSFR: MemMirror Special Function Register
func (o *MMF_Type) SetMMSFR_KEY(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMSFR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMSFR_MEMMIRADDR(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x7fff80)|value<<7)
}
func (o *MMF_Type) GetMMSFR_MEMMIRADDR() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0x7fff80) >> 7
}

// MMF.MMEN: MemMirror Enable Register
func (o *MMF_Type) SetMMEN_KEY(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMEN_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMEN.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMEN_EN(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0x1)|value)
}
func (o *MMF_Type) GetMMEN_EN() uint32 {
	return volatile.LoadUint32(&o.MMEN.Reg) & 0x1
}

// Direct memory access controller 0
type DMAC0_Type struct {
	DMSAR volatile.Register32 // 0x0
	DMDAR volatile.Register32 // 0x4
	DMCRA volatile.Register32 // 0x8
	DMCRB volatile.Register16 // 0xC
	_     [2]byte
	DMTMD volatile.Register16 // 0x10
	_     byte
	DMINT volatile.Register8  // 0x13
	DMAMD volatile.Register16 // 0x14
	_     [2]byte
	DMOFR volatile.Register32 // 0x18
	DMCNT volatile.Register8  // 0x1C
	DMREQ volatile.Register8  // 0x1D
	DMSTS volatile.Register8  // 0x1E
}

// DMAC0.DMSAR: DMA Source Address Register
func (o *DMAC0_Type) SetDMSAR(value uint32) {
	volatile.StoreUint32(&o.DMSAR.Reg, value)
}
func (o *DMAC0_Type) GetDMSAR() uint32 {
	return volatile.LoadUint32(&o.DMSAR.Reg)
}

// DMAC0.DMDAR: DMA Destination Address Register
func (o *DMAC0_Type) SetDMDAR(value uint32) {
	volatile.StoreUint32(&o.DMDAR.Reg, value)
}
func (o *DMAC0_Type) GetDMDAR() uint32 {
	return volatile.LoadUint32(&o.DMDAR.Reg)
}

// DMAC0.DMCRA: DMA Transfer Count Register
func (o *DMAC0_Type) SetDMCRA_DMCRAH(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0x3ff0000)|value<<16)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAH() uint32 {
	return (volatile.LoadUint32(&o.DMCRA.Reg) & 0x3ff0000) >> 16
}
func (o *DMAC0_Type) SetDMCRA_DMCRAL(value uint32) {
	volatile.StoreUint32(&o.DMCRA.Reg, volatile.LoadUint32(&o.DMCRA.Reg)&^(0xffff)|value)
}
func (o *DMAC0_Type) GetDMCRA_DMCRAL() uint32 {
	return volatile.LoadUint32(&o.DMCRA.Reg) & 0xffff
}

// DMAC0.DMCRB: DMA Block Transfer Count Register
func (o *DMAC0_Type) SetDMCRB(value uint16) {
	volatile.StoreUint16(&o.DMCRB.Reg, value)
}
func (o *DMAC0_Type) GetDMCRB() uint16 {
	return volatile.LoadUint16(&o.DMCRB.Reg)
}

// DMAC0.DMTMD: DMA Transfer Mode Register
func (o *DMAC0_Type) SetDMTMD_MD(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMTMD_MD() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0xc000) >> 14
}
func (o *DMAC0_Type) SetDMTMD_DTS(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3000)|value<<12)
}
func (o *DMAC0_Type) GetDMTMD_DTS() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x3000) >> 12
}
func (o *DMAC0_Type) SetDMTMD_SZ(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x300)|value<<8)
}
func (o *DMAC0_Type) GetDMTMD_SZ() uint16 {
	return (volatile.LoadUint16(&o.DMTMD.Reg) & 0x300) >> 8
}
func (o *DMAC0_Type) SetDMTMD_DCTG(value uint16) {
	volatile.StoreUint16(&o.DMTMD.Reg, volatile.LoadUint16(&o.DMTMD.Reg)&^(0x3)|value)
}
func (o *DMAC0_Type) GetDMTMD_DCTG() uint16 {
	return volatile.LoadUint16(&o.DMTMD.Reg) & 0x3
}

// DMAC0.DMINT: DMA Interrupt Setting Register
func (o *DMAC0_Type) SetDMINT_DTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMINT_DTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMINT_ESIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x8)|value<<3)
}
func (o *DMAC0_Type) GetDMINT_ESIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x8) >> 3
}
func (o *DMAC0_Type) SetDMINT_RPTIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x4)|value<<2)
}
func (o *DMAC0_Type) GetDMINT_RPTIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x4) >> 2
}
func (o *DMAC0_Type) SetDMINT_SARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x2)|value<<1)
}
func (o *DMAC0_Type) GetDMINT_SARIE() uint8 {
	return (volatile.LoadUint8(&o.DMINT.Reg) & 0x2) >> 1
}
func (o *DMAC0_Type) SetDMINT_DARIE(value uint8) {
	volatile.StoreUint8(&o.DMINT.Reg, volatile.LoadUint8(&o.DMINT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMINT_DARIE() uint8 {
	return volatile.LoadUint8(&o.DMINT.Reg) & 0x1
}

// DMAC0.DMAMD: DMA Address Mode Register
func (o *DMAC0_Type) SetDMAMD_SM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc000)|value<<14)
}
func (o *DMAC0_Type) GetDMAMD_SM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc000) >> 14
}
func (o *DMAC0_Type) SetDMAMD_SARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f00)|value<<8)
}
func (o *DMAC0_Type) GetDMAMD_SARA() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f00) >> 8
}
func (o *DMAC0_Type) SetDMAMD_DM(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0xc0)|value<<6)
}
func (o *DMAC0_Type) GetDMAMD_DM() uint16 {
	return (volatile.LoadUint16(&o.DMAMD.Reg) & 0xc0) >> 6
}
func (o *DMAC0_Type) SetDMAMD_DARA(value uint16) {
	volatile.StoreUint16(&o.DMAMD.Reg, volatile.LoadUint16(&o.DMAMD.Reg)&^(0x1f)|value)
}
func (o *DMAC0_Type) GetDMAMD_DARA() uint16 {
	return volatile.LoadUint16(&o.DMAMD.Reg) & 0x1f
}

// DMAC0.DMOFR: DMA Offset Register
func (o *DMAC0_Type) SetDMOFR(value uint32) {
	volatile.StoreUint32(&o.DMOFR.Reg, value)
}
func (o *DMAC0_Type) GetDMOFR() uint32 {
	return volatile.LoadUint32(&o.DMOFR.Reg)
}

// DMAC0.DMCNT: DMA Transfer Enable Register
func (o *DMAC0_Type) SetDMCNT_DTE(value uint8) {
	volatile.StoreUint8(&o.DMCNT.Reg, volatile.LoadUint8(&o.DMCNT.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMCNT_DTE() uint8 {
	return volatile.LoadUint8(&o.DMCNT.Reg) & 0x1
}

// DMAC0.DMREQ: DMA Software Start Register
func (o *DMAC0_Type) SetDMREQ_CLRS(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMREQ_CLRS() uint8 {
	return (volatile.LoadUint8(&o.DMREQ.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMREQ_SWREQ(value uint8) {
	volatile.StoreUint8(&o.DMREQ.Reg, volatile.LoadUint8(&o.DMREQ.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMREQ_SWREQ() uint8 {
	return volatile.LoadUint8(&o.DMREQ.Reg) & 0x1
}

// DMAC0.DMSTS: DMAC Module Activation Register
func (o *DMAC0_Type) SetDMSTS_ACT(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x80)|value<<7)
}
func (o *DMAC0_Type) GetDMSTS_ACT() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x80) >> 7
}
func (o *DMAC0_Type) SetDMSTS_DTIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x10)|value<<4)
}
func (o *DMAC0_Type) GetDMSTS_DTIF() uint8 {
	return (volatile.LoadUint8(&o.DMSTS.Reg) & 0x10) >> 4
}
func (o *DMAC0_Type) SetDMSTS_ESIF(value uint8) {
	volatile.StoreUint8(&o.DMSTS.Reg, volatile.LoadUint8(&o.DMSTS.Reg)&^(0x1)|value)
}
func (o *DMAC0_Type) GetDMSTS_ESIF() uint8 {
	return volatile.LoadUint8(&o.DMSTS.Reg) & 0x1
}

// DMAC Module Activation
type DMA_Type struct {
	DMAST volatile.Register8 // 0x0
}

// DMA.DMAST: DMA Module Activation Register
func (o *DMA_Type) SetDMAST_DMST(value uint8) {
	volatile.StoreUint8(&o.DMAST.Reg, volatile.LoadUint8(&o.DMAST.Reg)&^(0x1)|value)
}
func (o *DMA_Type) GetDMAST_DMST() uint8 {
	return volatile.LoadUint8(&o.DMAST.Reg) & 0x1
}

// Data Transfer Controller
type DTC_Type struct {
	DTCCR  volatile.Register8 // 0x0
	_      [3]byte
	DTCVBR volatile.Register32 // 0x4
	_      [4]byte
	DTCST  volatile.Register8 // 0xC
	_      byte
	DTCSTS volatile.Register16 // 0xE
}

// DTC.DTCCR: DTC Control Register
func (o *DTC_Type) SetDTCCR_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x10) >> 4
}

// DTC.DTCVBR: DTC Vector Base Register
func (o *DTC_Type) SetDTCVBR(value uint32) {
	volatile.StoreUint32(&o.DTCVBR.Reg, value)
}
func (o *DTC_Type) GetDTCVBR() uint32 {
	return volatile.LoadUint32(&o.DTCVBR.Reg)
}

// DTC.DTCST: DTC Module Start Register
func (o *DTC_Type) SetDTCST(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0x1)|value)
}
func (o *DTC_Type) GetDTCST() uint8 {
	return volatile.LoadUint8(&o.DTCST.Reg) & 0x1
}

// DTC.DTCSTS: DTC Status Register
func (o *DTC_Type) SetDTCSTS_ACT(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x8000)|value<<15)
}
func (o *DTC_Type) GetDTCSTS_ACT() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x8000) >> 15
}
func (o *DTC_Type) SetDTCSTS_VECN(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTCSTS_VECN() uint16 {
	return volatile.LoadUint16(&o.DTCSTS.Reg) & 0xff
}

// Debug Function
type DBG_Type struct {
	DBGSTR    volatile.Register32 // 0x0
	_         [12]byte
	DBGSTOPCR volatile.Register32 // 0x10
	_         [12]byte
	TRACECTR  volatile.Register32 // 0x20
}

// DBG.DBGSTR: Debug Status Register
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPACK(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPACK() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x20000000) >> 29
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPREQ(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPREQ() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x10000000) >> 28
}

// DBG.DBGSTOPCR: Debug Stop Control Register
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RECCR(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RECCR() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2000000) >> 25
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1000000) >> 24
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x70000)|value<<16)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x70000) >> 16
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_WDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_WDT() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_IWDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_IWDT() uint32 {
	return volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1
}

// DBG.TRACECTR: Trace Control Register
func (o *DBG_Type) SetTRACECTR_ENETBFULL(value uint32) {
	volatile.StoreUint32(&o.TRACECTR.Reg, volatile.LoadUint32(&o.TRACECTR.Reg)&^(0x80000000)|value<<31)
}
func (o *DBG_Type) GetTRACECTR_ENETBFULL() uint32 {
	return (volatile.LoadUint32(&o.TRACECTR.Reg) & 0x80000000) >> 31
}

// Temperature Sensor
type TSN_Type struct {
	TSCR volatile.Register8 // 0x0
}

// TSN.TSCR: Temperature Sensor Control Register
func (o *TSN_Type) SetTSCR_TSEN(value uint8) {
	volatile.StoreUint8(&o.TSCR.Reg, volatile.LoadUint8(&o.TSCR.Reg)&^(0x80)|value<<7)
}
func (o *TSN_Type) GetTSCR_TSEN() uint8 {
	return (volatile.LoadUint8(&o.TSCR.Reg) & 0x80) >> 7
}
func (o *TSN_Type) SetTSCR_TSOE(value uint8) {
	volatile.StoreUint8(&o.TSCR.Reg, volatile.LoadUint8(&o.TSCR.Reg)&^(0x10)|value<<4)
}
func (o *TSN_Type) GetTSCR_TSOE() uint8 {
	return (volatile.LoadUint8(&o.TSCR.Reg) & 0x10) >> 4
}

// High-Speed Analog Comparator 0
type ACMPHS0_Type struct {
	CMPCTL  volatile.Register8 // 0x0
	_       [3]byte
	CMPSEL0 volatile.Register8 // 0x4
	_       [3]byte
	CMPSEL1 volatile.Register8 // 0x8
	_       [3]byte
	CMPMON  volatile.Register8 // 0xC
	_       [3]byte
	CPIOC   volatile.Register8 // 0x10
}

// ACMPHS0.CMPCTL: Comparator Control Register
func (o *ACMPHS0_Type) SetCMPCTL_HCMPON(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS0_Type) GetCMPCTL_HCMPON() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x80) >> 7
}
func (o *ACMPHS0_Type) SetCMPCTL_CDFS(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x60)|value<<5)
}
func (o *ACMPHS0_Type) GetCMPCTL_CDFS() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x60) >> 5
}
func (o *ACMPHS0_Type) SetCMPCTL_CEG(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x18)|value<<3)
}
func (o *ACMPHS0_Type) GetCMPCTL_CEG() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x18) >> 3
}
func (o *ACMPHS0_Type) SetCMPCTL_CSTEN(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x4)|value<<2)
}
func (o *ACMPHS0_Type) GetCMPCTL_CSTEN() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x4) >> 2
}
func (o *ACMPHS0_Type) SetCMPCTL_COE(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x2)|value<<1)
}
func (o *ACMPHS0_Type) GetCMPCTL_COE() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x2) >> 1
}
func (o *ACMPHS0_Type) SetCMPCTL_CINV(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCMPCTL_CINV() uint8 {
	return volatile.LoadUint8(&o.CMPCTL.Reg) & 0x1
}

// ACMPHS0.CMPSEL0: Comparator Input Select Register
func (o *ACMPHS0_Type) SetCMPSEL0_CMPSEL(value uint8) {
	volatile.StoreUint8(&o.CMPSEL0.Reg, volatile.LoadUint8(&o.CMPSEL0.Reg)&^(0xf)|value)
}
func (o *ACMPHS0_Type) GetCMPSEL0_CMPSEL() uint8 {
	return volatile.LoadUint8(&o.CMPSEL0.Reg) & 0xf
}

// ACMPHS0.CMPSEL1: Comparator Reference Voltage Select Register
func (o *ACMPHS0_Type) SetCMPSEL1_CRVS(value uint8) {
	volatile.StoreUint8(&o.CMPSEL1.Reg, volatile.LoadUint8(&o.CMPSEL1.Reg)&^(0xf)|value)
}
func (o *ACMPHS0_Type) GetCMPSEL1_CRVS() uint8 {
	return volatile.LoadUint8(&o.CMPSEL1.Reg) & 0xf
}

// ACMPHS0.CMPMON: Comparator Output Monitor Register
func (o *ACMPHS0_Type) SetCMPMON(value uint8) {
	volatile.StoreUint8(&o.CMPMON.Reg, volatile.LoadUint8(&o.CMPMON.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCMPMON() uint8 {
	return volatile.LoadUint8(&o.CMPMON.Reg) & 0x1
}

// ACMPHS0.CPIOC: Comparator Output Control Register
func (o *ACMPHS0_Type) SetCPIOC_VREFEN(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS0_Type) GetCPIOC_VREFEN() uint8 {
	return (volatile.LoadUint8(&o.CPIOC.Reg) & 0x80) >> 7
}
func (o *ACMPHS0_Type) SetCPIOC_CPOE(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCPIOC_CPOE() uint8 {
	return volatile.LoadUint8(&o.CPIOC.Reg) & 0x1
}

// High-Speed Analog Comparator 1
type ACMPHS1_Type struct {
	CMPCTL  volatile.Register8 // 0x0
	_       [3]byte
	CMPSEL0 volatile.Register8 // 0x4
	_       [3]byte
	CMPSEL1 volatile.Register8 // 0x8
	_       [3]byte
	CMPMON  volatile.Register8 // 0xC
	_       [3]byte
	CPIOC   volatile.Register8 // 0x10
}

// ACMPHS1.CMPCTL: Comparator Control Register
func (o *ACMPHS1_Type) SetCMPCTL_HCMPON(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS1_Type) GetCMPCTL_HCMPON() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x80) >> 7
}
func (o *ACMPHS1_Type) SetCMPCTL_CDFS(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x60)|value<<5)
}
func (o *ACMPHS1_Type) GetCMPCTL_CDFS() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x60) >> 5
}
func (o *ACMPHS1_Type) SetCMPCTL_CEG(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x18)|value<<3)
}
func (o *ACMPHS1_Type) GetCMPCTL_CEG() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x18) >> 3
}
func (o *ACMPHS1_Type) SetCMPCTL_CSTEN(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x4)|value<<2)
}
func (o *ACMPHS1_Type) GetCMPCTL_CSTEN() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x4) >> 2
}
func (o *ACMPHS1_Type) SetCMPCTL_COE(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x2)|value<<1)
}
func (o *ACMPHS1_Type) GetCMPCTL_COE() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x2) >> 1
}
func (o *ACMPHS1_Type) SetCMPCTL_CINV(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x1)|value)
}
func (o *ACMPHS1_Type) GetCMPCTL_CINV() uint8 {
	return volatile.LoadUint8(&o.CMPCTL.Reg) & 0x1
}

// ACMPHS1.CMPSEL0: Comparator Input Select Register
func (o *ACMPHS1_Type) SetCMPSEL0_CMPSEL(value uint8) {
	volatile.StoreUint8(&o.CMPSEL0.Reg, volatile.LoadUint8(&o.CMPSEL0.Reg)&^(0xf)|value)
}
func (o *ACMPHS1_Type) GetCMPSEL0_CMPSEL() uint8 {
	return volatile.LoadUint8(&o.CMPSEL0.Reg) & 0xf
}

// ACMPHS1.CMPSEL1: Comparator Reference Voltage Select Register
func (o *ACMPHS1_Type) SetCMPSEL1_CRVS(value uint8) {
	volatile.StoreUint8(&o.CMPSEL1.Reg, volatile.LoadUint8(&o.CMPSEL1.Reg)&^(0xf)|value)
}
func (o *ACMPHS1_Type) GetCMPSEL1_CRVS() uint8 {
	return volatile.LoadUint8(&o.CMPSEL1.Reg) & 0xf
}

// ACMPHS1.CMPMON: Comparator Output Monitor Register
func (o *ACMPHS1_Type) SetCMPMON(value uint8) {
	volatile.StoreUint8(&o.CMPMON.Reg, volatile.LoadUint8(&o.CMPMON.Reg)&^(0x1)|value)
}
func (o *ACMPHS1_Type) GetCMPMON() uint8 {
	return volatile.LoadUint8(&o.CMPMON.Reg) & 0x1
}

// ACMPHS1.CPIOC: Comparator Output Control Register
func (o *ACMPHS1_Type) SetCPIOC_VREFEN(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS1_Type) GetCPIOC_VREFEN() uint8 {
	return (volatile.LoadUint8(&o.CPIOC.Reg) & 0x80) >> 7
}
func (o *ACMPHS1_Type) SetCPIOC_CPOE(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x1)|value)
}
func (o *ACMPHS1_Type) GetCPIOC_CPOE() uint8 {
	return volatile.LoadUint8(&o.CPIOC.Reg) & 0x1
}

// Event Link Controller
type ELC_Type struct {
	ELCR    volatile.Register8 // 0x0
	_       byte
	ELSEGR0 volatile.Register8 // 0x2
	_       byte
	ELSEGR1 volatile.Register8 // 0x4
	_       [11]byte
	ELSR0   volatile.Register16 // 0x10
	_       [2]byte
	ELSR1   volatile.Register16 // 0x14
	_       [2]byte
	ELSR2   volatile.Register16 // 0x18
	_       [2]byte
	ELSR3   volatile.Register16 // 0x1C
	_       [2]byte
	ELSR4   volatile.Register16 // 0x20
	_       [2]byte
	ELSR5   volatile.Register16 // 0x24
	_       [2]byte
	ELSR6   volatile.Register16 // 0x28
	_       [2]byte
	ELSR7   volatile.Register16 // 0x2C
	_       [2]byte
	ELSR8   volatile.Register16 // 0x30
	_       [2]byte
	ELSR9   volatile.Register16 // 0x34
	_       [2]byte
	ELSR10  volatile.Register16 // 0x38
	_       [2]byte
	ELSR11  volatile.Register16 // 0x3C
	_       [2]byte
	ELSR12  volatile.Register16 // 0x40
	_       [2]byte
	ELSR13  volatile.Register16 // 0x44
	_       [2]byte
	ELSR14  volatile.Register16 // 0x48
	_       [2]byte
	ELSR15  volatile.Register16 // 0x4C
	_       [2]byte
	ELSR16  volatile.Register16 // 0x50
	_       [2]byte
	ELSR17  volatile.Register16 // 0x54
	_       [2]byte
	ELSR18  volatile.Register16 // 0x58
}

// ELC.ELCR: Event Link Controller Register
func (o *ELC_Type) SetELCR_ELCON(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELCR_ELCON() uint8 {
	return (volatile.LoadUint8(&o.ELCR.Reg) & 0x80) >> 7
}

// ELC.ELSEGR0: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR0_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR0_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR0_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR0_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR0_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR0_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x1
}

// ELC.ELSEGR1: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR1_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR1_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR1_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR1_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR1_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR1_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x1
}

// ELC.ELSR0: Event Link Setting Register %s
func (o *ELC_Type) SetELSR0_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR0_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR0.Reg) & 0x1ff
}

// ELC.ELSR1: Event Link Setting Register %s
func (o *ELC_Type) SetELSR1_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR1_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR1.Reg) & 0x1ff
}

// ELC.ELSR2: Event Link Setting Register %s
func (o *ELC_Type) SetELSR2_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR2_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR2.Reg) & 0x1ff
}

// ELC.ELSR3: Event Link Setting Register %s
func (o *ELC_Type) SetELSR3_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR3_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR3.Reg) & 0x1ff
}

// ELC.ELSR4: Event Link Setting Register %s
func (o *ELC_Type) SetELSR4_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR4.Reg, volatile.LoadUint16(&o.ELSR4.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR4_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR4.Reg) & 0x1ff
}

// ELC.ELSR5: Event Link Setting Register %s
func (o *ELC_Type) SetELSR5_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR5.Reg, volatile.LoadUint16(&o.ELSR5.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR5_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR5.Reg) & 0x1ff
}

// ELC.ELSR6: Event Link Setting Register %s
func (o *ELC_Type) SetELSR6_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR6.Reg, volatile.LoadUint16(&o.ELSR6.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR6_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR6.Reg) & 0x1ff
}

// ELC.ELSR7: Event Link Setting Register %s
func (o *ELC_Type) SetELSR7_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR7.Reg, volatile.LoadUint16(&o.ELSR7.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR7_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR7.Reg) & 0x1ff
}

// ELC.ELSR8: Event Link Setting Register %s
func (o *ELC_Type) SetELSR8_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR8_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR8.Reg) & 0x1ff
}

// ELC.ELSR9: Event Link Setting Register %s
func (o *ELC_Type) SetELSR9_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR9_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR9.Reg) & 0x1ff
}

// ELC.ELSR10: Event Link Setting Register %s
func (o *ELC_Type) SetELSR10_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR10.Reg, volatile.LoadUint16(&o.ELSR10.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR10_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR10.Reg) & 0x1ff
}

// ELC.ELSR11: Event Link Setting Register %s
func (o *ELC_Type) SetELSR11_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR11.Reg, volatile.LoadUint16(&o.ELSR11.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR11_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR11.Reg) & 0x1ff
}

// ELC.ELSR12: Event Link Setting Register %s
func (o *ELC_Type) SetELSR12_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR12_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR12.Reg) & 0x1ff
}

// ELC.ELSR13: Event Link Setting Register %s
func (o *ELC_Type) SetELSR13_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR13.Reg, volatile.LoadUint16(&o.ELSR13.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR13_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR13.Reg) & 0x1ff
}

// ELC.ELSR14: Event Link Setting Register %s
func (o *ELC_Type) SetELSR14_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR14_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR14.Reg) & 0x1ff
}

// ELC.ELSR15: Event Link Setting Register %s
func (o *ELC_Type) SetELSR15_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR15_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR15.Reg) & 0x1ff
}

// ELC.ELSR16: Event Link Setting Register %s
func (o *ELC_Type) SetELSR16_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR16.Reg, volatile.LoadUint16(&o.ELSR16.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR16_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR16.Reg) & 0x1ff
}

// ELC.ELSR17: Event Link Setting Register %s
func (o *ELC_Type) SetELSR17_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR17.Reg, volatile.LoadUint16(&o.ELSR17.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR17_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR17.Reg) & 0x1ff
}

// ELC.ELSR18: Event Link Setting Register %s
func (o *ELC_Type) SetELSR18_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0x1ff)|value)
}
func (o *ELC_Type) GetELSR18_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR18.Reg) & 0x1ff
}

// Watchdog Timer
type WDT_Type struct {
	WDTRR    volatile.Register8 // 0x0
	_        byte
	WDTCR    volatile.Register16 // 0x2
	WDTSR    volatile.Register16 // 0x4
	WDTRCR   volatile.Register8  // 0x6
	_        byte
	WDTCSTPR volatile.Register8 // 0x8
}

// WDT.WDTRR: WDT Refresh Register
func (o *WDT_Type) SetWDTRR(value uint8) {
	volatile.StoreUint8(&o.WDTRR.Reg, value)
}
func (o *WDT_Type) GetWDTRR() uint8 {
	return volatile.LoadUint8(&o.WDTRR.Reg)
}

// WDT.WDTCR: WDT Control Register
func (o *WDT_Type) SetWDTCR_RPSS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3000)|value<<12)
}
func (o *WDT_Type) GetWDTCR_RPSS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x3000) >> 12
}
func (o *WDT_Type) SetWDTCR_RPES(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x300)|value<<8)
}
func (o *WDT_Type) GetWDTCR_RPES() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x300) >> 8
}
func (o *WDT_Type) SetWDTCR_CKS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetWDTCR_CKS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xf0) >> 4
}
func (o *WDT_Type) SetWDTCR_TOPS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3)|value)
}
func (o *WDT_Type) GetWDTCR_TOPS() uint16 {
	return volatile.LoadUint16(&o.WDTCR.Reg) & 0x3
}

// WDT.WDTSR: WDT Status Register
func (o *WDT_Type) SetWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x8000) >> 15
}
func (o *WDT_Type) SetWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *WDT_Type) GetWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x4000) >> 14
}
func (o *WDT_Type) SetWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x3fff)|value)
}
func (o *WDT_Type) GetWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.WDTSR.Reg) & 0x3fff
}

// WDT.WDTRCR: WDT Reset Control Register
func (o *WDT_Type) SetWDTRCR_RSTIRQS(value uint8) {
	volatile.StoreUint8(&o.WDTRCR.Reg, volatile.LoadUint8(&o.WDTRCR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTRCR_RSTIRQS() uint8 {
	return (volatile.LoadUint8(&o.WDTRCR.Reg) & 0x80) >> 7
}

// WDT.WDTCSTPR: WDT Count Stop Control Register
func (o *WDT_Type) SetWDTCSTPR_SLCSTP(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTCSTPR_SLCSTP() uint8 {
	return (volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x80) >> 7
}

// Independent Watchdog Timer
type IWDT_Type struct {
	IWDTRR volatile.Register8 // 0x0
	_      [3]byte
	IWDTSR volatile.Register16 // 0x4
}

// IWDT.IWDTRR: IWDT Refresh Register
func (o *IWDT_Type) SetIWDTRR(value uint8) {
	volatile.StoreUint8(&o.IWDTRR.Reg, value)
}
func (o *IWDT_Type) GetIWDTRR() uint8 {
	return volatile.LoadUint8(&o.IWDTRR.Reg)
}

// IWDT.IWDTSR: IWDT Status Register
func (o *IWDT_Type) SetIWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *IWDT_Type) GetIWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x8000) >> 15
}
func (o *IWDT_Type) SetIWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *IWDT_Type) GetIWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x4000) >> 14
}
func (o *IWDT_Type) SetIWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x3fff)|value)
}
func (o *IWDT_Type) GetIWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.IWDTSR.Reg) & 0x3fff
}

// Key Interrupt Function
type KINT_Type struct {
	KRCTL volatile.Register8 // 0x0
	_     [3]byte
	KRF   volatile.Register8 // 0x4
	_     [3]byte
	KRM   volatile.Register8 // 0x8
}

// KINT.KRCTL: KEY Return Control Register
func (o *KINT_Type) SetKRCTL_KRMD(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRCTL_KRMD() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRCTL_KREG(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRCTL_KREG() uint8 {
	return volatile.LoadUint8(&o.KRCTL.Reg) & 0x1
}

// KINT.KRF: KEY Return Flag Register
func (o *KINT_Type) SetKRF_KRF7(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRF_KRF7() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRF_KRF6(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRF_KRF6() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRF_KRF5(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRF_KRF5() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRF_KRF4(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRF_KRF4() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRF_KRF3(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRF_KRF3() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRF_KRF2(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRF_KRF2() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRF_KRF1(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRF_KRF1() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRF_KRF0(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRF_KRF0() uint8 {
	return volatile.LoadUint8(&o.KRF.Reg) & 0x1
}

// KINT.KRM: KEY Return Mode Register
func (o *KINT_Type) SetKRM_KRM7(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRM_KRM7() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRM_KRM6(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRM_KRM6() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRM_KRM5(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRM_KRM5() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRM_KRM4(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRM_KRM4() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRM_KRM3(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRM_KRM3() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRM_KRM2(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRM_KRM2() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRM_KRM1(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRM_KRM1() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRM_KRM0(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRM_KRM0() uint8 {
	return volatile.LoadUint8(&o.KRM.Reg) & 0x1
}

// Data Operation Circuit
type DOC_Type struct {
	DOCR  volatile.Register8 // 0x0
	_     byte
	DODIR volatile.Register16 // 0x2
	DODSR volatile.Register16 // 0x4
}

// DOC.DOCR: DOC Control Register
func (o *DOC_Type) SetDOCR_DOPCFCL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x40)|value<<6)
}
func (o *DOC_Type) GetDOCR_DOPCFCL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x40) >> 6
}
func (o *DOC_Type) SetDOCR_DOPCF(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x20)|value<<5)
}
func (o *DOC_Type) GetDOCR_DOPCF() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x20) >> 5
}
func (o *DOC_Type) SetDOCR_DCSEL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x4)|value<<2)
}
func (o *DOC_Type) GetDOCR_DCSEL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x4) >> 2
}
func (o *DOC_Type) SetDOCR_OMS(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x3)|value)
}
func (o *DOC_Type) GetDOCR_OMS() uint8 {
	return volatile.LoadUint8(&o.DOCR.Reg) & 0x3
}

// DOC.DODIR: DOC Data Input Register
func (o *DOC_Type) SetDODIR(value uint16) {
	volatile.StoreUint16(&o.DODIR.Reg, value)
}
func (o *DOC_Type) GetDODIR() uint16 {
	return volatile.LoadUint16(&o.DODIR.Reg)
}

// DOC.DODSR: DOC Data Setting Register
func (o *DOC_Type) SetDODSR(value uint16) {
	volatile.StoreUint16(&o.DODSR.Reg, value)
}
func (o *DOC_Type) GetDODSR() uint16 {
	return volatile.LoadUint16(&o.DODSR.Reg)
}

// Clock Frequency Accuracy Measurement Circuit
type CAC_Type struct {
	CACR0   volatile.Register8 // 0x0
	CACR1   volatile.Register8 // 0x1
	CACR2   volatile.Register8 // 0x2
	CAICR   volatile.Register8 // 0x3
	CASTR   volatile.Register8 // 0x4
	_       byte
	CAULVR  volatile.Register16 // 0x6
	CALLVR  volatile.Register16 // 0x8
	CACNTBR volatile.Register16 // 0xA
}

// CAC.CACR0: CAC Control Register 0
func (o *CAC_Type) SetCACR0_CFME(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR0_CFME() uint8 {
	return volatile.LoadUint8(&o.CACR0.Reg) & 0x1
}

// CAC.CACR1: CAC Control Register 1
func (o *CAC_Type) SetCACR1_EDGES(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR1_EDGES() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR1_TCSS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR1_TCSS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR1_FMCS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR1_FMCS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR1_CACREFE(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR1_CACREFE() uint8 {
	return volatile.LoadUint8(&o.CACR1.Reg) & 0x1
}

// CAC.CACR2: CAC Control Register 2
func (o *CAC_Type) SetCACR2_DFS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR2_DFS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR2_RCDS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR2_RCDS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR2_RSCS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR2_RSCS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR2_RPS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR2_RPS() uint8 {
	return volatile.LoadUint8(&o.CACR2.Reg) & 0x1
}

// CAC.CAICR: CAC Interrupt Control Register
func (o *CAC_Type) SetCAICR_OVFFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x40)|value<<6)
}
func (o *CAC_Type) GetCAICR_OVFFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x40) >> 6
}
func (o *CAC_Type) SetCAICR_MENDFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x20)|value<<5)
}
func (o *CAC_Type) GetCAICR_MENDFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x20) >> 5
}
func (o *CAC_Type) SetCAICR_FERRFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x10)|value<<4)
}
func (o *CAC_Type) GetCAICR_FERRFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x10) >> 4
}
func (o *CAC_Type) SetCAICR_OVFIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCAICR_OVFIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCAICR_MENDIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCAICR_MENDIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCAICR_FERRIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCAICR_FERRIE() uint8 {
	return volatile.LoadUint8(&o.CAICR.Reg) & 0x1
}

// CAC.CASTR: CAC Status Register
func (o *CAC_Type) SetCASTR_OVFF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCASTR_OVFF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCASTR_MENDF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCASTR_MENDF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCASTR_FERRF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCASTR_FERRF() uint8 {
	return volatile.LoadUint8(&o.CASTR.Reg) & 0x1
}

// CAC.CAULVR: CAC Upper-Limit Value Setting Register
func (o *CAC_Type) SetCAULVR(value uint16) {
	volatile.StoreUint16(&o.CAULVR.Reg, value)
}
func (o *CAC_Type) GetCAULVR() uint16 {
	return volatile.LoadUint16(&o.CAULVR.Reg)
}

// CAC.CALLVR: CAC Lower-Limit Value Setting Register
func (o *CAC_Type) SetCALLVR(value uint16) {
	volatile.StoreUint16(&o.CALLVR.Reg, value)
}
func (o *CAC_Type) GetCALLVR() uint16 {
	return volatile.LoadUint16(&o.CALLVR.Reg)
}

// CAC.CACNTBR: CAC Counter Buffer Register
func (o *CAC_Type) SetCACNTBR(value uint16) {
	volatile.StoreUint16(&o.CACNTBR.Reg, value)
}
func (o *CAC_Type) GetCACNTBR() uint16 {
	return volatile.LoadUint16(&o.CACNTBR.Reg)
}

// Constants for PORT0: Port 0 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PODR field.
	PORT0_PCNTR1_PODR_Pos = 0x10
	// Bit mask of PODR field.
	PORT0_PCNTR1_PODR_Msk = 0xffff0000
	// Low output
	PORT0_PCNTR1_PODR_0 = 0x0
	// High output.
	PORT0_PCNTR1_PODR_1 = 0x1
	// Position of PDR field.
	PORT0_PCNTR1_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT0_PCNTR1_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT0_PCNTR1_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT0_PCNTR1_PDR_1 = 0x1

	// PODR: Output data register
	// Position of PODR field.
	PORT0_PODR_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PORT0_PODR_PODR_Msk = 0xffff
	// Low output
	PORT0_PODR_PODR_0 = 0x0
	// High output.
	PORT0_PODR_PODR_1 = 0x1

	// PDR: Data direction register
	// Position of PDR field.
	PORT0_PDR_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT0_PDR_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT0_PDR_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT0_PDR_PDR_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of EIDR field.
	PORT0_PCNTR2_EIDR_Pos = 0x10
	// Bit mask of EIDR field.
	PORT0_PCNTR2_EIDR_Msk = 0xffff0000
	// Low input
	PORT0_PCNTR2_EIDR_0 = 0x0
	// High input.
	PORT0_PCNTR2_EIDR_1 = 0x1
	// Position of PIDR field.
	PORT0_PCNTR2_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT0_PCNTR2_PIDR_Msk = 0xffff
	// Low input
	PORT0_PCNTR2_PIDR_0 = 0x0
	// High input.
	PORT0_PCNTR2_PIDR_1 = 0x1

	// PIDR: Input data register
	// Position of PIDR field.
	PORT0_PIDR_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT0_PIDR_PIDR_Msk = 0xffff
	// Low input
	PORT0_PIDR_PIDR_0 = 0x0
	// High input.
	PORT0_PIDR_PIDR_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of PORR field.
	PORT0_PCNTR3_PORR_Pos = 0x10
	// Bit mask of PORR field.
	PORT0_PCNTR3_PORR_Msk = 0xffff0000
	// No affect to output
	PORT0_PCNTR3_PORR_0 = 0x0
	// Low output.
	PORT0_PCNTR3_PORR_1 = 0x1
	// Position of POSR field.
	PORT0_PCNTR3_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT0_PCNTR3_POSR_Msk = 0xffff
	// No affect to output
	PORT0_PCNTR3_POSR_0 = 0x0
	// High output.
	PORT0_PCNTR3_POSR_1 = 0x1

	// PORR: Output reset register
	// Position of PORR field.
	PORT0_PORR_PORR_Pos = 0x0
	// Bit mask of PORR field.
	PORT0_PORR_PORR_Msk = 0xffff
	// No affect to output
	PORT0_PORR_PORR_0 = 0x0
	// Low output.
	PORT0_PORR_PORR_1 = 0x1

	// POSR: Output set register
	// Position of POSR field.
	PORT0_POSR_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT0_POSR_POSR_Msk = 0xffff
	// No affect to output
	PORT0_POSR_POSR_0 = 0x0
	// High output.
	PORT0_POSR_POSR_1 = 0x1
)

// Constants for PORT1: Port 1 Control Registers
const (
	// PCNTR1: Port Control Register 1
	// Position of PODR field.
	PORT1_PCNTR1_PODR_Pos = 0x10
	// Bit mask of PODR field.
	PORT1_PCNTR1_PODR_Msk = 0xffff0000
	// Low output
	PORT1_PCNTR1_PODR_0 = 0x0
	// High output.
	PORT1_PCNTR1_PODR_1 = 0x1
	// Position of PDR field.
	PORT1_PCNTR1_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT1_PCNTR1_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT1_PCNTR1_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT1_PCNTR1_PDR_1 = 0x1

	// PODR: Output data register
	// Position of PODR field.
	PORT1_PODR_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PORT1_PODR_PODR_Msk = 0xffff
	// Low output
	PORT1_PODR_PODR_0 = 0x0
	// High output.
	PORT1_PODR_PODR_1 = 0x1

	// PDR: Data direction register
	// Position of PDR field.
	PORT1_PDR_PDR_Pos = 0x0
	// Bit mask of PDR field.
	PORT1_PDR_PDR_Msk = 0xffff
	// Input (functions as an input pin)
	PORT1_PDR_PDR_0 = 0x0
	// Output (functions as an output pin).
	PORT1_PDR_PDR_1 = 0x1

	// PCNTR2: Port Control Register 2
	// Position of EIDR field.
	PORT1_PCNTR2_EIDR_Pos = 0x10
	// Bit mask of EIDR field.
	PORT1_PCNTR2_EIDR_Msk = 0xffff0000
	// Low input
	PORT1_PCNTR2_EIDR_0 = 0x0
	// High input.
	PORT1_PCNTR2_EIDR_1 = 0x1
	// Position of PIDR field.
	PORT1_PCNTR2_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT1_PCNTR2_PIDR_Msk = 0xffff
	// Low input
	PORT1_PCNTR2_PIDR_0 = 0x0
	// High input.
	PORT1_PCNTR2_PIDR_1 = 0x1

	// EIDR: Event input data register
	// Position of EIDR field.
	PORT1_EIDR_EIDR_Pos = 0x0
	// Bit mask of EIDR field.
	PORT1_EIDR_EIDR_Msk = 0xffff
	// Low input
	PORT1_EIDR_EIDR_0 = 0x0
	// High input.
	PORT1_EIDR_EIDR_1 = 0x1

	// PIDR: Input data register
	// Position of PIDR field.
	PORT1_PIDR_PIDR_Pos = 0x0
	// Bit mask of PIDR field.
	PORT1_PIDR_PIDR_Msk = 0xffff
	// Low input
	PORT1_PIDR_PIDR_0 = 0x0
	// High input.
	PORT1_PIDR_PIDR_1 = 0x1

	// PCNTR3: Port Control Register 3
	// Position of PORR field.
	PORT1_PCNTR3_PORR_Pos = 0x10
	// Bit mask of PORR field.
	PORT1_PCNTR3_PORR_Msk = 0xffff0000
	// No affect to output
	PORT1_PCNTR3_PORR_0 = 0x0
	// Low output.
	PORT1_PCNTR3_PORR_1 = 0x1
	// Position of POSR field.
	PORT1_PCNTR3_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT1_PCNTR3_POSR_Msk = 0xffff
	// No affect to output
	PORT1_PCNTR3_POSR_0 = 0x0
	// High output.
	PORT1_PCNTR3_POSR_1 = 0x1

	// PORR: Output set register
	// Position of PORR field.
	PORT1_PORR_PORR_Pos = 0x0
	// Bit mask of PORR field.
	PORT1_PORR_PORR_Msk = 0xffff
	// No affect to output
	PORT1_PORR_PORR_0 = 0x0
	// Low output.
	PORT1_PORR_PORR_1 = 0x1

	// POSR: Output reset register
	// Position of POSR field.
	PORT1_POSR_POSR_Pos = 0x0
	// Bit mask of POSR field.
	PORT1_POSR_POSR_Msk = 0xffff
	// No affect to output
	PORT1_POSR_POSR_0 = 0x0
	// High output.
	PORT1_POSR_POSR_1 = 0x1

	// PCNTR4: Port Control Register 4
	// Position of EORR field.
	PORT1_PCNTR4_EORR_Pos = 0x10
	// Bit mask of EORR field.
	PORT1_PCNTR4_EORR_Msk = 0xffff0000
	// No affect to output
	PORT1_PCNTR4_EORR_0 = 0x0
	// Low output
	PORT1_PCNTR4_EORR_1 = 0x1
	// Position of EOSR field.
	PORT1_PCNTR4_EOSR_Pos = 0x0
	// Bit mask of EOSR field.
	PORT1_PCNTR4_EOSR_Msk = 0xffff
	// No affect to output
	PORT1_PCNTR4_EOSR_0 = 0x0
	// High output.
	PORT1_PCNTR4_EOSR_1 = 0x1

	// EORR: Event output set register
	// Position of EORR field.
	PORT1_EORR_EORR_Pos = 0x0
	// Bit mask of EORR field.
	PORT1_EORR_EORR_Msk = 0xffff
	// No affect to output
	PORT1_EORR_EORR_0 = 0x0
	// Low output
	PORT1_EORR_EORR_1 = 0x1

	// EOSR: Event output reset register
	// Position of EOSR field.
	PORT1_EOSR_EOSR_Pos = 0x0
	// Bit mask of EOSR field.
	PORT1_EOSR_EOSR_Msk = 0xffff
	// No affect to output
	PORT1_EOSR_EOSR_0 = 0x0
	// High output.
	PORT1_EOSR_EOSR_1 = 0x1
)

// Constants for PFS: Pmn Pin Function Control Register
const (
	// P000PFS: P000 Pin Function Control Register
	// Position of PSEL field.
	PFS_P000PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P000PFS_PSEL_Msk = 0x1f000000
	// Position of PMR field.
	PFS_P000PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P000PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P000PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P000PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P000PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P000PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_ISEL_1 = 0x1
	// Position of DSCR field.
	PFS_P000PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P000PFS_DSCR_00 = 0x0
	// Middle drive output
	PFS_P000PFS_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P000PFS_DSCR_10 = 0x2
	// High-drive output
	PFS_P000PFS_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P000PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P000PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P000PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_PIDR = 0x2
	// Low input
	PFS_P000PFS_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_PODR = 0x1
	// Low output
	PFS_P000PFS_PODR_0 = 0x0
	// High output
	PFS_P000PFS_PODR_1 = 0x1

	// P000PFS_HA: P000 Pin Function Control Register
	// Position of ASEL field.
	PFS_P000PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_HA_ISEL_1 = 0x1
	// Position of DSCR field.
	PFS_P000PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_HA_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P000PFS_HA_DSCR_00 = 0x0
	// Middle drive output
	PFS_P000PFS_HA_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P000PFS_HA_DSCR_10 = 0x2
	// High-drive output
	PFS_P000PFS_HA_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P000PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_HA_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P000PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_HA_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P000PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_HA_PIDR = 0x2
	// Low input
	PFS_P000PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_HA_PODR = 0x1
	// Low output
	PFS_P000PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P000PFS_HA_PODR_1 = 0x1

	// P000PFS_BY: P000 Pin Function Control Register
	// Position of NCODR field.
	PFS_P000PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_BY_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P000PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_BY_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P000PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_BY_PIDR = 0x2
	// Low input
	PFS_P000PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_BY_PODR = 0x1
	// Low output
	PFS_P000PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P000PFS_BY_PODR_1 = 0x1

	// P100PFS: P100 Pin Function Control Register
	// Position of PSEL field.
	PFS_P100PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P100PFS_PSEL_Msk = 0x1f000000
	// Position of PMR field.
	PFS_P100PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P100PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P100PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P100PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P100PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P100PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P100PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P100PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P100PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P100PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P100PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P100PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P100PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P100PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P100PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P100PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P100PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P100PFS_EOF = 0x2000
	// Do not care
	PFS_P100PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P100PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P100PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P100PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P100PFS_EOR = 0x1000
	// Do not care
	PFS_P100PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P100PFS_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P100PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P100PFS_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P100PFS_DSCR_00 = 0x0
	// Middle drive output
	PFS_P100PFS_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P100PFS_DSCR_10 = 0x2
	// High-drive output
	PFS_P100PFS_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P100PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P100PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P100PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_PIDR = 0x2
	// Low input
	PFS_P100PFS_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_PODR = 0x1
	// Low output
	PFS_P100PFS_PODR_0 = 0x0
	// High output
	PFS_P100PFS_PODR_1 = 0x1

	// P100PFS_HA: P100 Pin Function Control Register
	// Position of ASEL field.
	PFS_P100PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P100PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P100PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P100PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P100PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P100PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P100PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P100PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P100PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P100PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P100PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P100PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P100PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P100PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P100PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P100PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P100PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P100PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P100PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P100PFS_HA_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P100PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P100PFS_HA_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P100PFS_HA_DSCR_00 = 0x0
	// Middle drive output
	PFS_P100PFS_HA_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P100PFS_HA_DSCR_10 = 0x2
	// High-drive output
	PFS_P100PFS_HA_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P100PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_HA_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P100PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_HA_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P100PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_HA_PIDR = 0x2
	// Low input
	PFS_P100PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_HA_PODR = 0x1
	// Low output
	PFS_P100PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P100PFS_HA_PODR_1 = 0x1

	// P100PFS_BY: P100 Pin Function Control Register
	// Position of NCODR field.
	PFS_P100PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_BY_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P100PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_BY_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P100PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_BY_PIDR = 0x2
	// Low input
	PFS_P100PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_BY_PODR = 0x1
	// Low output
	PFS_P100PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P100PFS_BY_PODR_1 = 0x1

	// P108PFS: P108 Pin Function Control Register
	// Position of PSEL field.
	PFS_P108PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P108PFS_PSEL_Msk = 0x1f000000
	// Position of PMR field.
	PFS_P108PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P108PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P108PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P108PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P108PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P108PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P108PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P108PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P108PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P108PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P108PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P108PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P108PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P108PFS_EOF = 0x2000
	// Do not care
	PFS_P108PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P108PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P108PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P108PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P108PFS_EOR = 0x1000
	// Do not care
	PFS_P108PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P108PFS_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P108PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P108PFS_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P108PFS_DSCR_00 = 0x0
	// Middle drive output
	PFS_P108PFS_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P108PFS_DSCR_10 = 0x2
	// High-drive output
	PFS_P108PFS_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P108PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_PIDR = 0x2
	// Low input
	PFS_P108PFS_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_PODR = 0x1
	// Low output
	PFS_P108PFS_PODR_0 = 0x0
	// High output
	PFS_P108PFS_PODR_1 = 0x1

	// P108PFS_HA: P108 Pin Function Control Register
	// Position of ASEL field.
	PFS_P108PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P108PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P108PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P108PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P108PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P108PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P108PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P108PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P108PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P108PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P108PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P108PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P108PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P108PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P108PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P108PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P108PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P108PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P108PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P108PFS_HA_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P108PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P108PFS_HA_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P108PFS_HA_DSCR_00 = 0x0
	// Middle drive output
	PFS_P108PFS_HA_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P108PFS_HA_DSCR_10 = 0x2
	// High-drive output
	PFS_P108PFS_HA_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P108PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_HA_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_HA_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_HA_PIDR = 0x2
	// Low input
	PFS_P108PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_HA_PODR = 0x1
	// Low output
	PFS_P108PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P108PFS_HA_PODR_1 = 0x1

	// P108PFS_BY: P108 Pin Function Control Register
	// Position of NCODR field.
	PFS_P108PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P108PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P108PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P108PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P108PFS_BY_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P108PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P108PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P108PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P108PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P108PFS_BY_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P108PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P108PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P108PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P108PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P108PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P108PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P108PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P108PFS_BY_PIDR = 0x2
	// Low input
	PFS_P108PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P108PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P108PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P108PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P108PFS_BY_PODR = 0x1
	// Low output
	PFS_P108PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P108PFS_BY_PODR_1 = 0x1

	// P110PFS: P110 Pin Function Control Register
	// Position of PSEL field.
	PFS_P110PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P110PFS_PSEL_Msk = 0x1f000000
	// Position of PMR field.
	PFS_P110PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P110PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P110PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P110PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P110PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P110PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P110PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P110PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P110PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P110PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P110PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P110PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P110PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P110PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P110PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P110PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P110PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P110PFS_EOF = 0x2000
	// Do not care
	PFS_P110PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P110PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P110PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P110PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P110PFS_EOR = 0x1000
	// Do not care
	PFS_P110PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P110PFS_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P110PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P110PFS_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P110PFS_DSCR_00 = 0x0
	// Middle drive output
	PFS_P110PFS_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P110PFS_DSCR_10 = 0x2
	// High-drive output
	PFS_P110PFS_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P110PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P110PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P110PFS_NCODR = 0x40
	// CMOS output
	PFS_P110PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P110PFS_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P110PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P110PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P110PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P110PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P110PFS_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P110PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P110PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P110PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P110PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P110PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P110PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P110PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P110PFS_PIDR = 0x2
	// Low input
	PFS_P110PFS_PIDR_0 = 0x0
	// High input
	PFS_P110PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P110PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P110PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P110PFS_PODR = 0x1
	// Low output
	PFS_P110PFS_PODR_0 = 0x0
	// High output
	PFS_P110PFS_PODR_1 = 0x1

	// P110PFS_HA: P110 Pin Function Control Register
	// Position of ASEL field.
	PFS_P110PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P110PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P110PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P110PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P110PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P110PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P110PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P110PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P110PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P110PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P110PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P110PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P110PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P110PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P110PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P110PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P110PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P110PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P110PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P110PFS_HA_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P110PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P110PFS_HA_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P110PFS_HA_DSCR_00 = 0x0
	// Middle drive output
	PFS_P110PFS_HA_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P110PFS_HA_DSCR_10 = 0x2
	// High-drive output
	PFS_P110PFS_HA_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P110PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P110PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P110PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P110PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P110PFS_HA_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P110PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P110PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P110PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P110PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P110PFS_HA_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P110PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P110PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P110PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P110PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P110PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P110PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P110PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P110PFS_HA_PIDR = 0x2
	// Low input
	PFS_P110PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P110PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P110PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P110PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P110PFS_HA_PODR = 0x1
	// Low output
	PFS_P110PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P110PFS_HA_PODR_1 = 0x1

	// P110PFS_BY: P110 Pin Function Control Register
	// Position of NCODR field.
	PFS_P110PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P110PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P110PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P110PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P110PFS_BY_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P110PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P110PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P110PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P110PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P110PFS_BY_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P110PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P110PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P110PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P110PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P110PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P110PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P110PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P110PFS_BY_PIDR = 0x2
	// Low input
	PFS_P110PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P110PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P110PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P110PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P110PFS_BY_PODR = 0x1
	// Low output
	PFS_P110PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P110PFS_BY_PODR_1 = 0x1

	// P201PFS: P201 Pin Function Control Register
	// Position of PSEL field.
	PFS_P201PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P201PFS_PSEL_Msk = 0x1f000000
	// Position of PMR field.
	PFS_P201PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P201PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P201PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P201PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P201PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P201PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P201PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P201PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P201PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P201PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P201PFS_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P201PFS_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P201PFS_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P201PFS_EOF = 0x2000
	// Do not care
	PFS_P201PFS_EOF_0 = 0x0
	// Detect falling edge
	PFS_P201PFS_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P201PFS_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P201PFS_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P201PFS_EOR = 0x1000
	// Do not care
	PFS_P201PFS_EOR_0 = 0x0
	// Detect rising edge
	PFS_P201PFS_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P201PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P201PFS_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P201PFS_DSCR_00 = 0x0
	// Middle drive output
	PFS_P201PFS_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P201PFS_DSCR_10 = 0x2
	// High-drive output
	PFS_P201PFS_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P201PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_PIDR = 0x2
	// Low input
	PFS_P201PFS_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_PODR = 0x1
	// Low output
	PFS_P201PFS_PODR_0 = 0x0
	// High output
	PFS_P201PFS_PODR_1 = 0x1

	// P201PFS_HA: P201 Pin Function Control Register
	// Position of ASEL field.
	PFS_P201PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P201PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P201PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P201PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P201PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P201PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P201PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P201PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P201PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P201PFS_HA_ISEL_1 = 0x1
	// Position of EOF field.
	PFS_P201PFS_HA_EOF_Pos = 0xd
	// Bit mask of EOF field.
	PFS_P201PFS_HA_EOF_Msk = 0x2000
	// Bit EOF.
	PFS_P201PFS_HA_EOF = 0x2000
	// Do not care
	PFS_P201PFS_HA_EOF_0 = 0x0
	// Detect falling edge
	PFS_P201PFS_HA_EOF_1 = 0x1
	// Position of EOR field.
	PFS_P201PFS_HA_EOR_Pos = 0xc
	// Bit mask of EOR field.
	PFS_P201PFS_HA_EOR_Msk = 0x1000
	// Bit EOR.
	PFS_P201PFS_HA_EOR = 0x1000
	// Do not care
	PFS_P201PFS_HA_EOR_0 = 0x0
	// Detect rising edge
	PFS_P201PFS_HA_EOR_1 = 0x1
	// Position of DSCR field.
	PFS_P201PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P201PFS_HA_DSCR_Msk = 0xc00
	// Normal drive output
	PFS_P201PFS_HA_DSCR_00 = 0x0
	// Middle drive output
	PFS_P201PFS_HA_DSCR_01 = 0x1
	// Setting prohibited
	PFS_P201PFS_HA_DSCR_10 = 0x2
	// High-drive output
	PFS_P201PFS_HA_DSCR_11 = 0x3
	// Position of NCODR field.
	PFS_P201PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_HA_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_HA_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_HA_PIDR = 0x2
	// Low input
	PFS_P201PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_HA_PODR = 0x1
	// Low output
	PFS_P201PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P201PFS_HA_PODR_1 = 0x1

	// P201PFS_BY: P201 Pin Function Control Register
	// Position of NCODR field.
	PFS_P201PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P201PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P201PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P201PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P201PFS_BY_NCODR_1 = 0x1
	// Position of PCR field.
	PFS_P201PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P201PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P201PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P201PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P201PFS_BY_PCR_1 = 0x1
	// Position of PDR field.
	PFS_P201PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P201PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P201PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P201PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P201PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P201PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P201PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P201PFS_BY_PIDR = 0x2
	// Low input
	PFS_P201PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P201PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P201PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P201PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P201PFS_BY_PODR = 0x1
	// Low output
	PFS_P201PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P201PFS_BY_PODR_1 = 0x1
)

// Constants for PMISC: Miscellaneous Port Control Register
const (
	// PFENET: Ethernet Control Register
	// Position of PHYMODE0 field.
	PMISC_PFENET_PHYMODE0_Pos = 0x4
	// Bit mask of PHYMODE0 field.
	PMISC_PFENET_PHYMODE0_Msk = 0x10
	// Bit PHYMODE0.
	PMISC_PFENET_PHYMODE0 = 0x10
	// RMII mode (ETHERC channel 0)
	PMISC_PFENET_PHYMODE0_0 = 0x0
	// MII mode (ETHERC channel 0)
	PMISC_PFENET_PHYMODE0_1 = 0x1

	// PWPR: Write-Protect Register
	// Position of BOWI field.
	PMISC_PWPR_BOWI_Pos = 0x7
	// Bit mask of BOWI field.
	PMISC_PWPR_BOWI_Msk = 0x80
	// Bit BOWI.
	PMISC_PWPR_BOWI = 0x80
	// Writing to the PFSWE bit is enabled
	PMISC_PWPR_BOWI_0 = 0x0
	// Writing to the PFSWE bit is disabled
	PMISC_PWPR_BOWI_1 = 0x1
	// Position of PFSWE field.
	PMISC_PWPR_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PMISC_PWPR_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PMISC_PWPR_PFSWE = 0x40
	// Writing to the PFS register is disabled
	PMISC_PWPR_PFSWE_0 = 0x0
	// Writing to the PFS register is enabled
	PMISC_PWPR_PFSWE_1 = 0x1
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// SPCR: SPI Control Register
	// Position of SPRIE field.
	SPI0_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI0_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI0_SPCR_SPRIE = 0x80
	// Disables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_0 = 0x0
	// Enables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_1 = 0x1
	// Position of SPE field.
	SPI0_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI0_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI0_SPCR_SPE = 0x40
	// Disables the SPI function
	SPI0_SPCR_SPE_0 = 0x0
	// Enables the SPI function
	SPI0_SPCR_SPE_1 = 0x1
	// Position of SPTIE field.
	SPI0_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI0_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI0_SPCR_SPTIE = 0x20
	// Disables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_0 = 0x0
	// Enables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_1 = 0x1
	// Position of SPEIE field.
	SPI0_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI0_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI0_SPCR_SPEIE = 0x10
	// Disables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_0 = 0x0
	// Enables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_1 = 0x1
	// Position of MSTR field.
	SPI0_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI0_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI0_SPCR_MSTR = 0x8
	// Slave mode
	SPI0_SPCR_MSTR_0 = 0x0
	// Master mode
	SPI0_SPCR_MSTR_1 = 0x1
	// Position of MODFEN field.
	SPI0_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI0_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI0_SPCR_MODFEN = 0x4
	// Disables the detection of mode fault error
	SPI0_SPCR_MODFEN_0 = 0x0
	// Enables the detection of mode fault error
	SPI0_SPCR_MODFEN_1 = 0x1
	// Position of TXMD field.
	SPI0_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI0_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI0_SPCR_TXMD = 0x2
	// Full-duplex synchronous serial communications
	SPI0_SPCR_TXMD_0 = 0x0
	// Serial communications consisting of only transmit operations
	SPI0_SPCR_TXMD_1 = 0x1
	// Position of SPMS field.
	SPI0_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI0_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI0_SPCR_SPMS = 0x1
	// SPI operation (4-wire method)
	SPI0_SPCR_SPMS_0 = 0x0
	// Clock synchronous operation (3-wire method)
	SPI0_SPCR_SPMS_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of SSL3P field.
	SPI0_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI0_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI0_SSLP_SSL3P = 0x8
	// SSL3 signal is active low
	SPI0_SSLP_SSL3P_0 = 0x0
	// SSL3 signal is active high
	SPI0_SSLP_SSL3P_1 = 0x1
	// Position of SSL2P field.
	SPI0_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI0_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI0_SSLP_SSL2P = 0x4
	// SSL2 signal is active low
	SPI0_SSLP_SSL2P_0 = 0x0
	// SSL2 signal is active high
	SPI0_SSLP_SSL2P_1 = 0x1
	// Position of SSL1P field.
	SPI0_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI0_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI0_SSLP_SSL1P = 0x2
	// SSL1 signal is active low
	SPI0_SSLP_SSL1P_0 = 0x0
	// SSL1 signal is active high
	SPI0_SSLP_SSL1P_1 = 0x1
	// Position of SSL0P field.
	SPI0_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI0_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI0_SSLP_SSL0P = 0x1
	// SSL0 signal is active low
	SPI0_SSLP_SSL0P_0 = 0x0
	// SSL0 signal is active high
	SPI0_SSLP_SSL0P_1 = 0x1

	// SPPCR: RSPI Pin Control Register
	// Position of MOIFE field.
	SPI0_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI0_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI0_SPPCR_MOIFE = 0x20
	// MOSI output value equals final data from previous transfer
	SPI0_SPPCR_MOIFE_0 = 0x0
	// MOSI output value equals the value set in the MOIFV bit
	SPI0_SPPCR_MOIFE_1 = 0x1
	// Position of MOIFV field.
	SPI0_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI0_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI0_SPPCR_MOIFV = 0x10
	// The level output on the MOSIn pin during MOSI idling corresponds to low.
	SPI0_SPPCR_MOIFV_0 = 0x0
	// The level output on the MOSIn pin during MOSI idling corresponds to high.
	SPI0_SPPCR_MOIFV_1 = 0x1
	// Position of SPLP2 field.
	SPI0_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI0_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI0_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI0_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (data is not inverted for transmission)
	SPI0_SPPCR_SPLP2_1 = 0x1
	// Position of SPLP field.
	SPI0_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI0_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI0_SPPCR_SPLP = 0x1
	// Normal mode
	SPI0_SPPCR_SPLP_0 = 0x0
	// Loopback mode (data is inverted for transmission)
	SPI0_SPPCR_SPLP_1 = 0x1

	// SPSR: SPI Status Register
	// Position of SPRF field.
	SPI0_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI0_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI0_SPSR_SPRF = 0x80
	// No valid data in SPDR
	SPI0_SPSR_SPRF_0 = 0x0
	// Valid data found in SPDR
	SPI0_SPSR_SPRF_1 = 0x1
	// Position of SPTEF field.
	SPI0_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI0_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI0_SPSR_SPTEF = 0x20
	// Data found in the transmit buffer
	SPI0_SPSR_SPTEF_0 = 0x0
	// No data in the transmit buffer
	SPI0_SPSR_SPTEF_1 = 0x1
	// Position of UDRF field.
	SPI0_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI0_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI0_SPSR_UDRF = 0x10
	// A mode fault error occurs (MODF=1)
	SPI0_SPSR_UDRF_0 = 0x0
	// An underrun error occurs (MODF=1)
	SPI0_SPSR_UDRF_1 = 0x1
	// Position of PERF field.
	SPI0_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI0_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI0_SPSR_PERF = 0x8
	// No parity error occurs
	SPI0_SPSR_PERF_0 = 0x0
	// A parity error occurs
	SPI0_SPSR_PERF_1 = 0x1
	// Position of MODF field.
	SPI0_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI0_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI0_SPSR_MODF = 0x4
	// Neither mode fault error nor underrun error occurs
	SPI0_SPSR_MODF_0 = 0x0
	// A mode fault error or an underrun error occurs.
	SPI0_SPSR_MODF_1 = 0x1
	// Position of IDLNF field.
	SPI0_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI0_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI0_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI0_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI0_SPSR_IDLNF_1 = 0x1
	// Position of OVRF field.
	SPI0_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI0_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI0_SPSR_OVRF = 0x1
	// No overrun error occurs
	SPI0_SPSR_OVRF_0 = 0x0
	// An overrun error occurs
	SPI0_SPSR_OVRF_1 = 0x1

	// SPDR: SPI Data Register
	// Position of SPDR field.
	SPI0_SPDR_SPDR_Pos = 0x0
	// Bit mask of SPDR field.
	SPI0_SPDR_SPDR_Msk = 0xffffffff

	// SPDR_HA: SPI Data Register ( halfword access )
	// Position of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Pos = 0x0
	// Bit mask of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Msk = 0xffff

	// SPSCR: SPI Sequence Control Register
	// Position of SPSLN field.
	SPI0_SPSCR_SPSLN_Pos = 0x0
	// Bit mask of SPSLN field.
	SPI0_SPSCR_SPSLN_Msk = 0x7
	// Length 1 SPDMDx x = 0->0->...
	SPI0_SPSCR_SPSLN_000 = 0x0
	// Length 2 SPDMDx x = 0->1->0->...
	SPI0_SPSCR_SPSLN_001 = 0x1
	// Length 3 SPDMDx x = 0->1->2->0->...
	SPI0_SPSCR_SPSLN_010 = 0x2
	// Length 4 SPDMDx x = 0->1->2->3->0->...
	SPI0_SPSCR_SPSLN_011 = 0x3
	// Length 5 SPDMDx x = 0->1->2->3->4->0->...
	SPI0_SPSCR_SPSLN_100 = 0x4
	// Length 6 SPDMDx x = 0->1->2->3->4->5->0->...
	SPI0_SPSCR_SPSLN_101 = 0x5
	// Length 7 SPDMDx x = 0->1->2->3->4->5->6->0->...
	SPI0_SPSCR_SPSLN_110 = 0x6
	// Length 8 SPDMDx x = 0->1->2->3->4->5->6->7->0->...
	SPI0_SPSCR_SPSLN_111 = 0x7

	// SPSSR: SPI Sequence Status Register
	// Position of SPECM field.
	SPI0_SPSSR_SPECM_Pos = 0x4
	// Bit mask of SPECM field.
	SPI0_SPSSR_SPECM_Msk = 0x70
	// SPCMD0
	SPI0_SPSSR_SPECM_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPECM_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPECM_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPECM_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPECM_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPECM_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPECM_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPECM_111 = 0x7
	// Position of SPCP field.
	SPI0_SPSSR_SPCP_Pos = 0x0
	// Bit mask of SPCP field.
	SPI0_SPSSR_SPCP_Msk = 0x7
	// SPCMD0
	SPI0_SPSSR_SPCP_000 = 0x0
	// SPCMD1
	SPI0_SPSSR_SPCP_001 = 0x1
	// SPCMD2
	SPI0_SPSSR_SPCP_010 = 0x2
	// SPCMD3
	SPI0_SPSSR_SPCP_011 = 0x3
	// SPCMD4
	SPI0_SPSSR_SPCP_100 = 0x4
	// SPCMD5
	SPI0_SPSSR_SPCP_101 = 0x5
	// SPCMD6
	SPI0_SPSSR_SPCP_110 = 0x6
	// SPCMD7
	SPI0_SPSSR_SPCP_111 = 0x7

	// SPBR: SPI Bit Rate Register
	// Position of SPR field.
	SPI0_SPBR_SPR_Pos = 0x0
	// Bit mask of SPR field.
	SPI0_SPBR_SPR_Msk = 0xff

	// SPDCR: SPI Data Control Register
	// Position of SPBYT field.
	SPI0_SPDCR_SPBYT_Pos = 0x6
	// Bit mask of SPBYT field.
	SPI0_SPDCR_SPBYT_Msk = 0x40
	// Bit SPBYT.
	SPI0_SPDCR_SPBYT = 0x40
	// SPDR is accessed in word or longword (SPLW is valid)
	SPI0_SPDCR_SPBYT_0 = 0x0
	// SPDR is accessed in byte (SPLW is invalid)
	SPI0_SPDCR_SPBYT_1 = 0x1
	// Position of SPLW field.
	SPI0_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI0_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI0_SPDCR_SPLW = 0x20
	// SPDR_HA is valid to access in halfwords
	SPI0_SPDCR_SPLW_0 = 0x0
	// SPDR is valid (to access in words).
	SPI0_SPDCR_SPLW_1 = 0x1
	// Position of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI0_SPDCR_SPRDTD = 0x10
	// SPDR values are read from the receive buffer
	SPI0_SPDCR_SPRDTD_0 = 0x0
	// SPDR values are read from the transmit buffer (but only if the transmit buffer is empty)
	SPI0_SPDCR_SPRDTD_1 = 0x1
	// Position of SPFC field.
	SPI0_SPDCR_SPFC_Pos = 0x0
	// Bit mask of SPFC field.
	SPI0_SPDCR_SPFC_Msk = 0x3
	// 1 frame
	SPI0_SPDCR_SPFC_00 = 0x0
	// 2 frames
	SPI0_SPDCR_SPFC_01 = 0x1
	// 3 frames
	SPI0_SPDCR_SPFC_10 = 0x2
	// 4 frames.
	SPI0_SPDCR_SPFC_11 = 0x3

	// SPCKD: SPI Clock Delay Register
	// Position of SCKDL field.
	SPI0_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI0_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI0_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI0_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI0_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI0_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI0_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI0_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI0_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of SLNDL field.
	SPI0_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI0_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI0_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI0_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI0_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI0_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI0_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI0_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI0_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of SPNDL field.
	SPI0_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI0_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of SCKASE field.
	SPI0_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI0_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI0_SPCR2_SCKASE = 0x10
	// Disables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_0 = 0x0
	// Enables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_1 = 0x1
	// Position of PTE field.
	SPI0_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI0_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI0_SPCR2_PTE = 0x8
	// Disables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_0 = 0x0
	// Enables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_1 = 0x1
	// Position of SPIIE field.
	SPI0_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI0_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI0_SPCR2_SPIIE = 0x4
	// Disables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_0 = 0x0
	// Enables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_1 = 0x1
	// Position of SPOE field.
	SPI0_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI0_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI0_SPCR2_SPOE = 0x2
	// Selects even parity for use in transmission and reception
	SPI0_SPCR2_SPOE_0 = 0x0
	// Selects odd parity for use in transmission and reception
	SPI0_SPCR2_SPOE_1 = 0x1
	// Position of SPPE field.
	SPI0_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI0_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI0_SPCR2_SPPE = 0x1
	// Does not add the parity bit to transmit data and does not check the parity bit of receive data
	SPI0_SPCR2_SPPE_0 = 0x0
	// Adds the parity bit to transmit data and checks the parity bit of receive data (when SPCR.TXMD = 0) / Adds the parity bit to transmit data but does not check the parity bit of receive data (when SPCR.TXMD = 1)
	SPI0_SPCR2_SPPE_1 = 0x1

	// SPCMD0: SPI Command Register %s
	// Position of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI0_SPCMD_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI0_SPCMD_SCKDEN = 0x8000
	// An RSPCK delay of 1 RSPCK
	SPI0_SPCMD_SCKDEN_0 = 0x0
	// An RSPCK delay is equal to the setting of the RSPI clock delay register (SPCKD)
	SPI0_SPCMD_SCKDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI0_SPCMD_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI0_SPCMD_SLNDEN = 0x4000
	// An SSL negation delay of 1 RSPCK
	SPI0_SPCMD_SLNDEN_0 = 0x0
	// An SSL negation delay is equal to the setting of the RSPI slave select negation delay register (SSLND)
	SPI0_SPCMD_SLNDEN_1 = 0x1
	// Position of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI0_SPCMD_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI0_SPCMD_SPNDEN = 0x2000
	// A next-access delay of 1 RSPCK + 2 PCLK
	SPI0_SPCMD_SPNDEN_0 = 0x0
	// A next-access delay is equal to the setting of the RSPI next-access delay register (SPND)
	SPI0_SPCMD_SPNDEN_1 = 0x1
	// Position of LSBF field.
	SPI0_SPCMD_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI0_SPCMD_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI0_SPCMD_LSBF = 0x1000
	// MSB first
	SPI0_SPCMD_LSBF_0 = 0x0
	// LSB first
	SPI0_SPCMD_LSBF_1 = 0x1
	// Position of SPB field.
	SPI0_SPCMD_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI0_SPCMD_SPB_Msk = 0xf00
	// 20 bits
	SPI0_SPCMD_SPB_0000 = 0x0
	// 24 bits
	SPI0_SPCMD_SPB_0001 = 0x1
	// 32 bits
	SPI0_SPCMD_SPB_0010 = 0x2
	// 32 bits
	SPI0_SPCMD_SPB_0011 = 0x3
	// 9 bits
	SPI0_SPCMD_SPB_1000 = 0x8
	// 10 bits
	SPI0_SPCMD_SPB_1001 = 0x9
	// 11 bits
	SPI0_SPCMD_SPB_1010 = 0xa
	// 12 bits
	SPI0_SPCMD_SPB_1011 = 0xb
	// 13 bits
	SPI0_SPCMD_SPB_1100 = 0xc
	// 14 bits
	SPI0_SPCMD_SPB_1101 = 0xd
	// 15 bits
	SPI0_SPCMD_SPB_1110 = 0xe
	// 16 bits
	SPI0_SPCMD_SPB_1111 = 0xf
	// Position of SSLKP field.
	SPI0_SPCMD_SSLKP_Pos = 0x7
	// Bit mask of SSLKP field.
	SPI0_SPCMD_SSLKP_Msk = 0x80
	// Bit SSLKP.
	SPI0_SPCMD_SSLKP = 0x80
	// Negate all SSL signals on completion of transfer
	SPI0_SPCMD_SSLKP_0 = 0x0
	// Keep SSL signal level from the end of transfer until the beginning
	SPI0_SPCMD_SSLKP_1 = 0x1
	// Position of SSLA field.
	SPI0_SPCMD_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI0_SPCMD_SSLA_Msk = 0x70
	// SSL0
	SPI0_SPCMD_SSLA_000 = 0x0
	// SSL1
	SPI0_SPCMD_SSLA_001 = 0x1
	// SSL2
	SPI0_SPCMD_SSLA_010 = 0x2
	// SSL3
	SPI0_SPCMD_SSLA_011 = 0x3
	// Position of BRDV field.
	SPI0_SPCMD_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI0_SPCMD_BRDV_Msk = 0xc
	// These bits select the base bit rate
	SPI0_SPCMD_BRDV_00 = 0x0
	// These bits select the base bit rate divided by 2
	SPI0_SPCMD_BRDV_01 = 0x1
	// These bits select the base bit rate divided by 4
	SPI0_SPCMD_BRDV_10 = 0x2
	// These bits select the base bit rate divided by 8
	SPI0_SPCMD_BRDV_11 = 0x3
	// Position of CPOL field.
	SPI0_SPCMD_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI0_SPCMD_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI0_SPCMD_CPOL = 0x2
	// RSPCK is low when idle
	SPI0_SPCMD_CPOL_0 = 0x0
	// RSPCK is high when idle
	SPI0_SPCMD_CPOL_1 = 0x1
	// Position of CPHA field.
	SPI0_SPCMD_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI0_SPCMD_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI0_SPCMD_CPHA = 0x1
	// Data sampling on odd edge, data variation on even edge
	SPI0_SPCMD_CPHA_0 = 0x0
	// Data variation on odd edge, data sampling on even edge
	SPI0_SPCMD_CPHA_1 = 0x1

	// SPDCR2: SPI Data Control Register 2
	// Position of BYSW field.
	SPI0_SPDCR2_BYSW_Pos = 0x0
	// Bit mask of BYSW field.
	SPI0_SPDCR2_BYSW_Msk = 0x1
	// Bit BYSW.
	SPI0_SPDCR2_BYSW = 0x1
	// Byte Swap Operating Mode disabled
	SPI0_SPDCR2_BYSW_0 = 0x0
	// Byte Swap Operating Mode enabled
	SPI0_SPDCR2_BYSW_1 = 0x1
)

// Constants for GPT_OPS: Output Phase Switching Controller
const (
	// OPSCR: Output Phase Switching Control Register
	// Position of NFCS field.
	GPT_OPS_OPSCR_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	GPT_OPS_OPSCR_NFCS_Msk = 0xc0000000
	// PCLK/1
	GPT_OPS_OPSCR_NFCS_00 = 0x0
	// PCLK/4
	GPT_OPS_OPSCR_NFCS_01 = 0x1
	// PCLK/16
	GPT_OPS_OPSCR_NFCS_10 = 0x2
	// PCLK/64
	GPT_OPS_OPSCR_NFCS_11 = 0x3
	// Position of NFEN field.
	GPT_OPS_OPSCR_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	GPT_OPS_OPSCR_NFEN_Msk = 0x20000000
	// Bit NFEN.
	GPT_OPS_OPSCR_NFEN = 0x20000000
	// Do not use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_0 = 0x0
	// Use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_1 = 0x1
	// Position of GODF field.
	GPT_OPS_OPSCR_GODF_Pos = 0x1a
	// Bit mask of GODF field.
	GPT_OPS_OPSCR_GODF_Msk = 0x4000000
	// Bit GODF.
	GPT_OPS_OPSCR_GODF = 0x4000000
	// This bit function is ignored.
	GPT_OPS_OPSCR_GODF_0 = 0x0
	// Group disable will clear OPSCR.EN Bit.
	GPT_OPS_OPSCR_GODF_1 = 0x1
	// Position of GRP field.
	GPT_OPS_OPSCR_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT_OPS_OPSCR_GRP_Msk = 0x3000000
	// Select Group A output disable source
	GPT_OPS_OPSCR_GRP_00 = 0x0
	// Select Group B output disable source
	GPT_OPS_OPSCR_GRP_01 = 0x1
	// Select Group C output disable source
	GPT_OPS_OPSCR_GRP_10 = 0x2
	// Select Group D output disable source
	GPT_OPS_OPSCR_GRP_11 = 0x3
	// Position of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Pos = 0x15
	// Bit mask of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Msk = 0x200000
	// Bit ALIGN.
	GPT_OPS_OPSCR_ALIGN = 0x200000
	// Input phase is aligned to PCLK.
	GPT_OPS_OPSCR_ALIGN_0 = 0x0
	// Input phase is aligned PWM.
	GPT_OPS_OPSCR_ALIGN_1 = 0x1
	// Position of RV field.
	GPT_OPS_OPSCR_RV_Pos = 0x14
	// Bit mask of RV field.
	GPT_OPS_OPSCR_RV_Msk = 0x100000
	// Bit RV.
	GPT_OPS_OPSCR_RV = 0x100000
	// U/V/W-Phase output
	GPT_OPS_OPSCR_RV_0 = 0x0
	// Output to reverse the V / W-phase
	GPT_OPS_OPSCR_RV_1 = 0x1
	// Position of INV field.
	GPT_OPS_OPSCR_INV_Pos = 0x13
	// Bit mask of INV field.
	GPT_OPS_OPSCR_INV_Msk = 0x80000
	// Bit INV.
	GPT_OPS_OPSCR_INV = 0x80000
	// Positive Logic (Active High)output
	GPT_OPS_OPSCR_INV_0 = 0x0
	// Negative Logic (Active Low)output
	GPT_OPS_OPSCR_INV_1 = 0x1
	// Position of N field.
	GPT_OPS_OPSCR_N_Pos = 0x12
	// Bit mask of N field.
	GPT_OPS_OPSCR_N_Msk = 0x40000
	// Bit N.
	GPT_OPS_OPSCR_N = 0x40000
	// Level signal output
	GPT_OPS_OPSCR_N_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_N_1 = 0x1
	// Position of P field.
	GPT_OPS_OPSCR_P_Pos = 0x11
	// Bit mask of P field.
	GPT_OPS_OPSCR_P_Msk = 0x20000
	// Bit P.
	GPT_OPS_OPSCR_P = 0x20000
	// Level signal output
	GPT_OPS_OPSCR_P_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_P_1 = 0x1
	// Position of FB field.
	GPT_OPS_OPSCR_FB_Pos = 0x10
	// Bit mask of FB field.
	GPT_OPS_OPSCR_FB_Msk = 0x10000
	// Bit FB.
	GPT_OPS_OPSCR_FB = 0x10000
	// Select the external input.
	GPT_OPS_OPSCR_FB_0 = 0x0
	// Select the soft setting(OPSCR.UF, VF, WF).
	GPT_OPS_OPSCR_FB_1 = 0x1
	// Position of EN field.
	GPT_OPS_OPSCR_EN_Pos = 0x8
	// Bit mask of EN field.
	GPT_OPS_OPSCR_EN_Msk = 0x100
	// Bit EN.
	GPT_OPS_OPSCR_EN = 0x100
	// Not Output(Hi-Z external terminals).
	GPT_OPS_OPSCR_EN_0 = 0x0
	// Output
	GPT_OPS_OPSCR_EN_1 = 0x1
	// Position of W field.
	GPT_OPS_OPSCR_W_Pos = 0x6
	// Bit mask of W field.
	GPT_OPS_OPSCR_W_Msk = 0x40
	// Bit W.
	GPT_OPS_OPSCR_W = 0x40
	// Position of V field.
	GPT_OPS_OPSCR_V_Pos = 0x5
	// Bit mask of V field.
	GPT_OPS_OPSCR_V_Msk = 0x20
	// Bit V.
	GPT_OPS_OPSCR_V = 0x20
	// Position of U field.
	GPT_OPS_OPSCR_U_Pos = 0x4
	// Bit mask of U field.
	GPT_OPS_OPSCR_U_Msk = 0x10
	// Bit U.
	GPT_OPS_OPSCR_U = 0x10
	// Position of WF field.
	GPT_OPS_OPSCR_WF_Pos = 0x2
	// Bit mask of WF field.
	GPT_OPS_OPSCR_WF_Msk = 0x4
	// Bit WF.
	GPT_OPS_OPSCR_WF = 0x4
	// Position of VF field.
	GPT_OPS_OPSCR_VF_Pos = 0x1
	// Bit mask of VF field.
	GPT_OPS_OPSCR_VF_Msk = 0x2
	// Bit VF.
	GPT_OPS_OPSCR_VF = 0x2
	// Position of UF field.
	GPT_OPS_OPSCR_UF_Pos = 0x0
	// Bit mask of UF field.
	GPT_OPS_OPSCR_UF_Msk = 0x1
	// Bit UF.
	GPT_OPS_OPSCR_UF = 0x1
)

// Constants for GPT32EH0: General PWM Timer 0 (32-bit Enhanced High Resolution)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of PRKEY field.
	GPT32EH0_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT32EH0_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT32EH0_GTWP_PRKEY_0xA5 = 0xa5
	// Position of WP field.
	GPT32EH0_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT32EH0_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT32EH0_GTWP_WP = 0x1
	// Enable writes to the register
	GPT32EH0_GTWP_WP_0 = 0x0
	// Disable writes to the register
	GPT32EH0_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT13 field.
	GPT32EH0_GTSTR_CSTRT13_Pos = 0xd
	// Bit mask of CSTRT13 field.
	GPT32EH0_GTSTR_CSTRT13_Msk = 0x2000
	// Bit CSTRT13.
	GPT32EH0_GTSTR_CSTRT13 = 0x2000
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT13_0 = 0x0
	// GPT3213.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT13_1 = 0x1
	// Position of CSTRT12 field.
	GPT32EH0_GTSTR_CSTRT12_Pos = 0xc
	// Bit mask of CSTRT12 field.
	GPT32EH0_GTSTR_CSTRT12_Msk = 0x1000
	// Bit CSTRT12.
	GPT32EH0_GTSTR_CSTRT12 = 0x1000
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT12_0 = 0x0
	// GPT3212.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT12_1 = 0x1
	// Position of CSTRT11 field.
	GPT32EH0_GTSTR_CSTRT11_Pos = 0xb
	// Bit mask of CSTRT11 field.
	GPT32EH0_GTSTR_CSTRT11_Msk = 0x800
	// Bit CSTRT11.
	GPT32EH0_GTSTR_CSTRT11 = 0x800
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT11_0 = 0x0
	// GPT3211.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT11_1 = 0x1
	// Position of CSTRT10 field.
	GPT32EH0_GTSTR_CSTRT10_Pos = 0xa
	// Bit mask of CSTRT10 field.
	GPT32EH0_GTSTR_CSTRT10_Msk = 0x400
	// Bit CSTRT10.
	GPT32EH0_GTSTR_CSTRT10 = 0x400
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT10_0 = 0x0
	// GPT3210.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT10_1 = 0x1
	// Position of CSTRT9 field.
	GPT32EH0_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT32EH0_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT32EH0_GTSTR_CSTRT9 = 0x200
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT9_0 = 0x0
	// GPT329.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT9_1 = 0x1
	// Position of CSTRT8 field.
	GPT32EH0_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT32EH0_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT32EH0_GTSTR_CSTRT8 = 0x100
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT8_0 = 0x0
	// GPT328.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT7 field.
	GPT32EH0_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT32EH0_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT32EH0_GTSTR_CSTRT7 = 0x80
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT7_0 = 0x0
	// GPT32E7.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT6 field.
	GPT32EH0_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT32EH0_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT32EH0_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT6_0 = 0x0
	// GPT32E6.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT32EH0_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT32EH0_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT32EH0_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT5_0 = 0x0
	// GPT32E5.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT32EH0_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT32EH0_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT32EH0_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT4_0 = 0x0
	// GPT32E4.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT32EH0_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT32EH0_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT32EH0_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT3_0 = 0x0
	// GPT32EH3.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT32EH0_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT32EH0_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT32EH0_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT2_0 = 0x0
	// GPT32EH2.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT32EH0_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT32EH0_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT32EH0_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT1_0 = 0x0
	// GPT32EH1.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT32EH0_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT32EH0_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT32EH0_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT32EH0_GTSTR_CSTRT0_0 = 0x0
	// GPT32EH0.GTCNT counter starts (write) / Counter running (read)
	GPT32EH0_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP13 field.
	GPT32EH0_GTSTP_CSTOP13_Pos = 0xd
	// Bit mask of CSTOP13 field.
	GPT32EH0_GTSTP_CSTOP13_Msk = 0x2000
	// Bit CSTOP13.
	GPT32EH0_GTSTP_CSTOP13 = 0x2000
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP13_0 = 0x0
	// GPT3213.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP13_1 = 0x1
	// Position of CSTOP12 field.
	GPT32EH0_GTSTP_CSTOP12_Pos = 0xc
	// Bit mask of CSTOP12 field.
	GPT32EH0_GTSTP_CSTOP12_Msk = 0x1000
	// Bit CSTOP12.
	GPT32EH0_GTSTP_CSTOP12 = 0x1000
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP12_0 = 0x0
	// GPT3212.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP12_1 = 0x1
	// Position of CSTOP11 field.
	GPT32EH0_GTSTP_CSTOP11_Pos = 0xb
	// Bit mask of CSTOP11 field.
	GPT32EH0_GTSTP_CSTOP11_Msk = 0x800
	// Bit CSTOP11.
	GPT32EH0_GTSTP_CSTOP11 = 0x800
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP11_0 = 0x0
	// GPT3211.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP11_1 = 0x1
	// Position of CSTOP10 field.
	GPT32EH0_GTSTP_CSTOP10_Pos = 0xa
	// Bit mask of CSTOP10 field.
	GPT32EH0_GTSTP_CSTOP10_Msk = 0x400
	// Bit CSTOP10.
	GPT32EH0_GTSTP_CSTOP10 = 0x400
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP10_0 = 0x0
	// GPT3210.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP10_1 = 0x1
	// Position of CSTOP9 field.
	GPT32EH0_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT32EH0_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT32EH0_GTSTP_CSTOP9 = 0x200
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP9_0 = 0x0
	// GPT329.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP9_1 = 0x1
	// Position of CSTOP8 field.
	GPT32EH0_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT32EH0_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT32EH0_GTSTP_CSTOP8 = 0x100
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP8_0 = 0x0
	// GPT328.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP7 field.
	GPT32EH0_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT32EH0_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT32EH0_GTSTP_CSTOP7 = 0x80
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP7_0 = 0x0
	// GPT32E7.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP6 field.
	GPT32EH0_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT32EH0_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT32EH0_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP6_0 = 0x0
	// GPT32E6.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT32EH0_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT32EH0_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT32EH0_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP5_0 = 0x0
	// GPT32E5.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT32EH0_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT32EH0_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT32EH0_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP4_0 = 0x0
	// GPT32E4.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT32EH0_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT32EH0_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT32EH0_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP3_0 = 0x0
	// GPT32EH3.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT32EH0_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT32EH0_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT32EH0_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP2_0 = 0x0
	// GPT32EH2.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT32EH0_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT32EH0_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT32EH0_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP1_0 = 0x0
	// GPT32EH1.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT32EH0_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT32EH0_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT32EH0_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT32EH0_GTSTP_CSTOP0_0 = 0x0
	// GPT32EH0.GTCNT counter stops (write) / Counter stop (read)
	GPT32EH0_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR13 field.
	GPT32EH0_GTCLR_CCLR13_Pos = 0xd
	// Bit mask of CCLR13 field.
	GPT32EH0_GTCLR_CCLR13_Msk = 0x2000
	// Bit CCLR13.
	GPT32EH0_GTCLR_CCLR13 = 0x2000
	// No effect
	GPT32EH0_GTCLR_CCLR13_0 = 0x0
	// GPT3213.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR13_1 = 0x1
	// Position of CCLR12 field.
	GPT32EH0_GTCLR_CCLR12_Pos = 0xc
	// Bit mask of CCLR12 field.
	GPT32EH0_GTCLR_CCLR12_Msk = 0x1000
	// Bit CCLR12.
	GPT32EH0_GTCLR_CCLR12 = 0x1000
	// No effect
	GPT32EH0_GTCLR_CCLR12_0 = 0x0
	// GPT3212.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR12_1 = 0x1
	// Position of CCLR11 field.
	GPT32EH0_GTCLR_CCLR11_Pos = 0xb
	// Bit mask of CCLR11 field.
	GPT32EH0_GTCLR_CCLR11_Msk = 0x800
	// Bit CCLR11.
	GPT32EH0_GTCLR_CCLR11 = 0x800
	// No effect
	GPT32EH0_GTCLR_CCLR11_0 = 0x0
	// GPT3211.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR11_1 = 0x1
	// Position of CCLR10 field.
	GPT32EH0_GTCLR_CCLR10_Pos = 0xa
	// Bit mask of CCLR10 field.
	GPT32EH0_GTCLR_CCLR10_Msk = 0x400
	// Bit CCLR10.
	GPT32EH0_GTCLR_CCLR10 = 0x400
	// No effect
	GPT32EH0_GTCLR_CCLR10_0 = 0x0
	// GPT3210.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR10_1 = 0x1
	// Position of CCLR9 field.
	GPT32EH0_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT32EH0_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT32EH0_GTCLR_CCLR9 = 0x200
	// No effect
	GPT32EH0_GTCLR_CCLR9_0 = 0x0
	// GPT329.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR9_1 = 0x1
	// Position of CCLR8 field.
	GPT32EH0_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT32EH0_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT32EH0_GTCLR_CCLR8 = 0x100
	// No effect
	GPT32EH0_GTCLR_CCLR8_0 = 0x0
	// GPT328.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR7 field.
	GPT32EH0_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT32EH0_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT32EH0_GTCLR_CCLR7 = 0x80
	// No effect
	GPT32EH0_GTCLR_CCLR7_0 = 0x0
	// GPT32E7.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR6 field.
	GPT32EH0_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT32EH0_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT32EH0_GTCLR_CCLR6 = 0x40
	// No effect
	GPT32EH0_GTCLR_CCLR6_0 = 0x0
	// GPT32E6.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT32EH0_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT32EH0_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT32EH0_GTCLR_CCLR5 = 0x20
	// No effect
	GPT32EH0_GTCLR_CCLR5_0 = 0x0
	// GPT32E5.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT32EH0_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT32EH0_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT32EH0_GTCLR_CCLR4 = 0x10
	// No effect
	GPT32EH0_GTCLR_CCLR4_0 = 0x0
	// GPT32E4.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT32EH0_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT32EH0_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT32EH0_GTCLR_CCLR3 = 0x8
	// No effect
	GPT32EH0_GTCLR_CCLR3_0 = 0x0
	// GPT32EH3.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT32EH0_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT32EH0_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT32EH0_GTCLR_CCLR2 = 0x4
	// No effect
	GPT32EH0_GTCLR_CCLR2_0 = 0x0
	// GPT32EH2.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT32EH0_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT32EH0_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT32EH0_GTCLR_CCLR1 = 0x2
	// No effect
	GPT32EH0_GTCLR_CCLR1_0 = 0x0
	// GPT32EH1.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT32EH0_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT32EH0_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT32EH0_GTCLR_CCLR0 = 0x1
	// No effect
	GPT32EH0_GTCLR_CCLR0_0 = 0x0
	// GPT32EH0.GTCNT counter clears
	GPT32EH0_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT32EH0_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT32EH0_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT32EH0_GTSSR_CSTRT = 0x80000000
	// Disable counter start by the GTSTR register
	GPT32EH0_GTSSR_CSTRT_0 = 0x0
	// Enable counter start by the GTSTR register
	GPT32EH0_GTSSR_CSTRT_1 = 0x1
	// Position of SSELCH field.
	GPT32EH0_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT32EH0_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT32EH0_GTSSR_SSELCH = 0x800000
	// Disable counter start on ELC_GPTH input
	GPT32EH0_GTSSR_SSELCH_0 = 0x0
	// Enable counter start on ELC_GPTH input.
	GPT32EH0_GTSSR_SSELCH_1 = 0x1
	// Position of SSELCG field.
	GPT32EH0_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT32EH0_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT32EH0_GTSSR_SSELCG = 0x400000
	// Disable counter start on ELC_GPTG input
	GPT32EH0_GTSSR_SSELCG_0 = 0x0
	// Enable counter start on ELC_GPTG input.
	GPT32EH0_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCF field.
	GPT32EH0_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT32EH0_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT32EH0_GTSSR_SSELCF = 0x200000
	// Disable counter start on ELC_GPTF input
	GPT32EH0_GTSSR_SSELCF_0 = 0x0
	// Enable counter start on ELC_GPTF input
	GPT32EH0_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCE field.
	GPT32EH0_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT32EH0_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT32EH0_GTSSR_SSELCE = 0x100000
	// Disable counter start on ELC_GPTE input
	GPT32EH0_GTSSR_SSELCE_0 = 0x0
	// Enable counter start on ELC_GPTE input
	GPT32EH0_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCD field.
	GPT32EH0_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT32EH0_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT32EH0_GTSSR_SSELCD = 0x80000
	// Disable counter start on ELC_GPTD input
	GPT32EH0_GTSSR_SSELCD_0 = 0x0
	// Enable counter start on ELC_GPTD input.
	GPT32EH0_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT32EH0_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT32EH0_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT32EH0_GTSSR_SSELCC = 0x40000
	// Disable counter start on ELC_GPTC input
	GPT32EH0_GTSSR_SSELCC_0 = 0x0
	// Enable counter start on ELC_GPTC input.
	GPT32EH0_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT32EH0_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT32EH0_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT32EH0_GTSSR_SSELCB = 0x20000
	// Disable counter start on ELC_GPTB input
	GPT32EH0_GTSSR_SSELCB_0 = 0x0
	// Enable counter start on ELC_GPTB input.
	GPT32EH0_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT32EH0_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT32EH0_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT32EH0_GTSSR_SSELCA = 0x10000
	// Disable counter start on ELC_GPTA input
	GPT32EH0_GTSSR_SSELCA_0 = 0x0
	// Enable counter start on ELC_GPTA input.
	GPT32EH0_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT32EH0_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT32EH0_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT32EH0_GTSSR_SSCBFAH = 0x8000
	// Disable counter start on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTSSR_SSCBFAH_0 = 0x0
	// Enable counter start on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT32EH0_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT32EH0_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT32EH0_GTSSR_SSCBFAL = 0x4000
	// Disable counter start on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTSSR_SSCBFAL_0 = 0x0
	// Enable counter start on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT32EH0_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT32EH0_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT32EH0_GTSSR_SSCBRAH = 0x2000
	// Disable counter start on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTSSR_SSCBRAH_0 = 0x0
	// Enable counter start on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT32EH0_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT32EH0_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT32EH0_GTSSR_SSCBRAL = 0x1000
	// Disable counter start on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTSSR_SSCBRAL_0 = 0x0
	// Enable counter start on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT32EH0_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT32EH0_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT32EH0_GTSSR_SSCAFBH = 0x800
	// Disable counter start on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTSSR_SSCAFBH_0 = 0x0
	// Enable counter start on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT32EH0_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT32EH0_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT32EH0_GTSSR_SSCAFBL = 0x400
	// Disable counter start on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTSSR_SSCAFBL_0 = 0x0
	// Enable counter start on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT32EH0_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT32EH0_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT32EH0_GTSSR_SSCARBH = 0x200
	// Disable counter start on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTSSR_SSCARBH_0 = 0x0
	// Enable counter start on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT32EH0_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT32EH0_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT32EH0_GTSSR_SSCARBL = 0x100
	// Disable counter start on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTSSR_SSCARBL_0 = 0x0
	// Enable counter start on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTSSR_SSCARBL_1 = 0x1
	// Position of SSGTRGDF field.
	GPT32EH0_GTSSR_SSGTRGDF_Pos = 0x7
	// Bit mask of SSGTRGDF field.
	GPT32EH0_GTSSR_SSGTRGDF_Msk = 0x80
	// Bit SSGTRGDF.
	GPT32EH0_GTSSR_SSGTRGDF = 0x80
	// Disable counter start on the falling edge of GTETRGD input
	GPT32EH0_GTSSR_SSGTRGDF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGD input.
	GPT32EH0_GTSSR_SSGTRGDF_1 = 0x1
	// Position of SSGTRGDR field.
	GPT32EH0_GTSSR_SSGTRGDR_Pos = 0x6
	// Bit mask of SSGTRGDR field.
	GPT32EH0_GTSSR_SSGTRGDR_Msk = 0x40
	// Bit SSGTRGDR.
	GPT32EH0_GTSSR_SSGTRGDR = 0x40
	// Disable counter start on the rising edge of GTETRGD input
	GPT32EH0_GTSSR_SSGTRGDR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGD input
	GPT32EH0_GTSSR_SSGTRGDR_1 = 0x1
	// Position of SSGTRGCF field.
	GPT32EH0_GTSSR_SSGTRGCF_Pos = 0x5
	// Bit mask of SSGTRGCF field.
	GPT32EH0_GTSSR_SSGTRGCF_Msk = 0x20
	// Bit SSGTRGCF.
	GPT32EH0_GTSSR_SSGTRGCF = 0x20
	// Disable counter start on the falling edge of GTETRGC input
	GPT32EH0_GTSSR_SSGTRGCF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGC input
	GPT32EH0_GTSSR_SSGTRGCF_1 = 0x1
	// Position of SSGTRGCR field.
	GPT32EH0_GTSSR_SSGTRGCR_Pos = 0x4
	// Bit mask of SSGTRGCR field.
	GPT32EH0_GTSSR_SSGTRGCR_Msk = 0x10
	// Bit SSGTRGCR.
	GPT32EH0_GTSSR_SSGTRGCR = 0x10
	// Disable counter start on the rising edge of GTETRGC input
	GPT32EH0_GTSSR_SSGTRGCR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGC input
	GPT32EH0_GTSSR_SSGTRGCR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT32EH0_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT32EH0_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT32EH0_GTSSR_SSGTRGBF = 0x8
	// Disable counter start on the falling edge of GTETRGB input
	GPT32EH0_GTSSR_SSGTRGBF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGB input
	GPT32EH0_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT32EH0_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT32EH0_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT32EH0_GTSSR_SSGTRGBR = 0x4
	// Disable counter start on the rising edge of GTETRGB input
	GPT32EH0_GTSSR_SSGTRGBR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGB input.
	GPT32EH0_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT32EH0_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT32EH0_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT32EH0_GTSSR_SSGTRGAF = 0x2
	// Disable counter start on the falling edge of GTETRGA input
	GPT32EH0_GTSSR_SSGTRGAF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGA input
	GPT32EH0_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT32EH0_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT32EH0_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT32EH0_GTSSR_SSGTRGAR = 0x1
	// Disable counter start on the rising edge of GTETRGA input
	GPT32EH0_GTSSR_SSGTRGAR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGA input.
	GPT32EH0_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT32EH0_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT32EH0_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT32EH0_GTPSR_CSTOP = 0x80000000
	// Disable counter stop by the GTSTP register
	GPT32EH0_GTPSR_CSTOP_0 = 0x0
	// Enable counter stop by the GTSTP register
	GPT32EH0_GTPSR_CSTOP_1 = 0x1
	// Position of PSELCH field.
	GPT32EH0_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT32EH0_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT32EH0_GTPSR_PSELCH = 0x800000
	// Disable counter stop on ELC_GPTH input
	GPT32EH0_GTPSR_PSELCH_0 = 0x0
	// Enable counter stop on ELC_GPTH input
	GPT32EH0_GTPSR_PSELCH_1 = 0x1
	// Position of PSELCG field.
	GPT32EH0_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT32EH0_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT32EH0_GTPSR_PSELCG = 0x400000
	// Disable counter stop on ELC_GPTG input
	GPT32EH0_GTPSR_PSELCG_0 = 0x0
	// Enable counter stop on ELC_GPTG input
	GPT32EH0_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCF field.
	GPT32EH0_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT32EH0_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT32EH0_GTPSR_PSELCF = 0x200000
	// Disable counter stop on ELC_GPTF input
	GPT32EH0_GTPSR_PSELCF_0 = 0x0
	// Enable counter stop on ELC_GPTF input
	GPT32EH0_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCE field.
	GPT32EH0_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT32EH0_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT32EH0_GTPSR_PSELCE = 0x100000
	// Disable counter stop on ELC_GPTE input
	GPT32EH0_GTPSR_PSELCE_0 = 0x0
	// Enable counter stop on ELC_GPTE input
	GPT32EH0_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCD field.
	GPT32EH0_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT32EH0_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT32EH0_GTPSR_PSELCD = 0x80000
	// Disable counter stop on ELC_GPTD input
	GPT32EH0_GTPSR_PSELCD_0 = 0x0
	// Enable counter stop on ELC_GPTD input
	GPT32EH0_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT32EH0_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT32EH0_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT32EH0_GTPSR_PSELCC = 0x40000
	// Disable counter stop on ELC_GPTC input
	GPT32EH0_GTPSR_PSELCC_0 = 0x0
	// Enable counter stop on ELC_GPTC input
	GPT32EH0_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT32EH0_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT32EH0_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT32EH0_GTPSR_PSELCB = 0x20000
	// Disable counter stop on ELC_GPTB input
	GPT32EH0_GTPSR_PSELCB_0 = 0x0
	// Enable counter stop on ELC_GPTB input
	GPT32EH0_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT32EH0_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT32EH0_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT32EH0_GTPSR_PSELCA = 0x10000
	// Disable counter stop on ELC_GPTA input
	GPT32EH0_GTPSR_PSELCA_0 = 0x0
	// Enable counter stop on ELC_GPTA input
	GPT32EH0_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT32EH0_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT32EH0_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT32EH0_GTPSR_PSCBFAH = 0x8000
	// Disable counter stop on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTPSR_PSCBFAH_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT32EH0_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT32EH0_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT32EH0_GTPSR_PSCBFAL = 0x4000
	// Disable counter stop on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTPSR_PSCBFAL_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT32EH0_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT32EH0_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT32EH0_GTPSR_PSCBRAH = 0x2000
	// Disable counter stop on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTPSR_PSCBRAH_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT32EH0_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT32EH0_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT32EH0_GTPSR_PSCBRAL = 0x1000
	// Disable counter stop on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTPSR_PSCBRAL_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT32EH0_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT32EH0_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT32EH0_GTPSR_PSCAFBH = 0x800
	// Disable counter stop on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTPSR_PSCAFBH_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT32EH0_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT32EH0_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT32EH0_GTPSR_PSCAFBL = 0x400
	// Disable counter stop on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTPSR_PSCAFBL_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT32EH0_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT32EH0_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT32EH0_GTPSR_PSCARBH = 0x200
	// Disable counter stop on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTPSR_PSCARBH_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT32EH0_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT32EH0_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT32EH0_GTPSR_PSCARBL = 0x100
	// Disable counter stop on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTPSR_PSCARBL_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTPSR_PSCARBL_1 = 0x1
	// Position of PSGTRGDF field.
	GPT32EH0_GTPSR_PSGTRGDF_Pos = 0x7
	// Bit mask of PSGTRGDF field.
	GPT32EH0_GTPSR_PSGTRGDF_Msk = 0x80
	// Bit PSGTRGDF.
	GPT32EH0_GTPSR_PSGTRGDF = 0x80
	// Disable counter stop on the falling edge of GTETRGD input
	GPT32EH0_GTPSR_PSGTRGDF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGD input
	GPT32EH0_GTPSR_PSGTRGDF_1 = 0x1
	// Position of PSGTRGDR field.
	GPT32EH0_GTPSR_PSGTRGDR_Pos = 0x6
	// Bit mask of PSGTRGDR field.
	GPT32EH0_GTPSR_PSGTRGDR_Msk = 0x40
	// Bit PSGTRGDR.
	GPT32EH0_GTPSR_PSGTRGDR = 0x40
	// Disable counter stop on the rising edge of GTETRGD input
	GPT32EH0_GTPSR_PSGTRGDR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGD input
	GPT32EH0_GTPSR_PSGTRGDR_1 = 0x1
	// Position of PSGTRGCF field.
	GPT32EH0_GTPSR_PSGTRGCF_Pos = 0x5
	// Bit mask of PSGTRGCF field.
	GPT32EH0_GTPSR_PSGTRGCF_Msk = 0x20
	// Bit PSGTRGCF.
	GPT32EH0_GTPSR_PSGTRGCF = 0x20
	// Disable counter stop on the falling edge of GTETRGC input
	GPT32EH0_GTPSR_PSGTRGCF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGC input
	GPT32EH0_GTPSR_PSGTRGCF_1 = 0x1
	// Position of PSGTRGCR field.
	GPT32EH0_GTPSR_PSGTRGCR_Pos = 0x4
	// Bit mask of PSGTRGCR field.
	GPT32EH0_GTPSR_PSGTRGCR_Msk = 0x10
	// Bit PSGTRGCR.
	GPT32EH0_GTPSR_PSGTRGCR = 0x10
	// Disable counter stop on the rising edge of GTETRGC input
	GPT32EH0_GTPSR_PSGTRGCR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGC input
	GPT32EH0_GTPSR_PSGTRGCR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT32EH0_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT32EH0_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT32EH0_GTPSR_PSGTRGBF = 0x8
	// Disable counter stop on the falling edge of GTETRGB input
	GPT32EH0_GTPSR_PSGTRGBF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGB input
	GPT32EH0_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT32EH0_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT32EH0_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT32EH0_GTPSR_PSGTRGBR = 0x4
	// Disable counter stop on the rising edge of GTETRGB input
	GPT32EH0_GTPSR_PSGTRGBR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGB input
	GPT32EH0_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT32EH0_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT32EH0_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT32EH0_GTPSR_PSGTRGAF = 0x2
	// Disable counter stop on the falling edge of GTETRGA input
	GPT32EH0_GTPSR_PSGTRGAF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGA input
	GPT32EH0_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT32EH0_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT32EH0_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT32EH0_GTPSR_PSGTRGAR = 0x1
	// Disable counter stop on the rising edge of GTETRGA input
	GPT32EH0_GTPSR_PSGTRGAR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGA input
	GPT32EH0_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT32EH0_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT32EH0_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT32EH0_GTCSR_CCLR = 0x80000000
	// Disable counter clear by the GTCLR register
	GPT32EH0_GTCSR_CCLR_0 = 0x0
	// Enable counter clear by the GTCLR register
	GPT32EH0_GTCSR_CCLR_1 = 0x1
	// Position of CSELCH field.
	GPT32EH0_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT32EH0_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT32EH0_GTCSR_CSELCH = 0x800000
	// Disable counter clear on ELC_GPTH input
	GPT32EH0_GTCSR_CSELCH_0 = 0x0
	// Enable counter clear on ELC_GPTH input
	GPT32EH0_GTCSR_CSELCH_1 = 0x1
	// Position of CSELCG field.
	GPT32EH0_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT32EH0_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT32EH0_GTCSR_CSELCG = 0x400000
	// Disable counter clear on ELC_GPTG input
	GPT32EH0_GTCSR_CSELCG_0 = 0x0
	// Enable counter clear on ELC_GPTG input
	GPT32EH0_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCF field.
	GPT32EH0_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT32EH0_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT32EH0_GTCSR_CSELCF = 0x200000
	// Disable counter clear on ELC_GPTF input
	GPT32EH0_GTCSR_CSELCF_0 = 0x0
	// Enable counter clear on ELC_GPTF input
	GPT32EH0_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCE field.
	GPT32EH0_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT32EH0_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT32EH0_GTCSR_CSELCE = 0x100000
	// Disable counter clear on ELC_GPTE input
	GPT32EH0_GTCSR_CSELCE_0 = 0x0
	// Enable counter clear on ELC_GPTE input
	GPT32EH0_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCD field.
	GPT32EH0_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT32EH0_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT32EH0_GTCSR_CSELCD = 0x80000
	// Disable counter clear on ELC_GPTD input
	GPT32EH0_GTCSR_CSELCD_0 = 0x0
	// Enable counter clear on ELC_GPTD input
	GPT32EH0_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT32EH0_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT32EH0_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT32EH0_GTCSR_CSELCC = 0x40000
	// Disable counter clear on ELC_GPTC input
	GPT32EH0_GTCSR_CSELCC_0 = 0x0
	// Enable counter clear on ELC_GPTC input
	GPT32EH0_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT32EH0_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT32EH0_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT32EH0_GTCSR_CSELCB = 0x20000
	// Disable counter clear on ELC_GPTB input
	GPT32EH0_GTCSR_CSELCB_0 = 0x0
	// Enable counter clear on ELC_GPTB input
	GPT32EH0_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT32EH0_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT32EH0_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT32EH0_GTCSR_CSELCA = 0x10000
	// Disable counter clear on ELC_GPTA input
	GPT32EH0_GTCSR_CSELCA_0 = 0x0
	// Enable counter clear on ELC_GPTA input
	GPT32EH0_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT32EH0_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT32EH0_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT32EH0_GTCSR_CSCBFAH = 0x8000
	// Disable counter clear on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTCSR_CSCBFAH_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT32EH0_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT32EH0_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT32EH0_GTCSR_CSCBFAL = 0x4000
	// Disable counter clear on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTCSR_CSCBFAL_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT32EH0_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT32EH0_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT32EH0_GTCSR_CSCBRAH = 0x2000
	// Disable counter clear on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTCSR_CSCBRAH_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT32EH0_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT32EH0_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT32EH0_GTCSR_CSCBRAL = 0x1000
	// Disable counter clear on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTCSR_CSCBRAL_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT32EH0_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT32EH0_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT32EH0_GTCSR_CSCAFBH = 0x800
	// Disable counter clear on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTCSR_CSCAFBH_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT32EH0_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT32EH0_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT32EH0_GTCSR_CSCAFBL = 0x400
	// Disable counter clear on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTCSR_CSCAFBL_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT32EH0_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT32EH0_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT32EH0_GTCSR_CSCARBH = 0x200
	// Disable counter clear on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTCSR_CSCARBH_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT32EH0_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT32EH0_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT32EH0_GTCSR_CSCARBL = 0x100
	// Disable counter clear on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTCSR_CSCARBL_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTCSR_CSCARBL_1 = 0x1
	// Position of CSGTRGDF field.
	GPT32EH0_GTCSR_CSGTRGDF_Pos = 0x7
	// Bit mask of CSGTRGDF field.
	GPT32EH0_GTCSR_CSGTRGDF_Msk = 0x80
	// Bit CSGTRGDF.
	GPT32EH0_GTCSR_CSGTRGDF = 0x80
	// Disable counter clear on the falling edge of GTETRGD input
	GPT32EH0_GTCSR_CSGTRGDF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGD input
	GPT32EH0_GTCSR_CSGTRGDF_1 = 0x1
	// Position of CSGTRGDR field.
	GPT32EH0_GTCSR_CSGTRGDR_Pos = 0x6
	// Bit mask of CSGTRGDR field.
	GPT32EH0_GTCSR_CSGTRGDR_Msk = 0x40
	// Bit CSGTRGDR.
	GPT32EH0_GTCSR_CSGTRGDR = 0x40
	// Disable counter clear on the rising edge of GTETRGD input
	GPT32EH0_GTCSR_CSGTRGDR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGD input
	GPT32EH0_GTCSR_CSGTRGDR_1 = 0x1
	// Position of CSGTRGCF field.
	GPT32EH0_GTCSR_CSGTRGCF_Pos = 0x5
	// Bit mask of CSGTRGCF field.
	GPT32EH0_GTCSR_CSGTRGCF_Msk = 0x20
	// Bit CSGTRGCF.
	GPT32EH0_GTCSR_CSGTRGCF = 0x20
	// Disable counter clear on the falling edge of GTETRGC input
	GPT32EH0_GTCSR_CSGTRGCF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGC input
	GPT32EH0_GTCSR_CSGTRGCF_1 = 0x1
	// Position of CSGTRGCR field.
	GPT32EH0_GTCSR_CSGTRGCR_Pos = 0x4
	// Bit mask of CSGTRGCR field.
	GPT32EH0_GTCSR_CSGTRGCR_Msk = 0x10
	// Bit CSGTRGCR.
	GPT32EH0_GTCSR_CSGTRGCR = 0x10
	// Disable counter clear on the rising edge of GTETRGC input
	GPT32EH0_GTCSR_CSGTRGCR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGC input
	GPT32EH0_GTCSR_CSGTRGCR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT32EH0_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT32EH0_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT32EH0_GTCSR_CSGTRGBF = 0x8
	// Disable counter clear on the falling edge of GTETRGB input
	GPT32EH0_GTCSR_CSGTRGBF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGB input
	GPT32EH0_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT32EH0_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT32EH0_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT32EH0_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT32EH0_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT32EH0_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT32EH0_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT32EH0_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT32EH0_GTCSR_CSGTRGAF = 0x2
	// Disable counter clear on the falling edge of GTETRGA input
	GPT32EH0_GTCSR_CSGTRGAF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGA input
	GPT32EH0_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT32EH0_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT32EH0_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT32EH0_GTCSR_CSGTRGAR = 0x1
	// Disable counter clear on the rising edge of GTETRGA input
	GPT32EH0_GTCSR_CSGTRGAR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGA input
	GPT32EH0_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCH field.
	GPT32EH0_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT32EH0_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT32EH0_GTUPSR_USELCH = 0x800000
	// Disable counter count up on ELC_GPTH input
	GPT32EH0_GTUPSR_USELCH_0 = 0x0
	// Enable counter count up on ELC_GPTH input.
	GPT32EH0_GTUPSR_USELCH_1 = 0x1
	// Position of USELCG field.
	GPT32EH0_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT32EH0_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT32EH0_GTUPSR_USELCG = 0x400000
	// Disable counter count up on ELC_GPTG input
	GPT32EH0_GTUPSR_USELCG_0 = 0x0
	// Enable counter count up on ELC_GPTG input.
	GPT32EH0_GTUPSR_USELCG_1 = 0x1
	// Position of USELCF field.
	GPT32EH0_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT32EH0_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT32EH0_GTUPSR_USELCF = 0x200000
	// Disable counter count up on ELC_GPTF input
	GPT32EH0_GTUPSR_USELCF_0 = 0x0
	// Enable counter count up on ELC_GPTF input.
	GPT32EH0_GTUPSR_USELCF_1 = 0x1
	// Position of USELCE field.
	GPT32EH0_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT32EH0_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT32EH0_GTUPSR_USELCE = 0x100000
	// Disable counter count up on ELC_GPTE input
	GPT32EH0_GTUPSR_USELCE_0 = 0x0
	// Enable counter count up on ELC_GPTE input.put
	GPT32EH0_GTUPSR_USELCE_1 = 0x1
	// Position of USELCD field.
	GPT32EH0_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT32EH0_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT32EH0_GTUPSR_USELCD = 0x80000
	// Disable counter count up on ELC_GPTD input
	GPT32EH0_GTUPSR_USELCD_0 = 0x0
	// Enable counter count up on ELC_GPTD input
	GPT32EH0_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT32EH0_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT32EH0_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT32EH0_GTUPSR_USELCC = 0x40000
	// Disable counter count up on ELC_GPTC input
	GPT32EH0_GTUPSR_USELCC_0 = 0x0
	// Enable counter count up on ELC_GPTC input.
	GPT32EH0_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT32EH0_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT32EH0_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT32EH0_GTUPSR_USELCB = 0x20000
	// Disable counter count up on ELC_GPTB input
	GPT32EH0_GTUPSR_USELCB_0 = 0x0
	// Enable counter count up on ELC_GPTB input.
	GPT32EH0_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT32EH0_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT32EH0_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT32EH0_GTUPSR_USELCA = 0x10000
	// Disable counter count up on ELC_GPTA input
	GPT32EH0_GTUPSR_USELCA_0 = 0x0
	// Enable counter count up on ELC_GPTA input.
	GPT32EH0_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT32EH0_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT32EH0_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT32EH0_GTUPSR_USCBFAH = 0x8000
	// Disable counter count up on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTUPSR_USCBFAH_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT32EH0_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT32EH0_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT32EH0_GTUPSR_USCBFAL = 0x4000
	// Disable counter count up on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTUPSR_USCBFAL_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT32EH0_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT32EH0_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT32EH0_GTUPSR_USCBRAH = 0x2000
	// Disable counter count up on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTUPSR_USCBRAH_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT32EH0_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT32EH0_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT32EH0_GTUPSR_USCBRAL = 0x1000
	// Disable counter count up on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTUPSR_USCBRAL_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT32EH0_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT32EH0_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT32EH0_GTUPSR_USCAFBH = 0x800
	// Disable counter count up on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTUPSR_USCAFBH_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT32EH0_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT32EH0_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT32EH0_GTUPSR_USCAFBL = 0x400
	// Disable counter count up on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTUPSR_USCAFBL_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT32EH0_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT32EH0_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT32EH0_GTUPSR_USCARBH = 0x200
	// Disable counter count up on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTUPSR_USCARBH_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT32EH0_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT32EH0_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT32EH0_GTUPSR_USCARBL = 0x100
	// Disable counter count up on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTUPSR_USCARBL_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGDF field.
	GPT32EH0_GTUPSR_USGTRGDF_Pos = 0x7
	// Bit mask of USGTRGDF field.
	GPT32EH0_GTUPSR_USGTRGDF_Msk = 0x80
	// Bit USGTRGDF.
	GPT32EH0_GTUPSR_USGTRGDF = 0x80
	// Disable counter count up on the falling edge of GTETRGD input
	GPT32EH0_GTUPSR_USGTRGDF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGD input.
	GPT32EH0_GTUPSR_USGTRGDF_1 = 0x1
	// Position of USGTRGDR field.
	GPT32EH0_GTUPSR_USGTRGDR_Pos = 0x6
	// Bit mask of USGTRGDR field.
	GPT32EH0_GTUPSR_USGTRGDR_Msk = 0x40
	// Bit USGTRGDR.
	GPT32EH0_GTUPSR_USGTRGDR = 0x40
	// Disable counter count up on the rising edge of GTETRGD input
	GPT32EH0_GTUPSR_USGTRGDR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGD input
	GPT32EH0_GTUPSR_USGTRGDR_1 = 0x1
	// Position of USGTRGCF field.
	GPT32EH0_GTUPSR_USGTRGCF_Pos = 0x5
	// Bit mask of USGTRGCF field.
	GPT32EH0_GTUPSR_USGTRGCF_Msk = 0x20
	// Bit USGTRGCF.
	GPT32EH0_GTUPSR_USGTRGCF = 0x20
	// Disable counter count up on the falling edge of GTETRGC input
	GPT32EH0_GTUPSR_USGTRGCF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGC input.
	GPT32EH0_GTUPSR_USGTRGCF_1 = 0x1
	// Position of USGTRGCR field.
	GPT32EH0_GTUPSR_USGTRGCR_Pos = 0x4
	// Bit mask of USGTRGCR field.
	GPT32EH0_GTUPSR_USGTRGCR_Msk = 0x10
	// Bit USGTRGCR.
	GPT32EH0_GTUPSR_USGTRGCR = 0x10
	// Disable counter count up on the rising edge of GTETRGC input
	GPT32EH0_GTUPSR_USGTRGCR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGC input
	GPT32EH0_GTUPSR_USGTRGCR_1 = 0x1
	// Position of USGTRGBF field.
	GPT32EH0_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT32EH0_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT32EH0_GTUPSR_USGTRGBF = 0x8
	// Disable counter count up on the falling edge of GTETRGB input
	GPT32EH0_GTUPSR_USGTRGBF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGB input.
	GPT32EH0_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT32EH0_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT32EH0_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT32EH0_GTUPSR_USGTRGBR = 0x4
	// Disable counter count up on the rising edge of GTETRGB input
	GPT32EH0_GTUPSR_USGTRGBR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGB input.
	GPT32EH0_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT32EH0_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT32EH0_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT32EH0_GTUPSR_USGTRGAF = 0x2
	// Disable counter count up on the falling edge of GTETRGA input
	GPT32EH0_GTUPSR_USGTRGAF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGA input.
	GPT32EH0_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT32EH0_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT32EH0_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT32EH0_GTUPSR_USGTRGAR = 0x1
	// Disable counter count up on the rising edge of GTETRGA input
	GPT32EH0_GTUPSR_USGTRGAR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGA input
	GPT32EH0_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCH field.
	GPT32EH0_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT32EH0_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT32EH0_GTDNSR_DSELCH = 0x800000
	// Disable counter count down on ELC_GPTH input
	GPT32EH0_GTDNSR_DSELCH_0 = 0x0
	// Enable counter count down on ELC_GPTH input.
	GPT32EH0_GTDNSR_DSELCH_1 = 0x1
	// Position of DSELCG field.
	GPT32EH0_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT32EH0_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT32EH0_GTDNSR_DSELCG = 0x400000
	// Disable counter count down on ELC_GPTG input
	GPT32EH0_GTDNSR_DSELCG_0 = 0x0
	// Enable counter count down on ELC_GPTG input.
	GPT32EH0_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCF field.
	GPT32EH0_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT32EH0_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT32EH0_GTDNSR_DSELCF = 0x200000
	// Disable counter count down on ELC_GPTF input
	GPT32EH0_GTDNSR_DSELCF_0 = 0x0
	// Enable counter count down on ELC_GPTF input.
	GPT32EH0_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCE field.
	GPT32EH0_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT32EH0_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT32EH0_GTDNSR_DSELCE = 0x100000
	// Disable counter count down on ELC_GPTE input
	GPT32EH0_GTDNSR_DSELCE_0 = 0x0
	// Enable counter count down on ELC_GPTE input.
	GPT32EH0_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCD field.
	GPT32EH0_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT32EH0_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT32EH0_GTDNSR_DSELCD = 0x80000
	// Disable counter count down on ELC_GPTD input
	GPT32EH0_GTDNSR_DSELCD_0 = 0x0
	// Enable counter count down on ELC_GPTD input.
	GPT32EH0_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT32EH0_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT32EH0_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT32EH0_GTDNSR_DSELCC = 0x40000
	// Disable counter count down on ELC_GPTC input
	GPT32EH0_GTDNSR_DSELCC_0 = 0x0
	// Enable counter count down on ELC_GPTC input.
	GPT32EH0_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT32EH0_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT32EH0_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT32EH0_GTDNSR_DSELCB = 0x20000
	// Disable counter count down on ELC_GPTB input
	GPT32EH0_GTDNSR_DSELCB_0 = 0x0
	// Enable counter count down on ELC_GPTB input.
	GPT32EH0_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT32EH0_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT32EH0_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT32EH0_GTDNSR_DSELCA = 0x10000
	// Disable counter count down on ELC_GPTA input
	GPT32EH0_GTDNSR_DSELCA_0 = 0x0
	// Enable counter count down on ELC_GPTA input.
	GPT32EH0_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT32EH0_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT32EH0_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT32EH0_GTDNSR_DSCBFAH = 0x8000
	// Disable counter count down on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTDNSR_DSCBFAH_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT32EH0_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT32EH0_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT32EH0_GTDNSR_DSCBFAL = 0x4000
	// Disable counter count down on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTDNSR_DSCBFAL_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT32EH0_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT32EH0_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT32EH0_GTDNSR_DSCBRAH = 0x2000
	// Disable counter count down on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTDNSR_DSCBRAH_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT32EH0_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT32EH0_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT32EH0_GTDNSR_DSCBRAL = 0x1000
	// Disable counter count down on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTDNSR_DSCBRAL_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT32EH0_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT32EH0_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT32EH0_GTDNSR_DSCAFBH = 0x800
	// Disable counter count down on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTDNSR_DSCAFBH_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT32EH0_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT32EH0_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT32EH0_GTDNSR_DSCAFBL = 0x400
	// Disable counter count down on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTDNSR_DSCAFBL_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT32EH0_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT32EH0_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT32EH0_GTDNSR_DSCARBH = 0x200
	// Disable counter count down on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTDNSR_DSCARBH_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT32EH0_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT32EH0_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT32EH0_GTDNSR_DSCARBL = 0x100
	// Disable counter count down on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTDNSR_DSCARBL_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGDF field.
	GPT32EH0_GTDNSR_DSGTRGDF_Pos = 0x7
	// Bit mask of DSGTRGDF field.
	GPT32EH0_GTDNSR_DSGTRGDF_Msk = 0x80
	// Bit DSGTRGDF.
	GPT32EH0_GTDNSR_DSGTRGDF = 0x80
	// Disable counter count down on the falling edge of GTETRGD input
	GPT32EH0_GTDNSR_DSGTRGDF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGD input.
	GPT32EH0_GTDNSR_DSGTRGDF_1 = 0x1
	// Position of DSGTRGDR field.
	GPT32EH0_GTDNSR_DSGTRGDR_Pos = 0x6
	// Bit mask of DSGTRGDR field.
	GPT32EH0_GTDNSR_DSGTRGDR_Msk = 0x40
	// Bit DSGTRGDR.
	GPT32EH0_GTDNSR_DSGTRGDR = 0x40
	// Disable counter count down on the rising edge of GTETRGD input
	GPT32EH0_GTDNSR_DSGTRGDR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGD input.
	GPT32EH0_GTDNSR_DSGTRGDR_1 = 0x1
	// Position of DSGTRGCF field.
	GPT32EH0_GTDNSR_DSGTRGCF_Pos = 0x5
	// Bit mask of DSGTRGCF field.
	GPT32EH0_GTDNSR_DSGTRGCF_Msk = 0x20
	// Bit DSGTRGCF.
	GPT32EH0_GTDNSR_DSGTRGCF = 0x20
	// Disable counter count down on the falling edge of GTETRGC input
	GPT32EH0_GTDNSR_DSGTRGCF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGC input.
	GPT32EH0_GTDNSR_DSGTRGCF_1 = 0x1
	// Position of DSGTRGCR field.
	GPT32EH0_GTDNSR_DSGTRGCR_Pos = 0x4
	// Bit mask of DSGTRGCR field.
	GPT32EH0_GTDNSR_DSGTRGCR_Msk = 0x10
	// Bit DSGTRGCR.
	GPT32EH0_GTDNSR_DSGTRGCR = 0x10
	// Disable counter count down on the rising edge of GTETRGC input
	GPT32EH0_GTDNSR_DSGTRGCR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGC input
	GPT32EH0_GTDNSR_DSGTRGCR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT32EH0_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT32EH0_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT32EH0_GTDNSR_DSGTRGBF = 0x8
	// Disable counter count down on the falling edge of GTETRGB input
	GPT32EH0_GTDNSR_DSGTRGBF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGB input.
	GPT32EH0_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT32EH0_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT32EH0_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT32EH0_GTDNSR_DSGTRGBR = 0x4
	// Disable counter count down on the rising edge of GTETRGB input
	GPT32EH0_GTDNSR_DSGTRGBR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGB input.
	GPT32EH0_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT32EH0_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT32EH0_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT32EH0_GTDNSR_DSGTRGAF = 0x2
	// Disable counter count down on the falling edge of GTETRGA input
	GPT32EH0_GTDNSR_DSGTRGAF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGA input.
	GPT32EH0_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT32EH0_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT32EH0_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT32EH0_GTDNSR_DSGTRGAR = 0x1
	// Disable counter count down on the rising edge of GTETRGA input
	GPT32EH0_GTDNSR_DSGTRGAR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGA input
	GPT32EH0_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCH field.
	GPT32EH0_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT32EH0_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT32EH0_GTICASR_ASELCH = 0x800000
	// Disable GTCCRA input capture on ELC_GPTH input
	GPT32EH0_GTICASR_ASELCH_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTH input
	GPT32EH0_GTICASR_ASELCH_1 = 0x1
	// Position of ASELCG field.
	GPT32EH0_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT32EH0_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT32EH0_GTICASR_ASELCG = 0x400000
	// Disable GTCCRA input capture on ELC_GPTG input
	GPT32EH0_GTICASR_ASELCG_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTG input.
	GPT32EH0_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCF field.
	GPT32EH0_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT32EH0_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT32EH0_GTICASR_ASELCF = 0x200000
	// Disable GTCCRA input capture on ELC_GPTF input
	GPT32EH0_GTICASR_ASELCF_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTF input.
	GPT32EH0_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCE field.
	GPT32EH0_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT32EH0_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT32EH0_GTICASR_ASELCE = 0x100000
	// Disable GTCCRA input capture on ELC_GPTE input
	GPT32EH0_GTICASR_ASELCE_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTE input.
	GPT32EH0_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCD field.
	GPT32EH0_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT32EH0_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT32EH0_GTICASR_ASELCD = 0x80000
	// Disable GTCCRA input capture on ELC_GPTD input
	GPT32EH0_GTICASR_ASELCD_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTD input.
	GPT32EH0_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT32EH0_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT32EH0_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT32EH0_GTICASR_ASELCC = 0x40000
	// Disable GTCCRA input capture on ELC_GPTC input
	GPT32EH0_GTICASR_ASELCC_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTC input.
	GPT32EH0_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT32EH0_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT32EH0_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT32EH0_GTICASR_ASELCB = 0x20000
	// Disable GTCCRA input capture on ELC_GPTB input
	GPT32EH0_GTICASR_ASELCB_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTB input
	GPT32EH0_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT32EH0_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT32EH0_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT32EH0_GTICASR_ASELCA = 0x10000
	// Disable GTCCRA input capture on ELC_GPTA input
	GPT32EH0_GTICASR_ASELCA_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTA input.
	GPT32EH0_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT32EH0_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT32EH0_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT32EH0_GTICASR_ASCBFAH = 0x8000
	// Disable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTICASR_ASCBFAH_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT32EH0_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT32EH0_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT32EH0_GTICASR_ASCBFAL = 0x4000
	// Disable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTICASR_ASCBFAL_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT32EH0_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT32EH0_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT32EH0_GTICASR_ASCBRAH = 0x2000
	// Disable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTICASR_ASCBRAH_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT32EH0_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT32EH0_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT32EH0_GTICASR_ASCBRAL = 0x1000
	// Disable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTICASR_ASCBRAL_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT32EH0_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT32EH0_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT32EH0_GTICASR_ASCAFBH = 0x800
	// Disable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTICASR_ASCAFBH_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT32EH0_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT32EH0_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT32EH0_GTICASR_ASCAFBL = 0x400
	// Disable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTICASR_ASCAFBL_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT32EH0_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT32EH0_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT32EH0_GTICASR_ASCARBH = 0x200
	// Disable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTICASR_ASCARBH_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT32EH0_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT32EH0_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT32EH0_GTICASR_ASCARBL = 0x100
	// Disable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTICASR_ASCARBL_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGDF field.
	GPT32EH0_GTICASR_ASGTRGDF_Pos = 0x7
	// Bit mask of ASGTRGDF field.
	GPT32EH0_GTICASR_ASGTRGDF_Msk = 0x80
	// Bit ASGTRGDF.
	GPT32EH0_GTICASR_ASGTRGDF = 0x80
	// Disable GTCCRA input capture on the falling edge of GTETRGD input
	GPT32EH0_GTICASR_ASGTRGDF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGD input.
	GPT32EH0_GTICASR_ASGTRGDF_1 = 0x1
	// Position of ASGTRGDR field.
	GPT32EH0_GTICASR_ASGTRGDR_Pos = 0x6
	// Bit mask of ASGTRGDR field.
	GPT32EH0_GTICASR_ASGTRGDR_Msk = 0x40
	// Bit ASGTRGDR.
	GPT32EH0_GTICASR_ASGTRGDR = 0x40
	// Disable GTCCRA input capture on the rising edge of GTETRGD input
	GPT32EH0_GTICASR_ASGTRGDR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGD input.
	GPT32EH0_GTICASR_ASGTRGDR_1 = 0x1
	// Position of ASGTRGCF field.
	GPT32EH0_GTICASR_ASGTRGCF_Pos = 0x5
	// Bit mask of ASGTRGCF field.
	GPT32EH0_GTICASR_ASGTRGCF_Msk = 0x20
	// Bit ASGTRGCF.
	GPT32EH0_GTICASR_ASGTRGCF = 0x20
	// Disable GTCCRA input capture on the falling edge of GTETRGC input
	GPT32EH0_GTICASR_ASGTRGCF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGC input
	GPT32EH0_GTICASR_ASGTRGCF_1 = 0x1
	// Position of ASGTRGCR field.
	GPT32EH0_GTICASR_ASGTRGCR_Pos = 0x4
	// Bit mask of ASGTRGCR field.
	GPT32EH0_GTICASR_ASGTRGCR_Msk = 0x10
	// Bit ASGTRGCR.
	GPT32EH0_GTICASR_ASGTRGCR = 0x10
	// Disable GTCCRA input capture on the rising edge of GTETRGC input
	GPT32EH0_GTICASR_ASGTRGCR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGC input.
	GPT32EH0_GTICASR_ASGTRGCR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT32EH0_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT32EH0_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT32EH0_GTICASR_ASGTRGBF = 0x8
	// Disable GTCCRA input capture on the falling edge of GTETRGB input
	GPT32EH0_GTICASR_ASGTRGBF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGB input.
	GPT32EH0_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT32EH0_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT32EH0_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT32EH0_GTICASR_ASGTRGBR = 0x4
	// Disable GTCCRA input capture on the rising edge of GTETRGB input
	GPT32EH0_GTICASR_ASGTRGBR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGB input.
	GPT32EH0_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT32EH0_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT32EH0_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT32EH0_GTICASR_ASGTRGAF = 0x2
	// Disable GTCCRA input capture on the falling edge of GTETRGA input
	GPT32EH0_GTICASR_ASGTRGAF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGA input.
	GPT32EH0_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT32EH0_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT32EH0_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT32EH0_GTICASR_ASGTRGAR = 0x1
	// Disable GTCCRA input capture on the rising edge of GTETRGA input
	GPT32EH0_GTICASR_ASGTRGAR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGA input.
	GPT32EH0_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCH field.
	GPT32EH0_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT32EH0_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT32EH0_GTICBSR_BSELCH = 0x800000
	// Disable GTCCRB input capture on ELC_GPTH input
	GPT32EH0_GTICBSR_BSELCH_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTH input.
	GPT32EH0_GTICBSR_BSELCH_1 = 0x1
	// Position of BSELCG field.
	GPT32EH0_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT32EH0_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT32EH0_GTICBSR_BSELCG = 0x400000
	// Disable GTCCRB input capture on ELC_GPTG input
	GPT32EH0_GTICBSR_BSELCG_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTG input.
	GPT32EH0_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCF field.
	GPT32EH0_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT32EH0_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT32EH0_GTICBSR_BSELCF = 0x200000
	// Disable GTCCRB input capture on ELC_GPTF input
	GPT32EH0_GTICBSR_BSELCF_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTF input.
	GPT32EH0_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCE field.
	GPT32EH0_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT32EH0_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT32EH0_GTICBSR_BSELCE = 0x100000
	// Disable GTCCRB input capture on ELC_GPTE input
	GPT32EH0_GTICBSR_BSELCE_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTE input
	GPT32EH0_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCD field.
	GPT32EH0_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT32EH0_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT32EH0_GTICBSR_BSELCD = 0x80000
	// Disable GTCCRB input capture on ELC_GPTD input
	GPT32EH0_GTICBSR_BSELCD_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTD input.
	GPT32EH0_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT32EH0_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT32EH0_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT32EH0_GTICBSR_BSELCC = 0x40000
	// Disable GTCCRB input capture on ELC_GPTC input
	GPT32EH0_GTICBSR_BSELCC_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTC input
	GPT32EH0_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT32EH0_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT32EH0_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT32EH0_GTICBSR_BSELCB = 0x20000
	// Disable GTCCRB input capture on ELC_GPTB input
	GPT32EH0_GTICBSR_BSELCB_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTB input.
	GPT32EH0_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT32EH0_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT32EH0_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT32EH0_GTICBSR_BSELCA = 0x10000
	// Disable GTCCRB input capture on ELC_GPTA input
	GPT32EH0_GTICBSR_BSELCA_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTA input.
	GPT32EH0_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT32EH0_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT32EH0_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT32EH0_GTICBSR_BSCBFAH = 0x8000
	// Disable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTICBSR_BSCBFAH_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT32EH0_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT32EH0_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT32EH0_GTICBSR_BSCBFAL = 0x4000
	// Disable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTICBSR_BSCBFAL_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT32EH0_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT32EH0_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT32EH0_GTICBSR_BSCBRAH = 0x2000
	// Disable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT32EH0_GTICBSR_BSCBRAH_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT32EH0_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT32EH0_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT32EH0_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT32EH0_GTICBSR_BSCBRAL = 0x1000
	// Disable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT32EH0_GTICBSR_BSCBRAL_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT32EH0_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT32EH0_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT32EH0_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT32EH0_GTICBSR_BSCAFBH = 0x800
	// Disable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTICBSR_BSCAFBH_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT32EH0_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT32EH0_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT32EH0_GTICBSR_BSCAFBL = 0x400
	// Disable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTICBSR_BSCAFBL_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT32EH0_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT32EH0_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT32EH0_GTICBSR_BSCARBH = 0x200
	// Disable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT32EH0_GTICBSR_BSCARBH_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT32EH0_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT32EH0_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT32EH0_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT32EH0_GTICBSR_BSCARBL = 0x100
	// Disable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT32EH0_GTICBSR_BSCARBL_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT32EH0_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGDF field.
	GPT32EH0_GTICBSR_BSGTRGDF_Pos = 0x7
	// Bit mask of BSGTRGDF field.
	GPT32EH0_GTICBSR_BSGTRGDF_Msk = 0x80
	// Bit BSGTRGDF.
	GPT32EH0_GTICBSR_BSGTRGDF = 0x80
	// Disable GTCCRB input capture on the falling edge of GTETRGD input
	GPT32EH0_GTICBSR_BSGTRGDF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGD input.
	GPT32EH0_GTICBSR_BSGTRGDF_1 = 0x1
	// Position of BSGTRGDR field.
	GPT32EH0_GTICBSR_BSGTRGDR_Pos = 0x6
	// Bit mask of BSGTRGDR field.
	GPT32EH0_GTICBSR_BSGTRGDR_Msk = 0x40
	// Bit BSGTRGDR.
	GPT32EH0_GTICBSR_BSGTRGDR = 0x40
	// Disable GTCCRB input capture on the rising edge of GTETRGD input
	GPT32EH0_GTICBSR_BSGTRGDR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGD input.
	GPT32EH0_GTICBSR_BSGTRGDR_1 = 0x1
	// Position of BSGTRGCF field.
	GPT32EH0_GTICBSR_BSGTRGCF_Pos = 0x5
	// Bit mask of BSGTRGCF field.
	GPT32EH0_GTICBSR_BSGTRGCF_Msk = 0x20
	// Bit BSGTRGCF.
	GPT32EH0_GTICBSR_BSGTRGCF = 0x20
	// Disable GTCCRB input capture on the falling edge of GTETRGC input
	GPT32EH0_GTICBSR_BSGTRGCF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGC input.
	GPT32EH0_GTICBSR_BSGTRGCF_1 = 0x1
	// Position of BSGTRGCR field.
	GPT32EH0_GTICBSR_BSGTRGCR_Pos = 0x4
	// Bit mask of BSGTRGCR field.
	GPT32EH0_GTICBSR_BSGTRGCR_Msk = 0x10
	// Bit BSGTRGCR.
	GPT32EH0_GTICBSR_BSGTRGCR = 0x10
	// Disable GTCCRB input capture on the rising edge of GTETRGC input
	GPT32EH0_GTICBSR_BSGTRGCR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGC input.
	GPT32EH0_GTICBSR_BSGTRGCR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT32EH0_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT32EH0_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT32EH0_GTICBSR_BSGTRGBF = 0x8
	// Disable GTCCRB input capture on the falling edge of GTETRGB input
	GPT32EH0_GTICBSR_BSGTRGBF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGB input.
	GPT32EH0_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT32EH0_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT32EH0_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT32EH0_GTICBSR_BSGTRGBR = 0x4
	// Disable GTCCRB input capture on the rising edge of GTETRGB input
	GPT32EH0_GTICBSR_BSGTRGBR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGB input.
	GPT32EH0_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT32EH0_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT32EH0_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT32EH0_GTICBSR_BSGTRGAF = 0x2
	// Disable GTCCRB input capture on the falling edge of GTETRGA input
	GPT32EH0_GTICBSR_BSGTRGAF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGA input.
	GPT32EH0_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT32EH0_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT32EH0_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT32EH0_GTICBSR_BSGTRGAR = 0x1
	// Disable GTCCRB input capture on the rising edge of GTETRGA input
	GPT32EH0_GTICBSR_BSGTRGAR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGA input.
	GPT32EH0_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT32EH0_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT32EH0_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT32EH0_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT32EH0_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT32EH0_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT32EH0_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT32EH0_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT32EH0_GTCR_TPCS_101 = 0x5
	// Position of MD field.
	GPT32EH0_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT32EH0_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT32EH0_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT32EH0_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT32EH0_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT32EH0_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at crest) (single buffer or double buffer possible)
	GPT32EH0_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT32EH0_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) fixed buffer operation)
	GPT32EH0_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT32EH0_GTCR_MD_111 = 0x7
	// Position of CST field.
	GPT32EH0_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT32EH0_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT32EH0_GTCR_CST = 0x1
	// Count operation is stopped
	GPT32EH0_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT32EH0_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT32EH0_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT32EH0_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT32EH0_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0percent/100percent duty setting.
	GPT32EH0_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0percent/100percent duty setting.
	GPT32EH0_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT32EH0_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT32EH0_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT32EH0_GTUDDTYC_OBDTYF = 0x4000000
	// Do not force setting
	GPT32EH0_GTUDDTYC_OBDTYF_0 = 0x0
	// Force setting
	GPT32EH0_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT32EH0_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT32EH0_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT32EH0_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT32EH0_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0percent
	GPT32EH0_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100percent
	GPT32EH0_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OADTYR field.
	GPT32EH0_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT32EH0_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT32EH0_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT32EH0_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT32EH0_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT32EH0_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT32EH0_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT32EH0_GTUDDTYC_OADTYF = 0x40000
	// Do not force setting
	GPT32EH0_GTUDDTYC_OADTYF_0 = 0x0
	// Force setting
	GPT32EH0_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT32EH0_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT32EH0_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT32EH0_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT32EH0_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT32EH0_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT32EH0_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT32EH0_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT32EH0_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT32EH0_GTUDDTYC_UDF = 0x2
	// Do not force setting
	GPT32EH0_GTUDDTYC_UDF_0 = 0x0
	// Force setting
	GPT32EH0_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT32EH0_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT32EH0_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT32EH0_GTUDDTYC_UD = 0x1
	// Count down on GTCNT
	GPT32EH0_GTUDDTYC_UD_0 = 0x0
	// Counts up on GTCNT
	GPT32EH0_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT32EH0_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT32EH0_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT32EH0_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT32EH0_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT32EH0_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT32EH0_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT32EH0_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT32EH0_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT32EH0_GTIOR_NFBEN = 0x20000000
	// Disable noise filter for GTIOCB pin
	GPT32EH0_GTIOR_NFBEN_0 = 0x0
	// Enable noise filter for GTIOCB pin
	GPT32EH0_GTIOR_NFBEN_1 = 0x1
	// Position of OBDF field.
	GPT32EH0_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT32EH0_GTIOR_OBDF_Msk = 0x6000000
	// Prohibit output disable
	GPT32EH0_GTIOR_OBDF_00 = 0x0
	// Set GTIOCB pin to Hi-Z on output disable
	GPT32EH0_GTIOR_OBDF_01 = 0x1
	// Set GTIOCB pin to 0 on output disable
	GPT32EH0_GTIOR_OBDF_10 = 0x2
	// Set GTIOCB pin to 1 on output disable.
	GPT32EH0_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT32EH0_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT32EH0_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT32EH0_GTIOR_OBE = 0x1000000
	// Disable output
	GPT32EH0_GTIOR_OBE_0 = 0x0
	// Enable output
	GPT32EH0_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT32EH0_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT32EH0_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT32EH0_GTIOR_OBHLD = 0x800000
	// Set GTIOCB pin output level on counting start and stop based on the register setting
	GPT32EH0_GTIOR_OBHLD_0 = 0x0
	// Retain GTIOCB pin output level on counting start and stop
	GPT32EH0_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT32EH0_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT32EH0_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT32EH0_GTIOR_OBDFLT = 0x400000
	// Output low on GTIOCB pin when counting stops
	GPT32EH0_GTIOR_OBDFLT_0 = 0x0
	// Output high on GTIOCB pin when counting stops
	GPT32EH0_GTIOR_OBDFLT_1 = 0x1
	// Position of GTIOB field.
	GPT32EH0_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT32EH0_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT32EH0_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT32EH0_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT32EH0_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT32EH0_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT32EH0_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT32EH0_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT32EH0_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT32EH0_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT32EH0_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT32EH0_GTIOR_NFAEN = 0x2000
	// Disable noise filter for GTIOCA pin
	GPT32EH0_GTIOR_NFAEN_0 = 0x0
	// Enable noise filter for GTIOCA pin.
	GPT32EH0_GTIOR_NFAEN_1 = 0x1
	// Position of OADF field.
	GPT32EH0_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT32EH0_GTIOR_OADF_Msk = 0x600
	// Prohibit output disable
	GPT32EH0_GTIOR_OADF_00 = 0x0
	// Set GTIOCA pin to Hi-Z on output disable
	GPT32EH0_GTIOR_OADF_01 = 0x1
	// Set GTIOCA pin to 0 on output disable
	GPT32EH0_GTIOR_OADF_10 = 0x2
	// Set GTIOCA pin to 1 on output disable.
	GPT32EH0_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT32EH0_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT32EH0_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT32EH0_GTIOR_OAE = 0x100
	// Disable output
	GPT32EH0_GTIOR_OAE_0 = 0x0
	// Enable output.
	GPT32EH0_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT32EH0_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT32EH0_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT32EH0_GTIOR_OAHLD = 0x80
	// Set GTIOCA pin output level on counting start and stop based on the register setting.
	GPT32EH0_GTIOR_OAHLD_0 = 0x0
	// Retain GTIOCA pin output level on counting start and stop
	GPT32EH0_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT32EH0_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT32EH0_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT32EH0_GTIOR_OADFLT = 0x40
	// Output low on GTIOCA pin when counting stops
	GPT32EH0_GTIOR_OADFLT_0 = 0x0
	// Output high on GTIOCA pin when counting stops.
	GPT32EH0_GTIOR_OADFLT_1 = 0x1
	// Position of GTIOA field.
	GPT32EH0_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT32EH0_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT32EH0_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT32EH0_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT32EH0_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT32EH0_GTINTAD_GRPABL = 0x40000000
	// Disable same time output level low disable request
	GPT32EH0_GTINTAD_GRPABL_0 = 0x0
	// Enable same time output level low disable request
	GPT32EH0_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT32EH0_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT32EH0_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT32EH0_GTINTAD_GRPABH = 0x20000000
	// Disable same time output level high disable request
	GPT32EH0_GTINTAD_GRPABH_0 = 0x0
	// Enable same time output level high disable request
	GPT32EH0_GTINTAD_GRPABH_1 = 0x1
	// Position of GRPDTE field.
	GPT32EH0_GTINTAD_GRPDTE_Pos = 0x1c
	// Bit mask of GRPDTE field.
	GPT32EH0_GTINTAD_GRPDTE_Msk = 0x10000000
	// Bit GRPDTE.
	GPT32EH0_GTINTAD_GRPDTE = 0x10000000
	// Disable dead time error output disable request
	GPT32EH0_GTINTAD_GRPDTE_0 = 0x0
	// Enable dead time error output disable request
	GPT32EH0_GTINTAD_GRPDTE_1 = 0x1
	// Position of GRP field.
	GPT32EH0_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT32EH0_GTINTAD_GRP_Msk = 0x3000000
	// Select Group A output disable request
	GPT32EH0_GTINTAD_GRP_00 = 0x0
	// Select Group B output disable request
	GPT32EH0_GTINTAD_GRP_01 = 0x1
	// Select Group C output disable request
	GPT32EH0_GTINTAD_GRP_10 = 0x2
	// Select Group D output disable request.
	GPT32EH0_GTINTAD_GRP_11 = 0x3
	// Position of ADTRBDEN field.
	GPT32EH0_GTINTAD_ADTRBDEN_Pos = 0x13
	// Bit mask of ADTRBDEN field.
	GPT32EH0_GTINTAD_ADTRBDEN_Msk = 0x80000
	// Bit ADTRBDEN.
	GPT32EH0_GTINTAD_ADTRBDEN = 0x80000
	// Disable A/D converter start request
	GPT32EH0_GTINTAD_ADTRBDEN_0 = 0x0
	// Enable A/D converter start request.
	GPT32EH0_GTINTAD_ADTRBDEN_1 = 0x1
	// Position of ADTRBUEN field.
	GPT32EH0_GTINTAD_ADTRBUEN_Pos = 0x12
	// Bit mask of ADTRBUEN field.
	GPT32EH0_GTINTAD_ADTRBUEN_Msk = 0x40000
	// Bit ADTRBUEN.
	GPT32EH0_GTINTAD_ADTRBUEN = 0x40000
	// Disable A/D converter start request
	GPT32EH0_GTINTAD_ADTRBUEN_0 = 0x0
	// Enable A/D converter start request.
	GPT32EH0_GTINTAD_ADTRBUEN_1 = 0x1
	// Position of ADTRADEN field.
	GPT32EH0_GTINTAD_ADTRADEN_Pos = 0x11
	// Bit mask of ADTRADEN field.
	GPT32EH0_GTINTAD_ADTRADEN_Msk = 0x20000
	// Bit ADTRADEN.
	GPT32EH0_GTINTAD_ADTRADEN = 0x20000
	// Disable A/D converter start request
	GPT32EH0_GTINTAD_ADTRADEN_0 = 0x0
	// Enable A/D converter start request.
	GPT32EH0_GTINTAD_ADTRADEN_1 = 0x1
	// Position of ADTRAUEN field.
	GPT32EH0_GTINTAD_ADTRAUEN_Pos = 0x10
	// Bit mask of ADTRAUEN field.
	GPT32EH0_GTINTAD_ADTRAUEN_Msk = 0x10000
	// Bit ADTRAUEN.
	GPT32EH0_GTINTAD_ADTRAUEN = 0x10000
	// Disable A/D converter start request
	GPT32EH0_GTINTAD_ADTRAUEN_0 = 0x0
	// Enable A/D converter start request.
	GPT32EH0_GTINTAD_ADTRAUEN_1 = 0x1

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT32EH0_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT32EH0_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT32EH0_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT32EH0_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT32EH0_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT32EH0_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT32EH0_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT32EH0_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT32EH0_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT32EH0_GTST_OABHF_1 = 0x1
	// Position of DTEF field.
	GPT32EH0_GTST_DTEF_Pos = 0x1c
	// Bit mask of DTEF field.
	GPT32EH0_GTST_DTEF_Msk = 0x10000000
	// Bit DTEF.
	GPT32EH0_GTST_DTEF = 0x10000000
	// No dead time error has occurred.
	GPT32EH0_GTST_DTEF_0 = 0x0
	// A dead time error has occurred.
	GPT32EH0_GTST_DTEF_1 = 0x1
	// Position of ODF field.
	GPT32EH0_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT32EH0_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT32EH0_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT32EH0_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT32EH0_GTST_ODF_1 = 0x1
	// Position of TUCF field.
	GPT32EH0_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT32EH0_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT32EH0_GTST_TUCF = 0x8000
	// GTCNT counter is counting down
	GPT32EH0_GTST_TUCF_0 = 0x0
	// GTCNT counter is counting up.
	GPT32EH0_GTST_TUCF_1 = 0x1
	// Position of ITCNT field.
	GPT32EH0_GTST_ITCNT_Pos = 0x8
	// Bit mask of ITCNT field.
	GPT32EH0_GTST_ITCNT_Msk = 0x700
	// Position of TCFPU field.
	GPT32EH0_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT32EH0_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT32EH0_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT32EH0_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT32EH0_GTST_TCFPU_1 = 0x1
	// Position of TCFPO field.
	GPT32EH0_GTST_TCFPO_Pos = 0x6
	// Bit mask of TCFPO field.
	GPT32EH0_GTST_TCFPO_Msk = 0x40
	// Bit TCFPO.
	GPT32EH0_GTST_TCFPO = 0x40
	// No overflow (crest) has occurred.
	GPT32EH0_GTST_TCFPO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT32EH0_GTST_TCFPO_1 = 0x1
	// Position of TCFF field.
	GPT32EH0_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT32EH0_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT32EH0_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated.
	GPT32EH0_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT32EH0_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT32EH0_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT32EH0_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT32EH0_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated.
	GPT32EH0_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT32EH0_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT32EH0_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT32EH0_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT32EH0_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT32EH0_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT32EH0_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT32EH0_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT32EH0_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT32EH0_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT32EH0_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT32EH0_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT32EH0_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT32EH0_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT32EH0_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT32EH0_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT32EH0_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT32EH0_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT32EH0_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT32EH0_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT32EH0_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT32EH0_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of ADTDB field.
	GPT32EH0_GTBER_ADTDB_Pos = 0x1e
	// Bit mask of ADTDB field.
	GPT32EH0_GTBER_ADTDB_Msk = 0x40000000
	// Bit ADTDB.
	GPT32EH0_GTBER_ADTDB = 0x40000000
	// Single buffer operation (GTADTBRB --> GTADTRB)
	GPT32EH0_GTBER_ADTDB_0 = 0x0
	// Double buffer operation (GTADTDBRB --> GTADTBRB --> GTADTDRB)
	GPT32EH0_GTBER_ADTDB_1 = 0x1
	// Position of ADTTB field.
	GPT32EH0_GTBER_ADTTB_Pos = 0x1c
	// Bit mask of ADTTB field.
	GPT32EH0_GTBER_ADTTB_Msk = 0x30000000
	// No transfer
	GPT32EH0_GTBER_ADTTB_00 = 0x0
	// Transfer at crest
	GPT32EH0_GTBER_ADTTB_01 = 0x1
	// Transfer at trough
	GPT32EH0_GTBER_ADTTB_10 = 0x2
	// Transfer at both crest and trough
	GPT32EH0_GTBER_ADTTB_11 = 0x3
	// Position of ADTDA field.
	GPT32EH0_GTBER_ADTDA_Pos = 0x1a
	// Bit mask of ADTDA field.
	GPT32EH0_GTBER_ADTDA_Msk = 0x4000000
	// Bit ADTDA.
	GPT32EH0_GTBER_ADTDA = 0x4000000
	// Single buffer operation (GTADTBRA --> GTADTRA)
	GPT32EH0_GTBER_ADTDA_0 = 0x0
	// Double buffer operation (GTADTDBRA --> GTADTBRA --> GTADTDRA)
	GPT32EH0_GTBER_ADTDA_1 = 0x1
	// Position of ADTTA field.
	GPT32EH0_GTBER_ADTTA_Pos = 0x18
	// Bit mask of ADTTA field.
	GPT32EH0_GTBER_ADTTA_Msk = 0x3000000
	// No transfer
	GPT32EH0_GTBER_ADTTA_00 = 0x0
	// Transfer at crest
	GPT32EH0_GTBER_ADTTA_01 = 0x1
	// Transfer at trough
	GPT32EH0_GTBER_ADTTA_10 = 0x2
	// Transfer at both crest and trough
	GPT32EH0_GTBER_ADTTA_11 = 0x3
	// Position of CCRSWT field.
	GPT32EH0_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT32EH0_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT32EH0_GTBER_CCRSWT = 0x400000
	// no effect
	GPT32EH0_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT32EH0_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT32EH0_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT32EH0_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT32EH0_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT32EH0_GTBER_PR_01 = 0x1
	// Double buffer operation (GTPDBR --> GTPBR --> GTPR)
	GPT32EH0_GTBER_PR_10 = 0x2
	// Double buffer operation (GTPDBR --> GTPBR --> GTPR)
	GPT32EH0_GTBER_PR_11 = 0x3
	// Position of CCRB field.
	GPT32EH0_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT32EH0_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT32EH0_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT32EH0_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT32EH0_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT32EH0_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT32EH0_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT32EH0_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT32EH0_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT32EH0_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT32EH0_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT32EH0_GTBER_CCRA_11 = 0x3
	// Position of BD field.
	GPT32EH0_GTBER_BD_Pos = 0x0
	// Bit mask of BD field.
	GPT32EH0_GTBER_BD_Msk = 0xf
	// Enable buffer operation
	GPT32EH0_GTBER_BD_0 = 0x0
	// Disable buffer operation
	GPT32EH0_GTBER_BD_1 = 0x1

	// GTITC: General PWM Timer Interrupt and A/D Converter Start Request Skipping Setting Register
	// Position of ADTBL field.
	GPT32EH0_GTITC_ADTBL_Pos = 0xe
	// Bit mask of ADTBL field.
	GPT32EH0_GTITC_ADTBL_Msk = 0x4000
	// Bit ADTBL.
	GPT32EH0_GTITC_ADTBL = 0x4000
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ADTBL_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ADTBL_1 = 0x1
	// Position of ADTAL field.
	GPT32EH0_GTITC_ADTAL_Pos = 0xc
	// Bit mask of ADTAL field.
	GPT32EH0_GTITC_ADTAL_Msk = 0x1000
	// Bit ADTAL.
	GPT32EH0_GTITC_ADTAL = 0x1000
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ADTAL_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ADTAL_1 = 0x1
	// Position of IVTT field.
	GPT32EH0_GTITC_IVTT_Pos = 0x8
	// Bit mask of IVTT field.
	GPT32EH0_GTITC_IVTT_Msk = 0x700
	// No skipping
	GPT32EH0_GTITC_IVTT_000 = 0x0
	// Skipping count of 1
	GPT32EH0_GTITC_IVTT_001 = 0x1
	// Skipping count of 2
	GPT32EH0_GTITC_IVTT_010 = 0x2
	// Skipping count of 3
	GPT32EH0_GTITC_IVTT_011 = 0x3
	// Skipping count of 4
	GPT32EH0_GTITC_IVTT_100 = 0x4
	// Skipping count of 5
	GPT32EH0_GTITC_IVTT_101 = 0x5
	// Skipping count of 6
	GPT32EH0_GTITC_IVTT_110 = 0x6
	// Skipping count of 7.
	GPT32EH0_GTITC_IVTT_111 = 0x7
	// Position of IVTC field.
	GPT32EH0_GTITC_IVTC_Pos = 0x6
	// Bit mask of IVTC field.
	GPT32EH0_GTITC_IVTC_Msk = 0xc0
	// Do not perform skipping
	GPT32EH0_GTITC_IVTC_00 = 0x0
	// Count and skip both overflow and underflow for saw waves and crest for triangle waves
	GPT32EH0_GTITC_IVTC_01 = 0x1
	// Count and skip both overflow and underflow for saw waves and trough for triangle waves
	GPT32EH0_GTITC_IVTC_10 = 0x2
	// Count and skip both overflow and underflow for saw waves and both crest and trough for triangle waves.
	GPT32EH0_GTITC_IVTC_11 = 0x3
	// Position of ITLF field.
	GPT32EH0_GTITC_ITLF_Pos = 0x5
	// Bit mask of ITLF field.
	GPT32EH0_GTITC_ITLF_Msk = 0x20
	// Bit ITLF.
	GPT32EH0_GTITC_ITLF = 0x20
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLF_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLF_1 = 0x1
	// Position of ITLE field.
	GPT32EH0_GTITC_ITLE_Pos = 0x4
	// Bit mask of ITLE field.
	GPT32EH0_GTITC_ITLE_Msk = 0x10
	// Bit ITLE.
	GPT32EH0_GTITC_ITLE = 0x10
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLE_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLE_1 = 0x1
	// Position of ITLD field.
	GPT32EH0_GTITC_ITLD_Pos = 0x3
	// Bit mask of ITLD field.
	GPT32EH0_GTITC_ITLD_Msk = 0x8
	// Bit ITLD.
	GPT32EH0_GTITC_ITLD = 0x8
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLD_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLD_1 = 0x1
	// Position of ITLC field.
	GPT32EH0_GTITC_ITLC_Pos = 0x2
	// Bit mask of ITLC field.
	GPT32EH0_GTITC_ITLC_Msk = 0x4
	// Bit ITLC.
	GPT32EH0_GTITC_ITLC = 0x4
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLC_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLC_1 = 0x1
	// Position of ITLB field.
	GPT32EH0_GTITC_ITLB_Pos = 0x1
	// Bit mask of ITLB field.
	GPT32EH0_GTITC_ITLB_Msk = 0x2
	// Bit ITLB.
	GPT32EH0_GTITC_ITLB = 0x2
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLB_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLB_1 = 0x1
	// Position of ITLA field.
	GPT32EH0_GTITC_ITLA_Pos = 0x0
	// Bit mask of ITLA field.
	GPT32EH0_GTITC_ITLA_Msk = 0x1
	// Bit ITLA.
	GPT32EH0_GTITC_ITLA = 0x1
	// Do not link with GPTn_OVF/GPTn_UDF interrupt skipping function
	GPT32EH0_GTITC_ITLA_0 = 0x0
	// Link with GPTn_OVF/GPTn_UDF interrupt skipping function.
	GPT32EH0_GTITC_ITLA_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT32EH0_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT32EH0_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of GTCCRA field.
	GPT32EH0_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT32EH0_GTCCRA_GTCCRA_Msk = 0xffffffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of GTCCRB field.
	GPT32EH0_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT32EH0_GTCCRB_GTCCRB_Msk = 0xffffffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of GTCCRC field.
	GPT32EH0_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT32EH0_GTCCRC_GTCCRC_Msk = 0xffffffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of GTCCRE field.
	GPT32EH0_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT32EH0_GTCCRE_GTCCRE_Msk = 0xffffffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of GTCCRD field.
	GPT32EH0_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT32EH0_GTCCRD_GTCCRD_Msk = 0xffffffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of GTCCRF field.
	GPT32EH0_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT32EH0_GTCCRF_GTCCRF_Msk = 0xffffffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of GTPR field.
	GPT32EH0_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT32EH0_GTPR_GTPR_Msk = 0xffffffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of GTPBR field.
	GPT32EH0_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT32EH0_GTPBR_GTPBR_Msk = 0xffffffff

	// GTPDBR: General PWM Timer Cycle Setting Double-Buffer Register
	// Position of GTPDBR field.
	GPT32EH0_GTPDBR_GTPDBR_Pos = 0x0
	// Bit mask of GTPDBR field.
	GPT32EH0_GTPDBR_GTPDBR_Msk = 0xffffffff

	// GTADTRA: A/D Converter Start Request Timing Register A
	// Position of GTADTRA field.
	GPT32EH0_GTADTRA_GTADTRA_Pos = 0x0
	// Bit mask of GTADTRA field.
	GPT32EH0_GTADTRA_GTADTRA_Msk = 0xffffffff

	// GTADTBRA: A/D Converter Start Request Timing Buffer Register A
	// Position of GTADTBRA field.
	GPT32EH0_GTADTBRA_GTADTBRA_Pos = 0x0
	// Bit mask of GTADTBRA field.
	GPT32EH0_GTADTBRA_GTADTBRA_Msk = 0xffffffff

	// GTADTDBRA: A/D Converter Start Request Timing Double-Buffer Register A
	// Position of GTADTDBRA field.
	GPT32EH0_GTADTDBRA_GTADTDBRA_Pos = 0x0
	// Bit mask of GTADTDBRA field.
	GPT32EH0_GTADTDBRA_GTADTDBRA_Msk = 0xffffffff

	// GTADTRB: A/D Converter Start Request Timing Register B
	// Position of GTADTRB field.
	GPT32EH0_GTADTRB_GTADTRB_Pos = 0x0
	// Bit mask of GTADTRB field.
	GPT32EH0_GTADTRB_GTADTRB_Msk = 0xffffffff

	// GTADTBRB: A/D Converter Start Request Timing Buffer Register B
	// Position of GTADTBRB field.
	GPT32EH0_GTADTBRB_GTADTBRB_Pos = 0x0
	// Bit mask of GTADTBRB field.
	GPT32EH0_GTADTBRB_GTADTBRB_Msk = 0xffffffff

	// GTADTDBRB: A/D Converter Start Request Timing Double-Buffer Register B
	// Position of GTADTDBRB field.
	GPT32EH0_GTADTDBRB_GTADTDBRB_Pos = 0x0
	// Bit mask of GTADTDBRB field.
	GPT32EH0_GTADTDBRB_GTADTDBRB_Msk = 0xffffffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDFER field.
	GPT32EH0_GTDTCR_TDFER_Pos = 0x8
	// Bit mask of TDFER field.
	GPT32EH0_GTDTCR_TDFER_Msk = 0x100
	// Bit TDFER.
	GPT32EH0_GTDTCR_TDFER = 0x100
	// Set GTDVU and GTDVD separately
	GPT32EH0_GTDTCR_TDFER_0 = 0x0
	// Automatically set the value written to GTDVU to GTDVD
	GPT32EH0_GTDTCR_TDFER_1 = 0x1
	// Position of TDBDE field.
	GPT32EH0_GTDTCR_TDBDE_Pos = 0x5
	// Bit mask of TDBDE field.
	GPT32EH0_GTDTCR_TDBDE_Msk = 0x20
	// Bit TDBDE.
	GPT32EH0_GTDTCR_TDBDE = 0x20
	// Disable GTDVD buffer operation
	GPT32EH0_GTDTCR_TDBDE_0 = 0x0
	// Enable GTDVD buffer operation
	GPT32EH0_GTDTCR_TDBDE_1 = 0x1
	// Position of TDBUE field.
	GPT32EH0_GTDTCR_TDBUE_Pos = 0x4
	// Bit mask of TDBUE field.
	GPT32EH0_GTDTCR_TDBUE_Msk = 0x10
	// Bit TDBUE.
	GPT32EH0_GTDTCR_TDBUE = 0x10
	// Disable GTDVU buffer operation
	GPT32EH0_GTDTCR_TDBUE_0 = 0x0
	// Enable GTDVU buffer operation
	GPT32EH0_GTDTCR_TDBUE_1 = 0x1
	// Position of TDE field.
	GPT32EH0_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT32EH0_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT32EH0_GTDTCR_TDE = 0x1
	// Set GTCCRB without using GTDVU and GTDVD.
	GPT32EH0_GTDTCR_TDE_0 = 0x0
	// Use GTDVU and GTDVD to set the compare match value for negative-phase waveform with automatic dead time in GTCCRB.
	GPT32EH0_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of GTDVU field.
	GPT32EH0_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT32EH0_GTDVU_GTDVU_Msk = 0xffffffff

	// GTDVD: General PWM Timer Dead Time Value Register D
	// Position of GTDVD field.
	GPT32EH0_GTDVD_GTDVD_Pos = 0x0
	// Bit mask of GTDVD field.
	GPT32EH0_GTDVD_GTDVD_Msk = 0xffffffff

	// GTDBU: General PWM Timer Dead Time Buffer Register U
	// Position of GTDVU field.
	GPT32EH0_GTDBU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT32EH0_GTDBU_GTDVU_Msk = 0xffffffff

	// GTDBD: General PWM Timer Dead Time Buffer Register D
	// Position of GTDBD field.
	GPT32EH0_GTDBD_GTDBD_Pos = 0x0
	// Bit mask of GTDBD field.
	GPT32EH0_GTDBD_GTDBD_Msk = 0xffffffff

	// GTSOS: General PWM Timer Output Protection Function Status Register
	// Position of SOS field.
	GPT32EH0_GTSOS_SOS_Pos = 0x0
	// Bit mask of SOS field.
	GPT32EH0_GTSOS_SOS_Msk = 0x3
	// Normal operation
	GPT32EH0_GTSOS_SOS_00 = 0x0
	// Protected state (GTCCRA = 0 is set during transfer at trough or crest)
	GPT32EH0_GTSOS_SOS_01 = 0x1
	// Protected state (GTCCRA >= GTPR is set during transfer at trough)
	GPT32EH0_GTSOS_SOS_10 = 0x2
	// Protected state (GTCCRA >= GTPR is set during transfer at crest)
	GPT32EH0_GTSOS_SOS_11 = 0x3

	// GTSOTR: General PWM Timer Output Protection Function Temporary Release Register
	// Position of SOTR field.
	GPT32EH0_GTSOTR_SOTR_Pos = 0x0
	// Bit mask of SOTR field.
	GPT32EH0_GTSOTR_SOTR_Msk = 0x1
	// Bit SOTR.
	GPT32EH0_GTSOTR_SOTR = 0x1
	// Do not release protected state
	GPT32EH0_GTSOTR_SOTR_0 = 0x0
	// Release protected state
	GPT32EH0_GTSOTR_SOTR_1 = 0x1
)

// Constants for USBHS: USB 2.0 High-Speed Module
const (
	// SYSCFG: System Configuration Control Register
	// Position of CNEN field.
	USBHS_SYSCFG_CNEN_Pos = 0x8
	// Bit mask of CNEN field.
	USBHS_SYSCFG_CNEN_Msk = 0x100
	// Bit CNEN.
	USBHS_SYSCFG_CNEN = 0x100
	// Single end receiver operation is disabled.
	USBHS_SYSCFG_CNEN_0 = 0x0
	// Single end receiver operation is enabled.
	USBHS_SYSCFG_CNEN_1 = 0x1
	// Position of HSE field.
	USBHS_SYSCFG_HSE_Pos = 0x7
	// Bit mask of HSE field.
	USBHS_SYSCFG_HSE_Msk = 0x80
	// Bit HSE.
	USBHS_SYSCFG_HSE = 0x80
	// High-speed operation is disabled.(When the function controller function is selected: Full speed, When the host controller function is selected: Full/low speed)
	USBHS_SYSCFG_HSE_0 = 0x0
	// High-speed operation is enabled (the controller detects the communication speed).
	USBHS_SYSCFG_HSE_1 = 0x1
	// Position of DCFM field.
	USBHS_SYSCFG_DCFM_Pos = 0x6
	// Bit mask of DCFM field.
	USBHS_SYSCFG_DCFM_Msk = 0x40
	// Bit DCFM.
	USBHS_SYSCFG_DCFM = 0x40
	// Function controller function is selected.
	USBHS_SYSCFG_DCFM_0 = 0x0
	// Host controller function is selected.
	USBHS_SYSCFG_DCFM_1 = 0x1
	// Position of DRPD field.
	USBHS_SYSCFG_DRPD_Pos = 0x5
	// Bit mask of DRPD field.
	USBHS_SYSCFG_DRPD_Msk = 0x20
	// Bit DRPD.
	USBHS_SYSCFG_DRPD = 0x20
	// Pulling down the line is disabled.
	USBHS_SYSCFG_DRPD_0 = 0x0
	// Pulling down the line is enabled.
	USBHS_SYSCFG_DRPD_1 = 0x1
	// Position of DPRPU field.
	USBHS_SYSCFG_DPRPU_Pos = 0x4
	// Bit mask of DPRPU field.
	USBHS_SYSCFG_DPRPU_Msk = 0x10
	// Bit DPRPU.
	USBHS_SYSCFG_DPRPU = 0x10
	// Pulling up the line is disabled.
	USBHS_SYSCFG_DPRPU_0 = 0x0
	// Pulling up the line is enabled.
	USBHS_SYSCFG_DPRPU_1 = 0x1
	// Position of USBE field.
	USBHS_SYSCFG_USBE_Pos = 0x0
	// Bit mask of USBE field.
	USBHS_SYSCFG_USBE_Msk = 0x1
	// Bit USBE.
	USBHS_SYSCFG_USBE = 0x1
	// USB operation is disabled.
	USBHS_SYSCFG_USBE_0 = 0x0
	// USB operation is enabled.
	USBHS_SYSCFG_USBE_1 = 0x1

	// BUSWAIT: CPU Bus Wait Register
	// Position of BWAIT field.
	USBHS_BUSWAIT_BWAIT_Pos = 0x0
	// Bit mask of BWAIT field.
	USBHS_BUSWAIT_BWAIT_Msk = 0xf

	// SYSSTS0: System Configuration Status Register
	// Position of OVCMON field.
	USBHS_SYSSTS0_OVCMON_Pos = 0xe
	// Bit mask of OVCMON field.
	USBHS_SYSSTS0_OVCMON_Msk = 0xc000
	// Position of HTACT field.
	USBHS_SYSSTS0_HTACT_Pos = 0x6
	// Bit mask of HTACT field.
	USBHS_SYSSTS0_HTACT_Msk = 0x40
	// Bit HTACT.
	USBHS_SYSSTS0_HTACT = 0x40
	// Host sequencer is stopped.
	USBHS_SYSSTS0_HTACT_0 = 0x0
	// Host sequencer is operating.
	USBHS_SYSSTS0_HTACT_1 = 0x1
	// Position of SOFEA field.
	USBHS_SYSSTS0_SOFEA_Pos = 0x5
	// Bit mask of SOFEA field.
	USBHS_SYSSTS0_SOFEA_Msk = 0x20
	// Bit SOFEA.
	USBHS_SYSSTS0_SOFEA = 0x20
	// SOF output is stopped.
	USBHS_SYSSTS0_SOFEA_0 = 0x0
	// SOF output is operating.
	USBHS_SYSSTS0_SOFEA_1 = 0x1
	// Position of IDMON field.
	USBHS_SYSSTS0_IDMON_Pos = 0x2
	// Bit mask of IDMON field.
	USBHS_SYSSTS0_IDMON_Msk = 0x4
	// Bit IDMON.
	USBHS_SYSSTS0_IDMON = 0x4
	// ID0 = Low
	USBHS_SYSSTS0_IDMON_0 = 0x0
	// ID0 = High
	USBHS_SYSSTS0_IDMON_1 = 0x1
	// Position of LNST field.
	USBHS_SYSSTS0_LNST_Pos = 0x0
	// Bit mask of LNST field.
	USBHS_SYSSTS0_LNST_Msk = 0x3
	// SE0 (During Low-Speed Operation:only when the host controller function is selected or During Full-Speed Operation) /Squelch (During Hi-Speed Operation or During Chirp Operation)
	USBHS_SYSSTS0_LNST_00 = 0x0
	// K-State (During Low-Speed Operation:only when the host controller function is selected) /J-State (During Full-Speed Operation) /Unsquelch (During Hi-Speed Operation) /Chirp J (During Chirp Operation)
	USBHS_SYSSTS0_LNST_01 = 0x1
	// J-State (During Low-Speed Operation:only when the host controller function is selected) /K-State (During Full-Speed Operation) /Invalid (During Hi-Speed Operation) /Chirp K (During Chirp Operation)
	USBHS_SYSSTS0_LNST_10 = 0x2
	// SE1 (During Low-Speed Operation:only when the host controller function is selected or During Full-Speed Operation) /Invalid (During Hi-Speed Operation or During Chirp Operation)
	USBHS_SYSSTS0_LNST_11 = 0x3

	// PLLSTA: PLL Status Register
	// Position of PLLLOCK field.
	USBHS_PLLSTA_PLLLOCK_Pos = 0x0
	// Bit mask of PLLLOCK field.
	USBHS_PLLSTA_PLLLOCK_Msk = 0x1
	// Bit PLLLOCK.
	USBHS_PLLSTA_PLLLOCK = 0x1
	// PLL is not locked.
	USBHS_PLLSTA_PLLLOCK_0 = 0x0
	// PLL is locked.
	USBHS_PLLSTA_PLLLOCK_1 = 0x1

	// DVSTCTR0: Device State Control Register 0
	// Position of HNPBTOA field.
	USBHS_DVSTCTR0_HNPBTOA_Pos = 0xb
	// Bit mask of HNPBTOA field.
	USBHS_DVSTCTR0_HNPBTOA_Msk = 0x800
	// Bit HNPBTOA.
	USBHS_DVSTCTR0_HNPBTOA = 0x800
	// Position of EXICEN field.
	USBHS_DVSTCTR0_EXICEN_Pos = 0xa
	// Bit mask of EXICEN field.
	USBHS_DVSTCTR0_EXICEN_Msk = 0x400
	// Bit EXICEN.
	USBHS_DVSTCTR0_EXICEN = 0x400
	// Output low on external USBHS_EXICEN pin
	USBHS_DVSTCTR0_EXICEN_0 = 0x0
	// Output high on external USBHS_EXICEN pin.
	USBHS_DVSTCTR0_EXICEN_1 = 0x1
	// Position of VBUSEN field.
	USBHS_DVSTCTR0_VBUSEN_Pos = 0x9
	// Bit mask of VBUSEN field.
	USBHS_DVSTCTR0_VBUSEN_Msk = 0x200
	// Bit VBUSEN.
	USBHS_DVSTCTR0_VBUSEN = 0x200
	// Output low on external USBHS_VBUSEN pin
	USBHS_DVSTCTR0_VBUSEN_0 = 0x0
	// Output high on external USBHS_VBUSEN pin.
	USBHS_DVSTCTR0_VBUSEN_1 = 0x1
	// Position of WKUP field.
	USBHS_DVSTCTR0_WKUP_Pos = 0x8
	// Bit mask of WKUP field.
	USBHS_DVSTCTR0_WKUP_Msk = 0x100
	// Bit WKUP.
	USBHS_DVSTCTR0_WKUP = 0x100
	// Do not output remote wakeup signal
	USBHS_DVSTCTR0_WKUP_0 = 0x0
	// Output remote wakeup signal.
	USBHS_DVSTCTR0_WKUP_1 = 0x1
	// Position of RWUPE field.
	USBHS_DVSTCTR0_RWUPE_Pos = 0x7
	// Bit mask of RWUPE field.
	USBHS_DVSTCTR0_RWUPE_Msk = 0x80
	// Bit RWUPE.
	USBHS_DVSTCTR0_RWUPE = 0x80
	// Disable downstream port remote wakeup
	USBHS_DVSTCTR0_RWUPE_0 = 0x0
	// Enable downstream port remote wakeup.
	USBHS_DVSTCTR0_RWUPE_1 = 0x1
	// Position of USBRST field.
	USBHS_DVSTCTR0_USBRST_Pos = 0x6
	// Bit mask of USBRST field.
	USBHS_DVSTCTR0_USBRST_Msk = 0x40
	// Bit USBRST.
	USBHS_DVSTCTR0_USBRST = 0x40
	// Do not output USB bus reset signal
	USBHS_DVSTCTR0_USBRST_0 = 0x0
	// Output USB bus reset signal.
	USBHS_DVSTCTR0_USBRST_1 = 0x1
	// Position of RESUME field.
	USBHS_DVSTCTR0_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USBHS_DVSTCTR0_RESUME_Msk = 0x20
	// Bit RESUME.
	USBHS_DVSTCTR0_RESUME = 0x20
	// Do not output resume signal
	USBHS_DVSTCTR0_RESUME_0 = 0x0
	// Output resume signal.
	USBHS_DVSTCTR0_RESUME_1 = 0x1
	// Position of UACT field.
	USBHS_DVSTCTR0_UACT_Pos = 0x4
	// Bit mask of UACT field.
	USBHS_DVSTCTR0_UACT_Msk = 0x10
	// Bit UACT.
	USBHS_DVSTCTR0_UACT = 0x10
	// Disable downstream port (disable SOF or micro-SOF transmission)
	USBHS_DVSTCTR0_UACT_0 = 0x0
	// Enable downstream port (enable SOF or micro-SOF transmission).
	USBHS_DVSTCTR0_UACT_1 = 0x1
	// Position of RHST field.
	USBHS_DVSTCTR0_RHST_Pos = 0x0
	// Bit mask of RHST field.
	USBHS_DVSTCTR0_RHST_Msk = 0x7
	// Communication speed not determined
	USBHS_DVSTCTR0_RHST_000 = 0x0
	// Low-speed connection(When the host controller function is selected) /USB bus reset in progress or low-speed connection(When the function controller function is selected)
	USBHS_DVSTCTR0_RHST_001 = 0x1
	// Full-speed connection(When the host controller function is selected) /USB bus reset in progress or full-speed connection(When the function controller function is selected)
	USBHS_DVSTCTR0_RHST_010 = 0x2
	// Setting prohibited
	USBHS_DVSTCTR0_RHST_011 = 0x3

	// TESTMODE: USB Test Mode Register
	// Position of UTST field.
	USBHS_TESTMODE_UTST_Pos = 0x0
	// Bit mask of UTST field.
	USBHS_TESTMODE_UTST_Msk = 0xf
	// Normal operation
	USBHS_TESTMODE_UTST_0000 = 0x0
	// Test_J TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0001 = 0x1
	// Test_K TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0010 = 0x2
	// Test_SE0_NAK TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0011 = 0x3
	// Test_Packet TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0100 = 0x4
	// Reserved TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0101 = 0x5
	// Reserved TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0110 = 0x6
	// Reserved TestMode(When the Function Controller Function is Selected)
	USBHS_TESTMODE_UTST_0111 = 0x7
	// Test_J TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1001 = 0x9
	// Test_K TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1010 = 0xa
	// Test_SE0_NAK TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1011 = 0xb
	// Test_Packet TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1100 = 0xc
	// Test_Force_EnableTestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1101 = 0xd
	// Reserved TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1110 = 0xe
	// Reserved TestMode(When the Host Controller Function is Selected)
	USBHS_TESTMODE_UTST_1111 = 0xf

	// CFIFO: CFIFO Port Register
	// Position of FIFOPORT field.
	USBHS_CFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBHS_CFIFO_FIFOPORT_Msk = 0xffffffff

	// D0FIFO: D0FIFO Port Register
	// Position of FIFOPORT field.
	USBHS_D0FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBHS_D0FIFO_FIFOPORT_Msk = 0xffffffff

	// D1FIFO: D1FIFO Port Register
	// Position of FIFOPORT field.
	USBHS_D1FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBHS_D1FIFO_FIFOPORT_Msk = 0xffffffff

	// CFIFOSEL: CFIFO Port Select Register
	// Position of RCNT field.
	USBHS_CFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBHS_CFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBHS_CFIFOSEL_RCNT = 0x8000
	// Clear DTLN[11:0] flags in the FIFO port control register to 000h when all receive data is read from CFIFO
	USBHS_CFIFOSEL_RCNT_0 = 0x0
	// Decrement DTLN[11:0] flags each time receive data is read from CFIFO.
	USBHS_CFIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBHS_CFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBHS_CFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBHS_CFIFOSEL_REW = 0x4000
	// Do not rewind buffer pointer (Writing 0 has no effect.)
	USBHS_CFIFOSEL_REW_0 = 0x0
	// Rewind buffer pointer.
	USBHS_CFIFOSEL_REW_1 = 0x1
	// Position of MBW field.
	USBHS_CFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBHS_CFIFOSEL_MBW_Msk = 0xc00
	// 8-bit width
	USBHS_CFIFOSEL_MBW_00 = 0x0
	// 16-bit width
	USBHS_CFIFOSEL_MBW_01 = 0x1
	// 32-bit width
	USBHS_CFIFOSEL_MBW_10 = 0x2
	// Setting prohibited
	USBHS_CFIFOSEL_MBW_11 = 0x3
	// Position of BIGEND field.
	USBHS_CFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBHS_CFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBHS_CFIFOSEL_BIGEND = 0x100
	// Little endian
	USBHS_CFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBHS_CFIFOSEL_BIGEND_1 = 0x1
	// Position of ISEL field.
	USBHS_CFIFOSEL_ISEL_Pos = 0x5
	// Bit mask of ISEL field.
	USBHS_CFIFOSEL_ISEL_Msk = 0x20
	// Bit ISEL.
	USBHS_CFIFOSEL_ISEL = 0x20
	// Select reading from the FIFO buffer
	USBHS_CFIFOSEL_ISEL_0 = 0x0
	// Select writing to the FIFO buffer.
	USBHS_CFIFOSEL_ISEL_1 = 0x1
	// Position of CURPIPE field.
	USBHS_CFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBHS_CFIFOSEL_CURPIPE_Msk = 0xf
	// DCP
	USBHS_CFIFOSEL_CURPIPE_0000 = 0x0
	// PIPE1
	USBHS_CFIFOSEL_CURPIPE_0001 = 0x1
	// PIPE2
	USBHS_CFIFOSEL_CURPIPE_0010 = 0x2
	// PIPE3
	USBHS_CFIFOSEL_CURPIPE_0011 = 0x3
	// PIPE4
	USBHS_CFIFOSEL_CURPIPE_0100 = 0x4
	// PIPE5
	USBHS_CFIFOSEL_CURPIPE_0101 = 0x5
	// PIPE6
	USBHS_CFIFOSEL_CURPIPE_0110 = 0x6
	// PIPE7
	USBHS_CFIFOSEL_CURPIPE_0111 = 0x7
	// PIPE8
	USBHS_CFIFOSEL_CURPIPE_1000 = 0x8
	// PIPE9
	USBHS_CFIFOSEL_CURPIPE_1001 = 0x9

	// CFIFOCTR: CFIFO Port Control Register
	// Position of BVAL field.
	USBHS_CFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBHS_CFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBHS_CFIFOCTR_BVAL = 0x8000
	// Invalid
	USBHS_CFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBHS_CFIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBHS_CFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBHS_CFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBHS_CFIFOCTR_BCLR = 0x4000
	// No operation
	USBHS_CFIFOCTR_BCLR_0 = 0x0
	// Clear FIFO buffer on the CPU side.
	USBHS_CFIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBHS_CFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBHS_CFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBHS_CFIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled
	USBHS_CFIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled
	USBHS_CFIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBHS_CFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBHS_CFIFOCTR_DTLN_Msk = 0xfff

	// D0FIFOSEL: D0FIFO Port Select Register
	// Position of RCNT field.
	USBHS_D0FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBHS_D0FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBHS_D0FIFOSEL_RCNT = 0x8000
	// The DTLN bits are cleared when all of the receive data has been read from the CFIFO
	USBHS_D0FIFOSEL_RCNT_0 = 0x0
	// The DTLN bits are decremented each time the receive data is read from the CFIFO
	USBHS_D0FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBHS_D0FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBHS_D0FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBHS_D0FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound
	USBHS_D0FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound
	USBHS_D0FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBHS_D0FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBHS_D0FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBHS_D0FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled
	USBHS_D0FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled
	USBHS_D0FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBHS_D0FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBHS_D0FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBHS_D0FIFOSEL_DREQE = 0x1000
	// Disables the output
	USBHS_D0FIFOSEL_DREQE_0 = 0x0
	// Enables the output
	USBHS_D0FIFOSEL_DREQE_1 = 0x1
	// Position of MBW field.
	USBHS_D0FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBHS_D0FIFOSEL_MBW_Msk = 0xc00
	// 8-bit width
	USBHS_D0FIFOSEL_MBW_00 = 0x0
	// 16-bit width
	USBHS_D0FIFOSEL_MBW_01 = 0x1
	// 32-bit width
	USBHS_D0FIFOSEL_MBW_10 = 0x2
	// Setting prohibited
	USBHS_D0FIFOSEL_MBW_11 = 0x3
	// Position of BIGEND field.
	USBHS_D0FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBHS_D0FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBHS_D0FIFOSEL_BIGEND = 0x100
	// Little endian
	USBHS_D0FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBHS_D0FIFOSEL_BIGEND_1 = 0x1
	// Position of CURPIPE field.
	USBHS_D0FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBHS_D0FIFOSEL_CURPIPE_Msk = 0xf
	// No pipe specified
	USBHS_D0FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe1
	USBHS_D0FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBHS_D0FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBHS_D0FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBHS_D0FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBHS_D0FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBHS_D0FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBHS_D0FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBHS_D0FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBHS_D0FIFOSEL_CURPIPE_1001 = 0x9

	// D0FIFOCTR: D0FIFO Port Control Register
	// Position of BVAL field.
	USBHS_D0FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBHS_D0FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBHS_D0FIFOCTR_BVAL = 0x8000
	// Invalid
	USBHS_D0FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBHS_D0FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBHS_D0FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBHS_D0FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBHS_D0FIFOCTR_BCLR = 0x4000
	// No operation
	USBHS_D0FIFOCTR_BCLR_0 = 0x0
	// Clear FIFO buffer on the CPU side.
	USBHS_D0FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBHS_D0FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBHS_D0FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBHS_D0FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled
	USBHS_D0FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled
	USBHS_D0FIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBHS_D0FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBHS_D0FIFOCTR_DTLN_Msk = 0xfff

	// D1FIFOSEL: D1FIFO Port Select Register
	// Position of RCNT field.
	USBHS_D1FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBHS_D1FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBHS_D1FIFOSEL_RCNT = 0x8000
	// The DTLN bits are cleared when all of the receive data has been read from the CFIFO
	USBHS_D1FIFOSEL_RCNT_0 = 0x0
	// The DTLN bits are decremented each time the receive data is read from the CFIFO
	USBHS_D1FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBHS_D1FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBHS_D1FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBHS_D1FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound
	USBHS_D1FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound
	USBHS_D1FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBHS_D1FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBHS_D1FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBHS_D1FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled
	USBHS_D1FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled
	USBHS_D1FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBHS_D1FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBHS_D1FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBHS_D1FIFOSEL_DREQE = 0x1000
	// Disables the output
	USBHS_D1FIFOSEL_DREQE_0 = 0x0
	// Enables the output
	USBHS_D1FIFOSEL_DREQE_1 = 0x1
	// Position of MBW field.
	USBHS_D1FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBHS_D1FIFOSEL_MBW_Msk = 0xc00
	// 8-bit width
	USBHS_D1FIFOSEL_MBW_00 = 0x0
	// 16-bit width
	USBHS_D1FIFOSEL_MBW_01 = 0x1
	// 32-bit width
	USBHS_D1FIFOSEL_MBW_10 = 0x2
	// Setting prohibited
	USBHS_D1FIFOSEL_MBW_11 = 0x3
	// Position of BIGEND field.
	USBHS_D1FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBHS_D1FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBHS_D1FIFOSEL_BIGEND = 0x100
	// Little endian
	USBHS_D1FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBHS_D1FIFOSEL_BIGEND_1 = 0x1
	// Position of CURPIPE field.
	USBHS_D1FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBHS_D1FIFOSEL_CURPIPE_Msk = 0xf
	// No pipe specified
	USBHS_D1FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBHS_D1FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBHS_D1FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBHS_D1FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBHS_D1FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBHS_D1FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBHS_D1FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBHS_D1FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBHS_D1FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBHS_D1FIFOSEL_CURPIPE_1001 = 0x9

	// D1FIFOCTR: D1FIFO Port Control Register
	// Position of BVAL field.
	USBHS_D1FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBHS_D1FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBHS_D1FIFOCTR_BVAL = 0x8000
	// Invalid
	USBHS_D1FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBHS_D1FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBHS_D1FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBHS_D1FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBHS_D1FIFOCTR_BCLR = 0x4000
	// No operation
	USBHS_D1FIFOCTR_BCLR_0 = 0x0
	// Clear FIFO buffer on the CPU side.
	USBHS_D1FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBHS_D1FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBHS_D1FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBHS_D1FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled
	USBHS_D1FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled
	USBHS_D1FIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBHS_D1FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBHS_D1FIFOCTR_DTLN_Msk = 0xfff

	// INTENB0: Interrupt Enable Register 0
	// Position of VBSE field.
	USBHS_INTENB0_VBSE_Pos = 0xf
	// Bit mask of VBSE field.
	USBHS_INTENB0_VBSE_Msk = 0x8000
	// Bit VBSE.
	USBHS_INTENB0_VBSE = 0x8000
	// Interrupt output disabled
	USBHS_INTENB0_VBSE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_VBSE_1 = 0x1
	// Position of RSME field.
	USBHS_INTENB0_RSME_Pos = 0xe
	// Bit mask of RSME field.
	USBHS_INTENB0_RSME_Msk = 0x4000
	// Bit RSME.
	USBHS_INTENB0_RSME = 0x4000
	// Interrupt output disabled
	USBHS_INTENB0_RSME_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_RSME_1 = 0x1
	// Position of SOFE field.
	USBHS_INTENB0_SOFE_Pos = 0xd
	// Bit mask of SOFE field.
	USBHS_INTENB0_SOFE_Msk = 0x2000
	// Bit SOFE.
	USBHS_INTENB0_SOFE = 0x2000
	// Interrupt output disabled
	USBHS_INTENB0_SOFE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_SOFE_1 = 0x1
	// Position of DVSE field.
	USBHS_INTENB0_DVSE_Pos = 0xc
	// Bit mask of DVSE field.
	USBHS_INTENB0_DVSE_Msk = 0x1000
	// Bit DVSE.
	USBHS_INTENB0_DVSE = 0x1000
	// Interrupt output disabled
	USBHS_INTENB0_DVSE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_DVSE_1 = 0x1
	// Position of CTRE field.
	USBHS_INTENB0_CTRE_Pos = 0xb
	// Bit mask of CTRE field.
	USBHS_INTENB0_CTRE_Msk = 0x800
	// Bit CTRE.
	USBHS_INTENB0_CTRE = 0x800
	// Interrupt output disabled
	USBHS_INTENB0_CTRE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_CTRE_1 = 0x1
	// Position of BEMPE field.
	USBHS_INTENB0_BEMPE_Pos = 0xa
	// Bit mask of BEMPE field.
	USBHS_INTENB0_BEMPE_Msk = 0x400
	// Bit BEMPE.
	USBHS_INTENB0_BEMPE = 0x400
	// Interrupt output disabled
	USBHS_INTENB0_BEMPE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_BEMPE_1 = 0x1
	// Position of NRDYE field.
	USBHS_INTENB0_NRDYE_Pos = 0x9
	// Bit mask of NRDYE field.
	USBHS_INTENB0_NRDYE_Msk = 0x200
	// Bit NRDYE.
	USBHS_INTENB0_NRDYE = 0x200
	// Interrupt output disabled
	USBHS_INTENB0_NRDYE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_NRDYE_1 = 0x1
	// Position of BRDYE field.
	USBHS_INTENB0_BRDYE_Pos = 0x8
	// Bit mask of BRDYE field.
	USBHS_INTENB0_BRDYE_Msk = 0x100
	// Bit BRDYE.
	USBHS_INTENB0_BRDYE = 0x100
	// Interrupt output disabled
	USBHS_INTENB0_BRDYE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB0_BRDYE_1 = 0x1

	// INTENB1: Interrupt Enable Register 1
	// Position of OVRCRE field.
	USBHS_INTENB1_OVRCRE_Pos = 0xf
	// Bit mask of OVRCRE field.
	USBHS_INTENB1_OVRCRE_Msk = 0x8000
	// Bit OVRCRE.
	USBHS_INTENB1_OVRCRE = 0x8000
	// Interrupt output disabled
	USBHS_INTENB1_OVRCRE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_OVRCRE_1 = 0x1
	// Position of BCHGE field.
	USBHS_INTENB1_BCHGE_Pos = 0xe
	// Bit mask of BCHGE field.
	USBHS_INTENB1_BCHGE_Msk = 0x4000
	// Bit BCHGE.
	USBHS_INTENB1_BCHGE = 0x4000
	// Interrupt output disabled
	USBHS_INTENB1_BCHGE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_BCHGE_1 = 0x1
	// Position of DTCHE field.
	USBHS_INTENB1_DTCHE_Pos = 0xc
	// Bit mask of DTCHE field.
	USBHS_INTENB1_DTCHE_Msk = 0x1000
	// Bit DTCHE.
	USBHS_INTENB1_DTCHE = 0x1000
	// Interrupt output disabled
	USBHS_INTENB1_DTCHE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_DTCHE_1 = 0x1
	// Position of ATTCHE field.
	USBHS_INTENB1_ATTCHE_Pos = 0xb
	// Bit mask of ATTCHE field.
	USBHS_INTENB1_ATTCHE_Msk = 0x800
	// Bit ATTCHE.
	USBHS_INTENB1_ATTCHE = 0x800
	// Interrupt output disabled
	USBHS_INTENB1_ATTCHE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_ATTCHE_1 = 0x1
	// Position of L1RSMENDE field.
	USBHS_INTENB1_L1RSMENDE_Pos = 0x9
	// Bit mask of L1RSMENDE field.
	USBHS_INTENB1_L1RSMENDE_Msk = 0x200
	// Bit L1RSMENDE.
	USBHS_INTENB1_L1RSMENDE = 0x200
	// Interrupt output disabled
	USBHS_INTENB1_L1RSMENDE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_L1RSMENDE_1 = 0x1
	// Position of LPMENDE field.
	USBHS_INTENB1_LPMENDE_Pos = 0x8
	// Bit mask of LPMENDE field.
	USBHS_INTENB1_LPMENDE_Msk = 0x100
	// Bit LPMENDE.
	USBHS_INTENB1_LPMENDE = 0x100
	// Interrupt output disabled
	USBHS_INTENB1_LPMENDE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_LPMENDE_1 = 0x1
	// Position of EOFERRE field.
	USBHS_INTENB1_EOFERRE_Pos = 0x6
	// Bit mask of EOFERRE field.
	USBHS_INTENB1_EOFERRE_Msk = 0x40
	// Bit EOFERRE.
	USBHS_INTENB1_EOFERRE = 0x40
	// Interrupt output disabled
	USBHS_INTENB1_EOFERRE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_EOFERRE_1 = 0x1
	// Position of SIGNE field.
	USBHS_INTENB1_SIGNE_Pos = 0x5
	// Bit mask of SIGNE field.
	USBHS_INTENB1_SIGNE_Msk = 0x20
	// Bit SIGNE.
	USBHS_INTENB1_SIGNE = 0x20
	// Interrupt output disabled
	USBHS_INTENB1_SIGNE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_SIGNE_1 = 0x1
	// Position of SACKE field.
	USBHS_INTENB1_SACKE_Pos = 0x4
	// Bit mask of SACKE field.
	USBHS_INTENB1_SACKE_Msk = 0x10
	// Bit SACKE.
	USBHS_INTENB1_SACKE = 0x10
	// Interrupt output disabled
	USBHS_INTENB1_SACKE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_SACKE_1 = 0x1
	// Position of PDDETINTE field.
	USBHS_INTENB1_PDDETINTE_Pos = 0x0
	// Bit mask of PDDETINTE field.
	USBHS_INTENB1_PDDETINTE_Msk = 0x1
	// Bit PDDETINTE.
	USBHS_INTENB1_PDDETINTE = 0x1
	// Interrupt output disabled
	USBHS_INTENB1_PDDETINTE_0 = 0x0
	// Interrupt output enabled
	USBHS_INTENB1_PDDETINTE_1 = 0x1

	// BRDYENB: BRDY Interrupt Enable Register
	// Position of PIPEBRDYE field.
	USBHS_BRDYENB_PIPEBRDYE_Pos = 0x0
	// Bit mask of PIPEBRDYE field.
	USBHS_BRDYENB_PIPEBRDYE_Msk = 0x3ff
	// Interrupt output disabled
	USBHS_BRDYENB_PIPEBRDYE_0 = 0x0
	// Interrupt output enabled
	USBHS_BRDYENB_PIPEBRDYE_1 = 0x1

	// NRDYENB: NRDY Interrupt Enable Register
	// Position of PIPENRDYE field.
	USBHS_NRDYENB_PIPENRDYE_Pos = 0x0
	// Bit mask of PIPENRDYE field.
	USBHS_NRDYENB_PIPENRDYE_Msk = 0x3ff
	// Interrupt output disabled
	USBHS_NRDYENB_PIPENRDYE_0 = 0x0
	// Interrupt output enabled
	USBHS_NRDYENB_PIPENRDYE_1 = 0x1

	// BEMPENB: BEMP Interrupt Enable Register
	// Position of PIPEBEMPE field.
	USBHS_BEMPENB_PIPEBEMPE_Pos = 0x0
	// Bit mask of PIPEBEMPE field.
	USBHS_BEMPENB_PIPEBEMPE_Msk = 0x3ff
	// Interrupt output disabled
	USBHS_BEMPENB_PIPEBEMPE_0 = 0x0
	// Interrupt output enabled
	USBHS_BEMPENB_PIPEBEMPE_1 = 0x1

	// SOFCFG: SOF Pin Configuration Register
	// Position of TRNENSEL field.
	USBHS_SOFCFG_TRNENSEL_Pos = 0x8
	// Bit mask of TRNENSEL field.
	USBHS_SOFCFG_TRNENSEL_Msk = 0x100
	// Bit TRNENSEL.
	USBHS_SOFCFG_TRNENSEL = 0x100
	// For non-low-speed communication
	USBHS_SOFCFG_TRNENSEL_0 = 0x0
	// For low-speed communication
	USBHS_SOFCFG_TRNENSEL_1 = 0x1
	// Position of BRDYM field.
	USBHS_SOFCFG_BRDYM_Pos = 0x6
	// Bit mask of BRDYM field.
	USBHS_SOFCFG_BRDYM_Msk = 0x40
	// Bit BRDYM.
	USBHS_SOFCFG_BRDYM = 0x40
	// Software clears the status.
	USBHS_SOFCFG_BRDYM_0 = 0x0
	// Hardware clears the status when data has been read from the FIFO buffer or data has been written to the FIFO buffer.
	USBHS_SOFCFG_BRDYM_1 = 0x1
	// Position of INTL field.
	USBHS_SOFCFG_INTL_Pos = 0x5
	// Bit mask of INTL field.
	USBHS_SOFCFG_INTL_Msk = 0x20
	// Bit INTL.
	USBHS_SOFCFG_INTL = 0x20
	// Edge sense
	USBHS_SOFCFG_INTL_0 = 0x0
	// Level sense
	USBHS_SOFCFG_INTL_1 = 0x1
	// Position of EDGESTS field.
	USBHS_SOFCFG_EDGESTS_Pos = 0x4
	// Bit mask of EDGESTS field.
	USBHS_SOFCFG_EDGESTS_Msk = 0x10
	// Bit EDGESTS.
	USBHS_SOFCFG_EDGESTS = 0x10
	// Interrupt edge processing is not run
	USBHS_SOFCFG_EDGESTS_0 = 0x0
	// Interrupt edge processing is running
	USBHS_SOFCFG_EDGESTS_1 = 0x1

	// PHYSET: PHY Setting Register
	// Position of HSEB field.
	USBHS_PHYSET_HSEB_Pos = 0xf
	// Bit mask of HSEB field.
	USBHS_PHYSET_HSEB_Msk = 0x8000
	// Bit HSEB.
	USBHS_PHYSET_HSEB = 0x8000
	// CL-only mode is not activated.
	USBHS_PHYSET_HSEB_0 = 0x0
	// CL-only mode is activated.
	USBHS_PHYSET_HSEB_1 = 0x1
	// Position of REPSTART field.
	USBHS_PHYSET_REPSTART_Pos = 0xb
	// Bit mask of REPSTART field.
	USBHS_PHYSET_REPSTART_Msk = 0x800
	// Bit REPSTART.
	USBHS_PHYSET_REPSTART = 0x800
	// Terminating resistance adjustment is forcibly started
	USBHS_PHYSET_REPSTART_0 = 0x0
	// Terminating resistance adjustment is not forcibly started
	USBHS_PHYSET_REPSTART_1 = 0x1
	// Position of REPSEL field.
	USBHS_PHYSET_REPSEL_Pos = 0x8
	// Bit mask of REPSEL field.
	USBHS_PHYSET_REPSEL_Msk = 0x300
	// No cycle is set.
	USBHS_PHYSET_REPSEL_00 = 0x0
	// Adjust terminating resistance at 16-second intervals.
	USBHS_PHYSET_REPSEL_01 = 0x1
	// Adjust terminating resistance at 64-second intervals.
	USBHS_PHYSET_REPSEL_10 = 0x2
	// Adjust terminating resistance at 128-second intervals.
	USBHS_PHYSET_REPSEL_11 = 0x3
	// Position of CLKSEL field.
	USBHS_PHYSET_CLKSEL_Pos = 0x4
	// Bit mask of CLKSEL field.
	USBHS_PHYSET_CLKSEL_Msk = 0x30
	// Setting Prohibited
	USBHS_PHYSET_CLKSEL_00 = 0x0
	// 12 MHz
	USBHS_PHYSET_CLKSEL_01 = 0x1
	// 20 MHz
	USBHS_PHYSET_CLKSEL_10 = 0x2
	// 24 MHz
	USBHS_PHYSET_CLKSEL_11 = 0x3
	// Position of CDPEN field.
	USBHS_PHYSET_CDPEN_Pos = 0x3
	// Bit mask of CDPEN field.
	USBHS_PHYSET_CDPEN_Msk = 0x8
	// Bit CDPEN.
	USBHS_PHYSET_CDPEN = 0x8
	// Disable charging downstream port
	USBHS_PHYSET_CDPEN_0 = 0x0
	// Enable charging downstream port
	USBHS_PHYSET_CDPEN_1 = 0x1
	// Position of PLLRESET field.
	USBHS_PHYSET_PLLRESET_Pos = 0x1
	// Bit mask of PLLRESET field.
	USBHS_PHYSET_PLLRESET_Msk = 0x2
	// Bit PLLRESET.
	USBHS_PHYSET_PLLRESET = 0x2
	// Disable PLL reset control for UTMI_PHY
	USBHS_PHYSET_PLLRESET_0 = 0x0
	// Enable PLL reset control for UTMI_PHY
	USBHS_PHYSET_PLLRESET_1 = 0x1
	// Position of DIRPD field.
	USBHS_PHYSET_DIRPD_Pos = 0x0
	// Bit mask of DIRPD field.
	USBHS_PHYSET_DIRPD_Msk = 0x1
	// Bit DIRPD.
	USBHS_PHYSET_DIRPD = 0x1
	// Does not enter low-power consumption mode
	USBHS_PHYSET_DIRPD_0 = 0x0
	// Enter low-power consumption mode
	USBHS_PHYSET_DIRPD_1 = 0x1

	// INTSTS0: Interrupt Status Register 0
	// Position of VBINT field.
	USBHS_INTSTS0_VBINT_Pos = 0xf
	// Bit mask of VBINT field.
	USBHS_INTSTS0_VBINT_Msk = 0x8000
	// Bit VBINT.
	USBHS_INTSTS0_VBINT = 0x8000
	// VBUS interrupt is not generated on detecting a change in the USBHS_VBUS pin.
	USBHS_INTSTS0_VBINT_0 = 0x0
	// VBUS interrupt is generated on detecting a change in the USBHS_VBUS pin.
	USBHS_INTSTS0_VBINT_1 = 0x1
	// Position of RESM field.
	USBHS_INTSTS0_RESM_Pos = 0xe
	// Bit mask of RESM field.
	USBHS_INTSTS0_RESM_Msk = 0x4000
	// Bit RESM.
	USBHS_INTSTS0_RESM = 0x4000
	// Resume interrupts are not generated
	USBHS_INTSTS0_RESM_0 = 0x0
	// Resume interrupts are generated
	USBHS_INTSTS0_RESM_1 = 0x1
	// Position of SOFR field.
	USBHS_INTSTS0_SOFR_Pos = 0xd
	// Bit mask of SOFR field.
	USBHS_INTSTS0_SOFR_Msk = 0x2000
	// Bit SOFR.
	USBHS_INTSTS0_SOFR = 0x2000
	// SOF interrupts are not generated
	USBHS_INTSTS0_SOFR_0 = 0x0
	// SOF interrupts are generated
	USBHS_INTSTS0_SOFR_1 = 0x1
	// Position of DVST field.
	USBHS_INTSTS0_DVST_Pos = 0xc
	// Bit mask of DVST field.
	USBHS_INTSTS0_DVST_Msk = 0x1000
	// Bit DVST.
	USBHS_INTSTS0_DVST = 0x1000
	// Device state transition interrupts are not generated
	USBHS_INTSTS0_DVST_0 = 0x0
	// Device state transition interrupts are generated
	USBHS_INTSTS0_DVST_1 = 0x1
	// Position of CTRT field.
	USBHS_INTSTS0_CTRT_Pos = 0xb
	// Bit mask of CTRT field.
	USBHS_INTSTS0_CTRT_Msk = 0x800
	// Bit CTRT.
	USBHS_INTSTS0_CTRT = 0x800
	// Control transfer stage transition interrupts are not generated
	USBHS_INTSTS0_CTRT_0 = 0x0
	// Control transfer stage transition interrupts are generated
	USBHS_INTSTS0_CTRT_1 = 0x1
	// Position of BEMP field.
	USBHS_INTSTS0_BEMP_Pos = 0xa
	// Bit mask of BEMP field.
	USBHS_INTSTS0_BEMP_Msk = 0x400
	// Bit BEMP.
	USBHS_INTSTS0_BEMP = 0x400
	// BEMP interrupts are not generated
	USBHS_INTSTS0_BEMP_0 = 0x0
	// BEMP interrupts are not generated
	USBHS_INTSTS0_BEMP_1 = 0x1
	// Position of NRDY field.
	USBHS_INTSTS0_NRDY_Pos = 0x9
	// Bit mask of NRDY field.
	USBHS_INTSTS0_NRDY_Msk = 0x200
	// Bit NRDY.
	USBHS_INTSTS0_NRDY = 0x200
	// NRDY interrupts are not generated
	USBHS_INTSTS0_NRDY_0 = 0x0
	// NRDY interrupts are generated
	USBHS_INTSTS0_NRDY_1 = 0x1
	// Position of BRDY field.
	USBHS_INTSTS0_BRDY_Pos = 0x8
	// Bit mask of BRDY field.
	USBHS_INTSTS0_BRDY_Msk = 0x100
	// Bit BRDY.
	USBHS_INTSTS0_BRDY = 0x100
	// BRDY interrupts are not generated
	USBHS_INTSTS0_BRDY_0 = 0x0
	// BRDY interrupts are generated
	USBHS_INTSTS0_BRDY_1 = 0x1
	// Position of VBSTS field.
	USBHS_INTSTS0_VBSTS_Pos = 0x7
	// Bit mask of VBSTS field.
	USBHS_INTSTS0_VBSTS_Msk = 0x80
	// Bit VBSTS.
	USBHS_INTSTS0_VBSTS = 0x80
	// The USBHS_VBUS pin is low
	USBHS_INTSTS0_VBSTS_0 = 0x0
	// The USBHS_VBUS pin is high
	USBHS_INTSTS0_VBSTS_1 = 0x1
	// Position of DVSQ field.
	USBHS_INTSTS0_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBHS_INTSTS0_DVSQ_Msk = 0x70
	// Powered state
	USBHS_INTSTS0_DVSQ_000 = 0x0
	// Default state
	USBHS_INTSTS0_DVSQ_001 = 0x1
	// Address state
	USBHS_INTSTS0_DVSQ_010 = 0x2
	// Configured state
	USBHS_INTSTS0_DVSQ_011 = 0x3
	// Position of VALID field.
	USBHS_INTSTS0_VALID_Pos = 0x3
	// Bit mask of VALID field.
	USBHS_INTSTS0_VALID_Msk = 0x8
	// Bit VALID.
	USBHS_INTSTS0_VALID = 0x8
	// Not detected
	USBHS_INTSTS0_VALID_0 = 0x0
	// Setup packet reception
	USBHS_INTSTS0_VALID_1 = 0x1
	// Position of CTSQ field.
	USBHS_INTSTS0_CTSQ_Pos = 0x0
	// Bit mask of CTSQ field.
	USBHS_INTSTS0_CTSQ_Msk = 0x7
	// Idle or setup stage
	USBHS_INTSTS0_CTSQ_000 = 0x0
	// Control read data stage
	USBHS_INTSTS0_CTSQ_001 = 0x1
	// Control read status stage
	USBHS_INTSTS0_CTSQ_010 = 0x2
	// Control write data stage
	USBHS_INTSTS0_CTSQ_011 = 0x3
	// Control write status stage
	USBHS_INTSTS0_CTSQ_100 = 0x4
	// Control write (no data) status stage
	USBHS_INTSTS0_CTSQ_101 = 0x5
	// Control transfer sequence error
	USBHS_INTSTS0_CTSQ_110 = 0x6
	// Setting prohibited
	USBHS_INTSTS0_CTSQ_111 = 0x7

	// INTSTS1: Interrupt Status Register 1
	// Position of OVRCR field.
	USBHS_INTSTS1_OVRCR_Pos = 0xf
	// Bit mask of OVRCR field.
	USBHS_INTSTS1_OVRCR_Msk = 0x8000
	// Bit OVRCR.
	USBHS_INTSTS1_OVRCR = 0x8000
	// OVRCR interrupts are not generated
	USBHS_INTSTS1_OVRCR_0 = 0x0
	// OVRCR interrupts are generated
	USBHS_INTSTS1_OVRCR_1 = 0x1
	// Position of BCHG field.
	USBHS_INTSTS1_BCHG_Pos = 0xe
	// Bit mask of BCHG field.
	USBHS_INTSTS1_BCHG_Msk = 0x4000
	// Bit BCHG.
	USBHS_INTSTS1_BCHG = 0x4000
	// BCHG interrupts are not generated
	USBHS_INTSTS1_BCHG_0 = 0x0
	// BCHG interrupts are generated
	USBHS_INTSTS1_BCHG_1 = 0x1
	// Position of DTCH field.
	USBHS_INTSTS1_DTCH_Pos = 0xc
	// Bit mask of DTCH field.
	USBHS_INTSTS1_DTCH_Msk = 0x1000
	// Bit DTCH.
	USBHS_INTSTS1_DTCH = 0x1000
	// DTCH interrupts are not generated
	USBHS_INTSTS1_DTCH_0 = 0x0
	// DTCH interrupts are generated
	USBHS_INTSTS1_DTCH_1 = 0x1
	// Position of ATTCH field.
	USBHS_INTSTS1_ATTCH_Pos = 0xb
	// Bit mask of ATTCH field.
	USBHS_INTSTS1_ATTCH_Msk = 0x800
	// Bit ATTCH.
	USBHS_INTSTS1_ATTCH = 0x800
	// ATTCH interrupts are not generated
	USBHS_INTSTS1_ATTCH_0 = 0x0
	// ATTCH interrupts are generated
	USBHS_INTSTS1_ATTCH_1 = 0x1
	// Position of L1RSMEND field.
	USBHS_INTSTS1_L1RSMEND_Pos = 0x9
	// Bit mask of L1RSMEND field.
	USBHS_INTSTS1_L1RSMEND_Msk = 0x200
	// Bit L1RSMEND.
	USBHS_INTSTS1_L1RSMEND = 0x200
	// L1RSMEND interrupts are not generated
	USBHS_INTSTS1_L1RSMEND_0 = 0x0
	// L1RSMEND interrupts are generated
	USBHS_INTSTS1_L1RSMEND_1 = 0x1
	// Position of LPMEND field.
	USBHS_INTSTS1_LPMEND_Pos = 0x8
	// Bit mask of LPMEND field.
	USBHS_INTSTS1_LPMEND_Msk = 0x100
	// Bit LPMEND.
	USBHS_INTSTS1_LPMEND = 0x100
	// LPMEND interrupts are not generated
	USBHS_INTSTS1_LPMEND_0 = 0x0
	// LPMEND interrupts are generated
	USBHS_INTSTS1_LPMEND_1 = 0x1
	// Position of EOFERR field.
	USBHS_INTSTS1_EOFERR_Pos = 0x6
	// Bit mask of EOFERR field.
	USBHS_INTSTS1_EOFERR_Msk = 0x40
	// Bit EOFERR.
	USBHS_INTSTS1_EOFERR = 0x40
	// EOFERR interrupts are not generated
	USBHS_INTSTS1_EOFERR_0 = 0x0
	// EOFERR interrupts are generated
	USBHS_INTSTS1_EOFERR_1 = 0x1
	// Position of SIGN field.
	USBHS_INTSTS1_SIGN_Pos = 0x5
	// Bit mask of SIGN field.
	USBHS_INTSTS1_SIGN_Msk = 0x20
	// Bit SIGN.
	USBHS_INTSTS1_SIGN = 0x20
	// SIGN interrupts are not generated
	USBHS_INTSTS1_SIGN_0 = 0x0
	// SIGN interrupts are generated
	USBHS_INTSTS1_SIGN_1 = 0x1
	// Position of SACK field.
	USBHS_INTSTS1_SACK_Pos = 0x4
	// Bit mask of SACK field.
	USBHS_INTSTS1_SACK_Msk = 0x10
	// Bit SACK.
	USBHS_INTSTS1_SACK = 0x10
	// SACK interrupts are not generated
	USBHS_INTSTS1_SACK_0 = 0x0
	// SACK interrupts are generated
	USBHS_INTSTS1_SACK_1 = 0x1
	// Position of PDDETINT field.
	USBHS_INTSTS1_PDDETINT_Pos = 0x0
	// Bit mask of PDDETINT field.
	USBHS_INTSTS1_PDDETINT_Msk = 0x1
	// Bit PDDETINT.
	USBHS_INTSTS1_PDDETINT = 0x1
	// PDDET interrupts are not generated
	USBHS_INTSTS1_PDDETINT_0 = 0x0
	// PDDET interrupts are generated
	USBHS_INTSTS1_PDDETINT_1 = 0x1

	// BRDYSTS: BRDY Interrupt Status Register
	// Position of PIPEBRDY field.
	USBHS_BRDYSTS_PIPEBRDY_Pos = 0x0
	// Bit mask of PIPEBRDY field.
	USBHS_BRDYSTS_PIPEBRDY_Msk = 0x3ff
	// Interrupts are not generated
	USBHS_BRDYSTS_PIPEBRDY_0 = 0x0
	// Interrupts are generated
	USBHS_BRDYSTS_PIPEBRDY_1 = 0x1

	// NRDYSTS: NRDY Interrupt Status Register
	// Position of PIPENRDY field.
	USBHS_NRDYSTS_PIPENRDY_Pos = 0x0
	// Bit mask of PIPENRDY field.
	USBHS_NRDYSTS_PIPENRDY_Msk = 0x3ff
	// Interrupts are not generated
	USBHS_NRDYSTS_PIPENRDY_0 = 0x0
	// Interrupts are generated
	USBHS_NRDYSTS_PIPENRDY_1 = 0x1

	// BEMPSTS: BEMP Interrupt Status Register
	// Position of PIPEBEMP field.
	USBHS_BEMPSTS_PIPEBEMP_Pos = 0x0
	// Bit mask of PIPEBEMP field.
	USBHS_BEMPSTS_PIPEBEMP_Msk = 0x3ff
	// Interrupts are not generated
	USBHS_BEMPSTS_PIPEBEMP_0 = 0x0
	// Interrupts are generated
	USBHS_BEMPSTS_PIPEBEMP_1 = 0x1

	// FRMNUM: Frame Number Register
	// Position of OVRN field.
	USBHS_FRMNUM_OVRN_Pos = 0xf
	// Bit mask of OVRN field.
	USBHS_FRMNUM_OVRN_Msk = 0x8000
	// Bit OVRN.
	USBHS_FRMNUM_OVRN = 0x8000
	// No error
	USBHS_FRMNUM_OVRN_0 = 0x0
	// An error occurred
	USBHS_FRMNUM_OVRN_1 = 0x1
	// Position of CRCE field.
	USBHS_FRMNUM_CRCE_Pos = 0xe
	// Bit mask of CRCE field.
	USBHS_FRMNUM_CRCE_Msk = 0x4000
	// Bit CRCE.
	USBHS_FRMNUM_CRCE = 0x4000
	// No error
	USBHS_FRMNUM_CRCE_0 = 0x0
	// An error occurred
	USBHS_FRMNUM_CRCE_1 = 0x1
	// Position of FRNM field.
	USBHS_FRMNUM_FRNM_Pos = 0x0
	// Bit mask of FRNM field.
	USBHS_FRMNUM_FRNM_Msk = 0x7ff

	// UFRMNUM: uFrame Number Register
	// Position of DVCHG field.
	USBHS_UFRMNUM_DVCHG_Pos = 0xf
	// Bit mask of DVCHG field.
	USBHS_UFRMNUM_DVCHG_Msk = 0x8000
	// Bit DVCHG.
	USBHS_UFRMNUM_DVCHG = 0x8000
	// Disables the writing to the USBADDR.STSRECOV0[2:0] bits and USBADDR.USBADDR[6:0].
	USBHS_UFRMNUM_DVCHG_0 = 0x0
	// Enables the writing to the USBADDR.STSRECOV0[2:0] bits and USBADDR.USBADDR[6:0].
	USBHS_UFRMNUM_DVCHG_1 = 0x1
	// Position of UFRNM field.
	USBHS_UFRMNUM_UFRNM_Pos = 0x0
	// Bit mask of UFRNM field.
	USBHS_UFRMNUM_UFRNM_Msk = 0x7

	// USBADDR: USB Address Register
	// Position of STSRECOV0 field.
	USBHS_USBADDR_STSRECOV0_Pos = 0x8
	// Bit mask of STSRECOV0 field.
	USBHS_USBADDR_STSRECOV0_Msk = 0x700
	// Return to the full-speed state(bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 001b (Default state)(function controller selected)
	USBHS_USBADDR_STSRECOV0_001 = 0x1
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 010b (Address state)(function controller selected)/ Return to the low-speed state (bitsDVSTCTR0.RHST[2:0] = 001b)(host controller is selected)
	USBHS_USBADDR_STSRECOV0_010 = 0x2
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 011b (Configured state)(function controller selected)
	USBHS_USBADDR_STSRECOV0_011 = 0x3
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b)(host controller selected)
	USBHS_USBADDR_STSRECOV0_100 = 0x4
	// Return to the high-speed state (bits DVSTCTR0.RHST[2:0] = 011b), bits INTSTS0.DVSQ[2:0] = 001b (Default state)(function controller selected)
	USBHS_USBADDR_STSRECOV0_101 = 0x5
	// Return to the high-speed state (bits DVSTCTR0.RHST[2:0] = 011b), bits INTSTS0.DVSQ[2:0] = 010b (Address state)(function controller selected)/ Return to the high-speed state (bits DVSTCTR0.RHST[2:0] = 011b)(host controller selected)
	USBHS_USBADDR_STSRECOV0_110 = 0x6
	// Return to the high-speed state (bits DVSTCTR0.RHST[2:0] = 011b), bits INTSTS0.DVSQ[2:0] = 011b (Configured state)(function controller selected)
	USBHS_USBADDR_STSRECOV0_111 = 0x7
	// Position of USBADDR field.
	USBHS_USBADDR_USBADDR_Pos = 0x0
	// Bit mask of USBADDR field.
	USBHS_USBADDR_USBADDR_Msk = 0x7f

	// USBREQ: USB Request Type Register
	// Position of BREQUEST field.
	USBHS_USBREQ_BREQUEST_Pos = 0x8
	// Bit mask of BREQUEST field.
	USBHS_USBREQ_BREQUEST_Msk = 0xff00
	// Position of BMREQUESTTYPE field.
	USBHS_USBREQ_BMREQUESTTYPE_Pos = 0x0
	// Bit mask of BMREQUESTTYPE field.
	USBHS_USBREQ_BMREQUESTTYPE_Msk = 0xff

	// USBVAL: USB Request Value Register
	// Position of WVALUE field.
	USBHS_USBVAL_WVALUE_Pos = 0x0
	// Bit mask of WVALUE field.
	USBHS_USBVAL_WVALUE_Msk = 0xffff

	// USBINDX: USB Request Index Register
	// Position of WINDEX field.
	USBHS_USBINDX_WINDEX_Pos = 0x0
	// Bit mask of WINDEX field.
	USBHS_USBINDX_WINDEX_Msk = 0xffff

	// USBLENG: USB Request Length Register
	// Position of WLENGTH field.
	USBHS_USBLENG_WLENGTH_Pos = 0x0
	// Bit mask of WLENGTH field.
	USBHS_USBLENG_WLENGTH_Msk = 0xffff

	// DCPCFG: DCP Configuration Register
	// Position of CNTMD field.
	USBHS_DCPCFG_CNTMD_Pos = 0x8
	// Bit mask of CNTMD field.
	USBHS_DCPCFG_CNTMD_Msk = 0x100
	// Bit CNTMD.
	USBHS_DCPCFG_CNTMD = 0x100
	// Non-continuous transfer mode
	USBHS_DCPCFG_CNTMD_0 = 0x0
	// Continuous transfer mode
	USBHS_DCPCFG_CNTMD_1 = 0x1
	// Position of SHTNAK field.
	USBHS_DCPCFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBHS_DCPCFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBHS_DCPCFG_SHTNAK = 0x80
	// The pipe remains open after transfer ends.
	USBHS_DCPCFG_SHTNAK_0 = 0x0
	// The pipe is blocked after transfer ends.
	USBHS_DCPCFG_SHTNAK_1 = 0x1
	// Position of DIR field.
	USBHS_DCPCFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBHS_DCPCFG_DIR_Msk = 0x10
	// Bit DIR.
	USBHS_DCPCFG_DIR = 0x10
	// Data receiving direction
	USBHS_DCPCFG_DIR_0 = 0x0
	// Data transmitting direction
	USBHS_DCPCFG_DIR_1 = 0x1

	// DCPMAXP: DCP Maximum Packet Size Register
	// Position of DEVSEL field.
	USBHS_DCPMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBHS_DCPMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBHS_DCPMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBHS_DCPMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBHS_DCPMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBHS_DCPMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBHS_DCPMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBHS_DCPMAXP_DEVSEL_0101 = 0x5
	// Position of MXPS field.
	USBHS_DCPMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBHS_DCPMAXP_MXPS_Msk = 0x7f

	// DCPCTR: DCP Control Register
	// Position of BSTS field.
	USBHS_DCPCTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBHS_DCPCTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBHS_DCPCTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBHS_DCPCTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBHS_DCPCTR_BSTS_1 = 0x1
	// Position of SUREQ field.
	USBHS_DCPCTR_SUREQ_Pos = 0xe
	// Bit mask of SUREQ field.
	USBHS_DCPCTR_SUREQ_Msk = 0x4000
	// Bit SUREQ.
	USBHS_DCPCTR_SUREQ = 0x4000
	// Writing is ignored.
	USBHS_DCPCTR_SUREQ_0 = 0x0
	// Transmits the setup packet.
	USBHS_DCPCTR_SUREQ_1 = 0x1
	// Position of CSCLR field.
	USBHS_DCPCTR_CSCLR_Pos = 0xd
	// Bit mask of CSCLR field.
	USBHS_DCPCTR_CSCLR_Msk = 0x2000
	// Bit CSCLR.
	USBHS_DCPCTR_CSCLR = 0x2000
	// Writing is ignored.
	USBHS_DCPCTR_CSCLR_0 = 0x0
	// Clears the CSSTS bit to 0.
	USBHS_DCPCTR_CSCLR_1 = 0x1
	// Position of CSSTS field.
	USBHS_DCPCTR_CSSTS_Pos = 0xc
	// Bit mask of CSSTS field.
	USBHS_DCPCTR_CSSTS_Msk = 0x1000
	// Bit CSSTS.
	USBHS_DCPCTR_CSSTS = 0x1000
	// START-SPLIT(SSPLIT) transaction processing is in progress or processing for devices that do not use Split Transaction is in progress.
	USBHS_DCPCTR_CSSTS_0 = 0x0
	// The CSPLIT transaction processing is in progress.
	USBHS_DCPCTR_CSSTS_1 = 0x1
	// Position of SUREQCLR field.
	USBHS_DCPCTR_SUREQCLR_Pos = 0xb
	// Bit mask of SUREQCLR field.
	USBHS_DCPCTR_SUREQCLR_Msk = 0x800
	// Bit SUREQCLR.
	USBHS_DCPCTR_SUREQCLR = 0x800
	// Writing is ignored.
	USBHS_DCPCTR_SUREQCLR_0 = 0x0
	// Clears the SUREQ bit to 0.
	USBHS_DCPCTR_SUREQCLR_1 = 0x1
	// Position of SQCLR field.
	USBHS_DCPCTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBHS_DCPCTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBHS_DCPCTR_SQCLR = 0x100
	// Writing is ignored.
	USBHS_DCPCTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBHS_DCPCTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBHS_DCPCTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBHS_DCPCTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBHS_DCPCTR_SQSET = 0x80
	// Writing is ignored.
	USBHS_DCPCTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBHS_DCPCTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBHS_DCPCTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBHS_DCPCTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBHS_DCPCTR_SQMON = 0x40
	// DATA0
	USBHS_DCPCTR_SQMON_0 = 0x0
	// DATA1
	USBHS_DCPCTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBHS_DCPCTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBHS_DCPCTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBHS_DCPCTR_PBUSY = 0x20
	// The relevant pipe is not used for the USB bus.
	USBHS_DCPCTR_PBUSY_0 = 0x0
	// The relevant pipe is in use for the USB bus.
	USBHS_DCPCTR_PBUSY_1 = 0x1
	// Position of PINGE field.
	USBHS_DCPCTR_PINGE_Pos = 0x4
	// Bit mask of PINGE field.
	USBHS_DCPCTR_PINGE_Msk = 0x10
	// Bit PINGE.
	USBHS_DCPCTR_PINGE = 0x10
	// Issuing PING token is disabled.
	USBHS_DCPCTR_PINGE_0 = 0x0
	// Normal PING operation
	USBHS_DCPCTR_PINGE_1 = 0x1
	// Position of CCPL field.
	USBHS_DCPCTR_CCPL_Pos = 0x2
	// Bit mask of CCPL field.
	USBHS_DCPCTR_CCPL_Msk = 0x4
	// Bit CCPL.
	USBHS_DCPCTR_CCPL = 0x4
	// Completion of control transfer is disabled.
	USBHS_DCPCTR_CCPL_0 = 0x0
	// Completion of control transfer is enabled.
	USBHS_DCPCTR_CCPL_1 = 0x1
	// Position of PID field.
	USBHS_DCPCTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBHS_DCPCTR_PID_Msk = 0x3
	// NAK response
	USBHS_DCPCTR_PID_00 = 0x0
	// BUF response (depending on buffer state)
	USBHS_DCPCTR_PID_01 = 0x1
	// STALL response
	USBHS_DCPCTR_PID_10 = 0x2
	// STALL response
	USBHS_DCPCTR_PID_11 = 0x3

	// PIPESEL: Pipe Window Select Register
	// Position of PIPESEL field.
	USBHS_PIPESEL_PIPESEL_Pos = 0x0
	// Bit mask of PIPESEL field.
	USBHS_PIPESEL_PIPESEL_Msk = 0xf
	// No pipe selected
	USBHS_PIPESEL_PIPESEL_0000 = 0x0
	// PIPE1
	USBHS_PIPESEL_PIPESEL_0001 = 0x1
	// PIPE2
	USBHS_PIPESEL_PIPESEL_0010 = 0x2
	// PIPE3
	USBHS_PIPESEL_PIPESEL_0011 = 0x3
	// PIPE4
	USBHS_PIPESEL_PIPESEL_0100 = 0x4
	// PIPE5
	USBHS_PIPESEL_PIPESEL_0101 = 0x5
	// PIPE6
	USBHS_PIPESEL_PIPESEL_0110 = 0x6
	// PIPE7
	USBHS_PIPESEL_PIPESEL_0111 = 0x7
	// PIPE8
	USBHS_PIPESEL_PIPESEL_1000 = 0x8
	// PIPE9
	USBHS_PIPESEL_PIPESEL_1001 = 0x9

	// PIPECFG: Pipe Configuration Register
	// Position of TYPE field.
	USBHS_PIPECFG_TYPE_Pos = 0xe
	// Bit mask of TYPE field.
	USBHS_PIPECFG_TYPE_Msk = 0xc000
	// Pipe not used
	USBHS_PIPECFG_TYPE_00 = 0x0
	// Bulk transfer
	USBHS_PIPECFG_TYPE_01 = 0x1
	// Interrupt transfer
	USBHS_PIPECFG_TYPE_10 = 0x2
	// Isochronous transfer
	USBHS_PIPECFG_TYPE_11 = 0x3
	// Position of BFRE field.
	USBHS_PIPECFG_BFRE_Pos = 0xa
	// Bit mask of BFRE field.
	USBHS_PIPECFG_BFRE_Msk = 0x400
	// Bit BFRE.
	USBHS_PIPECFG_BFRE = 0x400
	// BRDY interrupt upon transmitting or receiving data
	USBHS_PIPECFG_BFRE_0 = 0x0
	// BRDY interrupt upon completion of reading data
	USBHS_PIPECFG_BFRE_1 = 0x1
	// Position of DBLB field.
	USBHS_PIPECFG_DBLB_Pos = 0x9
	// Bit mask of DBLB field.
	USBHS_PIPECFG_DBLB_Msk = 0x200
	// Bit DBLB.
	USBHS_PIPECFG_DBLB = 0x200
	// Single buffer
	USBHS_PIPECFG_DBLB_0 = 0x0
	// Double buffer
	USBHS_PIPECFG_DBLB_1 = 0x1
	// Position of CNTMD field.
	USBHS_PIPECFG_CNTMD_Pos = 0x8
	// Bit mask of CNTMD field.
	USBHS_PIPECFG_CNTMD_Msk = 0x100
	// Bit CNTMD.
	USBHS_PIPECFG_CNTMD = 0x100
	// Discontinuous transfer mode
	USBHS_PIPECFG_CNTMD_0 = 0x0
	// Continuous transfer mode
	USBHS_PIPECFG_CNTMD_1 = 0x1
	// Position of SHTNAK field.
	USBHS_PIPECFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBHS_PIPECFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBHS_PIPECFG_SHTNAK = 0x80
	// The pipe is continued at the end of transfer.
	USBHS_PIPECFG_SHTNAK_0 = 0x0
	// The pipe is disabled at the end of transfer.
	USBHS_PIPECFG_SHTNAK_1 = 0x1
	// Position of DIR field.
	USBHS_PIPECFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBHS_PIPECFG_DIR_Msk = 0x10
	// Bit DIR.
	USBHS_PIPECFG_DIR = 0x10
	// Receiving direction
	USBHS_PIPECFG_DIR_0 = 0x0
	// Transmitting direction
	USBHS_PIPECFG_DIR_1 = 0x1
	// Position of EPNUM field.
	USBHS_PIPECFG_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USBHS_PIPECFG_EPNUM_Msk = 0xf
	// the selected pipe is not used
	USBHS_PIPECFG_EPNUM_000 = 0x0

	// PIPEBUF: Pipe Buffer Register
	// Position of BUFSIZE field.
	USBHS_PIPEBUF_BUFSIZE_Pos = 0xa
	// Bit mask of BUFSIZE field.
	USBHS_PIPEBUF_BUFSIZE_Msk = 0x7c00
	// Position of BUFNMB field.
	USBHS_PIPEBUF_BUFNMB_Pos = 0x0
	// Bit mask of BUFNMB field.
	USBHS_PIPEBUF_BUFNMB_Msk = 0xff

	// PIPEMAXP: Pipe Maximum Packet Size Register
	// Position of DEVSEL field.
	USBHS_PIPEMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBHS_PIPEMAXP_DEVSEL_Msk = 0xf000
	// Position of MXPS field.
	USBHS_PIPEMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBHS_PIPEMAXP_MXPS_Msk = 0x7ff

	// PIPEPERI: Pipe Cycle Control Register
	// Position of IFIS field.
	USBHS_PIPEPERI_IFIS_Pos = 0xc
	// Bit mask of IFIS field.
	USBHS_PIPEPERI_IFIS_Msk = 0x1000
	// Bit IFIS.
	USBHS_PIPEPERI_IFIS = 0x1000
	// The buffer is not flushed.
	USBHS_PIPEPERI_IFIS_0 = 0x0
	// The buffer is flushed.
	USBHS_PIPEPERI_IFIS_1 = 0x1
	// Position of IITV field.
	USBHS_PIPEPERI_IITV_Pos = 0x0
	// Bit mask of IITV field.
	USBHS_PIPEPERI_IITV_Msk = 0x7

	// PIPE1CTR: PIPE Control Register
	// Position of BSTS field.
	USBHS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBHS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBHS_PIPECTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBHS_PIPECTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBHS_PIPECTR_BSTS_1 = 0x1
	// Position of INBUFM field.
	USBHS_PIPECTR_INBUFM_Pos = 0xe
	// Bit mask of INBUFM field.
	USBHS_PIPECTR_INBUFM_Msk = 0x4000
	// Bit INBUFM.
	USBHS_PIPECTR_INBUFM = 0x4000
	// No transmittable data is present in the FIFO buffer.
	USBHS_PIPECTR_INBUFM_0 = 0x0
	// Transmittable data is present in the FIFO buffer.
	USBHS_PIPECTR_INBUFM_1 = 0x1
	// Position of CSCLR field.
	USBHS_PIPECTR_CSCLR_Pos = 0xd
	// Bit mask of CSCLR field.
	USBHS_PIPECTR_CSCLR_Msk = 0x2000
	// Bit CSCLR.
	USBHS_PIPECTR_CSCLR = 0x2000
	// Writing is disabled.
	USBHS_PIPECTR_CSCLR_0 = 0x0
	// The CSSTS bit is cleared.
	USBHS_PIPECTR_CSCLR_1 = 0x1
	// Position of CSSTS field.
	USBHS_PIPECTR_CSSTS_Pos = 0xc
	// Bit mask of CSSTS field.
	USBHS_PIPECTR_CSSTS_Msk = 0x1000
	// Bit CSSTS.
	USBHS_PIPECTR_CSSTS = 0x1000
	// SSplit Transaction processing is in progress or transfer without Split Transaction is in progress.
	USBHS_PIPECTR_CSSTS_0 = 0x0
	// CSplit Transaction processing is in progress.
	USBHS_PIPECTR_CSSTS_1 = 0x1
	// Position of ATREPM field.
	USBHS_PIPECTR_ATREPM_Pos = 0xa
	// Bit mask of ATREPM field.
	USBHS_PIPECTR_ATREPM_Msk = 0x400
	// Bit ATREPM.
	USBHS_PIPECTR_ATREPM = 0x400
	// Auto response mode is disabled.
	USBHS_PIPECTR_ATREPM_0 = 0x0
	// Auto response mode is enabled (Transmission: zero-length packet response, Reception: NAK response and NRDY interrupt)
	USBHS_PIPECTR_ATREPM_1 = 0x1
	// Position of ACLRM field.
	USBHS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBHS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBHS_PIPECTR_ACLRM = 0x200
	// Disabled
	USBHS_PIPECTR_ACLRM_0 = 0x0
	// Enabled (all buffers are initialized)
	USBHS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBHS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBHS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBHS_PIPECTR_SQCLR = 0x100
	// Writing is ignored.
	USBHS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBHS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBHS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBHS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBHS_PIPECTR_SQSET = 0x80
	// Writing is ignored.
	USBHS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBHS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBHS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBHS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBHS_PIPECTR_SQMON = 0x40
	// DATA0
	USBHS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBHS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBHS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBHS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBHS_PIPECTR_PBUSY = 0x20
	// The relevant pipe is not used for the USB bus.
	USBHS_PIPECTR_PBUSY_0 = 0x0
	// The relevant pipe is in use for the USB bus.
	USBHS_PIPECTR_PBUSY_1 = 0x1
	// Position of PID field.
	USBHS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBHS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBHS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on buffer state)
	USBHS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBHS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBHS_PIPECTR_PID_11 = 0x3

	// PIPE1TRE: PIPE Transaction Counter Enable Register
	// Position of TRENB field.
	USBHS_PIPETRE_TRENB_Pos = 0x9
	// Bit mask of TRENB field.
	USBHS_PIPETRE_TRENB_Msk = 0x200
	// Bit TRENB.
	USBHS_PIPETRE_TRENB = 0x200
	// The transaction counter function is disabled.
	USBHS_PIPETRE_TRENB_0 = 0x0
	// The transaction counter function is enabled.
	USBHS_PIPETRE_TRENB_1 = 0x1
	// Position of TRCLR field.
	USBHS_PIPETRE_TRCLR_Pos = 0x8
	// Bit mask of TRCLR field.
	USBHS_PIPETRE_TRCLR_Msk = 0x100
	// Bit TRCLR.
	USBHS_PIPETRE_TRCLR = 0x100
	// Invalid
	USBHS_PIPETRE_TRCLR_0 = 0x0
	// The current counter value is cleared.
	USBHS_PIPETRE_TRCLR_1 = 0x1

	// PIPE1TRN: PIPE Transaction Counter Register
	// Position of TRNCNT field.
	USBHS_PIPETRN_TRNCNT_Pos = 0x0
	// Bit mask of TRNCNT field.
	USBHS_PIPETRN_TRNCNT_Msk = 0xffff

	// DEVADD0: Device Address Configuration Register
	// Position of UPPHUB field.
	USBHS_DEVADD_UPPHUB_Pos = 0xb
	// Bit mask of UPPHUB field.
	USBHS_DEVADD_UPPHUB_Msk = 0x7800
	// Directly connected to the port of the USBHS.
	USBHS_DEVADD_UPPHUB_0000 = 0x0
	// Position of HUBPORT field.
	USBHS_DEVADD_HUBPORT_Pos = 0x8
	// Bit mask of HUBPORT field.
	USBHS_DEVADD_HUBPORT_Msk = 0x700
	// Directly connected to the port of the USBHS.
	USBHS_DEVADD_HUBPORT_000 = 0x0
	// Position of USBSPD field.
	USBHS_DEVADD_USBSPD_Pos = 0x6
	// Bit mask of USBSPD field.
	USBHS_DEVADD_USBSPD_Msk = 0xc0
	// DEVADDx is not used.
	USBHS_DEVADD_USBSPD_00 = 0x0
	// Low speed
	USBHS_DEVADD_USBSPD_01 = 0x1
	// Full speed
	USBHS_DEVADD_USBSPD_10 = 0x2
	// High speed
	USBHS_DEVADD_USBSPD_11 = 0x3

	// DEVADDA: Device Address Configuration Register A
	// Position of UPPHUB field.
	USBHS_DEVADDA_UPPHUB_Pos = 0xb
	// Bit mask of UPPHUB field.
	USBHS_DEVADDA_UPPHUB_Msk = 0x7800
	// Directly connected to the port of the USBHS.
	USBHS_DEVADDA_UPPHUB_0000 = 0x0
	// Position of HUBPORT field.
	USBHS_DEVADDA_HUBPORT_Pos = 0x8
	// Bit mask of HUBPORT field.
	USBHS_DEVADDA_HUBPORT_Msk = 0x700
	// Directly connected to the port of the USBHS.
	USBHS_DEVADDA_HUBPORT_000 = 0x0
	// Position of USBSPD field.
	USBHS_DEVADDA_USBSPD_Pos = 0x6
	// Bit mask of USBSPD field.
	USBHS_DEVADDA_USBSPD_Msk = 0xc0
	// DEVADDA is not used.
	USBHS_DEVADDA_USBSPD_00 = 0x0
	// Low speed
	USBHS_DEVADDA_USBSPD_01 = 0x1
	// Full speed
	USBHS_DEVADDA_USBSPD_10 = 0x2
	// High speed
	USBHS_DEVADDA_USBSPD_11 = 0x3

	// LPCTRL: Low Power Control Register
	// Position of HWUPM field.
	USBHS_LPCTRL_HWUPM_Pos = 0x7
	// Bit mask of HWUPM field.
	USBHS_LPCTRL_HWUPM_Msk = 0x80
	// Bit HWUPM.
	USBHS_LPCTRL_HWUPM = 0x80
	// Hardware does not recover while CPU clock inactive
	USBHS_LPCTRL_HWUPM_0 = 0x0
	// Hardware recovers while CPU clock inactive.
	USBHS_LPCTRL_HWUPM_1 = 0x1

	// LPSTS: Low Power Status Register
	// Position of SUSPENDM field.
	USBHS_LPSTS_SUSPENDM_Pos = 0xe
	// Bit mask of SUSPENDM field.
	USBHS_LPSTS_SUSPENDM_Msk = 0x4000
	// Bit SUSPENDM.
	USBHS_LPSTS_SUSPENDM = 0x4000
	// UTMI suspension mode
	USBHS_LPSTS_SUSPENDM_0 = 0x0
	// UTMI normal mode
	USBHS_LPSTS_SUSPENDM_1 = 0x1

	// BCCTRL: Battery Charging Control Register
	// Position of PDDETSTS field.
	USBHS_BCCTRL_PDDETSTS_Pos = 0x9
	// Bit mask of PDDETSTS field.
	USBHS_BCCTRL_PDDETSTS_Msk = 0x200
	// Bit PDDETSTS.
	USBHS_BCCTRL_PDDETSTS = 0x200
	// The PDDET pin is at low level.
	USBHS_BCCTRL_PDDETSTS_0 = 0x0
	// The PDDET pin is at high level.
	USBHS_BCCTRL_PDDETSTS_1 = 0x1
	// Position of CHGDETSTS field.
	USBHS_BCCTRL_CHGDETSTS_Pos = 0x8
	// Bit mask of CHGDETSTS field.
	USBHS_BCCTRL_CHGDETSTS_Msk = 0x100
	// Bit CHGDETSTS.
	USBHS_BCCTRL_CHGDETSTS = 0x100
	// The CHGDET pin is at low level.
	USBHS_BCCTRL_CHGDETSTS_0 = 0x0
	// The CHGDET pin is at high level.
	USBHS_BCCTRL_CHGDETSTS_1 = 0x1
	// Position of DCPMODE field.
	USBHS_BCCTRL_DCPMODE_Pos = 0x5
	// Bit mask of DCPMODE field.
	USBHS_BCCTRL_DCPMODE_Msk = 0x20
	// Bit DCPMODE.
	USBHS_BCCTRL_DCPMODE = 0x20
	// The RDCP_DAT resistor is disabled
	USBHS_BCCTRL_DCPMODE_0 = 0x0
	// The RDCP_DAT resistor is enabled.
	USBHS_BCCTRL_DCPMODE_1 = 0x1
	// Position of VDMSRCE field.
	USBHS_BCCTRL_VDMSRCE_Pos = 0x4
	// Bit mask of VDMSRCE field.
	USBHS_BCCTRL_VDMSRCE_Msk = 0x10
	// Bit VDMSRCE.
	USBHS_BCCTRL_VDMSRCE = 0x10
	// The VDM_SRC circuit is disabled. (Initial value)
	USBHS_BCCTRL_VDMSRCE_0 = 0x0
	// The VDM_SRC circuit is enabled.
	USBHS_BCCTRL_VDMSRCE_1 = 0x1
	// Position of IDPSINKE field.
	USBHS_BCCTRL_IDPSINKE_Pos = 0x3
	// Bit mask of IDPSINKE field.
	USBHS_BCCTRL_IDPSINKE_Msk = 0x8
	// Bit IDPSINKE.
	USBHS_BCCTRL_IDPSINKE = 0x8
	// The IDP_SINK circuit is disabled. (Initial value)
	USBHS_BCCTRL_IDPSINKE_0 = 0x0
	// The IDP_SINK circuit is enabled.
	USBHS_BCCTRL_IDPSINKE_1 = 0x1
	// Position of VDPSRCE field.
	USBHS_BCCTRL_VDPSRCE_Pos = 0x2
	// Bit mask of VDPSRCE field.
	USBHS_BCCTRL_VDPSRCE_Msk = 0x4
	// Bit VDPSRCE.
	USBHS_BCCTRL_VDPSRCE = 0x4
	// The VDP_SRC circuit is disabled. (Initial value)
	USBHS_BCCTRL_VDPSRCE_0 = 0x0
	// The VDP_SRC circuit is enabled.
	USBHS_BCCTRL_VDPSRCE_1 = 0x1
	// Position of IDMSINKE field.
	USBHS_BCCTRL_IDMSINKE_Pos = 0x1
	// Bit mask of IDMSINKE field.
	USBHS_BCCTRL_IDMSINKE_Msk = 0x2
	// Bit IDMSINKE.
	USBHS_BCCTRL_IDMSINKE = 0x2
	// The IDM_SINK circuit is disabled. (Initial value)
	USBHS_BCCTRL_IDMSINKE_0 = 0x0
	// The IDM_SINK circuit is enabled.
	USBHS_BCCTRL_IDMSINKE_1 = 0x1
	// Position of IDPSRCE field.
	USBHS_BCCTRL_IDPSRCE_Pos = 0x0
	// Bit mask of IDPSRCE field.
	USBHS_BCCTRL_IDPSRCE_Msk = 0x1
	// Bit IDPSRCE.
	USBHS_BCCTRL_IDPSRCE = 0x1
	// The IDP_SRC circuit is disabled. (Initial value)
	USBHS_BCCTRL_IDPSRCE_0 = 0x0
	// The IDP_SRC circuit is enabled.
	USBHS_BCCTRL_IDPSRCE_1 = 0x1

	// PL1CTRL1: Function L1 Control Register 1
	// Position of L1EXTMD field.
	USBHS_PL1CTRL1_L1EXTMD_Pos = 0xe
	// Bit mask of L1EXTMD field.
	USBHS_PL1CTRL1_L1EXTMD_Msk = 0x4000
	// Bit L1EXTMD.
	USBHS_PL1CTRL1_L1EXTMD = 0x4000
	// SUSPENDM is not set by hardware when Host K is received.
	USBHS_PL1CTRL1_L1EXTMD_0 = 0x0
	// SUSPENDM is set by hardware when Host K is received.
	USBHS_PL1CTRL1_L1EXTMD_1 = 0x1
	// Position of HIRDTHR field.
	USBHS_PL1CTRL1_HIRDTHR_Pos = 0x8
	// Bit mask of HIRDTHR field.
	USBHS_PL1CTRL1_HIRDTHR_Msk = 0xf00
	// Position of DVSQ field.
	USBHS_PL1CTRL1_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBHS_PL1CTRL1_DVSQ_Msk = 0xf0
	// Powered state
	USBHS_PL1CTRL1_DVSQ_0000 = 0x0
	// Default state
	USBHS_PL1CTRL1_DVSQ_0001 = 0x1
	// Address state
	USBHS_PL1CTRL1_DVSQ_0010 = 0x2
	// Configured state
	USBHS_PL1CTRL1_DVSQ_0011 = 0x3
	// Suspended state
	USBHS_PL1CTRL1_DVSQ_0100 = 0x4
	// Suspended state
	USBHS_PL1CTRL1_DVSQ_0101 = 0x5
	// Suspended state
	USBHS_PL1CTRL1_DVSQ_0110 = 0x6
	// Suspended state
	USBHS_PL1CTRL1_DVSQ_0111 = 0x7
	// L1 state
	USBHS_PL1CTRL1_DVSQ_1000 = 0x8
	// L1 state
	USBHS_PL1CTRL1_DVSQ_1001 = 0x9
	// L1 state
	USBHS_PL1CTRL1_DVSQ_1010 = 0xa
	// L1 state
	USBHS_PL1CTRL1_DVSQ_1011 = 0xb
	// Position of L1NEGOMD field.
	USBHS_PL1CTRL1_L1NEGOMD_Pos = 0x3
	// Bit mask of L1NEGOMD field.
	USBHS_PL1CTRL1_L1NEGOMD_Msk = 0x8
	// Bit L1NEGOMD.
	USBHS_PL1CTRL1_L1NEGOMD = 0x8
	// When receive HIRD is larger than HIRDTHR[3:0], ACK response is returned. In other cases (including HIRD = HIRDTHR[3:0]), NYET response is returned.
	USBHS_PL1CTRL1_L1NEGOMD_0 = 0x0
	// When receive HIRD is smaller than HIRDTHR[3:0], ACK response is returned. In other cases (including HIRD = HIRDTHR[3:0]), NYET response is returned.
	USBHS_PL1CTRL1_L1NEGOMD_1 = 0x1
	// Position of L1RESPMD field.
	USBHS_PL1CTRL1_L1RESPMD_Pos = 0x1
	// Bit mask of L1RESPMD field.
	USBHS_PL1CTRL1_L1RESPMD_Msk = 0x6
	// NYET
	USBHS_PL1CTRL1_L1RESPMD_00 = 0x0
	// ACK
	USBHS_PL1CTRL1_L1RESPMD_01 = 0x1
	// STALL
	USBHS_PL1CTRL1_L1RESPMD_10 = 0x2
	// According to the L1NEGOMD bit
	USBHS_PL1CTRL1_L1RESPMD_11 = 0x3
	// Position of L1RESPEN field.
	USBHS_PL1CTRL1_L1RESPEN_Pos = 0x0
	// Bit mask of L1RESPEN field.
	USBHS_PL1CTRL1_L1RESPEN_Msk = 0x1
	// Bit L1RESPEN.
	USBHS_PL1CTRL1_L1RESPEN = 0x1
	// LPM is not supported.
	USBHS_PL1CTRL1_L1RESPEN_0 = 0x0
	// LPM is supported.
	USBHS_PL1CTRL1_L1RESPEN_1 = 0x1

	// PL1CTRL2: Function L1 Control Register 2
	// Position of RWEMON field.
	USBHS_PL1CTRL2_RWEMON_Pos = 0xc
	// Bit mask of RWEMON field.
	USBHS_PL1CTRL2_RWEMON_Msk = 0x1000
	// Bit RWEMON.
	USBHS_PL1CTRL2_RWEMON = 0x1000
	// The RWE bit value of the LPM token received last is reflected.
	USBHS_PL1CTRL2_RWEMON_0 = 0x0
	// The RWE bit value of the LPM token received last is reflected.
	USBHS_PL1CTRL2_RWEMON_1 = 0x1
	// Position of HIRDMON field.
	USBHS_PL1CTRL2_HIRDMON_Pos = 0x8
	// Bit mask of HIRDMON field.
	USBHS_PL1CTRL2_HIRDMON_Msk = 0xf00
	// The HIRD field value of the LPM token received last is reflected.
	USBHS_PL1CTRL2_HIRDMON_0 = 0x0
	// The HIRD field value of the LPM token received last is reflected.
	USBHS_PL1CTRL2_HIRDMON_1 = 0x1

	// HL1CTRL1: Host L1 Control Register 1
	// Position of L1STATUS field.
	USBHS_HL1CTRL1_L1STATUS_Pos = 0x1
	// Bit mask of L1STATUS field.
	USBHS_HL1CTRL1_L1STATUS_Msk = 0x6
	// ACK received
	USBHS_HL1CTRL1_L1STATUS_00 = 0x0
	// NYET received
	USBHS_HL1CTRL1_L1STATUS_01 = 0x1
	// STALL received
	USBHS_HL1CTRL1_L1STATUS_10 = 0x2
	// Transaction error
	USBHS_HL1CTRL1_L1STATUS_11 = 0x3
	// Position of L1REQ field.
	USBHS_HL1CTRL1_L1REQ_Pos = 0x0
	// Bit mask of L1REQ field.
	USBHS_HL1CTRL1_L1REQ_Msk = 0x1
	// Bit L1REQ.
	USBHS_HL1CTRL1_L1REQ = 0x1
	// This bit is cleared to 0 by hardware when the LPM transaction is completed.
	USBHS_HL1CTRL1_L1REQ_0 = 0x0
	// Set this bit to 1 when requesting a transition to the L1 state.
	USBHS_HL1CTRL1_L1REQ_1 = 0x1

	// HL1CTRL2: Host L1 Control Register 2
	// Position of BESL field.
	USBHS_HL1CTRL2_BESL_Pos = 0xf
	// Bit mask of BESL field.
	USBHS_HL1CTRL2_BESL_Msk = 0x8000
	// Bit BESL.
	USBHS_HL1CTRL2_BESL = 0x8000
	// Position of L1RWE field.
	USBHS_HL1CTRL2_L1RWE_Pos = 0xc
	// Bit mask of L1RWE field.
	USBHS_HL1CTRL2_L1RWE_Msk = 0x1000
	// Bit L1RWE.
	USBHS_HL1CTRL2_L1RWE = 0x1000
	// Position of HIRD field.
	USBHS_HL1CTRL2_HIRD_Pos = 0x8
	// Bit mask of HIRD field.
	USBHS_HL1CTRL2_HIRD_Msk = 0xf00
	// 50 us(Setting prohibited(BESL = 0)) / 75 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0000 = 0x0
	// 125 us(BESL = 0) / 100 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0001 = 0x1
	// 200 us(BESL = 0) / 150 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0010 = 0x2
	// 275 us(BESL = 0) / 250 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0011 = 0x3
	// 350 us(BESL = 0) / 350 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0100 = 0x4
	// 425 us(BESL = 0) / 450 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0101 = 0x5
	// 500 us(BESL = 0) / 950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0110 = 0x6
	// 575 us(BESL = 0) / 1950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_0111 = 0x7
	// 650 us(BESL = 0) / 2950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1000 = 0x8
	// 725 us(BESL = 0) / 3950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1001 = 0x9
	// 800 us(BESL = 0) / 4950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1010 = 0xa
	// 875 us(BESL = 0) / 5950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1011 = 0xb
	// 950 us(BESL = 0) / 6950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1100 = 0xc
	// 1025 us(Setting prohibited(BESL = 0)) / 7950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1101 = 0xd
	// 1100 us(Setting prohibited(BESL = 0)) / 8950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1110 = 0xe
	// 1175 us(Setting prohibited(BESL = 0)) / 9950 us(BESL = 1)
	USBHS_HL1CTRL2_HIRD_1111 = 0xf
	// Position of L1ADDR field.
	USBHS_HL1CTRL2_L1ADDR_Pos = 0x0
	// Bit mask of L1ADDR field.
	USBHS_HL1CTRL2_L1ADDR_Msk = 0xf

	// DPUSR0R: Deep Standby USB Transceiver Control/Pin Monitor Register
	// Position of DVBSTSHM field.
	USBHS_DPUSR0R_DVBSTSHM_Pos = 0x17
	// Bit mask of DVBSTSHM field.
	USBHS_DPUSR0R_DVBSTSHM_Msk = 0x800000
	// Bit DVBSTSHM.
	USBHS_DPUSR0R_DVBSTSHM = 0x800000
	// Position of DOVCBHM field.
	USBHS_DPUSR0R_DOVCBHM_Pos = 0x15
	// Bit mask of DOVCBHM field.
	USBHS_DPUSR0R_DOVCBHM_Msk = 0x200000
	// Bit DOVCBHM.
	USBHS_DPUSR0R_DOVCBHM = 0x200000
	// Position of DOVCAHM field.
	USBHS_DPUSR0R_DOVCAHM_Pos = 0x14
	// Bit mask of DOVCAHM field.
	USBHS_DPUSR0R_DOVCAHM_Msk = 0x100000
	// Bit DOVCAHM.
	USBHS_DPUSR0R_DOVCAHM = 0x100000

	// DPUSR1R: Deep Standby USB Suspend/Resume Interrupt Register
	// Position of DVBSTSH field.
	USBHS_DPUSR1R_DVBSTSH_Pos = 0x17
	// Bit mask of DVBSTSH field.
	USBHS_DPUSR1R_DVBSTSH_Msk = 0x800000
	// Bit DVBSTSH.
	USBHS_DPUSR1R_DVBSTSH = 0x800000
	// Indicates deep software standby mode
	USBHS_DPUSR1R_DVBSTSH_0 = 0x0
	// Indicates return from deep software standby mode
	USBHS_DPUSR1R_DVBSTSH_1 = 0x1
	// Position of DOVCBH field.
	USBHS_DPUSR1R_DOVCBH_Pos = 0x15
	// Bit mask of DOVCBH field.
	USBHS_DPUSR1R_DOVCBH_Msk = 0x200000
	// Bit DOVCBH.
	USBHS_DPUSR1R_DOVCBH = 0x200000
	// Indicates deep software standby mode
	USBHS_DPUSR1R_DOVCBH_0 = 0x0
	// Indicates return from deep software standby mode
	USBHS_DPUSR1R_DOVCBH_1 = 0x1
	// Position of DOVCAH field.
	USBHS_DPUSR1R_DOVCAH_Pos = 0x14
	// Bit mask of DOVCAH field.
	USBHS_DPUSR1R_DOVCAH_Msk = 0x100000
	// Bit DOVCAH.
	USBHS_DPUSR1R_DOVCAH = 0x100000
	// Indicates deep software standby mode
	USBHS_DPUSR1R_DOVCAH_0 = 0x0
	// Indicates return from deep software standby mode
	USBHS_DPUSR1R_DOVCAH_1 = 0x1
	// Position of DVBSTSHE field.
	USBHS_DPUSR1R_DVBSTSHE_Pos = 0x7
	// Bit mask of DVBSTSHE field.
	USBHS_DPUSR1R_DVBSTSHE_Msk = 0x80
	// Bit DVBSTSHE.
	USBHS_DPUSR1R_DVBSTSHE = 0x80
	// Disables return from deep software standby mode
	USBHS_DPUSR1R_DVBSTSHE_0 = 0x0
	// Enables return from deep software standby mode
	USBHS_DPUSR1R_DVBSTSHE_1 = 0x1
	// Position of DOVCBHE field.
	USBHS_DPUSR1R_DOVCBHE_Pos = 0x5
	// Bit mask of DOVCBHE field.
	USBHS_DPUSR1R_DOVCBHE_Msk = 0x20
	// Bit DOVCBHE.
	USBHS_DPUSR1R_DOVCBHE = 0x20
	// Disables return from deep software standby mode
	USBHS_DPUSR1R_DOVCBHE_0 = 0x0
	// Enables return from deep software standby mode
	USBHS_DPUSR1R_DOVCBHE_1 = 0x1
	// Position of DOVCAHE field.
	USBHS_DPUSR1R_DOVCAHE_Pos = 0x4
	// Bit mask of DOVCAHE field.
	USBHS_DPUSR1R_DOVCAHE_Msk = 0x10
	// Bit DOVCAHE.
	USBHS_DPUSR1R_DOVCAHE = 0x10
	// Disables return from deep software standby mode
	USBHS_DPUSR1R_DOVCAHE_0 = 0x0
	// Enables return from deep software standby mode
	USBHS_DPUSR1R_DOVCAHE_1 = 0x1

	// DPUSR2R: Deep Standby USB Suspend/Resume Interrupt Register
	// Position of DMINTE field.
	USBHS_DPUSR2R_DMINTE_Pos = 0x9
	// Bit mask of DMINTE field.
	USBHS_DPUSR2R_DMINTE_Msk = 0x200
	// Bit DMINTE.
	USBHS_DPUSR2R_DMINTE = 0x200
	// Disables return from deep software standby mode
	USBHS_DPUSR2R_DMINTE_0 = 0x0
	// Enables return from deep software standby mode
	USBHS_DPUSR2R_DMINTE_1 = 0x1
	// Position of DPINTE field.
	USBHS_DPUSR2R_DPINTE_Pos = 0x8
	// Bit mask of DPINTE field.
	USBHS_DPUSR2R_DPINTE_Msk = 0x100
	// Bit DPINTE.
	USBHS_DPUSR2R_DPINTE = 0x100
	// Disables return from deep software standby mode
	USBHS_DPUSR2R_DPINTE_0 = 0x0
	// Enables return from deep software standby mode
	USBHS_DPUSR2R_DPINTE_1 = 0x1
	// Position of DMVAL field.
	USBHS_DPUSR2R_DMVAL_Pos = 0x5
	// Bit mask of DMVAL field.
	USBHS_DPUSR2R_DMVAL_Msk = 0x20
	// Bit DMVAL.
	USBHS_DPUSR2R_DMVAL = 0x20
	// Position of DPVAL field.
	USBHS_DPUSR2R_DPVAL_Pos = 0x4
	// Bit mask of DPVAL field.
	USBHS_DPUSR2R_DPVAL_Msk = 0x10
	// Bit DPVAL.
	USBHS_DPUSR2R_DPVAL = 0x10
	// Position of DMINT field.
	USBHS_DPUSR2R_DMINT_Pos = 0x1
	// Bit mask of DMINT field.
	USBHS_DPUSR2R_DMINT_Msk = 0x2
	// Bit DMINT.
	USBHS_DPUSR2R_DMINT = 0x2
	// Indicates deep software standby mode
	USBHS_DPUSR2R_DMINT_0 = 0x0
	// Indicates return from deep software standby mode
	USBHS_DPUSR2R_DMINT_1 = 0x1
	// Position of DPINT field.
	USBHS_DPUSR2R_DPINT_Pos = 0x0
	// Bit mask of DPINT field.
	USBHS_DPUSR2R_DPINT_Msk = 0x1
	// Bit DPINT.
	USBHS_DPUSR2R_DPINT = 0x1
	// Indicates deep software standby mode
	USBHS_DPUSR2R_DPINT_0 = 0x0
	// Indicates return from deep software standby mode
	USBHS_DPUSR2R_DPINT_1 = 0x1

	// DPUSRCR: Deep Standby USB Suspend/Resume Command Register
	// Position of FIXPHYPD field.
	USBHS_DPUSRCR_FIXPHYPD_Pos = 0x1
	// Bit mask of FIXPHYPD field.
	USBHS_DPUSRCR_FIXPHYPD_Msk = 0x2
	// Bit FIXPHYPD.
	USBHS_DPUSRCR_FIXPHYPD = 0x2
	// Normal mode
	USBHS_DPUSRCR_FIXPHYPD_0 = 0x0
	// Go to/Return from deep software standby mode
	USBHS_DPUSRCR_FIXPHYPD_1 = 0x1
	// Position of FIXPHY field.
	USBHS_DPUSRCR_FIXPHY_Pos = 0x0
	// Bit mask of FIXPHY field.
	USBHS_DPUSRCR_FIXPHY_Msk = 0x1
	// Bit FIXPHY.
	USBHS_DPUSRCR_FIXPHY = 0x1
	// Normal mode
	USBHS_DPUSRCR_FIXPHY_0 = 0x0
	// Go to/Return from deep software standby mode
	USBHS_DPUSRCR_FIXPHY_1 = 0x1
)

// Constants for SCI0: Serial Communication Interface 0
const (
	// SMR: Serial Mode Register (SCMR.SMIF = 0)
	// Position of CM field.
	SCI0_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI0_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI0_SMR_CM = 0x80
	// Asynchronous mode or simple I2C mode
	SCI0_SMR_CM_0 = 0x0
	// Clock synchronous mode
	SCI0_SMR_CM_1 = 0x1
	// Position of CHR field.
	SCI0_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI0_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI0_SMR_CHR = 0x40
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 8bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_0 = 0x0
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 7bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_1 = 0x1
	// Position of PE field.
	SCI0_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_PE = 0x20
	// Parity bit addition is not performed (transmitting) / Parity bit checking is not performed ( receiving )
	SCI0_SMR_PE_0 = 0x0
	// The parity bit is added (transmitting) / The parity bit is checked (receiving)
	SCI0_SMR_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_PM = 0x10
	// Selects even parity
	SCI0_SMR_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_PM_1 = 0x1
	// Position of STOP field.
	SCI0_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI0_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI0_SMR_STOP = 0x8
	// 1 stop bit
	SCI0_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI0_SMR_STOP_1 = 0x1
	// Position of MP field.
	SCI0_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI0_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI0_SMR_MP = 0x4
	// Multi-processor communications function is disabled
	SCI0_SMR_MP_0 = 0x0
	// Multi-processor communications function is enabled
	SCI0_SMR_MP_1 = 0x1
	// Position of CKS field.
	SCI0_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_CKS_11 = 0x3

	// SMR_SMCI: Serial mode register (SCMR.SMIF = 1)
	// Position of GM field.
	SCI0_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI0_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI0_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI0_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI0_SMR_SMCI_GM_1 = 0x1
	// Position of BLK field.
	SCI0_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI0_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI0_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI0_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI0_SMR_SMCI_BLK_1 = 0x1
	// Position of PE field.
	SCI0_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_SMCI_PE = 0x20
	// Setting Prohibited
	SCI0_SMR_SMCI_PE_0 = 0x0
	// Set this bit to 1 in smart card interface mode.
	SCI0_SMR_SMCI_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_SMCI_PM = 0x10
	// Selects even parity
	SCI0_SMR_SMCI_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_SMCI_PM_1 = 0x1
	// Position of BCP field.
	SCI0_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI0_SMR_SMCI_BCP_Msk = 0xc
	// 93 clock cycles(S=93) (SCMR.BCP2=0) / 32 clock cycles(S=32) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_00 = 0x0
	// 128 clock cycles(S=128) (SCMR.BCP2=0) / 64 clock cycles(S=64) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_01 = 0x1
	// 186 clock cycles(S=186) (SCMR.BCP2=0) / 372 clock cycles(S=372) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_10 = 0x2
	// 512 clock cycles(S=512) (SCMR.BCP2=0) / 256 clock cycles(S=256) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_11 = 0x3
	// Position of CKS field.
	SCI0_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_SMCI_CKS_11 = 0x3

	// BRR: Bit Rate Register
	// Position of BRR field.
	SCI0_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	SCI0_BRR_BRR_Msk = 0xff

	// SCR: Serial Control Register (SCMR.SMIF = 0)
	// Position of TIE field.
	SCI0_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_TIE = 0x80
	// TXI interrupt request is disabled
	SCI0_SCR_TIE_0 = 0x0
	// TXI interrupt request is enabled
	SCI0_SCR_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI0_SCR_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI0_SCR_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_MPIE = 0x8
	// Normal reception
	SCI0_SCR_MPIE_0 = 0x0
	// When the data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF,ORER and FER in SSR to 1 is disabled. When the data with the multiprocessor bit set to 1 is received, the MPIE bit is automatically cleared to 0, and normal reception is resumed.
	SCI0_SCR_MPIE_1 = 0x1
	// Position of TEIE field.
	SCI0_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_TEIE = 0x4
	// TEI interrupt request is disabled
	SCI0_SCR_TEIE_0 = 0x0
	// TEI interrupt request is enabled
	SCI0_SCR_TEIE_1 = 0x1
	// Position of CKE field.
	SCI0_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_CKE_Msk = 0x3
	// The SCKn pin is available for use as an I/O port in accord with the I/O port settings.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_00 = 0x0
	// The clock with the same frequency as the bit rate is output from the SCKn pin.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_01 = 0x1

	// SCR_SMCI: Serial Control Register (SCMR.SMIF =1)
	// Position of TIE field.
	SCI0_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_SMCI_TIE = 0x80
	// A TXI interrupt request is disabled
	SCI0_SCR_SMCI_TIE_0 = 0x0
	// A TXI interrupt request is enabled
	SCI0_SCR_SMCI_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_SMCI_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI0_SCR_SMCI_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI0_SCR_SMCI_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_SMCI_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_SMCI_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_SMCI_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_SMCI_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_SMCI_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_SMCI_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_SMCI_MPIE = 0x8
	// Position of TEIE field.
	SCI0_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_SMCI_TEIE = 0x4
	// Position of CKE field.
	SCI0_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_SMCI_CKE_Msk = 0x3
	// Output disabled(SMR_SMCI.GM=0) / Output fixed low(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_00 = 0x0
	// Clock Output
	SCI0_SCR_SMCI_CKE_01 = 0x1
	// Setting prohibited(SMR_SMCI.GM=0) / Output fixed High(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_10 = 0x2
	// Setting prohibited(SMR_SMCI.GM=0) / Clock Output(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_11 = 0x3

	// TDR: Transmit Data Register
	// Position of TDR field.
	SCI0_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	SCI0_TDR_TDR_Msk = 0xff

	// SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
	// Position of TDRE field.
	SCI0_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FER_0 = 0x0
	// A framing error has occurred
	SCI0_SSR_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_PER = 0x8
	// No parity error occurred
	SCI0_SSR_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_MPB = 0x2
	// Data transmission cycles
	SCI0_SSR_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPB_1 = 0x1
	// Position of MPBT field.
	SCI0_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_MPBT = 0x1
	// Data transmission cycles
	SCI0_SSR_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPBT_1 = 0x1

	// SSR_FIFO: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
	// Position of TDFE field.
	SCI0_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI0_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI0_SSR_FIFO_TDFE = 0x80
	// The quantity of transmit data written in FTDR exceeds the specified transmit triggering number.
	SCI0_SSR_FIFO_TDFE_0 = 0x0
	// The quantity of transmit data written in FTDR is equal to or less than the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_1 = 0x1
	// Position of RDF field.
	SCI0_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_SSR_FIFO_RDF = 0x40
	// The quantity of receive data written in FRDR falls below the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_0 = 0x0
	// The quantity of receive data written in FRDR is equal to or greater than the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_FIFO_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_FIFO_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FIFO_FER = 0x10
	// No framing error occurred.
	SCI0_SSR_FIFO_FER_0 = 0x0
	// A framing error has occurred.
	SCI0_SSR_FIFO_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_FIFO_PER = 0x8
	// No parity error occurred.
	SCI0_SSR_FIFO_PER_0 = 0x0
	// A parity error has occurred.
	SCI0_SSR_FIFO_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_FIFO_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_FIFO_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_FIFO_TEND_1 = 0x1
	// Position of DR field.
	SCI0_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI0_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI0_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data has remained in FRDR after normally completed receiving.(receive FIFO is empty)
	SCI0_SSR_FIFO_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving, , when data is stored in FIFO to equal or less than receive triggering number.
	SCI0_SSR_FIFO_DR_1 = 0x1

	// SSR_SMCI: Serial Status Register(SCMR.SMIF = 1)
	// Position of TDRE field.
	SCI0_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_SMCI_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_SMCI_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_SMCI_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_SMCI_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_SMCI_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_SMCI_ORER_1 = 0x1
	// Position of ERS field.
	SCI0_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI0_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI0_SSR_SMCI_ERS = 0x10
	// Low error signal not responded
	SCI0_SSR_SMCI_ERS_0 = 0x0
	// Low error signal responded
	SCI0_SSR_SMCI_ERS_1 = 0x1
	// Position of PER field.
	SCI0_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI0_SSR_SMCI_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_SMCI_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_SMCI_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_SMCI_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_SMCI_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_SMCI_MPB = 0x2
	// Position of MPBT field.
	SCI0_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_SMCI_MPBT = 0x1

	// RDR: Receive Data Register
	// Position of RDR field.
	SCI0_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	SCI0_RDR_RDR_Msk = 0xff

	// SCMR: Smart Card Mode Register
	// Position of BCP2 field.
	SCI0_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI0_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI0_SCMR_BCP2 = 0x80
	// S=93(SMR.BCP[1:0]=00), 128(SMR.BCP[1:0]=01), 186(SMR.BCP[1:0]=10), 512(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_0 = 0x0
	// S=32(SMR.BCP[1:0]=00), 64(SMR.BCP[1:0]=01), 372(SMR.BCP[1:0]=10), 256(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_1 = 0x1
	// Position of CHR1 field.
	SCI0_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI0_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI0_SCMR_CHR1 = 0x10
	// Transmit/receive in 9-bit data length
	SCI0_SCMR_CHR1_0 = 0x0
	// Transmit/receive in 8-bit data length(SMR.CHR=0) / in 7bit data length(SMR.CHR=1)
	SCI0_SCMR_CHR1_1 = 0x1
	// Position of SDIR field.
	SCI0_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI0_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI0_SCMR_SDIR = 0x8
	// Transfer with LSB first
	SCI0_SCMR_SDIR_0 = 0x0
	// Transfer with MSB first
	SCI0_SCMR_SDIR_1 = 0x1
	// Position of SINV field.
	SCI0_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI0_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI0_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Receive data is stored as it is in RDR.
	SCI0_SCMR_SINV_0 = 0x0
	// TDR contents are inverted before being transmitted. Receive data is stored in inverted form in RDR.
	SCI0_SCMR_SINV_1 = 0x1
	// Position of SMIF field.
	SCI0_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI0_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI0_SCMR_SMIF = 0x1
	// Non-smart card interface mode(Asynchronous mode, clock synchronous mode, simple SPI mode, or simple I2C mode)
	SCI0_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI0_SCMR_SMIF_1 = 0x1

	// SEMR: Serial Extended Mode Register
	// Position of RXDESEL field.
	SCI0_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI0_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI0_SEMR_RXDESEL = 0x80
	// The low level on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_0 = 0x0
	// A falling edge on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_1 = 0x1
	// Position of BGDM field.
	SCI0_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI0_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI0_SEMR_BGDM = 0x40
	// Baud rate generator outputs the clock with normal frequency.
	SCI0_SEMR_BGDM_0 = 0x0
	// Baud rate generator outputs the clock with doubled frequency.
	SCI0_SEMR_BGDM_1 = 0x1
	// Position of NFEN field.
	SCI0_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI0_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI0_SEMR_NFEN = 0x20
	// Noise cancellation function for the RXDn/TXDn input signal is disabled.
	SCI0_SEMR_NFEN_0 = 0x0
	// Noise cancellation function for the RXDn/TXDn input signal is enabled.
	SCI0_SEMR_NFEN_1 = 0x1
	// Position of ABCS field.
	SCI0_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI0_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI0_SEMR_ABCS = 0x10
	// Selects 16 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_0 = 0x0
	// Selects 8 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_1 = 0x1
	// Position of ABCSE field.
	SCI0_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI0_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI0_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period is decided with combination between BGDM and ABCS in SEMR.
	SCI0_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period and the clock of a double frequency is output from the baud rate generator.
	SCI0_SEMR_ABCSE_1 = 0x1
	// Position of BRME field.
	SCI0_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI0_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI0_SEMR_BRME = 0x4
	// Bit rate modulation function is disabled.
	SCI0_SEMR_BRME_0 = 0x0
	// Bit rate modulation function is enabled.
	SCI0_SEMR_BRME_1 = 0x1

	// SNFR: Noise Filter Setting Register
	// Position of NFCS field.
	SCI0_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI0_SNFR_NFCS_Msk = 0x7
	// The clock signal divided by 1 is used with the noise filter.(In asynchronous mode)
	SCI0_SNFR_NFCS_000 = 0x0
	// The clock signal divided by 1 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_001 = 0x1
	// The clock signal divided by 2 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_010 = 0x2
	// The clock signal divided by 4 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_011 = 0x3
	// The clock signal divided by 8 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_100 = 0x4

	// SIMR1: I2C Mode Register 1
	// Position of IICDL field.
	SCI0_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI0_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI0_SIMR1_IICDL_00000 = 0x0
	// Position of IICM field.
	SCI0_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI0_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI0_SIMR1_IICM = 0x1
	// Asynchronous mode, Multi-processor mode, Clock synchronous mode(SCMR.SMIF=0) /Smart card interface mode(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_0 = 0x0
	// Simple I2C mode(SCMR.SMIF=0) / Setting prohibited.(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_1 = 0x1

	// SIMR2: I2C Mode Register 2
	// Position of IICACKT field.
	SCI0_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI0_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI0_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI0_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and reception of ACK/NACK
	SCI0_SIMR2_IICACKT_1 = 0x1
	// Position of IICCSC field.
	SCI0_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI0_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI0_SIMR2_IICCSC = 0x2
	// No synchronization with the clock signal
	SCI0_SIMR2_IICCSC_0 = 0x0
	// Synchronization with the clock signal
	SCI0_SIMR2_IICCSC_1 = 0x1
	// Position of IICINTM field.
	SCI0_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI0_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI0_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts.
	SCI0_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI0_SIMR2_IICINTM_1 = 0x1

	// SIMR3: I2C Mode Register 3
	// Position of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Msk = 0xc0
	// Serial clock output
	SCI0_SIMR3_IICSCLS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSCLS_01 = 0x1
	// Output the low level on the SSCLn pin.
	SCI0_SIMR3_IICSCLS_10 = 0x2
	// Place the SSCLn pin in the high-impedance state.
	SCI0_SIMR3_IICSCLS_11 = 0x3
	// Position of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Msk = 0x30
	// Serial data output
	SCI0_SIMR3_IICSDAS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSDAS_01 = 0x1
	// Output the low level on the SSDAn pin.
	SCI0_SIMR3_IICSDAS_10 = 0x2
	// Place the SSDAn pin in the high-impedance state.
	SCI0_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI0_SIMR3_IICSTIF = 0x8
	// There are no requests for generating conditions or a condition is being generated.
	SCI0_SIMR3_IICSTIF_0 = 0x0
	// A start, restart, or stop condition is completely generated.
	SCI0_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI0_SIMR3_IICSTPREQ = 0x4
	// A stop condition is not generated.
	SCI0_SIMR3_IICSTPREQ_0 = 0x0
	// A stop condition is generated.
	SCI0_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI0_SIMR3_IICRSTAREQ = 0x2
	// A restart condition is not generated.
	SCI0_SIMR3_IICRSTAREQ_0 = 0x0
	// A restart condition is generated.
	SCI0_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI0_SIMR3_IICSTAREQ = 0x1
	// A start condition is not generated.
	SCI0_SIMR3_IICSTAREQ_0 = 0x0
	// A start condition is generated.
	SCI0_SIMR3_IICSTAREQ_1 = 0x1

	// SISR: I2C Status Register
	// Position of IICACKR field.
	SCI0_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI0_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI0_SISR_IICACKR = 0x1
	// ACK received
	SCI0_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI0_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of CKPH field.
	SCI0_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI0_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI0_SPMR_CKPH = 0x80
	// Clock is not delayed.
	SCI0_SPMR_CKPH_0 = 0x0
	// Clock is delayed.
	SCI0_SPMR_CKPH_1 = 0x1
	// Position of CKPOL field.
	SCI0_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI0_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI0_SPMR_CKPOL = 0x40
	// Clock polarity is not inverted.
	SCI0_SPMR_CKPOL_0 = 0x0
	// Clock polarity is inverted
	SCI0_SPMR_CKPOL_1 = 0x1
	// Position of MFF field.
	SCI0_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI0_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI0_SPMR_MFF = 0x10
	// No mode fault error
	SCI0_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI0_SPMR_MFF_1 = 0x1
	// Position of MSS field.
	SCI0_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI0_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI0_SPMR_MSS = 0x4
	// Transmission is through the TXDn pin and reception is through the RXDn pin (master mode).
	SCI0_SPMR_MSS_0 = 0x0
	// Reception is through the TXDn pin and transmission is through the RXDn pin (slave mode).
	SCI0_SPMR_MSS_1 = 0x1
	// Position of CTSE field.
	SCI0_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI0_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI0_SPMR_CTSE = 0x2
	// CTS function is disabled (RTS output function is enabled).
	SCI0_SPMR_CTSE_0 = 0x0
	// CTS function is enabled.
	SCI0_SPMR_CTSE_1 = 0x1
	// Position of SSE field.
	SCI0_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI0_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI0_SPMR_SSE = 0x1
	// SSn# pin function is disabled.
	SCI0_SPMR_SSE_0 = 0x0
	// SSn# pin function is enabled.
	SCI0_SPMR_SSE_1 = 0x1

	// TDRHL: Transmit 9-bit Data Register
	// Position of TDRHL field.
	SCI0_TDRHL_TDRHL_Pos = 0x0
	// Bit mask of TDRHL field.
	SCI0_TDRHL_TDRHL_Msk = 0xffff

	// FTDRHL: Transmit FIFO Data Register HL
	// Position of MPBT field.
	SCI0_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI0_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI0_FTDRHL_MPBT = 0x200
	// Data transmission cycles
	SCI0_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRHL_MPBT_1 = 0x1
	// Position of TDAT field.
	SCI0_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register H
	// Position of MPBT field.
	SCI0_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI0_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI0_FTDRH_MPBT = 0x2
	// Data transmission cycles
	SCI0_FTDRH_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRH_MPBT_1 = 0x1
	// Position of TDATH field.
	SCI0_FTDRH_TDATH_Pos = 0x0
	// Bit mask of TDATH field.
	SCI0_FTDRH_TDATH_Msk = 0x1
	// Bit TDATH.
	SCI0_FTDRH_TDATH = 0x1

	// FTDRL: Transmit FIFO Data Register L
	// Position of TDATL field.
	SCI0_FTDRL_TDATL_Pos = 0x0
	// Bit mask of TDATL field.
	SCI0_FTDRL_TDATL_Msk = 0xff

	// RDRHL: Receive 9-bit Data Register
	// Position of RDRHL field.
	SCI0_RDRHL_RDRHL_Pos = 0x0
	// Bit mask of RDRHL field.
	SCI0_RDRHL_RDRHL_Msk = 0xffff

	// FRDRHL: Receive FIFO Data Register HL
	// Position of RDF field.
	SCI0_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI0_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI0_FRDRHL_RDF = 0x4000
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRHL_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRHL_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI0_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI0_FRDRHL_ORER = 0x2000
	// No overrun error occurred.
	SCI0_FRDRHL_ORER_0 = 0x0
	// An overrun error has occurred.
	SCI0_FRDRHL_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI0_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI0_FRDRHL_FER = 0x1000
	// No framing error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI0_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI0_FRDRHL_PER = 0x800
	// No parity error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI0_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI0_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRHL_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRHL_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI0_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI0_FRDRHL_MPB = 0x200
	// Data transmission cycles
	SCI0_FRDRHL_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRHL_MPB_1 = 0x1
	// Position of RDAT field.
	SCI0_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register H
	// Position of RDF field.
	SCI0_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_FRDRH_RDF = 0x40
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRH_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRH_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI0_FRDRH_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_FRDRH_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI0_FRDRH_FER = 0x10
	// No framing error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI0_FRDRH_PER = 0x8
	// No parity error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI0_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI0_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRH_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRH_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_FRDRH_MPB = 0x2
	// Data transmission cycles
	SCI0_FRDRH_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRH_MPB_1 = 0x1
	// Position of RDATH field.
	SCI0_FRDRH_RDATH_Pos = 0x0
	// Bit mask of RDATH field.
	SCI0_FRDRH_RDATH_Msk = 0x1
	// Bit RDATH.
	SCI0_FRDRH_RDATH = 0x1

	// FRDRL: Receive FIFO Data Register L
	// Position of RDATL field.
	SCI0_FRDRL_RDATL_Pos = 0x0
	// Bit mask of RDATL field.
	SCI0_FRDRL_RDATL_Msk = 0xff

	// MDDR: Modulation Duty Register
	// Position of MDDR field.
	SCI0_MDDR_MDDR_Pos = 0x0
	// Bit mask of MDDR field.
	SCI0_MDDR_MDDR_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCME field.
	SCI0_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI0_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI0_DCCR_DCME = 0x80
	// Address match function is disabled.
	SCI0_DCCR_DCME_0 = 0x0
	// Address match function is enabled
	SCI0_DCCR_DCME_1 = 0x1
	// Position of IDSEL field.
	SCI0_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI0_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI0_DCCR_IDSEL = 0x40
	// It's always compared data in spite of the value of the MPB bit.
	SCI0_DCCR_IDSEL_0 = 0x0
	// It's compared data when the MPB bit is 1 ( ID frame ) only.
	SCI0_DCCR_IDSEL_1 = 0x1
	// Position of DFER field.
	SCI0_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI0_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI0_DCCR_DFER = 0x10
	// No framing error occurred
	SCI0_DCCR_DFER_0 = 0x0
	// A framing error has occurred
	SCI0_DCCR_DFER_1 = 0x1
	// Position of DPER field.
	SCI0_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI0_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI0_DCCR_DPER = 0x8
	// No parity error occurred
	SCI0_DCCR_DPER_0 = 0x0
	// A parity error has occurred
	SCI0_DCCR_DPER_1 = 0x1
	// Position of DCMF field.
	SCI0_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI0_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI0_DCCR_DCMF = 0x1
	// No matched
	SCI0_DCCR_DCMF_0 = 0x0
	// Matched
	SCI0_DCCR_DCMF_1 = 0x1

	// FCR: FIFO Control Register
	// Position of RSTRG field.
	SCI0_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI0_FCR_RSTRG_Msk = 0xf000
	// Trigger number 0
	SCI0_FCR_RSTRG_0000 = 0x0
	// Position of RTRG field.
	SCI0_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI0_FCR_RTRG_Msk = 0xf00
	// Trigger number 0
	SCI0_FCR_RTRG_0000 = 0x0
	// Position of TTRG field.
	SCI0_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI0_FCR_TTRG_Msk = 0xf0
	// Trigger number 0
	SCI0_FCR_TTRG_0000 = 0x0
	// Position of DRES field.
	SCI0_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI0_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI0_FCR_DRES = 0x8
	// reception data full interrupt (RXI)
	SCI0_FCR_DRES_0 = 0x0
	// receive error interrupt (ERI)
	SCI0_FCR_DRES_1 = 0x1
	// Position of TFRST field.
	SCI0_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI0_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI0_FCR_TFRST = 0x4
	// The number of data stored in FTDRH and FTDRL register are NOT made 0
	SCI0_FCR_TFRST_0 = 0x0
	// The number of data stored in FTDRH and FTDRL register are made 0
	SCI0_FCR_TFRST_1 = 0x1
	// Position of RFRST field.
	SCI0_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI0_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI0_FCR_RFRST = 0x2
	// The number of data stored in FRDRH and FRDRL register are NOT made 0
	SCI0_FCR_RFRST_0 = 0x0
	// The number of data stored in FRDRH and FRDRL register are made 0
	SCI0_FCR_RFRST_1 = 0x1
	// Position of FM field.
	SCI0_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI0_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI0_FCR_FM = 0x1
	// Non-FIFO mode
	SCI0_FCR_FM_0 = 0x0
	// FIFO mode
	SCI0_FCR_FM_1 = 0x1

	// FDR: FIFO Data Count Register
	// Position of T field.
	SCI0_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI0_FDR_T_Msk = 0x1f00
	// Position of R field.
	SCI0_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI0_FDR_R_Msk = 0x1f

	// LSR: Line Status Register
	// Position of PNUM field.
	SCI0_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI0_LSR_PNUM_Msk = 0x1f00
	// Position of FNUM field.
	SCI0_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI0_LSR_FNUM_Msk = 0x7c
	// Position of ORER field.
	SCI0_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI0_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI0_LSR_ORER = 0x1
	// No overrun error occurred
	SCI0_LSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_LSR_ORER_1 = 0x1

	// CDR: Compare Match Data Register
	// Position of CMPD field.
	SCI0_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI0_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of SPB2IO field.
	SCI0_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI0_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI0_SPTR_SPB2IO = 0x4
	// The value of SPB2DT bit isn't output in TxD terminal.
	SCI0_SPTR_SPB2IO_0 = 0x0
	// The value of SPB2DT bit is output in TxD terminal.
	SCI0_SPTR_SPB2IO_1 = 0x1
	// Position of SPB2DT field.
	SCI0_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI0_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI0_SPTR_SPB2DT = 0x2
	// Low level is output in TxD terminal.
	SCI0_SPTR_SPB2DT_0 = 0x0
	// High level is output in TxD terminal.
	SCI0_SPTR_SPB2DT_1 = 0x1
	// Position of RXDMON field.
	SCI0_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI0_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI0_SPTR_RXDMON = 0x1
	// RXD terminal is the Low level.
	SCI0_SPTR_RXDMON_0 = 0x0
	// RXD terminal is the High level.
	SCI0_SPTR_RXDMON_1 = 0x1
)

// Constants for IIC0: Inter-Integrated Circuit 0
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC0_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC0_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC0_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC0_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC0_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC0_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC0_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC0_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC0_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC0_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC0_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC0_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC0_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC0_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC0_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC0_ICCR1_SOWP = 0x10
	// Enables a value to be written in SCLO bit and SDAO bit.
	IIC0_ICCR1_SOWP_0 = 0x0
	// Disables a value to be written in SCLO bit and SDAO bit.
	IIC0_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC0_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC0_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC0_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC0_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC0_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC0_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC0_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC0_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC0_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC0_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC0_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC0_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC0_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC0_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC0_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC0_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC0_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC0_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC0_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC0_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC0_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC0_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC0_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC0_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC0_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC0_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC0_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC0_ICCR2_MST = 0x40
	// Slave mode
	IIC0_ICCR2_MST_0 = 0x0
	// Master mode
	IIC0_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC0_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC0_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC0_ICCR2_TRS = 0x20
	// Receive mode
	IIC0_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC0_ICCR2_TRS_1 = 0x1
	// Position of SP field.
	IIC0_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC0_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC0_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC0_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC0_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC0_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC0_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC0_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC0_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC0_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC0_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC0_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC0_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC0_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC0_ICCR2_ST_1 = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC0_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC0_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC0_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC0_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC0_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC0_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC0_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC0_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC0_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC0_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC0_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC0_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC0_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC0_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC0_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC0_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC0_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC0_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC0_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC0_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC0_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC0_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC0_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC0_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC0_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC0_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC0_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC0_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC0_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC0_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC0_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC0_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_111 = 0x7
	// Position of TMOH field.
	IIC0_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC0_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC0_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC0_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC0_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC0_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC0_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC0_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC0_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC0_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC0_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBS field.
	IIC0_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC0_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC0_ICMR3_SMBS = 0x80
	// The I2C bus is selected.
	IIC0_ICMR3_SMBS_0 = 0x0
	// The SMBus is selected.
	IIC0_ICMR3_SMBS_1 = 0x1
	// Position of WAIT field.
	IIC0_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC0_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC0_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC0_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC0_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC0_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC0_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC0_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC0_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC0_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC0_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC0_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC0_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC0_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC0_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC0_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC0_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC0_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC0_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC0_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC0_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC0_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC0_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC0_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC0_ICMR3_NF_Msk = 0x3
	// Noise of up to one fIIC cycle is filtered out (single-stage filter).
	IIC0_ICMR3_NF_00 = 0x0
	// Noise of up to two fIIC cycles is filtered out (2-stage filter).
	IIC0_ICMR3_NF_01 = 0x1
	// Noise of up to three fIIC cycles is filtered out (3-stage filter).
	IIC0_ICMR3_NF_10 = 0x2
	// Noise of up to four fIIC cycles is filtered out (4-stage filter)
	IIC0_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of FMPE field.
	IIC0_ICFER_FMPE_Pos = 0x7
	// Bit mask of FMPE field.
	IIC0_ICFER_FMPE_Msk = 0x80
	// Bit FMPE.
	IIC0_ICFER_FMPE = 0x80
	// No Fm+ slope control circuit is used for the SCLn pin and SDAn pin.
	IIC0_ICFER_FMPE_0 = 0x0
	// An Fm+ slope control circuit is used for the SCLn pin and SDAn pin.
	IIC0_ICFER_FMPE_1 = 0x1
	// Position of SCLE field.
	IIC0_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC0_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC0_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC0_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC0_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC0_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC0_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC0_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC0_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC0_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC0_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC0_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC0_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC0_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC0_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC0_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC0_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC0_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC0_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC0_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC0_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC0_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC0_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC0_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC0_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC0_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC0_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC0_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC0_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC0_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC0_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC0_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC0_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC0_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC0_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC0_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC0_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC0_ICSER_HOAE_1 = 0x1
	// Position of DIDE field.
	IIC0_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC0_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC0_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC0_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC0_ICSER_DIDE_1 = 0x1
	// Position of GCAE field.
	IIC0_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC0_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC0_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC0_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC0_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC0_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC0_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC0_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC0_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC0_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC0_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC0_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC0_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC0_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC0_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC0_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC0_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC0_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC0_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC0_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC0_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC0_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC0_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (TXI) is disabled.
	IIC0_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (TXI) is enabled.
	IIC0_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC0_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC0_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC0_ICIER_TEIE = 0x40
	// Transmit end interrupt request (TEI) is disabled.
	IIC0_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (TEI) is enabled.
	IIC0_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC0_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC0_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC0_ICIER_RIE = 0x20
	// Receive data full interrupt request (RXI) is disabled.
	IIC0_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (RXI) is enabled.
	IIC0_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC0_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC0_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC0_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC0_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC0_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC0_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC0_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC0_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC0_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC0_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC0_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC0_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC0_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC0_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC0_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC0_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC0_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC0_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC0_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC0_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC0_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC0_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC0_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC0_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC0_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC0_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC0_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC0_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC0_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC0_ICSR1_HOA_1 = 0x1
	// Position of DID field.
	IIC0_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC0_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC0_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC0_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC0_ICSR1_DID_1 = 0x1
	// Position of GCA field.
	IIC0_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC0_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC0_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC0_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC0_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC0_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC0_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC0_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC0_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC0_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC0_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC0_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC0_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC0_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC0_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC0_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC0_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC0_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC0_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC0_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC0_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC0_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC0_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC0_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC0_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC0_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC0_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC0_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC0_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC0_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC0_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC0_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC0_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC0_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC0_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC0_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC0_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC0_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC0_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC0_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC0_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC0_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC0_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC0_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC0_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC0_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC0_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC0_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC0_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC0_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC0_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC0_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC0_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC0_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC0_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC0_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC0_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC0_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC0_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC0_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC0_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC0_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of SVA9 field.
	IIC0_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC0_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC0_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC0_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC0_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC0_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC0_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC0_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC0_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC0_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC0_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of BRL field.
	IIC0_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC0_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of BRH field.
	IIC0_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC0_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC0_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC0_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC0_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC0_ICDRR_ICDRR_Msk = 0xff

	// ICWUR: I2C Bus Wake Up Unit Register
	// Position of WUE field.
	IIC0_ICWUR_WUE_Pos = 0x7
	// Bit mask of WUE field.
	IIC0_ICWUR_WUE_Msk = 0x80
	// Bit WUE.
	IIC0_ICWUR_WUE = 0x80
	// Wake-up function is disabled
	IIC0_ICWUR_WUE_0 = 0x0
	// Wake-up function is enabled.
	IIC0_ICWUR_WUE_1 = 0x1
	// Position of WUIE field.
	IIC0_ICWUR_WUIE_Pos = 0x6
	// Bit mask of WUIE field.
	IIC0_ICWUR_WUIE_Msk = 0x40
	// Bit WUIE.
	IIC0_ICWUR_WUIE = 0x40
	// Wake Up Interrupt Request (WUI) is disabled.
	IIC0_ICWUR_WUIE_0 = 0x0
	// Wake Up Interrupt Request (WUI) is enabled.
	IIC0_ICWUR_WUIE_1 = 0x1
	// Position of WUF field.
	IIC0_ICWUR_WUF_Pos = 0x5
	// Bit mask of WUF field.
	IIC0_ICWUR_WUF_Msk = 0x20
	// Bit WUF.
	IIC0_ICWUR_WUF = 0x20
	// Slave address match during Wake-Up function.
	IIC0_ICWUR_WUF_0 = 0x0
	// Slave address not match during Wake-Up function.
	IIC0_ICWUR_WUF_1 = 0x1
	// Position of WUACK field.
	IIC0_ICWUR_WUACK_Pos = 0x4
	// Bit mask of WUACK field.
	IIC0_ICWUR_WUACK_Msk = 0x10
	// Bit WUACK.
	IIC0_ICWUR_WUACK = 0x10
	// State of synchronous operation
	IIC0_ICWUR_WUACK_0 = 0x0
	// State of asynchronous operation
	IIC0_ICWUR_WUACK_1 = 0x1
	// Position of WUAFA field.
	IIC0_ICWUR_WUAFA_Pos = 0x0
	// Bit mask of WUAFA field.
	IIC0_ICWUR_WUAFA_Msk = 0x1
	// Bit WUAFA.
	IIC0_ICWUR_WUAFA = 0x1
	// Do not add the Wake Up analog filter.
	IIC0_ICWUR_WUAFA_0 = 0x0
	// Add the Wake Up analog filter.
	IIC0_ICWUR_WUAFA_1 = 0x1

	// ICWUR2: I2C Bus Wake Up Unit Register 2
	// Position of WUSYF field.
	IIC0_ICWUR2_WUSYF_Pos = 0x2
	// Bit mask of WUSYF field.
	IIC0_ICWUR2_WUSYF_Msk = 0x4
	// Bit WUSYF.
	IIC0_ICWUR2_WUSYF = 0x4
	// IIC asynchronous circuit enable condition
	IIC0_ICWUR2_WUSYF_0 = 0x0
	// IIC synchronous circuit enable condition
	IIC0_ICWUR2_WUSYF_1 = 0x1
	// Position of WUASYF field.
	IIC0_ICWUR2_WUASYF_Pos = 0x1
	// Bit mask of WUASYF field.
	IIC0_ICWUR2_WUASYF_Msk = 0x2
	// Bit WUASYF.
	IIC0_ICWUR2_WUASYF = 0x2
	// IIC synchronous circuit enable condition
	IIC0_ICWUR2_WUASYF_0 = 0x0
	// IIC asynchronous circuit enable condition
	IIC0_ICWUR2_WUASYF_1 = 0x1
	// Position of WUSEN field.
	IIC0_ICWUR2_WUSEN_Pos = 0x0
	// Bit mask of WUSEN field.
	IIC0_ICWUR2_WUSEN_Msk = 0x1
	// Bit WUSEN.
	IIC0_ICWUR2_WUSEN = 0x1
	// IIC asynchronous circuit enable
	IIC0_ICWUR2_WUSEN_0 = 0x0
	// IIC synchronous circuit enable
	IIC0_ICWUR2_WUSEN_1 = 0x1
)

// Constants for IIC1: Inter-Integrated Circuit 1
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC1_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC1_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC1_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC1_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC1_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC1_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC1_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC1_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC1_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC1_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC1_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC1_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC1_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC1_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC1_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC1_ICCR1_SOWP = 0x10
	// Enables a value to be written in SCLO bit and SDAO bit.
	IIC1_ICCR1_SOWP_0 = 0x0
	// Disables a value to be written in SCLO bit and SDAO bit.
	IIC1_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC1_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC1_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC1_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC1_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC1_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC1_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC1_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC1_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC1_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC1_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC1_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC1_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC1_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC1_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC1_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC1_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC1_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC1_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC1_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC1_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC1_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC1_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC1_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC1_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC1_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC1_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC1_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC1_ICCR2_MST = 0x40
	// Slave mode
	IIC1_ICCR2_MST_0 = 0x0
	// Master mode
	IIC1_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC1_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC1_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC1_ICCR2_TRS = 0x20
	// Receive mode
	IIC1_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC1_ICCR2_TRS_1 = 0x1
	// Position of SP field.
	IIC1_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC1_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC1_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC1_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC1_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC1_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC1_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC1_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC1_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC1_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC1_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC1_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC1_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC1_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC1_ICCR2_ST_1 = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC1_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC1_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC1_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC1_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC1_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC1_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC1_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC1_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC1_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC1_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC1_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC1_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC1_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC1_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC1_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC1_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC1_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC1_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC1_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC1_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC1_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC1_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC1_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC1_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC1_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC1_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC1_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC1_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC1_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC1_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC1_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC1_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_111 = 0x7
	// Position of TMOH field.
	IIC1_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC1_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC1_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC1_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC1_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC1_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC1_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC1_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC1_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC1_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC1_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBS field.
	IIC1_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC1_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC1_ICMR3_SMBS = 0x80
	// The I2C bus is selected.
	IIC1_ICMR3_SMBS_0 = 0x0
	// The SMBus is selected.
	IIC1_ICMR3_SMBS_1 = 0x1
	// Position of WAIT field.
	IIC1_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC1_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC1_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC1_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC1_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC1_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC1_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC1_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC1_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC1_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC1_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC1_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC1_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC1_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC1_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC1_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC1_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC1_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC1_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC1_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC1_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC1_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC1_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC1_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC1_ICMR3_NF_Msk = 0x3
	// Noise of up to one fIIC cycle is filtered out (single-stage filter).
	IIC1_ICMR3_NF_00 = 0x0
	// Noise of up to two fIIC cycles is filtered out (2-stage filter).
	IIC1_ICMR3_NF_01 = 0x1
	// Noise of up to three fIIC cycles is filtered out (3-stage filter).
	IIC1_ICMR3_NF_10 = 0x2
	// Noise of up to four fIIC cycles is filtered out (4-stage filter)
	IIC1_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of FMPE field.
	IIC1_ICFER_FMPE_Pos = 0x7
	// Bit mask of FMPE field.
	IIC1_ICFER_FMPE_Msk = 0x80
	// Bit FMPE.
	IIC1_ICFER_FMPE = 0x80
	// No Fm+ slope control circuit is used for the SCLn pin and SDAn pin.
	IIC1_ICFER_FMPE_0 = 0x0
	// An Fm+ slope control circuit is used for the SCLn pin and SDAn pin.
	IIC1_ICFER_FMPE_1 = 0x1
	// Position of SCLE field.
	IIC1_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC1_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC1_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC1_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC1_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC1_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC1_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC1_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC1_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC1_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC1_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC1_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC1_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC1_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC1_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC1_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC1_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC1_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC1_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC1_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC1_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC1_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC1_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC1_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC1_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC1_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC1_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC1_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC1_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC1_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC1_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC1_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC1_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC1_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC1_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC1_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC1_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC1_ICSER_HOAE_1 = 0x1
	// Position of DIDE field.
	IIC1_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC1_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC1_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC1_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC1_ICSER_DIDE_1 = 0x1
	// Position of GCAE field.
	IIC1_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC1_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC1_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC1_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC1_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC1_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC1_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC1_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC1_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC1_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC1_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC1_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC1_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC1_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC1_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC1_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC1_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC1_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC1_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC1_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC1_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC1_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC1_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (TXI) is disabled.
	IIC1_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (TXI) is enabled.
	IIC1_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC1_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC1_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC1_ICIER_TEIE = 0x40
	// Transmit end interrupt request (TEI) is disabled.
	IIC1_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (TEI) is enabled.
	IIC1_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC1_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC1_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC1_ICIER_RIE = 0x20
	// Receive data full interrupt request (RXI) is disabled.
	IIC1_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (RXI) is enabled.
	IIC1_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC1_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC1_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC1_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC1_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC1_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC1_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC1_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC1_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC1_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC1_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC1_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC1_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC1_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC1_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC1_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC1_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC1_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC1_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC1_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC1_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC1_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC1_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC1_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC1_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC1_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC1_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC1_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC1_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC1_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC1_ICSR1_HOA_1 = 0x1
	// Position of DID field.
	IIC1_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC1_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC1_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC1_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC1_ICSR1_DID_1 = 0x1
	// Position of GCA field.
	IIC1_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC1_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC1_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC1_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC1_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC1_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC1_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC1_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC1_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC1_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC1_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC1_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC1_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC1_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC1_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC1_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC1_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC1_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC1_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC1_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC1_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC1_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC1_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC1_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC1_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC1_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC1_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC1_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC1_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC1_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC1_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC1_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC1_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC1_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC1_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC1_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC1_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC1_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC1_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC1_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC1_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC1_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC1_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC1_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC1_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC1_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC1_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC1_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC1_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC1_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC1_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC1_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC1_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC1_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC1_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC1_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC1_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC1_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC1_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC1_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC1_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC1_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of SVA9 field.
	IIC1_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC1_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC1_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC1_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC1_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC1_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC1_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC1_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC1_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC1_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC1_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of BRL field.
	IIC1_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC1_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of BRH field.
	IIC1_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC1_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC1_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC1_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC1_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC1_ICDRR_ICDRR_Msk = 0xff
)

// Constants for SYSTEM: System Control
const (
	// SBYCR: Standby Control Register
	// Position of SSBY field.
	SYSTEM_SBYCR_SSBY_Pos = 0xf
	// Bit mask of SSBY field.
	SYSTEM_SBYCR_SSBY_Msk = 0x8000
	// Bit SSBY.
	SYSTEM_SBYCR_SSBY = 0x8000
	// Sleep mode
	SYSTEM_SBYCR_SSBY_0 = 0x0
	// Software Standby mode (DPSBYCR.DPSBY=0) / Deep Software Standby mode (DPSBYCR.DPSBY=1)
	SYSTEM_SBYCR_SSBY_1 = 0x1
	// Position of OPE field.
	SYSTEM_SBYCR_OPE_Pos = 0xe
	// Bit mask of OPE field.
	SYSTEM_SBYCR_OPE_Msk = 0x4000
	// Bit OPE.
	SYSTEM_SBYCR_OPE = 0x4000
	// In software standby mode or deep software standby mode, the address bus and bus control signals are set to the high-impedance state.
	SYSTEM_SBYCR_OPE_0 = 0x0
	// In software standby mode or deep software standby mode, the address bus and bus control signals retain the output state..
	SYSTEM_SBYCR_OPE_1 = 0x1

	// MSTPCRA: Module Stop Control Register A
	// Position of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Pos = 0x16
	// Bit mask of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Msk = 0x400000
	// Bit MSTPA22.
	SYSTEM_MSTPCRA_MSTPA22 = 0x400000
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_1 = 0x1
	// Position of MSTPA7 field.
	SYSTEM_MSTPCRA_MSTPA7_Pos = 0x7
	// Bit mask of MSTPA7 field.
	SYSTEM_MSTPCRA_MSTPA7_Msk = 0x80
	// Bit MSTPA7.
	SYSTEM_MSTPCRA_MSTPA7 = 0x80
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA7_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA7_1 = 0x1
	// Position of MSTPA6 field.
	SYSTEM_MSTPCRA_MSTPA6_Pos = 0x6
	// Bit mask of MSTPA6 field.
	SYSTEM_MSTPCRA_MSTPA6_Msk = 0x40
	// Bit MSTPA6.
	SYSTEM_MSTPCRA_MSTPA6 = 0x40
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA6_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA6_1 = 0x1
	// Position of MSTPA5 field.
	SYSTEM_MSTPCRA_MSTPA5_Pos = 0x5
	// Bit mask of MSTPA5 field.
	SYSTEM_MSTPCRA_MSTPA5_Msk = 0x20
	// Bit MSTPA5.
	SYSTEM_MSTPCRA_MSTPA5 = 0x20
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA5_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA5_1 = 0x1
	// Position of MSTPA1 field.
	SYSTEM_MSTPCRA_MSTPA1_Pos = 0x1
	// Bit mask of MSTPA1 field.
	SYSTEM_MSTPCRA_MSTPA1_Msk = 0x2
	// Bit MSTPA1.
	SYSTEM_MSTPCRA_MSTPA1 = 0x2
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA1_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA1_1 = 0x1
	// Position of MSTPA0 field.
	SYSTEM_MSTPCRA_MSTPA0_Pos = 0x0
	// Bit mask of MSTPA0 field.
	SYSTEM_MSTPCRA_MSTPA0_Msk = 0x1
	// Bit MSTPA0.
	SYSTEM_MSTPCRA_MSTPA0 = 0x1
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA0_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA0_1 = 0x1

	// SCKDIVCR: System Clock Division Control Register
	// Position of FCK field.
	SYSTEM_SCKDIVCR_FCK_Pos = 0x1c
	// Bit mask of FCK field.
	SYSTEM_SCKDIVCR_FCK_Msk = 0x70000000
	// /1
	SYSTEM_SCKDIVCR_FCK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_FCK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_FCK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_FCK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_FCK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_FCK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_FCK_110 = 0x6
	// Position of ICK field.
	SYSTEM_SCKDIVCR_ICK_Pos = 0x18
	// Bit mask of ICK field.
	SYSTEM_SCKDIVCR_ICK_Msk = 0x7000000
	// /1
	SYSTEM_SCKDIVCR_ICK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_ICK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_ICK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_ICK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_ICK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_ICK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_ICK_110 = 0x6
	// Position of BCK field.
	SYSTEM_SCKDIVCR_BCK_Pos = 0x10
	// Bit mask of BCK field.
	SYSTEM_SCKDIVCR_BCK_Msk = 0x70000
	// /1
	SYSTEM_SCKDIVCR_BCK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_BCK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_BCK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_BCK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_BCK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_BCK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_BCK_110 = 0x6
	// Position of PCKA field.
	SYSTEM_SCKDIVCR_PCKA_Pos = 0xc
	// Bit mask of PCKA field.
	SYSTEM_SCKDIVCR_PCKA_Msk = 0x7000
	// /1
	SYSTEM_SCKDIVCR_PCKA_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKA_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKA_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKA_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKA_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKA_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKA_110 = 0x6
	// Position of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Pos = 0x8
	// Bit mask of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Msk = 0x700
	// /1
	SYSTEM_SCKDIVCR_PCKB_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKB_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKB_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKB_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKB_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKB_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKB_110 = 0x6
	// Position of PCKC field.
	SYSTEM_SCKDIVCR_PCKC_Pos = 0x4
	// Bit mask of PCKC field.
	SYSTEM_SCKDIVCR_PCKC_Msk = 0x70
	// /1
	SYSTEM_SCKDIVCR_PCKC_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKC_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKC_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKC_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKC_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKC_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKC_110 = 0x6
	// Position of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Pos = 0x0
	// Bit mask of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Msk = 0x7
	// /1
	SYSTEM_SCKDIVCR_PCKD_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKD_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKD_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKD_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKD_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKD_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKD_110 = 0x6

	// SCKDIVCR2: System Clock Division Control Register 2
	// Position of UCK field.
	SYSTEM_SCKDIVCR2_UCK_Pos = 0x4
	// Bit mask of UCK field.
	SYSTEM_SCKDIVCR2_UCK_Msk = 0x70
	// /3
	SYSTEM_SCKDIVCR2_UCK_010 = 0x2
	// /4
	SYSTEM_SCKDIVCR2_UCK_011 = 0x3
	// /5
	SYSTEM_SCKDIVCR2_UCK_100 = 0x4

	// SCKSCR: System Clock Source Control Register
	// Position of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Msk = 0x7
	// HOCO
	SYSTEM_SCKSCR_CKSEL_000 = 0x0
	// MOCO
	SYSTEM_SCKSCR_CKSEL_001 = 0x1
	// LOCO
	SYSTEM_SCKSCR_CKSEL_010 = 0x2
	// Main clock oscillator
	SYSTEM_SCKSCR_CKSEL_011 = 0x3
	// Sub-clock oscillator
	SYSTEM_SCKSCR_CKSEL_100 = 0x4
	// PLL
	SYSTEM_SCKSCR_CKSEL_101 = 0x5

	// PLLCCR: PLL Clock Control Register
	// Position of PLLMUL field.
	SYSTEM_PLLCCR_PLLMUL_Pos = 0x8
	// Bit mask of PLLMUL field.
	SYSTEM_PLLCCR_PLLMUL_Msk = 0x3f00
	// Position of PLSRCSEL field.
	SYSTEM_PLLCCR_PLSRCSEL_Pos = 0x4
	// Bit mask of PLSRCSEL field.
	SYSTEM_PLLCCR_PLSRCSEL_Msk = 0x10
	// Bit PLSRCSEL.
	SYSTEM_PLLCCR_PLSRCSEL = 0x10
	// Main clock oscillator
	SYSTEM_PLLCCR_PLSRCSEL_0 = 0x0
	// HOCO
	SYSTEM_PLLCCR_PLSRCSEL_1 = 0x1
	// Position of PLIDIV field.
	SYSTEM_PLLCCR_PLIDIV_Pos = 0x0
	// Bit mask of PLIDIV field.
	SYSTEM_PLLCCR_PLIDIV_Msk = 0x3
	// /1
	SYSTEM_PLLCCR_PLIDIV_00 = 0x0
	// /2
	SYSTEM_PLLCCR_PLIDIV_01 = 0x1
	// /3
	SYSTEM_PLLCCR_PLIDIV_10 = 0x2
	// Setting prohibited
	SYSTEM_PLLCCR_PLIDIV_11 = 0x3

	// PLLCR: PLL Control Register
	// Position of PLLSTP field.
	SYSTEM_PLLCR_PLLSTP_Pos = 0x0
	// Bit mask of PLLSTP field.
	SYSTEM_PLLCR_PLLSTP_Msk = 0x1
	// Bit PLLSTP.
	SYSTEM_PLLCR_PLLSTP = 0x1
	// Operate the PLL
	SYSTEM_PLLCR_PLLSTP_0 = 0x0
	// Stop the PLL.
	SYSTEM_PLLCR_PLLSTP_1 = 0x1

	// BCKCR: External Bus Clock Control Register
	// Position of BCLKDIV field.
	SYSTEM_BCKCR_BCLKDIV_Pos = 0x0
	// Bit mask of BCLKDIV field.
	SYSTEM_BCKCR_BCLKDIV_Msk = 0x1
	// Bit BCLKDIV.
	SYSTEM_BCKCR_BCLKDIV = 0x1
	// BCLK
	SYSTEM_BCKCR_BCLKDIV_0 = 0x0
	// BCLK/2
	SYSTEM_BCKCR_BCLKDIV_1 = 0x1

	// MOSCCR: Main Clock Oscillator Control Register
	// Position of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Pos = 0x0
	// Bit mask of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Msk = 0x1
	// Bit MOSTP.
	SYSTEM_MOSCCR_MOSTP = 0x1
	// Main clock oscillator is operating.
	SYSTEM_MOSCCR_MOSTP_0 = 0x0
	// Main clock oscillator is stopped.
	SYSTEM_MOSCCR_MOSTP_1 = 0x1

	// HOCOCR: High-Speed On-Chip Oscillator Control Register
	// Position of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Pos = 0x0
	// Bit mask of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Msk = 0x1
	// Bit HCSTP.
	SYSTEM_HOCOCR_HCSTP = 0x1
	// Operate the HOCO clock
	SYSTEM_HOCOCR_HCSTP_0 = 0x0
	// Stop the HOCO clock
	SYSTEM_HOCOCR_HCSTP_1 = 0x1

	// MOCOCR: Middle-Speed On-Chip Oscillator Control Register
	// Position of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Pos = 0x0
	// Bit mask of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Msk = 0x1
	// Bit MCSTP.
	SYSTEM_MOCOCR_MCSTP = 0x1
	// Operate the MOCO clock
	SYSTEM_MOCOCR_MCSTP_0 = 0x0
	// Stop the MOCO clock
	SYSTEM_MOCOCR_MCSTP_1 = 0x1

	// FLLCR1: FLL Control Register 1
	// Position of FLLEN field.
	SYSTEM_FLLCR1_FLLEN_Pos = 0x0
	// Bit mask of FLLEN field.
	SYSTEM_FLLCR1_FLLEN_Msk = 0x1
	// Bit FLLEN.
	SYSTEM_FLLCR1_FLLEN = 0x1
	// FLL function is disabled.
	SYSTEM_FLLCR1_FLLEN_0 = 0x0
	// FLL function is enabled.
	SYSTEM_FLLCR1_FLLEN_1 = 0x1

	// FLLCR2: FLL Control Register 2
	// Position of FLLCNTL field.
	SYSTEM_FLLCR2_FLLCNTL_Pos = 0x0
	// Bit mask of FLLCNTL field.
	SYSTEM_FLLCR2_FLLCNTL_Msk = 0x7ff

	// OSCSF: Oscillation Stabilization Flag Register
	// Position of PLLSF field.
	SYSTEM_OSCSF_PLLSF_Pos = 0x5
	// Bit mask of PLLSF field.
	SYSTEM_OSCSF_PLLSF_Msk = 0x20
	// Bit PLLSF.
	SYSTEM_OSCSF_PLLSF = 0x20
	// PLL clock is stopped or is not yet stable
	SYSTEM_OSCSF_PLLSF_0 = 0x0
	// PLL clock is stable, so is available for use as the system clock
	SYSTEM_OSCSF_PLLSF_1 = 0x1
	// Position of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Pos = 0x3
	// Bit mask of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Msk = 0x8
	// Bit MOSCSF.
	SYSTEM_OSCSF_MOSCSF = 0x8
	// Main clock oscillator is stopped (MOSTP = 1) or is not yet stable
	SYSTEM_OSCSF_MOSCSF_0 = 0x0
	// Main clock oscillator is stable, so is available for use as the system clock
	SYSTEM_OSCSF_MOSCSF_1 = 0x1
	// Position of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Pos = 0x0
	// Bit mask of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Msk = 0x1
	// Bit HOCOSF.
	SYSTEM_OSCSF_HOCOSF = 0x1
	// HOCO clock is stopped or is not yet stable
	SYSTEM_OSCSF_HOCOSF_0 = 0x0
	// HOCO clock is stable, so is available for use as the system clock
	SYSTEM_OSCSF_HOCOSF_1 = 0x1

	// CKOCR: Clock Out Control Register
	// Position of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Pos = 0x7
	// Bit mask of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Msk = 0x80
	// Bit CKOEN.
	SYSTEM_CKOCR_CKOEN = 0x80
	// Disable clock out
	SYSTEM_CKOCR_CKOEN_0 = 0x0
	// Enable clock out
	SYSTEM_CKOCR_CKOEN_1 = 0x1
	// Position of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Pos = 0x4
	// Bit mask of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Msk = 0x70
	// /1
	SYSTEM_CKOCR_CKODIV_000 = 0x0
	// /2
	SYSTEM_CKOCR_CKODIV_001 = 0x1
	// /4
	SYSTEM_CKOCR_CKODIV_010 = 0x2
	// /8
	SYSTEM_CKOCR_CKODIV_011 = 0x3
	// /16
	SYSTEM_CKOCR_CKODIV_100 = 0x4
	// /32
	SYSTEM_CKOCR_CKODIV_101 = 0x5
	// /64
	SYSTEM_CKOCR_CKODIV_110 = 0x6
	// /128
	SYSTEM_CKOCR_CKODIV_111 = 0x7
	// Position of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Pos = 0x0
	// Bit mask of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Msk = 0x7
	// HOCO
	SYSTEM_CKOCR_CKOSEL_000 = 0x0
	// MOCO
	SYSTEM_CKOCR_CKOSEL_001 = 0x1
	// LOCO
	SYSTEM_CKOCR_CKOSEL_010 = 0x2
	// MOSC
	SYSTEM_CKOCR_CKOSEL_011 = 0x3
	// SOSC
	SYSTEM_CKOCR_CKOSEL_100 = 0x4

	// TRCKCR: Trace Clock Control Register
	// Position of TRCKEN field.
	SYSTEM_TRCKCR_TRCKEN_Pos = 0x7
	// Bit mask of TRCKEN field.
	SYSTEM_TRCKCR_TRCKEN_Msk = 0x80
	// Bit TRCKEN.
	SYSTEM_TRCKCR_TRCKEN = 0x80
	// Disable operation
	SYSTEM_TRCKCR_TRCKEN_0 = 0x0
	// Enable operation
	SYSTEM_TRCKCR_TRCKEN_1 = 0x1
	// Position of TRCK field.
	SYSTEM_TRCKCR_TRCK_Pos = 0x0
	// Bit mask of TRCK field.
	SYSTEM_TRCKCR_TRCK_Msk = 0xf
	// /1
	SYSTEM_TRCKCR_TRCK_0000 = 0x0
	// /2
	SYSTEM_TRCKCR_TRCK_0001 = 0x1
	// /4
	SYSTEM_TRCKCR_TRCK_0010 = 0x2

	// OSTDCR: Oscillation Stop Detection Control Register
	// Position of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Pos = 0x7
	// Bit mask of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Msk = 0x80
	// Bit OSTDE.
	SYSTEM_OSTDCR_OSTDE = 0x80
	// Disable oscillation stop detection function
	SYSTEM_OSTDCR_OSTDE_0 = 0x0
	// Enable oscillation stop detection function
	SYSTEM_OSTDCR_OSTDE_1 = 0x1
	// Position of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Pos = 0x0
	// Bit mask of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Msk = 0x1
	// Bit OSTDIE.
	SYSTEM_OSTDCR_OSTDIE = 0x1
	// Disable oscillation stop detection interrupt (do not notify the POEG)
	SYSTEM_OSTDCR_OSTDIE_0 = 0x0
	// Enable oscillation stop detection interrupt (notify the POEG)
	SYSTEM_OSTDCR_OSTDIE_1 = 0x1

	// OSTDSR: Oscillation Stop Detection Status Register
	// Position of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Pos = 0x0
	// Bit mask of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Msk = 0x1
	// Bit OSTDF.
	SYSTEM_OSTDSR_OSTDF = 0x1
	// Main clock oscillation stop not detected
	SYSTEM_OSTDSR_OSTDF_0 = 0x0
	// Main clock oscillation stop detected
	SYSTEM_OSTDSR_OSTDF_1 = 0x1

	// EBCKOCR: External Bus Clock Output Control Register
	// Position of EBCKOEN field.
	SYSTEM_EBCKOCR_EBCKOEN_Pos = 0x0
	// Bit mask of EBCKOEN field.
	SYSTEM_EBCKOCR_EBCKOEN_Msk = 0x1
	// Bit EBCKOEN.
	SYSTEM_EBCKOCR_EBCKOEN = 0x1
	// Disable EBCLK pin output (fixed high)
	SYSTEM_EBCKOCR_EBCKOEN_0 = 0x0
	// Enable EBCLK pin output
	SYSTEM_EBCKOCR_EBCKOEN_1 = 0x1

	// SDCKOCR: SDRAM Clock Output Control Register
	// Position of SDCKOEN field.
	SYSTEM_SDCKOCR_SDCKOEN_Pos = 0x0
	// Bit mask of SDCKOEN field.
	SYSTEM_SDCKOCR_SDCKOEN_Msk = 0x1
	// Bit SDCKOEN.
	SYSTEM_SDCKOCR_SDCKOEN = 0x1
	// Disable SDCLK pin output (fixed high)
	SYSTEM_SDCKOCR_SDCKOEN_0 = 0x0
	// Enable SDCLK pin output
	SYSTEM_SDCKOCR_SDCKOEN_1 = 0x1

	// MOCOUTCR: MOCO User Trimming Control Register
	// Position of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Pos = 0x0
	// Bit mask of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Msk = 0xff

	// HOCOUTCR: HOCO User Trimming Control Register
	// Position of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Pos = 0x0
	// Bit mask of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Msk = 0xff

	// SNZCR: Snooze Control Register
	// Position of SNZE field.
	SYSTEM_SNZCR_SNZE_Pos = 0x7
	// Bit mask of SNZE field.
	SYSTEM_SNZCR_SNZE_Msk = 0x80
	// Bit SNZE.
	SYSTEM_SNZCR_SNZE = 0x80
	// Disable Snooze Mode
	SYSTEM_SNZCR_SNZE_0 = 0x0
	// Enable Snooze Mode
	SYSTEM_SNZCR_SNZE_1 = 0x1
	// Position of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Pos = 0x1
	// Bit mask of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Msk = 0x2
	// Bit SNZDTCEN.
	SYSTEM_SNZCR_SNZDTCEN = 0x2
	// Disable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_0 = 0x0
	// Enable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_1 = 0x1
	// Position of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Pos = 0x0
	// Bit mask of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Msk = 0x1
	// Bit RXDREQEN.
	SYSTEM_SNZCR_RXDREQEN = 0x1
	// Ignore RXD0 falling edge in Standby mode.
	SYSTEM_SNZCR_RXDREQEN_0 = 0x0
	// Accept RXD0 falling edge in Standby mode as a request to transit to Snooze mode.
	SYSTEM_SNZCR_RXDREQEN_1 = 0x1

	// SNZEDCR: Snooze End Control Register
	// Position of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Pos = 0x7
	// Bit mask of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Msk = 0x80
	// Bit SCI0UMTED.
	SYSTEM_SNZEDCR_SCI0UMTED = 0x80
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_1 = 0x1
	// Position of AD1UMTED field.
	SYSTEM_SNZEDCR_AD1UMTED_Pos = 0x6
	// Bit mask of AD1UMTED field.
	SYSTEM_SNZEDCR_AD1UMTED_Msk = 0x40
	// Bit AD1UMTED.
	SYSTEM_SNZEDCR_AD1UMTED = 0x40
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD1UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD1UMTED_1 = 0x1
	// Position of AD1MATED field.
	SYSTEM_SNZEDCR_AD1MATED_Pos = 0x5
	// Bit mask of AD1MATED field.
	SYSTEM_SNZEDCR_AD1MATED_Msk = 0x20
	// Bit AD1MATED.
	SYSTEM_SNZEDCR_AD1MATED = 0x20
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD1MATED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD1MATED_1 = 0x1
	// Position of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Pos = 0x4
	// Bit mask of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Msk = 0x10
	// Bit AD0UMTED.
	SYSTEM_SNZEDCR_AD0UMTED = 0x10
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_1 = 0x1
	// Position of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Pos = 0x3
	// Bit mask of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Msk = 0x8
	// Bit AD0MATED.
	SYSTEM_SNZEDCR_AD0MATED = 0x8
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_1 = 0x1
	// Position of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Pos = 0x2
	// Bit mask of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Msk = 0x4
	// Bit DTCNZRED.
	SYSTEM_SNZEDCR_DTCNZRED = 0x4
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_1 = 0x1
	// Position of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Pos = 0x1
	// Bit mask of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Msk = 0x2
	// Bit DTCZRED.
	SYSTEM_SNZEDCR_DTCZRED = 0x2
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_1 = 0x1
	// Position of AGT1UNFED field.
	SYSTEM_SNZEDCR_AGT1UNFED_Pos = 0x0
	// Bit mask of AGT1UNFED field.
	SYSTEM_SNZEDCR_AGT1UNFED_Msk = 0x1
	// Bit AGT1UNFED.
	SYSTEM_SNZEDCR_AGT1UNFED = 0x1
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AGT1UNFED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AGT1UNFED_1 = 0x1

	// SNZREQCR: Snooze Request Control Register
	// Position of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Pos = 0x1e
	// Bit mask of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Msk = 0x40000000
	// Bit SNZREQEN30.
	SYSTEM_SNZREQCR_SNZREQEN30 = 0x40000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_1 = 0x1
	// Position of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Pos = 0x1d
	// Bit mask of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Msk = 0x20000000
	// Bit SNZREQEN29.
	SYSTEM_SNZREQCR_SNZREQEN29 = 0x20000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_1 = 0x1
	// Position of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Pos = 0x1c
	// Bit mask of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Msk = 0x10000000
	// Bit SNZREQEN28.
	SYSTEM_SNZREQCR_SNZREQEN28 = 0x10000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_1 = 0x1
	// Position of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Pos = 0x19
	// Bit mask of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Msk = 0x2000000
	// Bit SNZREQEN25.
	SYSTEM_SNZREQCR_SNZREQEN25 = 0x2000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_1 = 0x1
	// Position of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Pos = 0x18
	// Bit mask of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Msk = 0x1000000
	// Bit SNZREQEN24.
	SYSTEM_SNZREQCR_SNZREQEN24 = 0x1000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_1 = 0x1
	// Position of SNZREQEN22 field.
	SYSTEM_SNZREQCR_SNZREQEN22_Pos = 0x16
	// Bit mask of SNZREQEN22 field.
	SYSTEM_SNZREQCR_SNZREQEN22_Msk = 0x400000
	// Bit SNZREQEN22.
	SYSTEM_SNZREQCR_SNZREQEN22 = 0x400000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN22_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN22_1 = 0x1
	// Position of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Pos = 0x11
	// Bit mask of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Msk = 0x20000
	// Bit SNZREQEN17.
	SYSTEM_SNZREQCR_SNZREQEN17 = 0x20000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_1 = 0x1
	// Position of SNZREQEN15 field.
	SYSTEM_SNZREQCR_SNZREQEN15_Pos = 0xf
	// Bit mask of SNZREQEN15 field.
	SYSTEM_SNZREQCR_SNZREQEN15_Msk = 0x8000
	// Bit SNZREQEN15.
	SYSTEM_SNZREQCR_SNZREQEN15 = 0x8000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN15_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN15_1 = 0x1
	// Position of SNZREQEN14 field.
	SYSTEM_SNZREQCR_SNZREQEN14_Pos = 0xe
	// Bit mask of SNZREQEN14 field.
	SYSTEM_SNZREQCR_SNZREQEN14_Msk = 0x4000
	// Bit SNZREQEN14.
	SYSTEM_SNZREQCR_SNZREQEN14 = 0x4000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN14_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN14_1 = 0x1
	// Position of SNZREQEN13 field.
	SYSTEM_SNZREQCR_SNZREQEN13_Pos = 0xd
	// Bit mask of SNZREQEN13 field.
	SYSTEM_SNZREQCR_SNZREQEN13_Msk = 0x2000
	// Bit SNZREQEN13.
	SYSTEM_SNZREQCR_SNZREQEN13 = 0x2000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN13_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN13_1 = 0x1
	// Position of SNZREQEN12 field.
	SYSTEM_SNZREQCR_SNZREQEN12_Pos = 0xc
	// Bit mask of SNZREQEN12 field.
	SYSTEM_SNZREQCR_SNZREQEN12_Msk = 0x1000
	// Bit SNZREQEN12.
	SYSTEM_SNZREQCR_SNZREQEN12 = 0x1000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN12_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN12_1 = 0x1
	// Position of SNZREQEN11 field.
	SYSTEM_SNZREQCR_SNZREQEN11_Pos = 0xb
	// Bit mask of SNZREQEN11 field.
	SYSTEM_SNZREQCR_SNZREQEN11_Msk = 0x800
	// Bit SNZREQEN11.
	SYSTEM_SNZREQCR_SNZREQEN11 = 0x800
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN11_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN11_1 = 0x1
	// Position of SNZREQEN10 field.
	SYSTEM_SNZREQCR_SNZREQEN10_Pos = 0xa
	// Bit mask of SNZREQEN10 field.
	SYSTEM_SNZREQCR_SNZREQEN10_Msk = 0x400
	// Bit SNZREQEN10.
	SYSTEM_SNZREQCR_SNZREQEN10 = 0x400
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN10_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN10_1 = 0x1
	// Position of SNZREQEN9 field.
	SYSTEM_SNZREQCR_SNZREQEN9_Pos = 0x9
	// Bit mask of SNZREQEN9 field.
	SYSTEM_SNZREQCR_SNZREQEN9_Msk = 0x200
	// Bit SNZREQEN9.
	SYSTEM_SNZREQCR_SNZREQEN9 = 0x200
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN9_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN9_1 = 0x1
	// Position of SNZREQEN8 field.
	SYSTEM_SNZREQCR_SNZREQEN8_Pos = 0x8
	// Bit mask of SNZREQEN8 field.
	SYSTEM_SNZREQCR_SNZREQEN8_Msk = 0x100
	// Bit SNZREQEN8.
	SYSTEM_SNZREQCR_SNZREQEN8 = 0x100
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN8_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN8_1 = 0x1
	// Position of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Pos = 0x7
	// Bit mask of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Msk = 0x80
	// Bit SNZREQEN7.
	SYSTEM_SNZREQCR_SNZREQEN7 = 0x80
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_1 = 0x1
	// Position of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Pos = 0x6
	// Bit mask of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Msk = 0x40
	// Bit SNZREQEN6.
	SYSTEM_SNZREQCR_SNZREQEN6 = 0x40
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_1 = 0x1
	// Position of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Pos = 0x5
	// Bit mask of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Msk = 0x20
	// Bit SNZREQEN5.
	SYSTEM_SNZREQCR_SNZREQEN5 = 0x20
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_1 = 0x1
	// Position of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Pos = 0x4
	// Bit mask of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Msk = 0x10
	// Bit SNZREQEN4.
	SYSTEM_SNZREQCR_SNZREQEN4 = 0x10
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_1 = 0x1
	// Position of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Pos = 0x3
	// Bit mask of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Msk = 0x8
	// Bit SNZREQEN3.
	SYSTEM_SNZREQCR_SNZREQEN3 = 0x8
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSTEM_SNZREQCR_SNZREQEN2 = 0x4
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSTEM_SNZREQCR_SNZREQEN1 = 0x2
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSTEM_SNZREQCR_SNZREQEN0 = 0x1
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_1 = 0x1

	// OPCCR: Operating Power Control Register
	// Position of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Pos = 0x4
	// Bit mask of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Msk = 0x10
	// Bit OPCMTSF.
	SYSTEM_OPCCR_OPCMTSF = 0x10
	// Transition completed
	SYSTEM_OPCCR_OPCMTSF_0 = 0x0
	// During transition
	SYSTEM_OPCCR_OPCMTSF_1 = 0x1
	// Position of OPCM field.
	SYSTEM_OPCCR_OPCM_Pos = 0x0
	// Bit mask of OPCM field.
	SYSTEM_OPCCR_OPCM_Msk = 0x3
	// High-speed mode
	SYSTEM_OPCCR_OPCM_00 = 0x0
	// Prohibited
	SYSTEM_OPCCR_OPCM_01 = 0x1
	// Prohibited
	SYSTEM_OPCCR_OPCM_10 = 0x2
	// Low-speed mode
	SYSTEM_OPCCR_OPCM_11 = 0x3

	// MOSCWTCR: Main Clock Oscillator Wait Control Register
	// Position of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Pos = 0x0
	// Bit mask of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Msk = 0xf
	// Wait time = 35 cycles (133.5 s)
	SYSTEM_MOSCWTCR_MSTS_0001 = 0x1
	// Wait time = 67 cycles (255.6 s)
	SYSTEM_MOSCWTCR_MSTS_0010 = 0x2
	// Wait time = 131 cycles (499.7 s)
	SYSTEM_MOSCWTCR_MSTS_0011 = 0x3
	// Wait time = 259 cycles (988.0 s)
	SYSTEM_MOSCWTCR_MSTS_0100 = 0x4
	// Wait time = 547 cycles (2086.6 s) (value after reset)
	SYSTEM_MOSCWTCR_MSTS_0101 = 0x5
	// Wait time = 1059 cycles (4039.8 s)
	SYSTEM_MOSCWTCR_MSTS_0110 = 0x6
	// Wait time = 2147 cycles (8190.2 s)
	SYSTEM_MOSCWTCR_MSTS_0111 = 0x7
	// Wait time = 4291 cycles (16368.9 s)
	SYSTEM_MOSCWTCR_MSTS_1000 = 0x8
	// Wait time = 8163 cycles (31139.4 s).
	SYSTEM_MOSCWTCR_MSTS_1001 = 0x9

	// HOCOWTCR: High-speed on-chip oscillator wait control register
	// Position of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Pos = 0x0
	// Bit mask of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Msk = 0x7

	// SOPCCR: Sub Operating Power Control Register
	// Position of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Pos = 0x4
	// Bit mask of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Msk = 0x10
	// Bit SOPCMTSF.
	SYSTEM_SOPCCR_SOPCMTSF = 0x10
	// Transition completed
	SYSTEM_SOPCCR_SOPCMTSF_0 = 0x0
	// During transition
	SYSTEM_SOPCCR_SOPCMTSF_1 = 0x1
	// Position of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Pos = 0x0
	// Bit mask of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Msk = 0x1
	// Bit SOPCM.
	SYSTEM_SOPCCR_SOPCM = 0x1
	// Other than Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_0 = 0x0
	// Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_1 = 0x1

	// RSTSR1: Reset Status Register 1
	// Position of SPERF field.
	SYSTEM_RSTSR1_SPERF_Pos = 0xc
	// Bit mask of SPERF field.
	SYSTEM_RSTSR1_SPERF_Msk = 0x1000
	// Bit SPERF.
	SYSTEM_RSTSR1_SPERF = 0x1000
	// SP error reset not detected.
	SYSTEM_RSTSR1_SPERF_0 = 0x0
	// SP error reset detected.
	SYSTEM_RSTSR1_SPERF_1 = 0x1
	// Position of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Pos = 0xb
	// Bit mask of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Msk = 0x800
	// Bit BUSMRF.
	SYSTEM_RSTSR1_BUSMRF = 0x800
	// Bus Master MPU reset not detected.
	SYSTEM_RSTSR1_BUSMRF_0 = 0x0
	// Bus Master MPU reset detected.
	SYSTEM_RSTSR1_BUSMRF_1 = 0x1
	// Position of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Pos = 0xa
	// Bit mask of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Msk = 0x400
	// Bit BUSSRF.
	SYSTEM_RSTSR1_BUSSRF = 0x400
	// Bus Slave MPU reset not detected.
	SYSTEM_RSTSR1_BUSSRF_0 = 0x0
	// Bus Slave MPU reset detected.
	SYSTEM_RSTSR1_BUSSRF_1 = 0x1
	// Position of REERF field.
	SYSTEM_RSTSR1_REERF_Pos = 0x9
	// Bit mask of REERF field.
	SYSTEM_RSTSR1_REERF_Msk = 0x200
	// Bit REERF.
	SYSTEM_RSTSR1_REERF = 0x200
	// RAM ECC error reset not detected.
	SYSTEM_RSTSR1_REERF_0 = 0x0
	// RAM ECC error reset detected.
	SYSTEM_RSTSR1_REERF_1 = 0x1
	// Position of RPERF field.
	SYSTEM_RSTSR1_RPERF_Pos = 0x8
	// Bit mask of RPERF field.
	SYSTEM_RSTSR1_RPERF_Msk = 0x100
	// Bit RPERF.
	SYSTEM_RSTSR1_RPERF = 0x100
	// RAM parity error reset not detected.
	SYSTEM_RSTSR1_RPERF_0 = 0x0
	// RAM parity error reset detected.
	SYSTEM_RSTSR1_RPERF_1 = 0x1
	// Position of SWRF field.
	SYSTEM_RSTSR1_SWRF_Pos = 0x2
	// Bit mask of SWRF field.
	SYSTEM_RSTSR1_SWRF_Msk = 0x4
	// Bit SWRF.
	SYSTEM_RSTSR1_SWRF = 0x4
	// Software reset not detected.
	SYSTEM_RSTSR1_SWRF_0 = 0x0
	// Software reset detected.
	SYSTEM_RSTSR1_SWRF_1 = 0x1
	// Position of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Pos = 0x1
	// Bit mask of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Msk = 0x2
	// Bit WDTRF.
	SYSTEM_RSTSR1_WDTRF = 0x2
	// Watchdog timer reset not detected.
	SYSTEM_RSTSR1_WDTRF_0 = 0x0
	// Watchdog timer reset detected.
	SYSTEM_RSTSR1_WDTRF_1 = 0x1
	// Position of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Pos = 0x0
	// Bit mask of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Msk = 0x1
	// Bit IWDTRF.
	SYSTEM_RSTSR1_IWDTRF = 0x1
	// Independent watchdog timer reset not detected.
	SYSTEM_RSTSR1_IWDTRF_0 = 0x0
	// Independent watchdog timer reset detected.
	SYSTEM_RSTSR1_IWDTRF_1 = 0x1

	// LVD1CR1: Voltage Monitor %s Circuit Control Register 1
	// Position of IRQSEL field.
	SYSTEM_LVDCR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSTEM_LVDCR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSTEM_LVDCR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSTEM_LVDCR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSTEM_LVDCR1_IRQSEL_1 = 0x1
	// Position of IDTSEL field.
	SYSTEM_LVDCR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSTEM_LVDCR1_IDTSEL_Msk = 0x3
	// Generate when VCC>=Vdet (rise) is detected
	SYSTEM_LVDCR1_IDTSEL_00 = 0x0
	// Generate when VCC<Vdet (drop) is detected
	SYSTEM_LVDCR1_IDTSEL_01 = 0x1
	// Generate when drop and rise are detected
	SYSTEM_LVDCR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSTEM_LVDCR1_IDTSEL_11 = 0x3

	// LVD1SR: Voltage Monitor %s Circuit Status Register
	// Position of MON field.
	SYSTEM_LVDSR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSTEM_LVDSR_MON_Msk = 0x2
	// Bit MON.
	SYSTEM_LVDSR_MON = 0x2
	// VCC < Vdet
	SYSTEM_LVDSR_MON_0 = 0x0
	// VCC >= Vdet or MON bit is disabled
	SYSTEM_LVDSR_MON_1 = 0x1
	// Position of DET field.
	SYSTEM_LVDSR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSTEM_LVDSR_DET_Msk = 0x1
	// Bit DET.
	SYSTEM_LVDSR_DET = 0x1
	// Not detected
	SYSTEM_LVDSR_DET_0 = 0x0
	// Vdet1 passage detection
	SYSTEM_LVDSR_DET_1 = 0x1

	// PRCR: Protect Register
	// Position of PRKEY field.
	SYSTEM_PRCR_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	SYSTEM_PRCR_PRKEY_Msk = 0xff00
	// Enables writing to the PRCR register.
	SYSTEM_PRCR_PRKEY_0x5A = 0x5a
	// Position of PRC3 field.
	SYSTEM_PRCR_PRC3_Pos = 0x3
	// Bit mask of PRC3 field.
	SYSTEM_PRCR_PRC3_Msk = 0x8
	// Bit PRC3.
	SYSTEM_PRCR_PRC3 = 0x8
	// Writes protected.
	SYSTEM_PRCR_PRC3_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC3_1 = 0x1
	// Position of PRC1 field.
	SYSTEM_PRCR_PRC1_Pos = 0x1
	// Bit mask of PRC1 field.
	SYSTEM_PRCR_PRC1_Msk = 0x2
	// Bit PRC1.
	SYSTEM_PRCR_PRC1 = 0x2
	// Writes protected.
	SYSTEM_PRCR_PRC1_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC1_1 = 0x1
	// Position of PRC0 field.
	SYSTEM_PRCR_PRC0_Pos = 0x0
	// Bit mask of PRC0 field.
	SYSTEM_PRCR_PRC0_Msk = 0x1
	// Bit PRC0.
	SYSTEM_PRCR_PRC0 = 0x1
	// Writes protected.
	SYSTEM_PRCR_PRC0_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC0_1 = 0x1

	// DPSBYCR: Deep Standby Control Register
	// Position of DPSBY field.
	SYSTEM_DPSBYCR_DPSBY_Pos = 0x7
	// Bit mask of DPSBY field.
	SYSTEM_DPSBYCR_DPSBY_Msk = 0x80
	// Bit DPSBY.
	SYSTEM_DPSBYCR_DPSBY = 0x80
	// Sleep mode (SBYCR.SSBY=0) / Software Standby mode (SBYCR.SSBY=1)
	SYSTEM_DPSBYCR_DPSBY_0 = 0x0
	// Sleep mode (SBYCR.SSBY=0) / Deep Software Standby mode (SBYCR.SSBY=1)
	SYSTEM_DPSBYCR_DPSBY_1 = 0x1
	// Position of IOKEEP field.
	SYSTEM_DPSBYCR_IOKEEP_Pos = 0x6
	// Bit mask of IOKEEP field.
	SYSTEM_DPSBYCR_IOKEEP_Msk = 0x40
	// Bit IOKEEP.
	SYSTEM_DPSBYCR_IOKEEP = 0x40
	// When the Deep Software Standby mode is canceled, the I/O ports are in the reset state.
	SYSTEM_DPSBYCR_IOKEEP_0 = 0x0
	// When the Deep Software Standby mode is canceled, the I/O ports are in the same state as in the Deep Software Standby mode.
	SYSTEM_DPSBYCR_IOKEEP_1 = 0x1
	// Position of DEEPCUT field.
	SYSTEM_DPSBYCR_DEEPCUT_Pos = 0x0
	// Bit mask of DEEPCUT field.
	SYSTEM_DPSBYCR_DEEPCUT_Msk = 0x3
	// Power to the standby RAM, Low-speed on-chip oscillator, AGTn, and USBFS/HS resume detecting unit is supplied in deep software standby mode.
	SYSTEM_DPSBYCR_DEEPCUT_00 = 0x0
	// Power to the standby RAM, Low-speed on-chip oscillator, AGTn, and USBFS/HS resume detecting unit is not supplied in deep software standby mode.
	SYSTEM_DPSBYCR_DEEPCUT_01 = 0x1
	// Setting prohibited.
	SYSTEM_DPSBYCR_DEEPCUT_10 = 0x2
	// Power to the standby RAM, Low-speed on-chip oscillator, AGTn, and USBFS/HS resume detecting unit is supplied in deep software standby mode. In addition, LVD is disabled and the low power function in a power-on reset circuit is enabled.
	SYSTEM_DPSBYCR_DEEPCUT_11 = 0x3

	// DPSIER0: Deep Standby Interrupt Enable Register 0
	// Position of DIRQ7E field.
	SYSTEM_DPSIER0_DIRQ7E_Pos = 0x7
	// Bit mask of DIRQ7E field.
	SYSTEM_DPSIER0_DIRQ7E_Msk = 0x80
	// Bit DIRQ7E.
	SYSTEM_DPSIER0_DIRQ7E = 0x80
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ7E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ7E_1 = 0x1
	// Position of DIRQ6E field.
	SYSTEM_DPSIER0_DIRQ6E_Pos = 0x6
	// Bit mask of DIRQ6E field.
	SYSTEM_DPSIER0_DIRQ6E_Msk = 0x40
	// Bit DIRQ6E.
	SYSTEM_DPSIER0_DIRQ6E = 0x40
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ6E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ6E_1 = 0x1
	// Position of DIRQ5E field.
	SYSTEM_DPSIER0_DIRQ5E_Pos = 0x5
	// Bit mask of DIRQ5E field.
	SYSTEM_DPSIER0_DIRQ5E_Msk = 0x20
	// Bit DIRQ5E.
	SYSTEM_DPSIER0_DIRQ5E = 0x20
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ5E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ5E_1 = 0x1
	// Position of DIRQ4E field.
	SYSTEM_DPSIER0_DIRQ4E_Pos = 0x4
	// Bit mask of DIRQ4E field.
	SYSTEM_DPSIER0_DIRQ4E_Msk = 0x10
	// Bit DIRQ4E.
	SYSTEM_DPSIER0_DIRQ4E = 0x10
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ4E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ4E_1 = 0x1
	// Position of DIRQ3E field.
	SYSTEM_DPSIER0_DIRQ3E_Pos = 0x3
	// Bit mask of DIRQ3E field.
	SYSTEM_DPSIER0_DIRQ3E_Msk = 0x8
	// Bit DIRQ3E.
	SYSTEM_DPSIER0_DIRQ3E = 0x8
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ3E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ3E_1 = 0x1
	// Position of DIRQ2E field.
	SYSTEM_DPSIER0_DIRQ2E_Pos = 0x2
	// Bit mask of DIRQ2E field.
	SYSTEM_DPSIER0_DIRQ2E_Msk = 0x4
	// Bit DIRQ2E.
	SYSTEM_DPSIER0_DIRQ2E = 0x4
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ2E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ2E_1 = 0x1
	// Position of DIRQ1E field.
	SYSTEM_DPSIER0_DIRQ1E_Pos = 0x1
	// Bit mask of DIRQ1E field.
	SYSTEM_DPSIER0_DIRQ1E_Msk = 0x2
	// Bit DIRQ1E.
	SYSTEM_DPSIER0_DIRQ1E = 0x2
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ1E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ1E_1 = 0x1
	// Position of DIRQ0E field.
	SYSTEM_DPSIER0_DIRQ0E_Pos = 0x0
	// Bit mask of DIRQ0E field.
	SYSTEM_DPSIER0_DIRQ0E_Msk = 0x1
	// Bit DIRQ0E.
	SYSTEM_DPSIER0_DIRQ0E = 0x1
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER0_DIRQ0E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER0_DIRQ0E_1 = 0x1

	// DPSIER1: Deep Standby Interrupt Enable Register 1
	// Position of DIRQ14E field.
	SYSTEM_DPSIER1_DIRQ14E_Pos = 0x6
	// Bit mask of DIRQ14E field.
	SYSTEM_DPSIER1_DIRQ14E_Msk = 0x40
	// Bit DIRQ14E.
	SYSTEM_DPSIER1_DIRQ14E = 0x40
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ14E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ14E_1 = 0x1
	// Position of DIRQ13E field.
	SYSTEM_DPSIER1_DIRQ13E_Pos = 0x5
	// Bit mask of DIRQ13E field.
	SYSTEM_DPSIER1_DIRQ13E_Msk = 0x20
	// Bit DIRQ13E.
	SYSTEM_DPSIER1_DIRQ13E = 0x20
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ13E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ13E_1 = 0x1
	// Position of DIRQ12E field.
	SYSTEM_DPSIER1_DIRQ12E_Pos = 0x4
	// Bit mask of DIRQ12E field.
	SYSTEM_DPSIER1_DIRQ12E_Msk = 0x10
	// Bit DIRQ12E.
	SYSTEM_DPSIER1_DIRQ12E = 0x10
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ12E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ12E_1 = 0x1
	// Position of DIRQ11E field.
	SYSTEM_DPSIER1_DIRQ11E_Pos = 0x3
	// Bit mask of DIRQ11E field.
	SYSTEM_DPSIER1_DIRQ11E_Msk = 0x8
	// Bit DIRQ11E.
	SYSTEM_DPSIER1_DIRQ11E = 0x8
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ11E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ11E_1 = 0x1
	// Position of DIRQ10E field.
	SYSTEM_DPSIER1_DIRQ10E_Pos = 0x2
	// Bit mask of DIRQ10E field.
	SYSTEM_DPSIER1_DIRQ10E_Msk = 0x4
	// Bit DIRQ10E.
	SYSTEM_DPSIER1_DIRQ10E = 0x4
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ10E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ10E_1 = 0x1
	// Position of DIRQ9E field.
	SYSTEM_DPSIER1_DIRQ9E_Pos = 0x1
	// Bit mask of DIRQ9E field.
	SYSTEM_DPSIER1_DIRQ9E_Msk = 0x2
	// Bit DIRQ9E.
	SYSTEM_DPSIER1_DIRQ9E = 0x2
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ9E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ9E_1 = 0x1
	// Position of DIRQ8E field.
	SYSTEM_DPSIER1_DIRQ8E_Pos = 0x0
	// Bit mask of DIRQ8E field.
	SYSTEM_DPSIER1_DIRQ8E_Msk = 0x1
	// Bit DIRQ8E.
	SYSTEM_DPSIER1_DIRQ8E = 0x1
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER1_DIRQ8E_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER1_DIRQ8E_1 = 0x1

	// DPSIER2: Deep Standby Interrupt Enable Register 2
	// Position of DNMIE field.
	SYSTEM_DPSIER2_DNMIE_Pos = 0x4
	// Bit mask of DNMIE field.
	SYSTEM_DPSIER2_DNMIE_Msk = 0x10
	// Bit DNMIE.
	SYSTEM_DPSIER2_DNMIE = 0x10
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER2_DNMIE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER2_DNMIE_1 = 0x1
	// Position of DRTCAIE field.
	SYSTEM_DPSIER2_DRTCAIE_Pos = 0x3
	// Bit mask of DRTCAIE field.
	SYSTEM_DPSIER2_DRTCAIE_Msk = 0x8
	// Bit DRTCAIE.
	SYSTEM_DPSIER2_DRTCAIE = 0x8
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER2_DRTCAIE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER2_DRTCAIE_1 = 0x1
	// Position of DTRTCIIE field.
	SYSTEM_DPSIER2_DTRTCIIE_Pos = 0x2
	// Bit mask of DTRTCIIE field.
	SYSTEM_DPSIER2_DTRTCIIE_Msk = 0x4
	// Bit DTRTCIIE.
	SYSTEM_DPSIER2_DTRTCIIE = 0x4
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER2_DTRTCIIE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER2_DTRTCIIE_1 = 0x1
	// Position of DLVD2IE field.
	SYSTEM_DPSIER2_DLVD2IE_Pos = 0x1
	// Bit mask of DLVD2IE field.
	SYSTEM_DPSIER2_DLVD2IE_Msk = 0x2
	// Bit DLVD2IE.
	SYSTEM_DPSIER2_DLVD2IE = 0x2
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER2_DLVD2IE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER2_DLVD2IE_1 = 0x1
	// Position of DLVD1IE field.
	SYSTEM_DPSIER2_DLVD1IE_Pos = 0x0
	// Bit mask of DLVD1IE field.
	SYSTEM_DPSIER2_DLVD1IE_Msk = 0x1
	// Bit DLVD1IE.
	SYSTEM_DPSIER2_DLVD1IE = 0x1
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER2_DLVD1IE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER2_DLVD1IE_1 = 0x1

	// DPSIER3: Deep Standby Interrupt Enable Register 3
	// Position of DAGT1IE field.
	SYSTEM_DPSIER3_DAGT1IE_Pos = 0x2
	// Bit mask of DAGT1IE field.
	SYSTEM_DPSIER3_DAGT1IE_Msk = 0x4
	// Bit DAGT1IE.
	SYSTEM_DPSIER3_DAGT1IE = 0x4
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER3_DAGT1IE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER3_DAGT1IE_1 = 0x1
	// Position of DUSBHSIE field.
	SYSTEM_DPSIER3_DUSBHSIE_Pos = 0x1
	// Bit mask of DUSBHSIE field.
	SYSTEM_DPSIER3_DUSBHSIE_Msk = 0x2
	// Bit DUSBHSIE.
	SYSTEM_DPSIER3_DUSBHSIE = 0x2
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER3_DUSBHSIE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER3_DUSBHSIE_1 = 0x1
	// Position of DUSBFSIE field.
	SYSTEM_DPSIER3_DUSBFSIE_Pos = 0x0
	// Bit mask of DUSBFSIE field.
	SYSTEM_DPSIER3_DUSBFSIE_Msk = 0x1
	// Bit DUSBFSIE.
	SYSTEM_DPSIER3_DUSBFSIE = 0x1
	// Canceling deep software standby mode is disabled
	SYSTEM_DPSIER3_DUSBFSIE_0 = 0x0
	// Canceling deep software standby mode is enabled
	SYSTEM_DPSIER3_DUSBFSIE_1 = 0x1

	// DPSIFR0: Deep Standby Interrupt Flag Register 0
	// Position of DIRQ7F field.
	SYSTEM_DPSIFR0_DIRQ7F_Pos = 0x7
	// Bit mask of DIRQ7F field.
	SYSTEM_DPSIFR0_DIRQ7F_Msk = 0x80
	// Bit DIRQ7F.
	SYSTEM_DPSIFR0_DIRQ7F = 0x80
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ7F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ7F_1 = 0x1
	// Position of DIRQ6F field.
	SYSTEM_DPSIFR0_DIRQ6F_Pos = 0x6
	// Bit mask of DIRQ6F field.
	SYSTEM_DPSIFR0_DIRQ6F_Msk = 0x40
	// Bit DIRQ6F.
	SYSTEM_DPSIFR0_DIRQ6F = 0x40
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ6F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ6F_1 = 0x1
	// Position of DIRQ5F field.
	SYSTEM_DPSIFR0_DIRQ5F_Pos = 0x5
	// Bit mask of DIRQ5F field.
	SYSTEM_DPSIFR0_DIRQ5F_Msk = 0x20
	// Bit DIRQ5F.
	SYSTEM_DPSIFR0_DIRQ5F = 0x20
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ5F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ5F_1 = 0x1
	// Position of DIRQ4F field.
	SYSTEM_DPSIFR0_DIRQ4F_Pos = 0x4
	// Bit mask of DIRQ4F field.
	SYSTEM_DPSIFR0_DIRQ4F_Msk = 0x10
	// Bit DIRQ4F.
	SYSTEM_DPSIFR0_DIRQ4F = 0x10
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ4F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ4F_1 = 0x1
	// Position of DIRQ3F field.
	SYSTEM_DPSIFR0_DIRQ3F_Pos = 0x3
	// Bit mask of DIRQ3F field.
	SYSTEM_DPSIFR0_DIRQ3F_Msk = 0x8
	// Bit DIRQ3F.
	SYSTEM_DPSIFR0_DIRQ3F = 0x8
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ3F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ3F_1 = 0x1
	// Position of DIRQ2F field.
	SYSTEM_DPSIFR0_DIRQ2F_Pos = 0x2
	// Bit mask of DIRQ2F field.
	SYSTEM_DPSIFR0_DIRQ2F_Msk = 0x4
	// Bit DIRQ2F.
	SYSTEM_DPSIFR0_DIRQ2F = 0x4
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ2F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ2F_1 = 0x1
	// Position of DIRQ1F field.
	SYSTEM_DPSIFR0_DIRQ1F_Pos = 0x1
	// Bit mask of DIRQ1F field.
	SYSTEM_DPSIFR0_DIRQ1F_Msk = 0x2
	// Bit DIRQ1F.
	SYSTEM_DPSIFR0_DIRQ1F = 0x2
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ1F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ1F_1 = 0x1
	// Position of DIRQ0F field.
	SYSTEM_DPSIFR0_DIRQ0F_Pos = 0x0
	// Bit mask of DIRQ0F field.
	SYSTEM_DPSIFR0_DIRQ0F_Msk = 0x1
	// Bit DIRQ0F.
	SYSTEM_DPSIFR0_DIRQ0F = 0x1
	// The cancel request is not generated
	SYSTEM_DPSIFR0_DIRQ0F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR0_DIRQ0F_1 = 0x1

	// DPSIFR1: Deep Standby Interrupt Flag Register 1
	// Position of DIRQ14F field.
	SYSTEM_DPSIFR1_DIRQ14F_Pos = 0x6
	// Bit mask of DIRQ14F field.
	SYSTEM_DPSIFR1_DIRQ14F_Msk = 0x40
	// Bit DIRQ14F.
	SYSTEM_DPSIFR1_DIRQ14F = 0x40
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ14F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ14F_1 = 0x1
	// Position of DIRQ13F field.
	SYSTEM_DPSIFR1_DIRQ13F_Pos = 0x5
	// Bit mask of DIRQ13F field.
	SYSTEM_DPSIFR1_DIRQ13F_Msk = 0x20
	// Bit DIRQ13F.
	SYSTEM_DPSIFR1_DIRQ13F = 0x20
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ13F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ13F_1 = 0x1
	// Position of DIRQ12F field.
	SYSTEM_DPSIFR1_DIRQ12F_Pos = 0x4
	// Bit mask of DIRQ12F field.
	SYSTEM_DPSIFR1_DIRQ12F_Msk = 0x10
	// Bit DIRQ12F.
	SYSTEM_DPSIFR1_DIRQ12F = 0x10
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ12F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ12F_1 = 0x1
	// Position of DIRQ11F field.
	SYSTEM_DPSIFR1_DIRQ11F_Pos = 0x3
	// Bit mask of DIRQ11F field.
	SYSTEM_DPSIFR1_DIRQ11F_Msk = 0x8
	// Bit DIRQ11F.
	SYSTEM_DPSIFR1_DIRQ11F = 0x8
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ11F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ11F_1 = 0x1
	// Position of DIRQ10F field.
	SYSTEM_DPSIFR1_DIRQ10F_Pos = 0x2
	// Bit mask of DIRQ10F field.
	SYSTEM_DPSIFR1_DIRQ10F_Msk = 0x4
	// Bit DIRQ10F.
	SYSTEM_DPSIFR1_DIRQ10F = 0x4
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ10F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ10F_1 = 0x1
	// Position of DIRQ9F field.
	SYSTEM_DPSIFR1_DIRQ9F_Pos = 0x1
	// Bit mask of DIRQ9F field.
	SYSTEM_DPSIFR1_DIRQ9F_Msk = 0x2
	// Bit DIRQ9F.
	SYSTEM_DPSIFR1_DIRQ9F = 0x2
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ9F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ9F_1 = 0x1
	// Position of DIRQ8F field.
	SYSTEM_DPSIFR1_DIRQ8F_Pos = 0x0
	// Bit mask of DIRQ8F field.
	SYSTEM_DPSIFR1_DIRQ8F_Msk = 0x1
	// Bit DIRQ8F.
	SYSTEM_DPSIFR1_DIRQ8F = 0x1
	// The cancel request is not generated
	SYSTEM_DPSIFR1_DIRQ8F_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR1_DIRQ8F_1 = 0x1

	// DPSIFR2: Deep Standby Interrupt Flag Register 2
	// Position of DNMIF field.
	SYSTEM_DPSIFR2_DNMIF_Pos = 0x4
	// Bit mask of DNMIF field.
	SYSTEM_DPSIFR2_DNMIF_Msk = 0x10
	// Bit DNMIF.
	SYSTEM_DPSIFR2_DNMIF = 0x10
	// The cancel request is not generated
	SYSTEM_DPSIFR2_DNMIF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR2_DNMIF_1 = 0x1
	// Position of DRTCAIF field.
	SYSTEM_DPSIFR2_DRTCAIF_Pos = 0x3
	// Bit mask of DRTCAIF field.
	SYSTEM_DPSIFR2_DRTCAIF_Msk = 0x8
	// Bit DRTCAIF.
	SYSTEM_DPSIFR2_DRTCAIF = 0x8
	// The cancel request is not generated
	SYSTEM_DPSIFR2_DRTCAIF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR2_DRTCAIF_1 = 0x1
	// Position of DTRTCIIF field.
	SYSTEM_DPSIFR2_DTRTCIIF_Pos = 0x2
	// Bit mask of DTRTCIIF field.
	SYSTEM_DPSIFR2_DTRTCIIF_Msk = 0x4
	// Bit DTRTCIIF.
	SYSTEM_DPSIFR2_DTRTCIIF = 0x4
	// The cancel request is not generated
	SYSTEM_DPSIFR2_DTRTCIIF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR2_DTRTCIIF_1 = 0x1
	// Position of DLVD2IF field.
	SYSTEM_DPSIFR2_DLVD2IF_Pos = 0x1
	// Bit mask of DLVD2IF field.
	SYSTEM_DPSIFR2_DLVD2IF_Msk = 0x2
	// Bit DLVD2IF.
	SYSTEM_DPSIFR2_DLVD2IF = 0x2
	// The cancel request is not generated
	SYSTEM_DPSIFR2_DLVD2IF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR2_DLVD2IF_1 = 0x1
	// Position of DLVD1IF field.
	SYSTEM_DPSIFR2_DLVD1IF_Pos = 0x0
	// Bit mask of DLVD1IF field.
	SYSTEM_DPSIFR2_DLVD1IF_Msk = 0x1
	// Bit DLVD1IF.
	SYSTEM_DPSIFR2_DLVD1IF = 0x1
	// The cancel request is not generated
	SYSTEM_DPSIFR2_DLVD1IF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR2_DLVD1IF_1 = 0x1

	// DPSIFR3: Deep Standby Interrupt Flag Register 3
	// Position of DAGT1IF field.
	SYSTEM_DPSIFR3_DAGT1IF_Pos = 0x2
	// Bit mask of DAGT1IF field.
	SYSTEM_DPSIFR3_DAGT1IF_Msk = 0x4
	// Bit DAGT1IF.
	SYSTEM_DPSIFR3_DAGT1IF = 0x4
	// The cancel request is not generated
	SYSTEM_DPSIFR3_DAGT1IF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR3_DAGT1IF_1 = 0x1
	// Position of DUSBHSIF field.
	SYSTEM_DPSIFR3_DUSBHSIF_Pos = 0x1
	// Bit mask of DUSBHSIF field.
	SYSTEM_DPSIFR3_DUSBHSIF_Msk = 0x2
	// Bit DUSBHSIF.
	SYSTEM_DPSIFR3_DUSBHSIF = 0x2
	// The cancel request is not generated
	SYSTEM_DPSIFR3_DUSBHSIF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR3_DUSBHSIF_1 = 0x1
	// Position of DUSBFSIF field.
	SYSTEM_DPSIFR3_DUSBFSIF_Pos = 0x0
	// Bit mask of DUSBFSIF field.
	SYSTEM_DPSIFR3_DUSBFSIF_Msk = 0x1
	// Bit DUSBFSIF.
	SYSTEM_DPSIFR3_DUSBFSIF = 0x1
	// The cancel request is not generated
	SYSTEM_DPSIFR3_DUSBFSIF_0 = 0x0
	// The cancel request is generated
	SYSTEM_DPSIFR3_DUSBFSIF_1 = 0x1

	// DPSIEGR0: Deep Standby Interrupt Edge Register 0
	// Position of DIRQ7EG field.
	SYSTEM_DPSIEGR0_DIRQ7EG_Pos = 0x7
	// Bit mask of DIRQ7EG field.
	SYSTEM_DPSIEGR0_DIRQ7EG_Msk = 0x80
	// Bit DIRQ7EG.
	SYSTEM_DPSIEGR0_DIRQ7EG = 0x80
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ7EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ7EG_1 = 0x1
	// Position of DIRQ6EG field.
	SYSTEM_DPSIEGR0_DIRQ6EG_Pos = 0x6
	// Bit mask of DIRQ6EG field.
	SYSTEM_DPSIEGR0_DIRQ6EG_Msk = 0x40
	// Bit DIRQ6EG.
	SYSTEM_DPSIEGR0_DIRQ6EG = 0x40
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ6EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ6EG_1 = 0x1
	// Position of DIRQ5EG field.
	SYSTEM_DPSIEGR0_DIRQ5EG_Pos = 0x5
	// Bit mask of DIRQ5EG field.
	SYSTEM_DPSIEGR0_DIRQ5EG_Msk = 0x20
	// Bit DIRQ5EG.
	SYSTEM_DPSIEGR0_DIRQ5EG = 0x20
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ5EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ5EG_1 = 0x1
	// Position of DIRQ4EG field.
	SYSTEM_DPSIEGR0_DIRQ4EG_Pos = 0x4
	// Bit mask of DIRQ4EG field.
	SYSTEM_DPSIEGR0_DIRQ4EG_Msk = 0x10
	// Bit DIRQ4EG.
	SYSTEM_DPSIEGR0_DIRQ4EG = 0x10
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ4EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ4EG_1 = 0x1
	// Position of DIRQ3EG field.
	SYSTEM_DPSIEGR0_DIRQ3EG_Pos = 0x3
	// Bit mask of DIRQ3EG field.
	SYSTEM_DPSIEGR0_DIRQ3EG_Msk = 0x8
	// Bit DIRQ3EG.
	SYSTEM_DPSIEGR0_DIRQ3EG = 0x8
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ3EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ3EG_1 = 0x1
	// Position of DIRQ2EG field.
	SYSTEM_DPSIEGR0_DIRQ2EG_Pos = 0x2
	// Bit mask of DIRQ2EG field.
	SYSTEM_DPSIEGR0_DIRQ2EG_Msk = 0x4
	// Bit DIRQ2EG.
	SYSTEM_DPSIEGR0_DIRQ2EG = 0x4
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ2EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ2EG_1 = 0x1
	// Position of DIRQ1EG field.
	SYSTEM_DPSIEGR0_DIRQ1EG_Pos = 0x1
	// Bit mask of DIRQ1EG field.
	SYSTEM_DPSIEGR0_DIRQ1EG_Msk = 0x2
	// Bit DIRQ1EG.
	SYSTEM_DPSIEGR0_DIRQ1EG = 0x2
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ1EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ1EG_1 = 0x1
	// Position of DIRQ0EG field.
	SYSTEM_DPSIEGR0_DIRQ0EG_Pos = 0x0
	// Bit mask of DIRQ0EG field.
	SYSTEM_DPSIEGR0_DIRQ0EG_Msk = 0x1
	// Bit DIRQ0EG.
	SYSTEM_DPSIEGR0_DIRQ0EG = 0x1
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR0_DIRQ0EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR0_DIRQ0EG_1 = 0x1

	// DPSIEGR1: Deep Standby Interrupt Edge Register 1
	// Position of DIRQ14EG field.
	SYSTEM_DPSIEGR1_DIRQ14EG_Pos = 0x6
	// Bit mask of DIRQ14EG field.
	SYSTEM_DPSIEGR1_DIRQ14EG_Msk = 0x40
	// Bit DIRQ14EG.
	SYSTEM_DPSIEGR1_DIRQ14EG = 0x40
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ14EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ14EG_1 = 0x1
	// Position of DIRQ13EG field.
	SYSTEM_DPSIEGR1_DIRQ13EG_Pos = 0x5
	// Bit mask of DIRQ13EG field.
	SYSTEM_DPSIEGR1_DIRQ13EG_Msk = 0x20
	// Bit DIRQ13EG.
	SYSTEM_DPSIEGR1_DIRQ13EG = 0x20
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ13EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ13EG_1 = 0x1
	// Position of DIRQ12EG field.
	SYSTEM_DPSIEGR1_DIRQ12EG_Pos = 0x4
	// Bit mask of DIRQ12EG field.
	SYSTEM_DPSIEGR1_DIRQ12EG_Msk = 0x10
	// Bit DIRQ12EG.
	SYSTEM_DPSIEGR1_DIRQ12EG = 0x10
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ12EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ12EG_1 = 0x1
	// Position of DIRQ11EG field.
	SYSTEM_DPSIEGR1_DIRQ11EG_Pos = 0x3
	// Bit mask of DIRQ11EG field.
	SYSTEM_DPSIEGR1_DIRQ11EG_Msk = 0x8
	// Bit DIRQ11EG.
	SYSTEM_DPSIEGR1_DIRQ11EG = 0x8
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ11EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ11EG_1 = 0x1
	// Position of DIRQ10EG field.
	SYSTEM_DPSIEGR1_DIRQ10EG_Pos = 0x2
	// Bit mask of DIRQ10EG field.
	SYSTEM_DPSIEGR1_DIRQ10EG_Msk = 0x4
	// Bit DIRQ10EG.
	SYSTEM_DPSIEGR1_DIRQ10EG = 0x4
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ10EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ10EG_1 = 0x1
	// Position of DIRQ9EG field.
	SYSTEM_DPSIEGR1_DIRQ9EG_Pos = 0x1
	// Bit mask of DIRQ9EG field.
	SYSTEM_DPSIEGR1_DIRQ9EG_Msk = 0x2
	// Bit DIRQ9EG.
	SYSTEM_DPSIEGR1_DIRQ9EG = 0x2
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ9EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ9EG_1 = 0x1
	// Position of DIRQ8EG field.
	SYSTEM_DPSIEGR1_DIRQ8EG_Pos = 0x0
	// Bit mask of DIRQ8EG field.
	SYSTEM_DPSIEGR1_DIRQ8EG_Msk = 0x1
	// Bit DIRQ8EG.
	SYSTEM_DPSIEGR1_DIRQ8EG = 0x1
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR1_DIRQ8EG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR1_DIRQ8EG_1 = 0x1

	// DPSIEGR2: Deep Standby Interrupt Edge Register 2
	// Position of DNMIEG field.
	SYSTEM_DPSIEGR2_DNMIEG_Pos = 0x4
	// Bit mask of DNMIEG field.
	SYSTEM_DPSIEGR2_DNMIEG_Msk = 0x10
	// Bit DNMIEG.
	SYSTEM_DPSIEGR2_DNMIEG = 0x10
	// A cancel request is generated at a falling edge
	SYSTEM_DPSIEGR2_DNMIEG_0 = 0x0
	// A cancel request is generated at a rising edge
	SYSTEM_DPSIEGR2_DNMIEG_1 = 0x1
	// Position of DLVD2IEG field.
	SYSTEM_DPSIEGR2_DLVD2IEG_Pos = 0x1
	// Bit mask of DLVD2IEG field.
	SYSTEM_DPSIEGR2_DLVD2IEG_Msk = 0x2
	// Bit DLVD2IEG.
	SYSTEM_DPSIEGR2_DLVD2IEG = 0x2
	// A cancel request is generated when VCC<Vdet2 (fall) is detected
	SYSTEM_DPSIEGR2_DLVD2IEG_0 = 0x0
	// A cancel request is generated when VCC>=Vdet2 (rise) is detected
	SYSTEM_DPSIEGR2_DLVD2IEG_1 = 0x1
	// Position of DLVD1IEG field.
	SYSTEM_DPSIEGR2_DLVD1IEG_Pos = 0x0
	// Bit mask of DLVD1IEG field.
	SYSTEM_DPSIEGR2_DLVD1IEG_Msk = 0x1
	// Bit DLVD1IEG.
	SYSTEM_DPSIEGR2_DLVD1IEG = 0x1
	// A cancel request is generated when VCC<Vdet1 (fall) is detected
	SYSTEM_DPSIEGR2_DLVD1IEG_0 = 0x0
	// A cancel request is generated when VCC>=Vdet1 (rise) is detected
	SYSTEM_DPSIEGR2_DLVD1IEG_1 = 0x1

	// SYOCDCR: System Control OCD Control Register
	// Position of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Pos = 0x7
	// Bit mask of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Msk = 0x80
	// Bit DBGEN.
	SYSTEM_SYOCDCR_DBGEN = 0x80
	// On-chip debugger is disabled
	SYSTEM_SYOCDCR_DBGEN_0 = 0x0
	// On-chip debugger is enabled
	SYSTEM_SYOCDCR_DBGEN_1 = 0x1
	// Position of DOCDF field.
	SYSTEM_SYOCDCR_DOCDF_Pos = 0x0
	// Bit mask of DOCDF field.
	SYSTEM_SYOCDCR_DOCDF_Msk = 0x1
	// Bit DOCDF.
	SYSTEM_SYOCDCR_DOCDF = 0x1
	// On-chip debugger is disabled
	SYSTEM_SYOCDCR_DOCDF_0 = 0x0
	// On-chip debugger is enabled
	SYSTEM_SYOCDCR_DOCDF_1 = 0x1

	// STCONR: Standby Condition Register
	// Position of STCON field.
	SYSTEM_STCONR_STCON_Pos = 0x0
	// Bit mask of STCON field.
	SYSTEM_STCONR_STCON_Msk = 0x3
	// set this value in case of transferring to Software Standby Mode in using HOCO.
	SYSTEM_STCONR_STCON_00 = 0x0
	// set this value in case of transferring to Software Standby Mode in using expect for HOCO.
	SYSTEM_STCONR_STCON_11 = 0x3

	// RSTSR0: Reset Status Register 0
	// Position of DPSRSTF field.
	SYSTEM_RSTSR0_DPSRSTF_Pos = 0x7
	// Bit mask of DPSRSTF field.
	SYSTEM_RSTSR0_DPSRSTF_Msk = 0x80
	// Bit DPSRSTF.
	SYSTEM_RSTSR0_DPSRSTF = 0x80
	// Deep software standby mode cancelation not requested by an interrupt.
	SYSTEM_RSTSR0_DPSRSTF_0 = 0x0
	// Deep software standby mode cancelation requested by an interrupt.
	SYSTEM_RSTSR0_DPSRSTF_1 = 0x1
	// Position of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Pos = 0x3
	// Bit mask of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Msk = 0x8
	// Bit LVD2RF.
	SYSTEM_RSTSR0_LVD2RF = 0x8
	// Voltage Monitor 2 reset not detected.
	SYSTEM_RSTSR0_LVD2RF_0 = 0x0
	// Voltage Monitor 2 reset detected.
	SYSTEM_RSTSR0_LVD2RF_1 = 0x1
	// Position of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Pos = 0x2
	// Bit mask of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Msk = 0x4
	// Bit LVD1RF.
	SYSTEM_RSTSR0_LVD1RF = 0x4
	// Voltage Monitor 1 reset not detected.
	SYSTEM_RSTSR0_LVD1RF_0 = 0x0
	// Voltage Monitor 1 reset detected.
	SYSTEM_RSTSR0_LVD1RF_1 = 0x1
	// Position of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Pos = 0x1
	// Bit mask of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Msk = 0x2
	// Bit LVD0RF.
	SYSTEM_RSTSR0_LVD0RF = 0x2
	// Voltage Monitor 0 reset not detected.
	SYSTEM_RSTSR0_LVD0RF_0 = 0x0
	// Voltage Monitor 0 reset detected.
	SYSTEM_RSTSR0_LVD0RF_1 = 0x1
	// Position of PORF field.
	SYSTEM_RSTSR0_PORF_Pos = 0x0
	// Bit mask of PORF field.
	SYSTEM_RSTSR0_PORF_Msk = 0x1
	// Bit PORF.
	SYSTEM_RSTSR0_PORF = 0x1
	// Power-on reset not detected.
	SYSTEM_RSTSR0_PORF_0 = 0x0
	// Power-on reset detected.
	SYSTEM_RSTSR0_PORF_1 = 0x1

	// RSTSR2: Reset Status Register 2
	// Position of CWSF field.
	SYSTEM_RSTSR2_CWSF_Pos = 0x0
	// Bit mask of CWSF field.
	SYSTEM_RSTSR2_CWSF_Msk = 0x1
	// Bit CWSF.
	SYSTEM_RSTSR2_CWSF = 0x1
	// Cold start
	SYSTEM_RSTSR2_CWSF_0 = 0x0
	// Warm start
	SYSTEM_RSTSR2_CWSF_1 = 0x1

	// MOMCR: Main Clock Oscillator Mode Oscillation Control Register
	// Position of AUTODRVEN field.
	SYSTEM_MOMCR_AUTODRVEN_Pos = 0x7
	// Bit mask of AUTODRVEN field.
	SYSTEM_MOMCR_AUTODRVEN_Msk = 0x80
	// Bit AUTODRVEN.
	SYSTEM_MOMCR_AUTODRVEN = 0x80
	// Disable
	SYSTEM_MOMCR_AUTODRVEN_0 = 0x0
	// Enable.
	SYSTEM_MOMCR_AUTODRVEN_1 = 0x1
	// Position of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Pos = 0x6
	// Bit mask of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Msk = 0x40
	// Bit MOSEL.
	SYSTEM_MOMCR_MOSEL = 0x40
	// Resonator
	SYSTEM_MOMCR_MOSEL_0 = 0x0
	// External clock input
	SYSTEM_MOMCR_MOSEL_1 = 0x1
	// Position of MODRV0 field.
	SYSTEM_MOMCR_MODRV0_Pos = 0x4
	// Bit mask of MODRV0 field.
	SYSTEM_MOMCR_MODRV0_Msk = 0x30
	// 20MHz to 24MHz
	SYSTEM_MOMCR_MODRV0_00 = 0x0
	// 16MHz to 20MHz
	SYSTEM_MOMCR_MODRV0_01 = 0x1
	// 8MHz to 16MHz
	SYSTEM_MOMCR_MODRV0_10 = 0x2
	// 8MHz
	SYSTEM_MOMCR_MODRV0_11 = 0x3

	// FWEPROR: Flash P/E Protect Register
	// Position of FLWE field.
	SYSTEM_FWEPROR_FLWE_Pos = 0x0
	// Bit mask of FLWE field.
	SYSTEM_FWEPROR_FLWE_Msk = 0x3
	// Prohibits programming and erasure of the code flash, data flash or blank checking.
	SYSTEM_FWEPROR_FLWE_00 = 0x0
	// Permits programming and erasure of the code flash, data flash or blank checking.
	SYSTEM_FWEPROR_FLWE_01 = 0x1
	// Prohibits programming and erasure of the code flash, data flash or blank checking.
	SYSTEM_FWEPROR_FLWE_10 = 0x2
	// Prohibits programming and erasure of the code flash, data flash or blank checking.
	SYSTEM_FWEPROR_FLWE_11 = 0x3

	// LVCMPCR: Voltage Monitor Circuit Control Register
	// Position of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Pos = 0x6
	// Bit mask of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Msk = 0x40
	// Bit LVD2E.
	SYSTEM_LVCMPCR_LVD2E = 0x40
	// Voltage detection 2 circuit disabled
	SYSTEM_LVCMPCR_LVD2E_0 = 0x0
	// Voltage detection 2 circuit enabled
	SYSTEM_LVCMPCR_LVD2E_1 = 0x1
	// Position of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Pos = 0x5
	// Bit mask of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Msk = 0x20
	// Bit LVD1E.
	SYSTEM_LVCMPCR_LVD1E = 0x20
	// Voltage detection 1 circuit disabled
	SYSTEM_LVCMPCR_LVD1E_0 = 0x0
	// Voltage detection 1 circuit enabled
	SYSTEM_LVCMPCR_LVD1E_1 = 0x1

	// LVDLVLR: Voltage Detection Level Select Register
	// Position of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Pos = 0x5
	// Bit mask of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Msk = 0xe0
	// 2.99V (Vdet2_1)
	SYSTEM_LVDLVLR_LVD2LVL_101 = 0x5
	// 2.92V (Vdet2_2)
	SYSTEM_LVDLVLR_LVD2LVL_110 = 0x6
	// 2.85V (Vdet2_3)
	SYSTEM_LVDLVLR_LVD2LVL_111 = 0x7
	// Position of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Pos = 0x0
	// Bit mask of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Msk = 0x1f
	// 2.99V (Vdet1_1)
	SYSTEM_LVDLVLR_LVD1LVL_10001 = 0x11
	// 2.92V (Vdet1_2)
	SYSTEM_LVDLVLR_LVD1LVL_10010 = 0x12
	// 2.85V (Vdet1_3)
	SYSTEM_LVDLVLR_LVD1LVL_10011 = 0x13

	// LVD1CR0: Voltage Monitor %s Circuit Control Register 0
	// Position of RN field.
	SYSTEM_LVDCR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSTEM_LVDCR0_RN_Msk = 0x80
	// Bit RN.
	SYSTEM_LVDCR0_RN = 0x80
	// Negation follows a stabilization time (tLVD) after VCC > Vdet is detected.
	SYSTEM_LVDCR0_RN_0 = 0x0
	// Negation follows a stabilization time (tLVD) after assertion of the LVD reset.
	SYSTEM_LVDCR0_RN_1 = 0x1
	// Position of RI field.
	SYSTEM_LVDCR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSTEM_LVDCR0_RI_Msk = 0x40
	// Bit RI.
	SYSTEM_LVDCR0_RI = 0x40
	// Voltage Monitor interrupt during Vdet1 passage
	SYSTEM_LVDCR0_RI_0 = 0x0
	// Voltage Monitor reset enabled when the voltage falls to and below Vdet1
	SYSTEM_LVDCR0_RI_1 = 0x1
	// Position of FSAMP field.
	SYSTEM_LVDCR0_FSAMP_Pos = 0x4
	// Bit mask of FSAMP field.
	SYSTEM_LVDCR0_FSAMP_Msk = 0x30
	// 1/2 LOCO frequency
	SYSTEM_LVDCR0_FSAMP_00 = 0x0
	// 1/4 LOCO frequency
	SYSTEM_LVDCR0_FSAMP_01 = 0x1
	// 1/8 LOCO frequency
	SYSTEM_LVDCR0_FSAMP_10 = 0x2
	// 1/16 LOCO frequency
	SYSTEM_LVDCR0_FSAMP_11 = 0x3
	// Position of CMPE field.
	SYSTEM_LVDCR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSTEM_LVDCR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSTEM_LVDCR0_CMPE = 0x4
	// Disable voltage monitor 1 circuit comparison result output
	SYSTEM_LVDCR0_CMPE_0 = 0x0
	// Enable voltage monitor 1 circuit comparison result output.
	SYSTEM_LVDCR0_CMPE_1 = 0x1
	// Position of DFDIS field.
	SYSTEM_LVDCR0_DFDIS_Pos = 0x1
	// Bit mask of DFDIS field.
	SYSTEM_LVDCR0_DFDIS_Msk = 0x2
	// Bit DFDIS.
	SYSTEM_LVDCR0_DFDIS = 0x2
	// Enable digital filter
	SYSTEM_LVDCR0_DFDIS_0 = 0x0
	// Disable digital filter
	SYSTEM_LVDCR0_DFDIS_1 = 0x1
	// Position of RIE field.
	SYSTEM_LVDCR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSTEM_LVDCR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSTEM_LVDCR0_RIE = 0x1
	// Disable
	SYSTEM_LVDCR0_RIE_0 = 0x0
	// Enable
	SYSTEM_LVDCR0_RIE_1 = 0x1

	// SOSCCR: Sub-clock oscillator control register
	// Position of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Pos = 0x0
	// Bit mask of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Msk = 0x1
	// Bit SOSTP.
	SYSTEM_SOSCCR_SOSTP = 0x1
	// Operate the sub-clock oscillator
	SYSTEM_SOSCCR_SOSTP_0 = 0x0
	// Stop the sub-clock oscillator
	SYSTEM_SOSCCR_SOSTP_1 = 0x1

	// SOMCR: Sub Clock Oscillator Mode Control Register
	// Position of SODRV1 field.
	SYSTEM_SOMCR_SODRV1_Pos = 0x1
	// Bit mask of SODRV1 field.
	SYSTEM_SOMCR_SODRV1_Msk = 0x2
	// Bit SODRV1.
	SYSTEM_SOMCR_SODRV1 = 0x2
	// Standard
	SYSTEM_SOMCR_SODRV1_0 = 0x0
	// Middle
	SYSTEM_SOMCR_SODRV1_1 = 0x1

	// LOCOCR: Low-Speed On-Chip Oscillator Control Register
	// Position of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Pos = 0x0
	// Bit mask of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Msk = 0x1
	// Bit LCSTP.
	SYSTEM_LOCOCR_LCSTP = 0x1
	// Operate the LOCO clock
	SYSTEM_LOCOCR_LCSTP_0 = 0x0
	// Stop the LOCO clock
	SYSTEM_LOCOCR_LCSTP_1 = 0x1

	// LOCOUTCR: LOCO User Trimming Control Register
	// Position of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Pos = 0x0
	// Bit mask of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Msk = 0xff

	// VBTICTLR: VBATT Input Control Register
	// Position of VCH2INEN field.
	SYSTEM_VBTICTLR_VCH2INEN_Pos = 0x2
	// Bit mask of VCH2INEN field.
	SYSTEM_VBTICTLR_VCH2INEN_Msk = 0x4
	// Bit VCH2INEN.
	SYSTEM_VBTICTLR_VCH2INEN = 0x4
	// Disabled
	SYSTEM_VBTICTLR_VCH2INEN_0 = 0x0
	// Enabled
	SYSTEM_VBTICTLR_VCH2INEN_1 = 0x1
	// Position of VCH1INEN field.
	SYSTEM_VBTICTLR_VCH1INEN_Pos = 0x1
	// Bit mask of VCH1INEN field.
	SYSTEM_VBTICTLR_VCH1INEN_Msk = 0x2
	// Bit VCH1INEN.
	SYSTEM_VBTICTLR_VCH1INEN = 0x2
	// Disabled
	SYSTEM_VBTICTLR_VCH1INEN_0 = 0x0
	// Enabled
	SYSTEM_VBTICTLR_VCH1INEN_1 = 0x1
	// Position of VCH0INEN field.
	SYSTEM_VBTICTLR_VCH0INEN_Pos = 0x0
	// Bit mask of VCH0INEN field.
	SYSTEM_VBTICTLR_VCH0INEN_Msk = 0x1
	// Bit VCH0INEN.
	SYSTEM_VBTICTLR_VCH0INEN = 0x1
	// Disabled
	SYSTEM_VBTICTLR_VCH0INEN_0 = 0x0
	// Enabled
	SYSTEM_VBTICTLR_VCH0INEN_1 = 0x1

	// VBTBKR: VBATT Backup Register [%s]
	// Position of VBTBKR field.
	SYSTEM_VBTBKR_VBTBKR_Pos = 0x0
	// Bit mask of VBTBKR field.
	SYSTEM_VBTBKR_VBTBKR_Msk = 0xff
)

// Constants for EDMAC0: DMA Controller for the Ethernet Controller Channel 0
const (
	// EDMR: EDMAC Mode Register
	// Position of DE field.
	EDMAC0_EDMR_DE_Pos = 0x6
	// Bit mask of DE field.
	EDMAC0_EDMR_DE_Msk = 0x40
	// Bit DE.
	EDMAC0_EDMR_DE = 0x40
	// Big endian mode
	EDMAC0_EDMR_DE_0 = 0x0
	// Little endian mode
	EDMAC0_EDMR_DE_1 = 0x1
	// Position of DL field.
	EDMAC0_EDMR_DL_Pos = 0x4
	// Bit mask of DL field.
	EDMAC0_EDMR_DL_Msk = 0x30
	// 16 bytes
	EDMAC0_EDMR_DL_00 = 0x0
	// 32 bytes
	EDMAC0_EDMR_DL_01 = 0x1
	// 64 bytes
	EDMAC0_EDMR_DL_10 = 0x2
	// 16 bytes
	EDMAC0_EDMR_DL_11 = 0x3
	// Position of SWR field.
	EDMAC0_EDMR_SWR_Pos = 0x0
	// Bit mask of SWR field.
	EDMAC0_EDMR_SWR_Msk = 0x1
	// Bit SWR.
	EDMAC0_EDMR_SWR = 0x1
	// no effect.
	EDMAC0_EDMR_SWR_0 = 0x0
	// the corresponding channels of the EDMAC and ETHERC are reset. Registers TDLAR, RDLAR, RMFCR, TFUCR, and RFOCR are not reset.
	EDMAC0_EDMR_SWR_1 = 0x1

	// EDTRR: EDMAC Transmit Request Register
	// Position of TR field.
	EDMAC0_EDTRR_TR_Pos = 0x0
	// Bit mask of TR field.
	EDMAC0_EDTRR_TR_Msk = 0x1
	// Bit TR.
	EDMAC0_EDTRR_TR = 0x1
	// no effect.
	EDMAC0_EDTRR_TR_0 = 0x0
	// When 1 is written, the EDMAC reads the corresponding descriptor and transmits frames where the TD0.TACT bit is 1. The TR bit becomes 0 after all the valid frames are transmitted.
	EDMAC0_EDTRR_TR_1 = 0x1

	// EDRRR: EDMAC Receive Request Register
	// Position of RR field.
	EDMAC0_EDRRR_RR_Pos = 0x0
	// Bit mask of RR field.
	EDMAC0_EDRRR_RR_Msk = 0x1
	// Bit RR.
	EDMAC0_EDRRR_RR = 0x1
	// Receive function is disabled.
	EDMAC0_EDRRR_RR_0 = 0x0
	// Receive descriptor is read, and the receive function is enabled.
	EDMAC0_EDRRR_RR_1 = 0x1

	// TDLAR: Transmit Descriptor List Start Address Register
	// Position of TDLAR field.
	EDMAC0_TDLAR_TDLAR_Pos = 0x0
	// Bit mask of TDLAR field.
	EDMAC0_TDLAR_TDLAR_Msk = 0xffffffff

	// RDLAR: Receive Descriptor List Start Address Register
	// Position of RDLAR field.
	EDMAC0_RDLAR_RDLAR_Pos = 0x0
	// Bit mask of RDLAR field.
	EDMAC0_RDLAR_RDLAR_Msk = 0xffffffff

	// EESR: ETHERC/EDMAC Status Register
	// Position of TWB field.
	EDMAC0_EESR_TWB_Pos = 0x1e
	// Bit mask of TWB field.
	EDMAC0_EESR_TWB_Msk = 0x40000000
	// Bit TWB.
	EDMAC0_EESR_TWB = 0x40000000
	// Write-back has not been completed, or no transmission has been requested.
	EDMAC0_EESR_TWB_0 = 0x0
	// Write-back to the transmit descriptor has been completed.
	EDMAC0_EESR_TWB_1 = 0x1
	// Position of TABT field.
	EDMAC0_EESR_TABT_Pos = 0x1a
	// Bit mask of TABT field.
	EDMAC0_EESR_TABT_Msk = 0x4000000
	// Bit TABT.
	EDMAC0_EESR_TABT = 0x4000000
	// Frame transmission has not been aborted or no transmission has been requested.
	EDMAC0_EESR_TABT_0 = 0x0
	// Frame transmission has been aborted.
	EDMAC0_EESR_TABT_1 = 0x1
	// Position of RABT field.
	EDMAC0_EESR_RABT_Pos = 0x19
	// Bit mask of RABT field.
	EDMAC0_EESR_RABT_Msk = 0x2000000
	// Bit RABT.
	EDMAC0_EESR_RABT = 0x2000000
	// Frame reception has not been aborted or no reception has been requested.
	EDMAC0_EESR_RABT_0 = 0x0
	// Frame reception has been aborted.
	EDMAC0_EESR_RABT_1 = 0x1
	// Position of RFCOF field.
	EDMAC0_EESR_RFCOF_Pos = 0x18
	// Bit mask of RFCOF field.
	EDMAC0_EESR_RFCOF_Msk = 0x1000000
	// Bit RFCOF.
	EDMAC0_EESR_RFCOF = 0x1000000
	// Receive frame counter has not overflowed.
	EDMAC0_EESR_RFCOF_0 = 0x0
	// Receive frame counter has overflowed.
	EDMAC0_EESR_RFCOF_1 = 0x1
	// Position of ADE field.
	EDMAC0_EESR_ADE_Pos = 0x17
	// Bit mask of ADE field.
	EDMAC0_EESR_ADE_Msk = 0x800000
	// Bit ADE.
	EDMAC0_EESR_ADE = 0x800000
	// Invalid memory address has not been detected (normal operation).
	EDMAC0_EESR_ADE_0 = 0x0
	// Invalid memory address has been detected.
	EDMAC0_EESR_ADE_1 = 0x1
	// Position of ECI field.
	EDMAC0_EESR_ECI_Pos = 0x16
	// Bit mask of ECI field.
	EDMAC0_EESR_ECI_Msk = 0x400000
	// Bit ECI.
	EDMAC0_EESR_ECI = 0x400000
	// ETHERC status interrupt source has not been detected.
	EDMAC0_EESR_ECI_0 = 0x0
	// ETHERC status interrupt source has been detected.
	EDMAC0_EESR_ECI_1 = 0x1
	// Position of TC field.
	EDMAC0_EESR_TC_Pos = 0x15
	// Bit mask of TC field.
	EDMAC0_EESR_TC_Msk = 0x200000
	// Bit TC.
	EDMAC0_EESR_TC = 0x200000
	// Transfer have not been completed, or no transfer has been requested.
	EDMAC0_EESR_TC_0 = 0x0
	// All frames indicated by the transmit descriptor have been completely transferred to the transmit FIFO.
	EDMAC0_EESR_TC_1 = 0x1
	// Position of TDE field.
	EDMAC0_EESR_TDE_Pos = 0x14
	// Bit mask of TDE field.
	EDMAC0_EESR_TDE_Msk = 0x100000
	// Bit TDE.
	EDMAC0_EESR_TDE = 0x100000
	// The EDMAC detects that the transmit descriptor valid bit (TDn.TACT) is 1.
	EDMAC0_EESR_TDE_0 = 0x0
	// The EDMAC detects that the transmit descriptor valid bit (TDn.TACT) is 0.
	EDMAC0_EESR_TDE_1 = 0x1
	// Position of TFUF field.
	EDMAC0_EESR_TFUF_Pos = 0x13
	// Bit mask of TFUF field.
	EDMAC0_EESR_TFUF_Msk = 0x80000
	// Bit TFUF.
	EDMAC0_EESR_TFUF = 0x80000
	// Underflow has not occurred.
	EDMAC0_EESR_TFUF_0 = 0x0
	// Underflow has occurred.
	EDMAC0_EESR_TFUF_1 = 0x1
	// Position of FR field.
	EDMAC0_EESR_FR_Pos = 0x12
	// Bit mask of FR field.
	EDMAC0_EESR_FR_Msk = 0x40000
	// Bit FR.
	EDMAC0_EESR_FR = 0x40000
	// Frame has not been received.
	EDMAC0_EESR_FR_0 = 0x0
	// Frame has been received. Update of the receive descriptor is complete.
	EDMAC0_EESR_FR_1 = 0x1
	// Position of RDE field.
	EDMAC0_EESR_RDE_Pos = 0x11
	// Bit mask of RDE field.
	EDMAC0_EESR_RDE_Msk = 0x20000
	// Bit RDE.
	EDMAC0_EESR_RDE = 0x20000
	// The EDMAC detects that the receive descriptor valid bit (RDn.RACT) is 1.
	EDMAC0_EESR_RDE_0 = 0x0
	// The EDMAC detects that the receive descriptor valid bit (RDn.RACT) is 0.
	EDMAC0_EESR_RDE_1 = 0x1
	// Position of RFOF field.
	EDMAC0_EESR_RFOF_Pos = 0x10
	// Bit mask of RFOF field.
	EDMAC0_EESR_RFOF_Msk = 0x10000
	// Bit RFOF.
	EDMAC0_EESR_RFOF = 0x10000
	// Overflow has not occurred.
	EDMAC0_EESR_RFOF_0 = 0x0
	// Overflow has occurred.
	EDMAC0_EESR_RFOF_1 = 0x1
	// Position of CND field.
	EDMAC0_EESR_CND_Pos = 0xb
	// Bit mask of CND field.
	EDMAC0_EESR_CND_Msk = 0x800
	// Bit CND.
	EDMAC0_EESR_CND = 0x800
	// A carrier has been detected when transmission starts.
	EDMAC0_EESR_CND_0 = 0x0
	// A carrier has not been detected during preamble transmission.
	EDMAC0_EESR_CND_1 = 0x1
	// Position of DLC field.
	EDMAC0_EESR_DLC_Pos = 0xa
	// Bit mask of DLC field.
	EDMAC0_EESR_DLC_Msk = 0x400
	// Bit DLC.
	EDMAC0_EESR_DLC = 0x400
	// Loss of carrier has not been detected.
	EDMAC0_EESR_DLC_0 = 0x0
	// Loss of carrier has been detected during frame transmission.
	EDMAC0_EESR_DLC_1 = 0x1
	// Position of CD field.
	EDMAC0_EESR_CD_Pos = 0x9
	// Bit mask of CD field.
	EDMAC0_EESR_CD_Msk = 0x200
	// Bit CD.
	EDMAC0_EESR_CD = 0x200
	// Late collision has not been detected.
	EDMAC0_EESR_CD_0 = 0x0
	// Late collision has been detected during frame transmission.
	EDMAC0_EESR_CD_1 = 0x1
	// Position of TRO field.
	EDMAC0_EESR_TRO_Pos = 0x8
	// Bit mask of TRO field.
	EDMAC0_EESR_TRO_Msk = 0x100
	// Bit TRO.
	EDMAC0_EESR_TRO = 0x100
	// Transmit retry-over condition has not been detected.
	EDMAC0_EESR_TRO_0 = 0x0
	// Transmit retry-over condition has been detected.
	EDMAC0_EESR_TRO_1 = 0x1
	// Position of RMAF field.
	EDMAC0_EESR_RMAF_Pos = 0x7
	// Bit mask of RMAF field.
	EDMAC0_EESR_RMAF_Msk = 0x80
	// Bit RMAF.
	EDMAC0_EESR_RMAF = 0x80
	// Multicast address frame has not been received.
	EDMAC0_EESR_RMAF_0 = 0x0
	// Multicast address frame has been received.
	EDMAC0_EESR_RMAF_1 = 0x1
	// Position of RRF field.
	EDMAC0_EESR_RRF_Pos = 0x4
	// Bit mask of RRF field.
	EDMAC0_EESR_RRF_Msk = 0x10
	// Bit RRF.
	EDMAC0_EESR_RRF = 0x10
	// Alignment error has not been detected.
	EDMAC0_EESR_RRF_0 = 0x0
	// Alignment error has been detected.
	EDMAC0_EESR_RRF_1 = 0x1
	// Position of RTLF field.
	EDMAC0_EESR_RTLF_Pos = 0x3
	// Bit mask of RTLF field.
	EDMAC0_EESR_RTLF_Msk = 0x8
	// Bit RTLF.
	EDMAC0_EESR_RTLF = 0x8
	// Frame-too-long error has not been detected.
	EDMAC0_EESR_RTLF_0 = 0x0
	// Frame-too-long error has been detected.
	EDMAC0_EESR_RTLF_1 = 0x1
	// Position of RTSF field.
	EDMAC0_EESR_RTSF_Pos = 0x2
	// Bit mask of RTSF field.
	EDMAC0_EESR_RTSF_Msk = 0x4
	// Bit RTSF.
	EDMAC0_EESR_RTSF = 0x4
	// Frame-too-short error has not been detected.
	EDMAC0_EESR_RTSF_0 = 0x0
	// Frame-too-short error has been detected.
	EDMAC0_EESR_RTSF_1 = 0x1
	// Position of PRE field.
	EDMAC0_EESR_PRE_Pos = 0x1
	// Bit mask of PRE field.
	EDMAC0_EESR_PRE_Msk = 0x2
	// Bit PRE.
	EDMAC0_EESR_PRE = 0x2
	// PHY-LSI receive error has not been detected.
	EDMAC0_EESR_PRE_0 = 0x0
	// PHY-LSI receive error has been detected.
	EDMAC0_EESR_PRE_1 = 0x1
	// Position of CERF field.
	EDMAC0_EESR_CERF_Pos = 0x0
	// Bit mask of CERF field.
	EDMAC0_EESR_CERF_Msk = 0x1
	// Bit CERF.
	EDMAC0_EESR_CERF = 0x1
	// CRC error has not been detected.
	EDMAC0_EESR_CERF_0 = 0x0
	// CRC error has been detected.
	EDMAC0_EESR_CERF_1 = 0x1

	// EESIPR: ETHERC/EDMAC Status Interrupt Enable Register
	// Position of TWBIP field.
	EDMAC0_EESIPR_TWBIP_Pos = 0x1e
	// Bit mask of TWBIP field.
	EDMAC0_EESIPR_TWBIP_Msk = 0x40000000
	// Bit TWBIP.
	EDMAC0_EESIPR_TWBIP = 0x40000000
	// Write-back complete interrupt request is disabled.
	EDMAC0_EESIPR_TWBIP_0 = 0x0
	// Write-back complete interrupt request is enabled.
	EDMAC0_EESIPR_TWBIP_1 = 0x1
	// Position of TABTIP field.
	EDMAC0_EESIPR_TABTIP_Pos = 0x1a
	// Bit mask of TABTIP field.
	EDMAC0_EESIPR_TABTIP_Msk = 0x4000000
	// Bit TABTIP.
	EDMAC0_EESIPR_TABTIP = 0x4000000
	// Transmit abort detect interrupt request is disabled.
	EDMAC0_EESIPR_TABTIP_0 = 0x0
	// Transmit abort detect interrupt request is enabled.
	EDMAC0_EESIPR_TABTIP_1 = 0x1
	// Position of RABTIP field.
	EDMAC0_EESIPR_RABTIP_Pos = 0x19
	// Bit mask of RABTIP field.
	EDMAC0_EESIPR_RABTIP_Msk = 0x2000000
	// Bit RABTIP.
	EDMAC0_EESIPR_RABTIP = 0x2000000
	// Receive abort detect interrupt request is disabled.
	EDMAC0_EESIPR_RABTIP_0 = 0x0
	// Receive abort detect interrupt request is enabled.
	EDMAC0_EESIPR_RABTIP_1 = 0x1
	// Position of RFCOFIP field.
	EDMAC0_EESIPR_RFCOFIP_Pos = 0x18
	// Bit mask of RFCOFIP field.
	EDMAC0_EESIPR_RFCOFIP_Msk = 0x1000000
	// Bit RFCOFIP.
	EDMAC0_EESIPR_RFCOFIP = 0x1000000
	// Receive frame counter overflow interrupt request is disabled.
	EDMAC0_EESIPR_RFCOFIP_0 = 0x0
	// Receive frame counter overflow interrupt request is enabled.
	EDMAC0_EESIPR_RFCOFIP_1 = 0x1
	// Position of ADEIP field.
	EDMAC0_EESIPR_ADEIP_Pos = 0x17
	// Bit mask of ADEIP field.
	EDMAC0_EESIPR_ADEIP_Msk = 0x800000
	// Bit ADEIP.
	EDMAC0_EESIPR_ADEIP = 0x800000
	// Address error interrupt request is disabled.
	EDMAC0_EESIPR_ADEIP_0 = 0x0
	// Address error interrupt request is enabled.
	EDMAC0_EESIPR_ADEIP_1 = 0x1
	// Position of ECIIP field.
	EDMAC0_EESIPR_ECIIP_Pos = 0x16
	// Bit mask of ECIIP field.
	EDMAC0_EESIPR_ECIIP_Msk = 0x400000
	// Bit ECIIP.
	EDMAC0_EESIPR_ECIIP = 0x400000
	// ETHERC status interrupt request is disabled.
	EDMAC0_EESIPR_ECIIP_0 = 0x0
	// ETHERC status interrupt request is enabled.
	EDMAC0_EESIPR_ECIIP_1 = 0x1
	// Position of TCIP field.
	EDMAC0_EESIPR_TCIP_Pos = 0x15
	// Bit mask of TCIP field.
	EDMAC0_EESIPR_TCIP_Msk = 0x200000
	// Bit TCIP.
	EDMAC0_EESIPR_TCIP = 0x200000
	// Frame transmission complete interrupt request is disabled.
	EDMAC0_EESIPR_TCIP_0 = 0x0
	// Frame transmission complete interrupt request is enabled.
	EDMAC0_EESIPR_TCIP_1 = 0x1
	// Position of TDEIP field.
	EDMAC0_EESIPR_TDEIP_Pos = 0x14
	// Bit mask of TDEIP field.
	EDMAC0_EESIPR_TDEIP_Msk = 0x100000
	// Bit TDEIP.
	EDMAC0_EESIPR_TDEIP = 0x100000
	// Transmit descriptor empty interrupt request is disabled.
	EDMAC0_EESIPR_TDEIP_0 = 0x0
	// Transmit descriptor empty interrupt request is enabled.
	EDMAC0_EESIPR_TDEIP_1 = 0x1
	// Position of TFUFIP field.
	EDMAC0_EESIPR_TFUFIP_Pos = 0x13
	// Bit mask of TFUFIP field.
	EDMAC0_EESIPR_TFUFIP_Msk = 0x80000
	// Bit TFUFIP.
	EDMAC0_EESIPR_TFUFIP = 0x80000
	// Underflow interrupt request is disabled.
	EDMAC0_EESIPR_TFUFIP_0 = 0x0
	// Underflow interrupt request is enabled.
	EDMAC0_EESIPR_TFUFIP_1 = 0x1
	// Position of FRIP field.
	EDMAC0_EESIPR_FRIP_Pos = 0x12
	// Bit mask of FRIP field.
	EDMAC0_EESIPR_FRIP_Msk = 0x40000
	// Bit FRIP.
	EDMAC0_EESIPR_FRIP = 0x40000
	// Frame reception interrupt request is disabled.
	EDMAC0_EESIPR_FRIP_0 = 0x0
	// Frame reception interrupt request is enabled.
	EDMAC0_EESIPR_FRIP_1 = 0x1
	// Position of RDEIP field.
	EDMAC0_EESIPR_RDEIP_Pos = 0x11
	// Bit mask of RDEIP field.
	EDMAC0_EESIPR_RDEIP_Msk = 0x20000
	// Bit RDEIP.
	EDMAC0_EESIPR_RDEIP = 0x20000
	// Receive descriptor empty interrupt request is disabled.
	EDMAC0_EESIPR_RDEIP_0 = 0x0
	// Receive descriptor empty interrupt request is enabled.
	EDMAC0_EESIPR_RDEIP_1 = 0x1
	// Position of RFOFIP field.
	EDMAC0_EESIPR_RFOFIP_Pos = 0x10
	// Bit mask of RFOFIP field.
	EDMAC0_EESIPR_RFOFIP_Msk = 0x10000
	// Bit RFOFIP.
	EDMAC0_EESIPR_RFOFIP = 0x10000
	// Overflow interrupt request is disabled.
	EDMAC0_EESIPR_RFOFIP_0 = 0x0
	// Overflow interrupt request is enabled.
	EDMAC0_EESIPR_RFOFIP_1 = 0x1
	// Position of CNDIP field.
	EDMAC0_EESIPR_CNDIP_Pos = 0xb
	// Bit mask of CNDIP field.
	EDMAC0_EESIPR_CNDIP_Msk = 0x800
	// Bit CNDIP.
	EDMAC0_EESIPR_CNDIP = 0x800
	// Carrier not detect interrupt request is disabled.
	EDMAC0_EESIPR_CNDIP_0 = 0x0
	// Carrier not detect interrupt request is enabled.
	EDMAC0_EESIPR_CNDIP_1 = 0x1
	// Position of DLCIP field.
	EDMAC0_EESIPR_DLCIP_Pos = 0xa
	// Bit mask of DLCIP field.
	EDMAC0_EESIPR_DLCIP_Msk = 0x400
	// Bit DLCIP.
	EDMAC0_EESIPR_DLCIP = 0x400
	// Loss of carrier detect interrupt request is disabled.
	EDMAC0_EESIPR_DLCIP_0 = 0x0
	// Loss of carrier detect interrupt request is enabled.
	EDMAC0_EESIPR_DLCIP_1 = 0x1
	// Position of CDIP field.
	EDMAC0_EESIPR_CDIP_Pos = 0x9
	// Bit mask of CDIP field.
	EDMAC0_EESIPR_CDIP_Msk = 0x200
	// Bit CDIP.
	EDMAC0_EESIPR_CDIP = 0x200
	// Late collision detect interrupt request is disabled.
	EDMAC0_EESIPR_CDIP_0 = 0x0
	// Late collision detect interrupt request is enabled.
	EDMAC0_EESIPR_CDIP_1 = 0x1
	// Position of TROIP field.
	EDMAC0_EESIPR_TROIP_Pos = 0x8
	// Bit mask of TROIP field.
	EDMAC0_EESIPR_TROIP_Msk = 0x100
	// Bit TROIP.
	EDMAC0_EESIPR_TROIP = 0x100
	// Transmit retry over interrupt request is disabled.
	EDMAC0_EESIPR_TROIP_0 = 0x0
	// Transmit retry over interrupt request is enabled.
	EDMAC0_EESIPR_TROIP_1 = 0x1
	// Position of RMAFIP field.
	EDMAC0_EESIPR_RMAFIP_Pos = 0x7
	// Bit mask of RMAFIP field.
	EDMAC0_EESIPR_RMAFIP_Msk = 0x80
	// Bit RMAFIP.
	EDMAC0_EESIPR_RMAFIP = 0x80
	// Multicast address frame receive interrupt request is disabled.
	EDMAC0_EESIPR_RMAFIP_0 = 0x0
	// Multicast address frame receive interrupt request is enabled.
	EDMAC0_EESIPR_RMAFIP_1 = 0x1
	// Position of RRFIP field.
	EDMAC0_EESIPR_RRFIP_Pos = 0x4
	// Bit mask of RRFIP field.
	EDMAC0_EESIPR_RRFIP_Msk = 0x10
	// Bit RRFIP.
	EDMAC0_EESIPR_RRFIP = 0x10
	// Alignment error interrupt request is disabled.
	EDMAC0_EESIPR_RRFIP_0 = 0x0
	// Alignment error interrupt request is enabled.
	EDMAC0_EESIPR_RRFIP_1 = 0x1
	// Position of RTLFIP field.
	EDMAC0_EESIPR_RTLFIP_Pos = 0x3
	// Bit mask of RTLFIP field.
	EDMAC0_EESIPR_RTLFIP_Msk = 0x8
	// Bit RTLFIP.
	EDMAC0_EESIPR_RTLFIP = 0x8
	// Frame-too-long error interrupt request is disabled.
	EDMAC0_EESIPR_RTLFIP_0 = 0x0
	// Frame-too-long error interrupt request is enabled.
	EDMAC0_EESIPR_RTLFIP_1 = 0x1
	// Position of RTSFIP field.
	EDMAC0_EESIPR_RTSFIP_Pos = 0x2
	// Bit mask of RTSFIP field.
	EDMAC0_EESIPR_RTSFIP_Msk = 0x4
	// Bit RTSFIP.
	EDMAC0_EESIPR_RTSFIP = 0x4
	// Frame-too-short error interrupt request is disabled.
	EDMAC0_EESIPR_RTSFIP_0 = 0x0
	// Frame-too-short error interrupt request is enabled.
	EDMAC0_EESIPR_RTSFIP_1 = 0x1
	// Position of PREIP field.
	EDMAC0_EESIPR_PREIP_Pos = 0x1
	// Bit mask of PREIP field.
	EDMAC0_EESIPR_PREIP_Msk = 0x2
	// Bit PREIP.
	EDMAC0_EESIPR_PREIP = 0x2
	// PHY-LSI receive error interrupt request is disabled.
	EDMAC0_EESIPR_PREIP_0 = 0x0
	// PHY-LSI receive error interrupt request is enabled.
	EDMAC0_EESIPR_PREIP_1 = 0x1
	// Position of CERFIP field.
	EDMAC0_EESIPR_CERFIP_Pos = 0x0
	// Bit mask of CERFIP field.
	EDMAC0_EESIPR_CERFIP_Msk = 0x1
	// Bit CERFIP.
	EDMAC0_EESIPR_CERFIP = 0x1
	// CRC error interrupt request is disabled.
	EDMAC0_EESIPR_CERFIP_0 = 0x0
	// CRC error interrupt request is enabled.
	EDMAC0_EESIPR_CERFIP_1 = 0x1

	// TRSCER: ETHERC/EDMAC Transmit/Receive Status Copy Enable Register
	// Position of RMAFCE field.
	EDMAC0_TRSCER_RMAFCE_Pos = 0x7
	// Bit mask of RMAFCE field.
	EDMAC0_TRSCER_RMAFCE_Msk = 0x80
	// Bit RMAFCE.
	EDMAC0_TRSCER_RMAFCE = 0x80
	// The EDMACn.EESR.RMAF flag status is reflected in the RDn.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RMAFCE_0 = 0x0
	// The EDMACn.EESR.RMAF flag status is not reflected in the RDn.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RMAFCE_1 = 0x1
	// Position of RRFCE field.
	EDMAC0_TRSCER_RRFCE_Pos = 0x4
	// Bit mask of RRFCE field.
	EDMAC0_TRSCER_RRFCE_Msk = 0x10
	// Bit RRFCE.
	EDMAC0_TRSCER_RRFCE = 0x10
	// The EDMACn.EESR.RRF flag status is reflected in the RDn.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RRFCE_0 = 0x0
	// The EDMACn.EESR.RRF flag status is not reflected in the RDn.RFE bit of the receive descriptor.
	EDMAC0_TRSCER_RRFCE_1 = 0x1

	// RMFCR: Missed-Frame Counter Register
	// Position of MFC field.
	EDMAC0_RMFCR_MFC_Pos = 0x0
	// Bit mask of MFC field.
	EDMAC0_RMFCR_MFC_Msk = 0xffff

	// TFTR: Transmit FIFO Threshold Register
	// Position of TFT field.
	EDMAC0_TFTR_TFT_Pos = 0x0
	// Bit mask of TFT field.
	EDMAC0_TFTR_TFT_Msk = 0x7ff
	// Store and forward mode
	EDMAC0_TFTR_TFT_0x000 = 0x0

	// FDR: Transmit FIFO Threshold Register
	// Position of TFD field.
	EDMAC0_FDR_TFD_Pos = 0x8
	// Bit mask of TFD field.
	EDMAC0_FDR_TFD_Msk = 0x1f00
	// 4096 bytes
	EDMAC0_FDR_TFD_01111 = 0xf
	// Position of RFD field.
	EDMAC0_FDR_RFD_Pos = 0x0
	// Bit mask of RFD field.
	EDMAC0_FDR_RFD_Msk = 0x1f
	// 2048 bytes
	EDMAC0_FDR_RFD_00111 = 0x7

	// RMCR: Receive Method Control Register
	// Position of RNR field.
	EDMAC0_RMCR_RNR_Pos = 0x0
	// Bit mask of RNR field.
	EDMAC0_RMCR_RNR_Msk = 0x1
	// Bit RNR.
	EDMAC0_RMCR_RNR = 0x1
	// EDRRR.RR bit (receive request bit) is set to 0 when one frame has been received.
	EDMAC0_RMCR_RNR_0 = 0x0
	// EDRRR.RR bit (receive request bit) is not set to 0 when one frame has been received.
	EDMAC0_RMCR_RNR_1 = 0x1

	// TFUCR: Transmit FIFO Underflow Counter
	// Position of UNDER field.
	EDMAC0_TFUCR_UNDER_Pos = 0x0
	// Bit mask of UNDER field.
	EDMAC0_TFUCR_UNDER_Msk = 0xffff

	// RFOCR: Receive FIFO Overflow Counter
	// Position of OVER field.
	EDMAC0_RFOCR_OVER_Pos = 0x0
	// Bit mask of OVER field.
	EDMAC0_RFOCR_OVER_Msk = 0xffff

	// IOSR: Independent Output Signal Setting Register
	// Position of ELB field.
	EDMAC0_IOSR_ELB_Pos = 0x0
	// Bit mask of ELB field.
	EDMAC0_IOSR_ELB_Msk = 0x1
	// Bit ELB.
	EDMAC0_IOSR_ELB = 0x1
	// The ETn_EXOUT pin outputs low.
	EDMAC0_IOSR_ELB_0 = 0x0
	// The ETn_EXOUT pin outputs high.
	EDMAC0_IOSR_ELB_1 = 0x1

	// FCFTR: Flow Control Start FIFO Threshold Setting Register
	// Position of RFFO field.
	EDMAC0_FCFTR_RFFO_Pos = 0x10
	// Bit mask of RFFO field.
	EDMAC0_FCFTR_RFFO_Msk = 0x70000
	// When 2 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_000 = 0x0
	// When 4 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_001 = 0x1
	// When 6 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_010 = 0x2
	// When 8 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_011 = 0x3
	// When 10 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_100 = 0x4
	// When 12 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_101 = 0x5
	// When 14 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_110 = 0x6
	// When 16 receive frames have been stored in the receive FIFO.
	EDMAC0_FCFTR_RFFO_111 = 0x7
	// Position of RFDO field.
	EDMAC0_FCFTR_RFDO_Pos = 0x0
	// Bit mask of RFDO field.
	EDMAC0_FCFTR_RFDO_Msk = 0x7
	// When 224 ( 256 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_000 = 0x0
	// When 480 ( 512 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_001 = 0x1
	// When 736 ( 768 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_010 = 0x2
	// When 992 (1024 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_011 = 0x3
	// When 1248 (1280 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_100 = 0x4
	// When 1504 (1536 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_101 = 0x5
	// When 1760 (1792 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_110 = 0x6
	// When 2016 (2048 - 32) bytes of data is stored in the receive FIFO.
	EDMAC0_FCFTR_RFDO_111 = 0x7

	// RPADIR: Receive Data Padding Insert Register
	// Position of PADS field.
	EDMAC0_RPADIR_PADS_Pos = 0x10
	// Bit mask of PADS field.
	EDMAC0_RPADIR_PADS_Msk = 0x30000
	// No padding is inserted.
	EDMAC0_RPADIR_PADS_00 = 0x0
	// 1 byte is inserted.
	EDMAC0_RPADIR_PADS_01 = 0x1
	// 2 bytes are inserted.
	EDMAC0_RPADIR_PADS_10 = 0x2
	// 3 bytes are inserted.
	EDMAC0_RPADIR_PADS_11 = 0x3
	// Position of PADR field.
	EDMAC0_RPADIR_PADR_Pos = 0x0
	// Bit mask of PADR field.
	EDMAC0_RPADIR_PADR_Msk = 0x3f
	// Padding is inserted at the head of received data.
	EDMAC0_RPADIR_PADR_00h = 0x0

	// TRIMD: Transmit Interrupt Setting Register
	// Position of TIM field.
	EDMAC0_TRIMD_TIM_Pos = 0x4
	// Bit mask of TIM field.
	EDMAC0_TRIMD_TIM_Msk = 0x10
	// Bit TIM.
	EDMAC0_TRIMD_TIM = 0x10
	// Transmission complete interrupt mode: An interrupt occurs when a frame has been transmitted.
	EDMAC0_TRIMD_TIM_0 = 0x0
	// Write-back complete interrupt mode: An interrupt occurs when write-back to the transmit descriptor has been completed.
	EDMAC0_TRIMD_TIM_1 = 0x1
	// Position of TIS field.
	EDMAC0_TRIMD_TIS_Pos = 0x0
	// Bit mask of TIS field.
	EDMAC0_TRIMD_TIS_Msk = 0x1
	// Bit TIS.
	EDMAC0_TRIMD_TIS = 0x1
	// Transmit Interrupt is disabled.
	EDMAC0_TRIMD_TIS_0 = 0x0
	// Transmit Interrupt is enabled.
	EDMAC0_TRIMD_TIS_1 = 0x1

	// RBWAR: Receive Buffer Write Address Register
	// Position of RBWAR field.
	EDMAC0_RBWAR_RBWAR_Pos = 0x0
	// Bit mask of RBWAR field.
	EDMAC0_RBWAR_RBWAR_Msk = 0xffffffff

	// RDFAR: Receive Descriptor Fetch Address Register
	// Position of RDFAR field.
	EDMAC0_RDFAR_RDFAR_Pos = 0x0
	// Bit mask of RDFAR field.
	EDMAC0_RDFAR_RDFAR_Msk = 0xffffffff

	// TBRAR: Transmit Buffer Read Address Register
	// Position of TBRAR field.
	EDMAC0_TBRAR_TBRAR_Pos = 0x0
	// Bit mask of TBRAR field.
	EDMAC0_TBRAR_TBRAR_Msk = 0xffffffff

	// TDFAR: Transmit Descriptor Fetch Address Register
	// Position of TDFAR field.
	EDMAC0_TDFAR_TDFAR_Pos = 0x0
	// Bit mask of TDFAR field.
	EDMAC0_TDFAR_TDFAR_Msk = 0xffffffff
)

// Constants for ETHERC0: Ethernet Controller Channel 0
const (
	// ECMR: ETHERC Mode Register
	// Position of TPC field.
	ETHERC0_ECMR_TPC_Pos = 0x14
	// Bit mask of TPC field.
	ETHERC0_ECMR_TPC_Msk = 0x100000
	// Bit TPC.
	ETHERC0_ECMR_TPC = 0x100000
	// PAUSE frame is transmitted even during a PAUSE period.
	ETHERC0_ECMR_TPC_0 = 0x0
	// PAUSE frame is not transmitted during a PAUSE period.
	ETHERC0_ECMR_TPC_1 = 0x1
	// Position of ZPF field.
	ETHERC0_ECMR_ZPF_Pos = 0x13
	// Bit mask of ZPF field.
	ETHERC0_ECMR_ZPF_Msk = 0x80000
	// Bit ZPF.
	ETHERC0_ECMR_ZPF = 0x80000
	// PAUSE frame that contains the pause_time parameter of 0 is not used.
	ETHERC0_ECMR_ZPF_0 = 0x0
	// PAUSE frame that contains the pause_time parameter of 0 is used.
	ETHERC0_ECMR_ZPF_1 = 0x1
	// Position of PFR field.
	ETHERC0_ECMR_PFR_Pos = 0x12
	// Bit mask of PFR field.
	ETHERC0_ECMR_PFR_Msk = 0x40000
	// Bit PFR.
	ETHERC0_ECMR_PFR = 0x40000
	// PAUSE frame is not transferred to the EDMAC.
	ETHERC0_ECMR_PFR_0 = 0x0
	// PAUSE frame is transferred to the EDMAC.
	ETHERC0_ECMR_PFR_1 = 0x1
	// Position of RXF field.
	ETHERC0_ECMR_RXF_Pos = 0x11
	// Bit mask of RXF field.
	ETHERC0_ECMR_RXF_Msk = 0x20000
	// Bit RXF.
	ETHERC0_ECMR_RXF = 0x20000
	// PAUSE frame detection is disabled.
	ETHERC0_ECMR_RXF_0 = 0x0
	// PAUSE frame detection is enabled.
	ETHERC0_ECMR_RXF_1 = 0x1
	// Position of TXF field.
	ETHERC0_ECMR_TXF_Pos = 0x10
	// Bit mask of TXF field.
	ETHERC0_ECMR_TXF_Msk = 0x10000
	// Bit TXF.
	ETHERC0_ECMR_TXF = 0x10000
	// Automatic PAUSE frame transmission is disabled.(PAUSE frame is not automatically transmitted.)
	ETHERC0_ECMR_TXF_0 = 0x0
	// Automatic PAUSE frame transmission is enabled.(PAUSE frame is automatically transmitted as required.)
	ETHERC0_ECMR_TXF_1 = 0x1
	// Position of PRCEF field.
	ETHERC0_ECMR_PRCEF_Pos = 0xc
	// Bit mask of PRCEF field.
	ETHERC0_ECMR_PRCEF_Msk = 0x1000
	// Bit PRCEF.
	ETHERC0_ECMR_PRCEF = 0x1000
	// EDMAC is notified of a CRC error.
	ETHERC0_ECMR_PRCEF_0 = 0x0
	// EDMAC is not notified of a CRC error.
	ETHERC0_ECMR_PRCEF_1 = 0x1
	// Position of MPDE field.
	ETHERC0_ECMR_MPDE_Pos = 0x9
	// Bit mask of MPDE field.
	ETHERC0_ECMR_MPDE_Msk = 0x200
	// Bit MPDE.
	ETHERC0_ECMR_MPDE = 0x200
	// Magic Packet detection is disabled.
	ETHERC0_ECMR_MPDE_0 = 0x0
	// Magic Packet detection is enabled.
	ETHERC0_ECMR_MPDE_1 = 0x1
	// Position of RE field.
	ETHERC0_ECMR_RE_Pos = 0x6
	// Bit mask of RE field.
	ETHERC0_ECMR_RE_Msk = 0x40
	// Bit RE.
	ETHERC0_ECMR_RE = 0x40
	// Receive function is disabled.
	ETHERC0_ECMR_RE_0 = 0x0
	// Receive function is enabled.
	ETHERC0_ECMR_RE_1 = 0x1
	// Position of TE field.
	ETHERC0_ECMR_TE_Pos = 0x5
	// Bit mask of TE field.
	ETHERC0_ECMR_TE_Msk = 0x20
	// Bit TE.
	ETHERC0_ECMR_TE = 0x20
	// Transmit function is disabled.
	ETHERC0_ECMR_TE_0 = 0x0
	// Transmit function is enabled.
	ETHERC0_ECMR_TE_1 = 0x1
	// Position of ILB field.
	ETHERC0_ECMR_ILB_Pos = 0x3
	// Bit mask of ILB field.
	ETHERC0_ECMR_ILB_Msk = 0x8
	// Bit ILB.
	ETHERC0_ECMR_ILB = 0x8
	// Normal data transmission or reception is performed.
	ETHERC0_ECMR_ILB_0 = 0x0
	// Data is looped back in the ETHERC when full-duplex mode is selected.
	ETHERC0_ECMR_ILB_1 = 0x1
	// Position of RTM field.
	ETHERC0_ECMR_RTM_Pos = 0x2
	// Bit mask of RTM field.
	ETHERC0_ECMR_RTM_Msk = 0x4
	// Bit RTM.
	ETHERC0_ECMR_RTM = 0x4
	// 10 Mbps
	ETHERC0_ECMR_RTM_0 = 0x0
	// 100 Mbps
	ETHERC0_ECMR_RTM_1 = 0x1
	// Position of DM field.
	ETHERC0_ECMR_DM_Pos = 0x1
	// Bit mask of DM field.
	ETHERC0_ECMR_DM_Msk = 0x2
	// Bit DM.
	ETHERC0_ECMR_DM = 0x2
	// Half-duplex mode
	ETHERC0_ECMR_DM_0 = 0x0
	// Full-duplex mode
	ETHERC0_ECMR_DM_1 = 0x1
	// Position of PRM field.
	ETHERC0_ECMR_PRM_Pos = 0x0
	// Bit mask of PRM field.
	ETHERC0_ECMR_PRM_Msk = 0x1
	// Bit PRM.
	ETHERC0_ECMR_PRM = 0x1
	// Promiscuous mode is disabled.
	ETHERC0_ECMR_PRM_0 = 0x0
	// Promiscuous mode is enabled.
	ETHERC0_ECMR_PRM_1 = 0x1

	// RFLR: Receive Frame Maximum Length Register
	// Position of RFL field.
	ETHERC0_RFLR_RFL_Pos = 0x0
	// Bit mask of RFL field.
	ETHERC0_RFLR_RFL_Msk = 0xfff

	// ECSR: ETHERC Status Register
	// Position of BFR field.
	ETHERC0_ECSR_BFR_Pos = 0x5
	// Bit mask of BFR field.
	ETHERC0_ECSR_BFR_Msk = 0x20
	// Bit BFR.
	ETHERC0_ECSR_BFR = 0x20
	// Continuous reception of broadcast frames has not been detected.
	ETHERC0_ECSR_BFR_0 = 0x0
	// Continuous reception of broadcast frames has been detected.
	ETHERC0_ECSR_BFR_1 = 0x1
	// Position of PSRTO field.
	ETHERC0_ECSR_PSRTO_Pos = 0x4
	// Bit mask of PSRTO field.
	ETHERC0_ECSR_PSRTO_Msk = 0x10
	// Bit PSRTO.
	ETHERC0_ECSR_PSRTO = 0x10
	// PAUSE frame retransmit count has not reached the upper limit.
	ETHERC0_ECSR_PSRTO_0 = 0x0
	// PAUSE frame retransmit count has reached the upper limit.
	ETHERC0_ECSR_PSRTO_1 = 0x1
	// Position of LCHNG field.
	ETHERC0_ECSR_LCHNG_Pos = 0x2
	// Bit mask of LCHNG field.
	ETHERC0_ECSR_LCHNG_Msk = 0x4
	// Bit LCHNG.
	ETHERC0_ECSR_LCHNG = 0x4
	// Change in the ETn_LINKSTA signal has not been detected.
	ETHERC0_ECSR_LCHNG_0 = 0x0
	// Change in the ETn_LINKSTA signal has been detected (high to low, or low to high).
	ETHERC0_ECSR_LCHNG_1 = 0x1
	// Position of MPD field.
	ETHERC0_ECSR_MPD_Pos = 0x1
	// Bit mask of MPD field.
	ETHERC0_ECSR_MPD_Msk = 0x2
	// Bit MPD.
	ETHERC0_ECSR_MPD = 0x2
	// Magic Packet has not been detected.
	ETHERC0_ECSR_MPD_0 = 0x0
	// Magic Packet has been detected.
	ETHERC0_ECSR_MPD_1 = 0x1
	// Position of ICD field.
	ETHERC0_ECSR_ICD_Pos = 0x0
	// Bit mask of ICD field.
	ETHERC0_ECSR_ICD_Msk = 0x1
	// Bit ICD.
	ETHERC0_ECSR_ICD = 0x1
	// PHY-LSI has not detected a false carrier on the line.
	ETHERC0_ECSR_ICD_0 = 0x0
	// PHY-LSI has detected a false carrier on the line.
	ETHERC0_ECSR_ICD_1 = 0x1

	// ECSIPR: ETHERC Interrupt Enable Register
	// Position of BFSIPR field.
	ETHERC0_ECSIPR_BFSIPR_Pos = 0x5
	// Bit mask of BFSIPR field.
	ETHERC0_ECSIPR_BFSIPR_Msk = 0x20
	// Bit BFSIPR.
	ETHERC0_ECSIPR_BFSIPR = 0x20
	// Notification of continuous broadcast frame reception interrupt is disabled.
	ETHERC0_ECSIPR_BFSIPR_0 = 0x0
	// Notification of continuous broadcast frame reception interrupt is enabled.
	ETHERC0_ECSIPR_BFSIPR_1 = 0x1
	// Position of PSRTOIP field.
	ETHERC0_ECSIPR_PSRTOIP_Pos = 0x4
	// Bit mask of PSRTOIP field.
	ETHERC0_ECSIPR_PSRTOIP_Msk = 0x10
	// Bit PSRTOIP.
	ETHERC0_ECSIPR_PSRTOIP = 0x10
	// Notification of PAUSE frame retransmit over interrupt is disabled.
	ETHERC0_ECSIPR_PSRTOIP_0 = 0x0
	// Notification of PAUSE frame retransmit over interrupt is enabled.
	ETHERC0_ECSIPR_PSRTOIP_1 = 0x1
	// Position of LCHNGIP field.
	ETHERC0_ECSIPR_LCHNGIP_Pos = 0x2
	// Bit mask of LCHNGIP field.
	ETHERC0_ECSIPR_LCHNGIP_Msk = 0x4
	// Bit LCHNGIP.
	ETHERC0_ECSIPR_LCHNGIP = 0x4
	// Notification of ETn_LINKSTA signal change interrupt is disabled.
	ETHERC0_ECSIPR_LCHNGIP_0 = 0x0
	// Notification of ETn_LINKSTA signal change interrupt is enabled.
	ETHERC0_ECSIPR_LCHNGIP_1 = 0x1
	// Position of MPDIP field.
	ETHERC0_ECSIPR_MPDIP_Pos = 0x1
	// Bit mask of MPDIP field.
	ETHERC0_ECSIPR_MPDIP_Msk = 0x2
	// Bit MPDIP.
	ETHERC0_ECSIPR_MPDIP = 0x2
	// Notification of the Magic Packet detect interrupt is disabled.
	ETHERC0_ECSIPR_MPDIP_0 = 0x0
	// Notification of the Magic Packet detect interrupt is enabled.
	ETHERC0_ECSIPR_MPDIP_1 = 0x1
	// Position of ICDIP field.
	ETHERC0_ECSIPR_ICDIP_Pos = 0x0
	// Bit mask of ICDIP field.
	ETHERC0_ECSIPR_ICDIP_Msk = 0x1
	// Bit ICDIP.
	ETHERC0_ECSIPR_ICDIP = 0x1
	// Notification of the false carrier detect interrupt is disabled.
	ETHERC0_ECSIPR_ICDIP_0 = 0x0
	// Notification of the false carrier detect interrupt is enabled.
	ETHERC0_ECSIPR_ICDIP_1 = 0x1

	// PIR: PHY Interface Register
	// Position of MDI field.
	ETHERC0_PIR_MDI_Pos = 0x3
	// Bit mask of MDI field.
	ETHERC0_PIR_MDI_Msk = 0x8
	// Bit MDI.
	ETHERC0_PIR_MDI = 0x8
	// Position of MDO field.
	ETHERC0_PIR_MDO_Pos = 0x2
	// Bit mask of MDO field.
	ETHERC0_PIR_MDO_Msk = 0x4
	// Bit MDO.
	ETHERC0_PIR_MDO = 0x4
	// Position of MMD field.
	ETHERC0_PIR_MMD_Pos = 0x1
	// Bit mask of MMD field.
	ETHERC0_PIR_MMD_Msk = 0x2
	// Bit MMD.
	ETHERC0_PIR_MMD = 0x2
	// Read
	ETHERC0_PIR_MMD_0 = 0x0
	// Write
	ETHERC0_PIR_MMD_1 = 0x1
	// Position of MDC field.
	ETHERC0_PIR_MDC_Pos = 0x0
	// Bit mask of MDC field.
	ETHERC0_PIR_MDC_Msk = 0x1
	// Bit MDC.
	ETHERC0_PIR_MDC = 0x1

	// PSR: PHY Status Register
	// Position of LMON field.
	ETHERC0_PSR_LMON_Pos = 0x0
	// Bit mask of LMON field.
	ETHERC0_PSR_LMON_Msk = 0x1
	// Bit LMON.
	ETHERC0_PSR_LMON = 0x1

	// RDMLR: Random Number Generation Counter Upper Limit Setting Register
	// Position of RMD field.
	ETHERC0_RDMLR_RMD_Pos = 0x0
	// Bit mask of RMD field.
	ETHERC0_RDMLR_RMD_Msk = 0xfffff
	// Normal operation
	ETHERC0_RDMLR_RMD_00000h = 0x0

	// IPGR: IPG Register
	// Position of IPG field.
	ETHERC0_IPGR_IPG_Pos = 0x0
	// Bit mask of IPG field.
	ETHERC0_IPGR_IPG_Msk = 0x1f
	// 96 bit time (initial value)
	ETHERC0_IPGR_IPG_14h = 0x14

	// APR: Automatic PAUSE Frame Register
	// Position of AP field.
	ETHERC0_APR_AP_Pos = 0x0
	// Bit mask of AP field.
	ETHERC0_APR_AP_Msk = 0xffff

	// MPR: Manual PAUSE Frame Register
	// Position of MP field.
	ETHERC0_MPR_MP_Pos = 0x0
	// Bit mask of MP field.
	ETHERC0_MPR_MP_Msk = 0xffff

	// RFCF: Received PAUSE Frame Counter
	// Position of RPAUSE field.
	ETHERC0_RFCF_RPAUSE_Pos = 0x0
	// Bit mask of RPAUSE field.
	ETHERC0_RFCF_RPAUSE_Msk = 0xff

	// TPAUSER: PAUSE Frame Retransmit Count Setting Register
	// Position of TPAUSE field.
	ETHERC0_TPAUSER_TPAUSE_Pos = 0x0
	// Bit mask of TPAUSE field.
	ETHERC0_TPAUSER_TPAUSE_Msk = 0xffff
	// Number of retransmissions is unlimited
	ETHERC0_TPAUSER_TPAUSE_0x0000 = 0x0

	// BCFRR: Broadcast Frame Receive Count Setting Register
	// Position of BCF field.
	ETHERC0_BCFRR_BCF_Pos = 0x0
	// Bit mask of BCF field.
	ETHERC0_BCFRR_BCF_Msk = 0xffff
	// Number of receptions is unlimited.
	ETHERC0_BCFRR_BCF_0000h = 0x0

	// MAHR: MAC Address Upper Bit Register
	// Position of MAHR field.
	ETHERC0_MAHR_MAHR_Pos = 0x0
	// Bit mask of MAHR field.
	ETHERC0_MAHR_MAHR_Msk = 0xffffffff

	// MALR: MAC Address Lower Bit Register
	// Position of MALR field.
	ETHERC0_MALR_MALR_Pos = 0x0
	// Bit mask of MALR field.
	ETHERC0_MALR_MALR_Msk = 0xffff

	// TROCR: Transmit Retry Over Counter Register
	// Position of TROCR field.
	ETHERC0_TROCR_TROCR_Pos = 0x0
	// Bit mask of TROCR field.
	ETHERC0_TROCR_TROCR_Msk = 0xffffffff

	// LCCR: Lost Carrier Counter Register
	// Position of LCCR field.
	ETHERC0_LCCR_LCCR_Pos = 0x0
	// Bit mask of LCCR field.
	ETHERC0_LCCR_LCCR_Msk = 0xffffffff

	// CNDCR: Carrier Not Detect Counter Register
	// Position of CNDCR field.
	ETHERC0_CNDCR_CNDCR_Pos = 0x0
	// Bit mask of CNDCR field.
	ETHERC0_CNDCR_CNDCR_Msk = 0xffffffff

	// CEFCR: CRC Error Frame Receive Counter Register
	// Position of CEFCR field.
	ETHERC0_CEFCR_CEFCR_Pos = 0x0
	// Bit mask of CEFCR field.
	ETHERC0_CEFCR_CEFCR_Msk = 0xffffffff

	// FRECR: Frame Receive Error Counter Register
	// Position of FRECR field.
	ETHERC0_FRECR_FRECR_Pos = 0x0
	// Bit mask of FRECR field.
	ETHERC0_FRECR_FRECR_Msk = 0xffffffff

	// TSFRCR: Too-Short Frame Receive Counter Register
	// Position of TSFRCR field.
	ETHERC0_TSFRCR_TSFRCR_Pos = 0x0
	// Bit mask of TSFRCR field.
	ETHERC0_TSFRCR_TSFRCR_Msk = 0xffffffff

	// TLFRCR: Too-Long Frame Receive Counter Register
	// Position of TLFRCR field.
	ETHERC0_TLFRCR_TLFRCR_Pos = 0x0
	// Bit mask of TLFRCR field.
	ETHERC0_TLFRCR_TLFRCR_Msk = 0xffffffff

	// RFCR: Received Alignment Error Frame Counter Register
	// Position of RFCR field.
	ETHERC0_RFCR_RFCR_Pos = 0x0
	// Bit mask of RFCR field.
	ETHERC0_RFCR_RFCR_Msk = 0xffffffff

	// MAFCR: Multicast Address Frame Receive Counter Register
	// Position of MAFCR field.
	ETHERC0_MAFCR_MAFCR_Pos = 0x0
	// Bit mask of MAFCR field.
	ETHERC0_MAFCR_MAFCR_Msk = 0xffffffff
)

// Constants for SDHI0: SD Host Interface 0
const (
	// SD_CMD: Command Type Register
	// Position of CMD12AT field.
	SDHI0_SD_CMD_CMD12AT_Pos = 0xe
	// Bit mask of CMD12AT field.
	SDHI0_SD_CMD_CMD12AT_Msk = 0xc000
	// CMD12 is automatically issued at multiple block transfer.
	SDHI0_SD_CMD_CMD12AT_00 = 0x0
	// CMD12 is not automatically issued at multiple block transfer.
	SDHI0_SD_CMD_CMD12AT_01 = 0x1
	// Setting prohibited
	SDHI0_SD_CMD_CMD12AT_10 = 0x2
	// Setting prohibited
	SDHI0_SD_CMD_CMD12AT_11 = 0x3
	// Position of TRSTP field.
	SDHI0_SD_CMD_TRSTP_Pos = 0xd
	// Bit mask of TRSTP field.
	SDHI0_SD_CMD_TRSTP_Msk = 0x2000
	// Bit TRSTP.
	SDHI0_SD_CMD_TRSTP = 0x2000
	// Single block transfer
	SDHI0_SD_CMD_TRSTP_0 = 0x0
	// Multiple block transfer
	SDHI0_SD_CMD_TRSTP_1 = 0x1
	// Position of CMDRW field.
	SDHI0_SD_CMD_CMDRW_Pos = 0xc
	// Bit mask of CMDRW field.
	SDHI0_SD_CMD_CMDRW_Msk = 0x1000
	// Bit CMDRW.
	SDHI0_SD_CMD_CMDRW = 0x1000
	// Write (SD/MMC host interface -> SD card/MMC)
	SDHI0_SD_CMD_CMDRW_0 = 0x0
	// Read (SD/MMC host interface <- SD card/MMC)
	SDHI0_SD_CMD_CMDRW_1 = 0x1
	// Position of CMDTP field.
	SDHI0_SD_CMD_CMDTP_Pos = 0xb
	// Bit mask of CMDTP field.
	SDHI0_SD_CMD_CMDTP_Msk = 0x800
	// Bit CMDTP.
	SDHI0_SD_CMD_CMDTP = 0x800
	// Command does not include data transfer (bc, bcr, or ac)
	SDHI0_SD_CMD_CMDTP_0 = 0x0
	// Command includes data transfer (adtc)
	SDHI0_SD_CMD_CMDTP_1 = 0x1
	// Position of RSPTP field.
	SDHI0_SD_CMD_RSPTP_Pos = 0x8
	// Bit mask of RSPTP field.
	SDHI0_SD_CMD_RSPTP_Msk = 0x700
	// Normal mode The response type and the transfer mode are selected by SD_CMD[7:0], and the SD_CMD[15:11] setting is disabled.
	SDHI0_SD_CMD_RSPTP_000 = 0x0
	// Expansion mode and no response
	SDHI0_SD_CMD_RSPTP_011 = 0x3
	// Expansion mode and R1, R5, R6, or R7 response
	SDHI0_SD_CMD_RSPTP_100 = 0x4
	// Expansion mode and R1b response
	SDHI0_SD_CMD_RSPTP_101 = 0x5
	// Expansion mode and R2 response
	SDHI0_SD_CMD_RSPTP_110 = 0x6
	// Expansion mode and R3 or R4 response
	SDHI0_SD_CMD_RSPTP_111 = 0x7
	// Position of ACMD field.
	SDHI0_SD_CMD_ACMD_Pos = 0x6
	// Bit mask of ACMD field.
	SDHI0_SD_CMD_ACMD_Msk = 0xc0
	// CMD
	SDHI0_SD_CMD_ACMD_00 = 0x0
	// ACMD
	SDHI0_SD_CMD_ACMD_01 = 0x1
	// Position of CMDIDX field.
	SDHI0_SD_CMD_CMDIDX_Pos = 0x0
	// Bit mask of CMDIDX field.
	SDHI0_SD_CMD_CMDIDX_Msk = 0x3f

	// SD_ARG: SD Command Argument Register
	// Position of SD_ARG field.
	SDHI0_SD_ARG_SD_ARG_Pos = 0x0
	// Bit mask of SD_ARG field.
	SDHI0_SD_ARG_SD_ARG_Msk = 0xffffffff

	// SD_ARG1: SD Command Argument Register 1
	// Position of SD_ARG1 field.
	SDHI0_SD_ARG1_SD_ARG1_Pos = 0x0
	// Bit mask of SD_ARG1 field.
	SDHI0_SD_ARG1_SD_ARG1_Msk = 0xffff

	// SD_STOP: Data Stop Register
	// Position of SEC field.
	SDHI0_SD_STOP_SEC_Pos = 0x8
	// Bit mask of SEC field.
	SDHI0_SD_STOP_SEC_Msk = 0x100
	// Bit SEC.
	SDHI0_SD_STOP_SEC = 0x100
	// Disables SD_SECCNT setting value.
	SDHI0_SD_STOP_SEC_0 = 0x0
	// Enables SD_SECCNT setting value.
	SDHI0_SD_STOP_SEC_1 = 0x1
	// Position of STP field.
	SDHI0_SD_STOP_STP_Pos = 0x0
	// Bit mask of STP field.
	SDHI0_SD_STOP_STP_Msk = 0x1
	// Bit STP.
	SDHI0_SD_STOP_STP = 0x1

	// SD_SECCNT: Block Count Register
	// Position of SD_SECCNT field.
	SDHI0_SD_SECCNT_SD_SECCNT_Pos = 0x0
	// Bit mask of SD_SECCNT field.
	SDHI0_SD_SECCNT_SD_SECCNT_Msk = 0xffffffff

	// SD_RSP10: SD Card Response Register 10
	// Position of SD_RSP10 field.
	SDHI0_SD_RSP10_SD_RSP10_Pos = 0x0
	// Bit mask of SD_RSP10 field.
	SDHI0_SD_RSP10_SD_RSP10_Msk = 0xffffffff

	// SD_RSP1: SD Card Response Register 1
	// Position of SD_RSP1 field.
	SDHI0_SD_RSP1_SD_RSP1_Pos = 0x0
	// Bit mask of SD_RSP1 field.
	SDHI0_SD_RSP1_SD_RSP1_Msk = 0xffff

	// SD_RSP32: SD Card Response Register 32
	// Position of SD_RSP32 field.
	SDHI0_SD_RSP32_SD_RSP32_Pos = 0x0
	// Bit mask of SD_RSP32 field.
	SDHI0_SD_RSP32_SD_RSP32_Msk = 0xffffffff

	// SD_RSP3: SD Card Response Register 3
	// Position of SD_RSP3 field.
	SDHI0_SD_RSP3_SD_RSP3_Pos = 0x0
	// Bit mask of SD_RSP3 field.
	SDHI0_SD_RSP3_SD_RSP3_Msk = 0xffff

	// SD_RSP54: SD Card Response Register 54
	// Position of SD_RSP54 field.
	SDHI0_SD_RSP54_SD_RSP54_Pos = 0x0
	// Bit mask of SD_RSP54 field.
	SDHI0_SD_RSP54_SD_RSP54_Msk = 0xffffffff

	// SD_RSP5: SD Card Response Register 5
	// Position of SD_RSP5 field.
	SDHI0_SD_RSP5_SD_RSP5_Pos = 0x0
	// Bit mask of SD_RSP5 field.
	SDHI0_SD_RSP5_SD_RSP5_Msk = 0xffff

	// SD_RSP76: SD Card Response Register 76
	// Position of SD_RSP76 field.
	SDHI0_SD_RSP76_SD_RSP76_Pos = 0x0
	// Bit mask of SD_RSP76 field.
	SDHI0_SD_RSP76_SD_RSP76_Msk = 0xffffff

	// SD_RSP7: SD Card Response Register 7
	// Position of SD_RSP7 field.
	SDHI0_SD_RSP7_SD_RSP7_Pos = 0x0
	// Bit mask of SD_RSP7 field.
	SDHI0_SD_RSP7_SD_RSP7_Msk = 0xff

	// SD_INFO1: SD Card Interrupt Flag Register 1
	// Position of SDD3MON field.
	SDHI0_SD_INFO1_SDD3MON_Pos = 0xa
	// Bit mask of SDD3MON field.
	SDHI0_SD_INFO1_SDD3MON_Msk = 0x400
	// Bit SDD3MON.
	SDHI0_SD_INFO1_SDD3MON = 0x400
	// SDnDAT3 is set to 0.
	SDHI0_SD_INFO1_SDD3MON_0 = 0x0
	// SDnDAT3 is set to 1.
	SDHI0_SD_INFO1_SDD3MON_1 = 0x1
	// Position of SDD3IN field.
	SDHI0_SD_INFO1_SDD3IN_Pos = 0x9
	// Bit mask of SDD3IN field.
	SDHI0_SD_INFO1_SDD3IN_Msk = 0x200
	// Bit SDD3IN.
	SDHI0_SD_INFO1_SDD3IN = 0x200
	// SD card insertion not detected
	SDHI0_SD_INFO1_SDD3IN_0 = 0x0
	// SD card insertion detected
	SDHI0_SD_INFO1_SDD3IN_1 = 0x1
	// Position of SDD3RM field.
	SDHI0_SD_INFO1_SDD3RM_Pos = 0x8
	// Bit mask of SDD3RM field.
	SDHI0_SD_INFO1_SDD3RM_Msk = 0x100
	// Bit SDD3RM.
	SDHI0_SD_INFO1_SDD3RM = 0x100
	// SD card removal not detected
	SDHI0_SD_INFO1_SDD3RM_0 = 0x0
	// SD card removal detected
	SDHI0_SD_INFO1_SDD3RM_1 = 0x1
	// Position of SDWPMON field.
	SDHI0_SD_INFO1_SDWPMON_Pos = 0x7
	// Bit mask of SDWPMON field.
	SDHI0_SD_INFO1_SDWPMON_Msk = 0x80
	// Bit SDWPMON.
	SDHI0_SD_INFO1_SDWPMON = 0x80
	// SDnWP is set to 1.
	SDHI0_SD_INFO1_SDWPMON_0 = 0x0
	// SDnWP is set to 0.
	SDHI0_SD_INFO1_SDWPMON_1 = 0x1
	// Position of SDCDMON field.
	SDHI0_SD_INFO1_SDCDMON_Pos = 0x5
	// Bit mask of SDCDMON field.
	SDHI0_SD_INFO1_SDCDMON_Msk = 0x20
	// Bit SDCDMON.
	SDHI0_SD_INFO1_SDCDMON = 0x20
	// Indicates that Mcycle has elapsed with SDnCD held 1.(Mcycle is set by bits 3 to 0 in SD_OPTION.)
	SDHI0_SD_INFO1_SDCDMON_0 = 0x0
	// Indicates that Mcycle has elapsed with SDnCD held 0. (Mcycle is set by bits 3 to 0 in SD_OPTION.)
	SDHI0_SD_INFO1_SDCDMON_1 = 0x1
	// Position of SDCDIN field.
	SDHI0_SD_INFO1_SDCDIN_Pos = 0x4
	// Bit mask of SDCDIN field.
	SDHI0_SD_INFO1_SDCDIN_Msk = 0x10
	// Bit SDCDIN.
	SDHI0_SD_INFO1_SDCDIN = 0x10
	// Card insertion not detected
	SDHI0_SD_INFO1_SDCDIN_0 = 0x0
	// Card insertion detected
	SDHI0_SD_INFO1_SDCDIN_1 = 0x1
	// Position of SDCDRM field.
	SDHI0_SD_INFO1_SDCDRM_Pos = 0x3
	// Bit mask of SDCDRM field.
	SDHI0_SD_INFO1_SDCDRM_Msk = 0x8
	// Bit SDCDRM.
	SDHI0_SD_INFO1_SDCDRM = 0x8
	// Card removal not detected
	SDHI0_SD_INFO1_SDCDRM_0 = 0x0
	// Card removal detected
	SDHI0_SD_INFO1_SDCDRM_1 = 0x1
	// Position of ACEND field.
	SDHI0_SD_INFO1_ACEND_Pos = 0x2
	// Bit mask of ACEND field.
	SDHI0_SD_INFO1_ACEND_Msk = 0x4
	// Bit ACEND.
	SDHI0_SD_INFO1_ACEND = 0x4
	// Access end is not detected
	SDHI0_SD_INFO1_ACEND_0 = 0x0
	// Access end is detected
	SDHI0_SD_INFO1_ACEND_1 = 0x1
	// Position of RSPEND field.
	SDHI0_SD_INFO1_RSPEND_Pos = 0x0
	// Bit mask of RSPEND field.
	SDHI0_SD_INFO1_RSPEND_Msk = 0x1
	// Bit RSPEND.
	SDHI0_SD_INFO1_RSPEND = 0x1
	// Response end is not detected
	SDHI0_SD_INFO1_RSPEND_0 = 0x0
	// Response end is detected
	SDHI0_SD_INFO1_RSPEND_1 = 0x1

	// SD_INFO2: SD Card Interrupt Flag Register 2
	// Position of ILA field.
	SDHI0_SD_INFO2_ILA_Pos = 0xf
	// Bit mask of ILA field.
	SDHI0_SD_INFO2_ILA_Msk = 0x8000
	// Bit ILA.
	SDHI0_SD_INFO2_ILA = 0x8000
	// Illegal access error not detected
	SDHI0_SD_INFO2_ILA_0 = 0x0
	// Illegal access error detected
	SDHI0_SD_INFO2_ILA_1 = 0x1
	// Position of CBSY field.
	SDHI0_SD_INFO2_CBSY_Pos = 0xe
	// Bit mask of CBSY field.
	SDHI0_SD_INFO2_CBSY_Msk = 0x4000
	// Bit CBSY.
	SDHI0_SD_INFO2_CBSY = 0x4000
	// A command sequence is being executed.
	SDHI0_SD_INFO2_CBSY_0 = 0x0
	// A command sequence has been completed.
	SDHI0_SD_INFO2_CBSY_1 = 0x1
	// Position of SD_CLK_CTRLEN field.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_Pos = 0xd
	// Bit mask of SD_CLK_CTRLEN field.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_Msk = 0x2000
	// Bit SD_CLK_CTRLEN.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN = 0x2000
	// The SD/MMC bus (CMD, DAT) is busy. Writing to the SCLKEN and DIV bits in SD_CLK_CTRL is not possible.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_0 = 0x0
	// The SD/MMC bus (CMD, DAT) is not busy.
	SDHI0_SD_INFO2_SD_CLK_CTRLEN_1 = 0x1
	// Position of BWE field.
	SDHI0_SD_INFO2_BWE_Pos = 0x9
	// Bit mask of BWE field.
	SDHI0_SD_INFO2_BWE_Msk = 0x200
	// Bit BWE.
	SDHI0_SD_INFO2_BWE = 0x200
	// Data can be written in SD_BUF0.
	SDHI0_SD_INFO2_BWE_1 = 0x1
	// Data cannot be written in SD_BUF0.
	SDHI0_SD_INFO2_BWE_0 = 0x0
	// Position of BRE field.
	SDHI0_SD_INFO2_BRE_Pos = 0x8
	// Bit mask of BRE field.
	SDHI0_SD_INFO2_BRE_Msk = 0x100
	// Bit BRE.
	SDHI0_SD_INFO2_BRE = 0x100
	// Data can be read from SD_BUF0.
	SDHI0_SD_INFO2_BRE_1 = 0x1
	// Data cannot be read from SD_BUF0.
	SDHI0_SD_INFO2_BRE_0 = 0x0
	// Position of SDD0MON field.
	SDHI0_SD_INFO2_SDD0MON_Pos = 0x7
	// Bit mask of SDD0MON field.
	SDHI0_SD_INFO2_SDD0MON_Msk = 0x80
	// Bit SDD0MON.
	SDHI0_SD_INFO2_SDD0MON = 0x80
	// SDDAT0 is set to 1.
	SDHI0_SD_INFO2_SDD0MON_1 = 0x1
	// SDDAT0 is set to 0.
	SDHI0_SD_INFO2_SDD0MON_0 = 0x0
	// Position of RSPTO field.
	SDHI0_SD_INFO2_RSPTO_Pos = 0x6
	// Bit mask of RSPTO field.
	SDHI0_SD_INFO2_RSPTO_Msk = 0x40
	// Bit RSPTO.
	SDHI0_SD_INFO2_RSPTO = 0x40
	// Response timeout not detected
	SDHI0_SD_INFO2_RSPTO_0 = 0x0
	// Response timeout detected
	SDHI0_SD_INFO2_RSPTO_1 = 0x1
	// Position of ILR field.
	SDHI0_SD_INFO2_ILR_Pos = 0x5
	// Bit mask of ILR field.
	SDHI0_SD_INFO2_ILR_Msk = 0x20
	// Bit ILR.
	SDHI0_SD_INFO2_ILR = 0x20
	// Illegal read access to the SD_BUF register not detected
	SDHI0_SD_INFO2_ILR_0 = 0x0
	// Illegal read access to the SD_BUF register detected
	SDHI0_SD_INFO2_ILR_1 = 0x1
	// Position of ILW field.
	SDHI0_SD_INFO2_ILW_Pos = 0x4
	// Bit mask of ILW field.
	SDHI0_SD_INFO2_ILW_Msk = 0x10
	// Bit ILW.
	SDHI0_SD_INFO2_ILW = 0x10
	// Illegal write access to the SD_BUF register not detected
	SDHI0_SD_INFO2_ILW_0 = 0x0
	// Illegal write access to the SD_BUF register detected
	SDHI0_SD_INFO2_ILW_1 = 0x1
	// Position of DTO field.
	SDHI0_SD_INFO2_DTO_Pos = 0x3
	// Bit mask of DTO field.
	SDHI0_SD_INFO2_DTO_Msk = 0x8
	// Bit DTO.
	SDHI0_SD_INFO2_DTO = 0x8
	// Data timeout not detected
	SDHI0_SD_INFO2_DTO_0 = 0x0
	// Data timeout detected
	SDHI0_SD_INFO2_DTO_1 = 0x1
	// Position of ENDE field.
	SDHI0_SD_INFO2_ENDE_Pos = 0x2
	// Bit mask of ENDE field.
	SDHI0_SD_INFO2_ENDE_Msk = 0x4
	// Bit ENDE.
	SDHI0_SD_INFO2_ENDE = 0x4
	// End bit error not detected
	SDHI0_SD_INFO2_ENDE_0 = 0x0
	// End bit error detected
	SDHI0_SD_INFO2_ENDE_1 = 0x1
	// Position of CRCE field.
	SDHI0_SD_INFO2_CRCE_Pos = 0x1
	// Bit mask of CRCE field.
	SDHI0_SD_INFO2_CRCE_Msk = 0x2
	// Bit CRCE.
	SDHI0_SD_INFO2_CRCE = 0x2
	// CRC error not detected
	SDHI0_SD_INFO2_CRCE_0 = 0x0
	// CRC error detected
	SDHI0_SD_INFO2_CRCE_1 = 0x1
	// Position of CMDE field.
	SDHI0_SD_INFO2_CMDE_Pos = 0x0
	// Bit mask of CMDE field.
	SDHI0_SD_INFO2_CMDE_Msk = 0x1
	// Bit CMDE.
	SDHI0_SD_INFO2_CMDE = 0x1
	// Command error not detected
	SDHI0_SD_INFO2_CMDE_0 = 0x0
	// Command error detected
	SDHI0_SD_INFO2_CMDE_1 = 0x1

	// SD_INFO1_MASK: SD_INFO1 Interrupt Mask Register
	// Position of SDD3INM field.
	SDHI0_SD_INFO1_MASK_SDD3INM_Pos = 0x9
	// Bit mask of SDD3INM field.
	SDHI0_SD_INFO1_MASK_SDD3INM_Msk = 0x200
	// Bit SDD3INM.
	SDHI0_SD_INFO1_MASK_SDD3INM = 0x200
	// SD card insertion interrupt request by the SDnDAT3 is not masked
	SDHI0_SD_INFO1_MASK_SDD3INM_0 = 0x0
	// SD card insertion interrupt request by the SDnDAT3 is masked
	SDHI0_SD_INFO1_MASK_SDD3INM_1 = 0x1
	// Position of SDD3RMM field.
	SDHI0_SD_INFO1_MASK_SDD3RMM_Pos = 0x8
	// Bit mask of SDD3RMM field.
	SDHI0_SD_INFO1_MASK_SDD3RMM_Msk = 0x100
	// Bit SDD3RMM.
	SDHI0_SD_INFO1_MASK_SDD3RMM = 0x100
	// SD card removal interrupt request by the SDnDAT3 is not masked
	SDHI0_SD_INFO1_MASK_SDD3RMM_0 = 0x0
	// SD card removal interrupt request by the SDnDAT3 is masked
	SDHI0_SD_INFO1_MASK_SDD3RMM_1 = 0x1
	// Position of SDCDINM field.
	SDHI0_SD_INFO1_MASK_SDCDINM_Pos = 0x4
	// Bit mask of SDCDINM field.
	SDHI0_SD_INFO1_MASK_SDCDINM_Msk = 0x10
	// Bit SDCDINM.
	SDHI0_SD_INFO1_MASK_SDCDINM = 0x10
	// Card insertion interrupt request by the SDnCD is not masked
	SDHI0_SD_INFO1_MASK_SDCDINM_0 = 0x0
	// Card insertion interrupt request by the SDnCD is masked
	SDHI0_SD_INFO1_MASK_SDCDINM_1 = 0x1
	// Position of SDCDRMM field.
	SDHI0_SD_INFO1_MASK_SDCDRMM_Pos = 0x3
	// Bit mask of SDCDRMM field.
	SDHI0_SD_INFO1_MASK_SDCDRMM_Msk = 0x8
	// Bit SDCDRMM.
	SDHI0_SD_INFO1_MASK_SDCDRMM = 0x8
	// Card removal interrupt request by the by the SDnCD is not masked
	SDHI0_SD_INFO1_MASK_SDCDRMM_0 = 0x0
	// Card removal interrupt request by the by the SDnCD is masked
	SDHI0_SD_INFO1_MASK_SDCDRMM_1 = 0x1
	// Position of ACENDM field.
	SDHI0_SD_INFO1_MASK_ACENDM_Pos = 0x2
	// Bit mask of ACENDM field.
	SDHI0_SD_INFO1_MASK_ACENDM_Msk = 0x4
	// Bit ACENDM.
	SDHI0_SD_INFO1_MASK_ACENDM = 0x4
	// Access end interrupt request is not masked
	SDHI0_SD_INFO1_MASK_ACENDM_0 = 0x0
	// Access end interrupt request is masked
	SDHI0_SD_INFO1_MASK_ACENDM_1 = 0x1
	// Position of RSPENDM field.
	SDHI0_SD_INFO1_MASK_RSPENDM_Pos = 0x0
	// Bit mask of RSPENDM field.
	SDHI0_SD_INFO1_MASK_RSPENDM_Msk = 0x1
	// Bit RSPENDM.
	SDHI0_SD_INFO1_MASK_RSPENDM = 0x1
	// Response end interrupt request is not masked
	SDHI0_SD_INFO1_MASK_RSPENDM_0 = 0x0
	// Response end interrupt request is masked
	SDHI0_SD_INFO1_MASK_RSPENDM_1 = 0x1

	// SD_INFO2_MASK: SD_INFO2 Interrupt Mask Register
	// Position of ILAM field.
	SDHI0_SD_INFO2_MASK_ILAM_Pos = 0xf
	// Bit mask of ILAM field.
	SDHI0_SD_INFO2_MASK_ILAM_Msk = 0x8000
	// Bit ILAM.
	SDHI0_SD_INFO2_MASK_ILAM = 0x8000
	// Illegal access error interrupt request not masked
	SDHI0_SD_INFO2_MASK_ILAM_0 = 0x0
	// Illegal access error interrupt request masked
	SDHI0_SD_INFO2_MASK_ILAM_1 = 0x1
	// Position of BWEM field.
	SDHI0_SD_INFO2_MASK_BWEM_Pos = 0x9
	// Bit mask of BWEM field.
	SDHI0_SD_INFO2_MASK_BWEM_Msk = 0x200
	// Bit BWEM.
	SDHI0_SD_INFO2_MASK_BWEM = 0x200
	// Write enable interrupt request for the SD_BUF register not masked
	SDHI0_SD_INFO2_MASK_BWEM_0 = 0x0
	// Write enable interrupt request for the SD_BUF register masked
	SDHI0_SD_INFO2_MASK_BWEM_1 = 0x1
	// Position of BREM field.
	SDHI0_SD_INFO2_MASK_BREM_Pos = 0x8
	// Bit mask of BREM field.
	SDHI0_SD_INFO2_MASK_BREM_Msk = 0x100
	// Bit BREM.
	SDHI0_SD_INFO2_MASK_BREM = 0x100
	// Read enable interrupt request for the SD buffer not masked
	SDHI0_SD_INFO2_MASK_BREM_0 = 0x0
	// Read enable interrupt request for the SD buffer masked
	SDHI0_SD_INFO2_MASK_BREM_1 = 0x1
	// Position of RSPTOM field.
	SDHI0_SD_INFO2_MASK_RSPTOM_Pos = 0x6
	// Bit mask of RSPTOM field.
	SDHI0_SD_INFO2_MASK_RSPTOM_Msk = 0x40
	// Bit RSPTOM.
	SDHI0_SD_INFO2_MASK_RSPTOM = 0x40
	// Response timeout interrupt request not masked
	SDHI0_SD_INFO2_MASK_RSPTOM_0 = 0x0
	// Response timeout interrupt request masked
	SDHI0_SD_INFO2_MASK_RSPTOM_1 = 0x1
	// Position of ILRM field.
	SDHI0_SD_INFO2_MASK_ILRM_Pos = 0x5
	// Bit mask of ILRM field.
	SDHI0_SD_INFO2_MASK_ILRM_Msk = 0x20
	// Bit ILRM.
	SDHI0_SD_INFO2_MASK_ILRM = 0x20
	// Illegal read detection interrupt request for the SD_BUF register not masked
	SDHI0_SD_INFO2_MASK_ILRM_0 = 0x0
	// Illegal read detection interrupt request for the SD_BUF register masked
	SDHI0_SD_INFO2_MASK_ILRM_1 = 0x1
	// Position of ILWM field.
	SDHI0_SD_INFO2_MASK_ILWM_Pos = 0x4
	// Bit mask of ILWM field.
	SDHI0_SD_INFO2_MASK_ILWM_Msk = 0x10
	// Bit ILWM.
	SDHI0_SD_INFO2_MASK_ILWM = 0x10
	// Illegal write detection interrupt request for the SD_BUF register not masked
	SDHI0_SD_INFO2_MASK_ILWM_0 = 0x0
	// Illegal write detection interrupt request for the SD_BUF register masked
	SDHI0_SD_INFO2_MASK_ILWM_1 = 0x1
	// Position of DTOM field.
	SDHI0_SD_INFO2_MASK_DTOM_Pos = 0x3
	// Bit mask of DTOM field.
	SDHI0_SD_INFO2_MASK_DTOM_Msk = 0x8
	// Bit DTOM.
	SDHI0_SD_INFO2_MASK_DTOM = 0x8
	// Data timeout interrupt request not masked
	SDHI0_SD_INFO2_MASK_DTOM_0 = 0x0
	// Data timeout interrupt request masked
	SDHI0_SD_INFO2_MASK_DTOM_1 = 0x1
	// Position of ENDEM field.
	SDHI0_SD_INFO2_MASK_ENDEM_Pos = 0x2
	// Bit mask of ENDEM field.
	SDHI0_SD_INFO2_MASK_ENDEM_Msk = 0x4
	// Bit ENDEM.
	SDHI0_SD_INFO2_MASK_ENDEM = 0x4
	// End bit detection error interrupt request not masked
	SDHI0_SD_INFO2_MASK_ENDEM_0 = 0x0
	// End bit detection error interrupt request masked
	SDHI0_SD_INFO2_MASK_ENDEM_1 = 0x1
	// Position of CRCEM field.
	SDHI0_SD_INFO2_MASK_CRCEM_Pos = 0x1
	// Bit mask of CRCEM field.
	SDHI0_SD_INFO2_MASK_CRCEM_Msk = 0x2
	// Bit CRCEM.
	SDHI0_SD_INFO2_MASK_CRCEM = 0x2
	// CRC error interrupt request not masked
	SDHI0_SD_INFO2_MASK_CRCEM_0 = 0x0
	// CRC error interrupt request masked
	SDHI0_SD_INFO2_MASK_CRCEM_1 = 0x1
	// Position of CMDEM field.
	SDHI0_SD_INFO2_MASK_CMDEM_Pos = 0x0
	// Bit mask of CMDEM field.
	SDHI0_SD_INFO2_MASK_CMDEM_Msk = 0x1
	// Bit CMDEM.
	SDHI0_SD_INFO2_MASK_CMDEM = 0x1
	// Command error interrupt request not masked
	SDHI0_SD_INFO2_MASK_CMDEM_0 = 0x0
	// Command error interrupt request masked
	SDHI0_SD_INFO2_MASK_CMDEM_1 = 0x1

	// SD_CLK_CTRL: SD Clock Control Register
	// Position of CLKCTRLEN field.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_Pos = 0x9
	// Bit mask of CLKCTRLEN field.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_Msk = 0x200
	// Bit CLKCTRLEN.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN = 0x200
	// Automatic control for SD/MMC Clock output is disabled.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_0 = 0x0
	// Automatic control for SD/MMC Clock output is enabled.
	SDHI0_SD_CLK_CTRL_CLKCTRLEN_1 = 0x1
	// Position of CLKEN field.
	SDHI0_SD_CLK_CTRL_CLKEN_Pos = 0x8
	// Bit mask of CLKEN field.
	SDHI0_SD_CLK_CTRL_CLKEN_Msk = 0x100
	// Bit CLKEN.
	SDHI0_SD_CLK_CTRL_CLKEN = 0x100
	// SD/MMC Clock output is disabled. The SDCLK signal is fixed 0.
	SDHI0_SD_CLK_CTRL_CLKEN_0 = 0x0
	// SD/MMC Clock output is enabled.
	SDHI0_SD_CLK_CTRL_CLKEN_1 = 0x1
	// Position of CLKSEL field.
	SDHI0_SD_CLK_CTRL_CLKSEL_Pos = 0x0
	// Bit mask of CLKSEL field.
	SDHI0_SD_CLK_CTRL_CLKSEL_Msk = 0xff
	// PCLKA divided by 2
	SDHI0_SD_CLK_CTRL_CLKSEL_0x00 = 0x0
	// PCLKA divided by 4
	SDHI0_SD_CLK_CTRL_CLKSEL_0x01 = 0x1
	// PCLKA divided by 8
	SDHI0_SD_CLK_CTRL_CLKSEL_0x02 = 0x2
	// PCLKA divided by 16
	SDHI0_SD_CLK_CTRL_CLKSEL_0x04 = 0x4
	// PCLKA divided by 32
	SDHI0_SD_CLK_CTRL_CLKSEL_0x08 = 0x8
	// PCLKA divided by 64
	SDHI0_SD_CLK_CTRL_CLKSEL_0x10 = 0x10
	// PCLKA divided by 128
	SDHI0_SD_CLK_CTRL_CLKSEL_0x20 = 0x20
	// PCLKA divided by 256
	SDHI0_SD_CLK_CTRL_CLKSEL_0x40 = 0x40
	// PCLKA divided by 512
	SDHI0_SD_CLK_CTRL_CLKSEL_0x80 = 0x80

	// SD_SIZE: Transfer Data Length Register
	// Position of LEN field.
	SDHI0_SD_SIZE_LEN_Pos = 0x0
	// Bit mask of LEN field.
	SDHI0_SD_SIZE_LEN_Msk = 0x3ff

	// SD_OPTION: SD Card Access Control Option Register
	// Position of WIDTH field.
	SDHI0_SD_OPTION_WIDTH_Pos = 0xf
	// Bit mask of WIDTH field.
	SDHI0_SD_OPTION_WIDTH_Msk = 0x8000
	// Bit WIDTH.
	SDHI0_SD_OPTION_WIDTH = 0x8000
	// 4-bit width (WIDTH8=0) / 8-bit width (WIDTH8=1)
	SDHI0_SD_OPTION_WIDTH_0 = 0x0
	// 1-bit width (WIDTH8=0 or 1 )
	SDHI0_SD_OPTION_WIDTH_1 = 0x1
	// Position of WIDTH8 field.
	SDHI0_SD_OPTION_WIDTH8_Pos = 0xd
	// Bit mask of WIDTH8 field.
	SDHI0_SD_OPTION_WIDTH8_Msk = 0x2000
	// Bit WIDTH8.
	SDHI0_SD_OPTION_WIDTH8 = 0x2000
	// Position of TOUTMASK field.
	SDHI0_SD_OPTION_TOUTMASK_Pos = 0x8
	// Bit mask of TOUTMASK field.
	SDHI0_SD_OPTION_TOUTMASK_Msk = 0x100
	// Bit TOUTMASK.
	SDHI0_SD_OPTION_TOUTMASK = 0x100
	// Activate Timeout
	SDHI0_SD_OPTION_TOUTMASK_0 = 0x0
	// Inactivate Timeout(RSPTO bit and DTO bit of SD_INFO2 and SD_ERR_STS2 won't be set)
	SDHI0_SD_OPTION_TOUTMASK_1 = 0x1
	// Position of TOP field.
	SDHI0_SD_OPTION_TOP_Pos = 0x4
	// Bit mask of TOP field.
	SDHI0_SD_OPTION_TOP_Msk = 0xf0
	// Setting prohibited
	SDHI0_SD_OPTION_TOP_1111 = 0xf
	// Position of CTOP field.
	SDHI0_SD_OPTION_CTOP_Pos = 0x0
	// Bit mask of CTOP field.
	SDHI0_SD_OPTION_CTOP_Msk = 0xf
	// Setting prohibited
	SDHI0_SD_OPTION_CTOP_1111 = 0xf

	// SD_ERR_STS1: SD Error Status Register 1
	// Position of CRCTK field.
	SDHI0_SD_ERR_STS1_CRCTK_Pos = 0xc
	// Bit mask of CRCTK field.
	SDHI0_SD_ERR_STS1_CRCTK_Msk = 0x7000
	// Position of CRCTKE field.
	SDHI0_SD_ERR_STS1_CRCTKE_Pos = 0xb
	// Bit mask of CRCTKE field.
	SDHI0_SD_ERR_STS1_CRCTKE_Msk = 0x800
	// Bit CRCTKE.
	SDHI0_SD_ERR_STS1_CRCTKE = 0x800
	// An error has not occured in the CRC status.
	SDHI0_SD_ERR_STS1_CRCTKE_0 = 0x0
	// An error has occured in the CRC status.
	SDHI0_SD_ERR_STS1_CRCTKE_1 = 0x1
	// Position of RDCRCE field.
	SDHI0_SD_ERR_STS1_RDCRCE_Pos = 0xa
	// Bit mask of RDCRCE field.
	SDHI0_SD_ERR_STS1_RDCRCE_Msk = 0x400
	// Bit RDCRCE.
	SDHI0_SD_ERR_STS1_RDCRCE = 0x400
	// CRC error has detected in read data
	SDHI0_SD_ERR_STS1_RDCRCE_0 = 0x0
	// CRC error has not detected in read data
	SDHI0_SD_ERR_STS1_RDCRCE_1 = 0x1
	// Position of RSPCRCE1 field.
	SDHI0_SD_ERR_STS1_RSPCRCE1_Pos = 0x9
	// Bit mask of RSPCRCE1 field.
	SDHI0_SD_ERR_STS1_RSPCRCE1_Msk = 0x200
	// Bit RSPCRCE1.
	SDHI0_SD_ERR_STS1_RSPCRCE1 = 0x200
	// CRC error has not occured.
	SDHI0_SD_ERR_STS1_RSPCRCE1_0 = 0x0
	// CRC error has occured in the response to a command issued within a command sequence.
	SDHI0_SD_ERR_STS1_RSPCRCE1_1 = 0x1
	// Position of RSPCRCE0 field.
	SDHI0_SD_ERR_STS1_RSPCRCE0_Pos = 0x8
	// Bit mask of RSPCRCE0 field.
	SDHI0_SD_ERR_STS1_RSPCRCE0_Msk = 0x100
	// Bit RSPCRCE0.
	SDHI0_SD_ERR_STS1_RSPCRCE0 = 0x100
	// A CRC error has not occur in a response
	SDHI0_SD_ERR_STS1_RSPCRCE0_0 = 0x0
	// A CRC error has occured in a response
	SDHI0_SD_ERR_STS1_RSPCRCE0_1 = 0x1
	// Position of CRCLENE field.
	SDHI0_SD_ERR_STS1_CRCLENE_Pos = 0x5
	// Bit mask of CRCLENE field.
	SDHI0_SD_ERR_STS1_CRCLENE_Msk = 0x20
	// Bit CRCLENE.
	SDHI0_SD_ERR_STS1_CRCLENE = 0x20
	// An error has not occured in the CRC status length.
	SDHI0_SD_ERR_STS1_CRCLENE_0 = 0x0
	// An error has occured in the CRC status length (and the end bit has not been detected)
	SDHI0_SD_ERR_STS1_CRCLENE_1 = 0x1
	// Position of RDLENE field.
	SDHI0_SD_ERR_STS1_RDLENE_Pos = 0x4
	// Bit mask of RDLENE field.
	SDHI0_SD_ERR_STS1_RDLENE_Msk = 0x10
	// Bit RDLENE.
	SDHI0_SD_ERR_STS1_RDLENE = 0x10
	// An error has occurred not in the read data length.
	SDHI0_SD_ERR_STS1_RDLENE_0 = 0x0
	// An error has occured in the read data length (and the end bit has not been detected among the valid bits).
	SDHI0_SD_ERR_STS1_RDLENE_1 = 0x1
	// Position of RSPLENE1 field.
	SDHI0_SD_ERR_STS1_RSPLENE1_Pos = 0x3
	// Bit mask of RSPLENE1 field.
	SDHI0_SD_ERR_STS1_RSPLENE1_Msk = 0x8
	// Bit RSPLENE1.
	SDHI0_SD_ERR_STS1_RSPLENE1 = 0x8
	// An error has not occurred in the response length to a command issued within a command sequence.
	SDHI0_SD_ERR_STS1_RSPLENE1_0 = 0x0
	// An error has occured in the response length to a command issued within a command sequence.
	SDHI0_SD_ERR_STS1_RSPLENE1_1 = 0x1
	// Position of RSPLENE0 field.
	SDHI0_SD_ERR_STS1_RSPLENE0_Pos = 0x2
	// Bit mask of RSPLENE0 field.
	SDHI0_SD_ERR_STS1_RSPLENE0_Msk = 0x4
	// Bit RSPLENE0.
	SDHI0_SD_ERR_STS1_RSPLENE0 = 0x4
	// An error has not occured in the response length
	SDHI0_SD_ERR_STS1_RSPLENE0_0 = 0x0
	// An error has occured in the response length
	SDHI0_SD_ERR_STS1_RSPLENE0_1 = 0x1
	// Position of CMDE1 field.
	SDHI0_SD_ERR_STS1_CMDE1_Pos = 0x1
	// Bit mask of CMDE1 field.
	SDHI0_SD_ERR_STS1_CMDE1_Msk = 0x2
	// Bit CMDE1.
	SDHI0_SD_ERR_STS1_CMDE1 = 0x2
	// An error has not occurs in the command index of the response to a command issued within a command sequence.
	SDHI0_SD_ERR_STS1_CMDE1_0 = 0x0
	// An error has occured in the command index of the response to a command issued within a command sequence.
	SDHI0_SD_ERR_STS1_CMDE1_1 = 0x1
	// Position of CMDE0 field.
	SDHI0_SD_ERR_STS1_CMDE0_Pos = 0x0
	// Bit mask of CMDE0 field.
	SDHI0_SD_ERR_STS1_CMDE0_Msk = 0x1
	// Bit CMDE0.
	SDHI0_SD_ERR_STS1_CMDE0 = 0x1
	// An error has not occured in the command index of a response.
	SDHI0_SD_ERR_STS1_CMDE0_0 = 0x0
	// An error has occured in the command index of a response.
	SDHI0_SD_ERR_STS1_CMDE0_1 = 0x1

	// SD_ERR_STS2: SD Error Status Register 2
	// Position of CRCBSYTO field.
	SDHI0_SD_ERR_STS2_CRCBSYTO_Pos = 0x6
	// Bit mask of CRCBSYTO field.
	SDHI0_SD_ERR_STS2_CRCBSYTO_Msk = 0x40
	// Bit CRCBSYTO.
	SDHI0_SD_ERR_STS2_CRCBSYTO = 0x40
	// Not timeout
	SDHI0_SD_ERR_STS2_CRCBSYTO_0 = 0x0
	// The busy state continues for longer than N-cycle after the CRC status
	SDHI0_SD_ERR_STS2_CRCBSYTO_1 = 0x1
	// Position of CRCTO field.
	SDHI0_SD_ERR_STS2_CRCTO_Pos = 0x5
	// Bit mask of CRCTO field.
	SDHI0_SD_ERR_STS2_CRCTO_Msk = 0x20
	// Bit CRCTO.
	SDHI0_SD_ERR_STS2_CRCTO = 0x20
	// Not timeout
	SDHI0_SD_ERR_STS2_CRCTO_0 = 0x0
	// The CRC status is not received though a longer time than N-cycle has elapsed after data writing.
	SDHI0_SD_ERR_STS2_CRCTO_1 = 0x1
	// Position of RDTO field.
	SDHI0_SD_ERR_STS2_RDTO_Pos = 0x4
	// Bit mask of RDTO field.
	SDHI0_SD_ERR_STS2_RDTO_Msk = 0x10
	// Bit RDTO.
	SDHI0_SD_ERR_STS2_RDTO = 0x10
	// Not timeout
	SDHI0_SD_ERR_STS2_RDTO_0 = 0x0
	// The read data is not received though a longer time than N-cycle has elapsed after read command. / The read data for the next block are not received though a longer time than N-cycle has elapsed after the reception of read data. / The read data for the next block are not received though a longer time than N-cycle has elapsed after release of the read wait state.
	SDHI0_SD_ERR_STS2_RDTO_1 = 0x1
	// Position of BSYTO1 field.
	SDHI0_SD_ERR_STS2_BSYTO1_Pos = 0x3
	// Bit mask of BSYTO1 field.
	SDHI0_SD_ERR_STS2_BSYTO1_Msk = 0x8
	// Bit BSYTO1.
	SDHI0_SD_ERR_STS2_BSYTO1 = 0x8
	// Not timeout.
	SDHI0_SD_ERR_STS2_BSYTO1_0 = 0x0
	// The busy state for longer than N-cycle continues after CMD12 has been issued within a command sequence. In cases where CMD12 is issued by setting a command index in SD_CMD, this is indicated in BSYTO0.
	SDHI0_SD_ERR_STS2_BSYTO1_1 = 0x1
	// Position of BSYTO0 field.
	SDHI0_SD_ERR_STS2_BSYTO0_Pos = 0x2
	// Bit mask of BSYTO0 field.
	SDHI0_SD_ERR_STS2_BSYTO0_Msk = 0x4
	// Bit BSYTO0.
	SDHI0_SD_ERR_STS2_BSYTO0 = 0x4
	// Not timeout.
	SDHI0_SD_ERR_STS2_BSYTO0_0 = 0x0
	// The busy state for longer than N-cycle continues after R1b response.
	SDHI0_SD_ERR_STS2_BSYTO0_1 = 0x1
	// Position of RSPTO1 field.
	SDHI0_SD_ERR_STS2_RSPTO1_Pos = 0x1
	// Bit mask of RSPTO1 field.
	SDHI0_SD_ERR_STS2_RSPTO1_Msk = 0x2
	// Bit RSPTO1.
	SDHI0_SD_ERR_STS2_RSPTO1 = 0x2
	// Not timeout.
	SDHI0_SD_ERR_STS2_RSPTO1_0 = 0x0
	// The response to a command issued within a command sequence*2 is not received though a longer time than 640 cycles of SD/MMC clock has elapsed. In cases where CMD12 is issued by setting a command index in SD_CMD, this is indicated in RSPTO0.
	SDHI0_SD_ERR_STS2_RSPTO1_1 = 0x1
	// Position of RSPTO0 field.
	SDHI0_SD_ERR_STS2_RSPTO0_Pos = 0x0
	// Bit mask of RSPTO0 field.
	SDHI0_SD_ERR_STS2_RSPTO0_Msk = 0x1
	// Bit RSPTO0.
	SDHI0_SD_ERR_STS2_RSPTO0 = 0x1
	// Not timeout.
	SDHI0_SD_ERR_STS2_RSPTO0_0 = 0x0
	// The response (other than a response to a command issued within a command sequence) is not received though a longer time than 640 cycles of SD/MMC clock has elapsed.
	SDHI0_SD_ERR_STS2_RSPTO0_1 = 0x1

	// SD_BUF0: SD Buffer Register
	// Position of SD_BUF field.
	SDHI0_SD_BUF0_SD_BUF_Pos = 0x0
	// Bit mask of SD_BUF field.
	SDHI0_SD_BUF0_SD_BUF_Msk = 0xffffffff

	// SDIO_MODE: SDIO Mode Control Register
	// Position of C52PUB field.
	SDHI0_SDIO_MODE_C52PUB_Pos = 0x9
	// Bit mask of C52PUB field.
	SDHI0_SDIO_MODE_C52PUB_Msk = 0x200
	// Bit C52PUB.
	SDHI0_SDIO_MODE_C52PUB = 0x200
	// Position of IOABT field.
	SDHI0_SDIO_MODE_IOABT_Pos = 0x8
	// Bit mask of IOABT field.
	SDHI0_SDIO_MODE_IOABT_Msk = 0x100
	// Bit IOABT.
	SDHI0_SDIO_MODE_IOABT = 0x100
	// Position of RWREQ field.
	SDHI0_SDIO_MODE_RWREQ_Pos = 0x2
	// Bit mask of RWREQ field.
	SDHI0_SDIO_MODE_RWREQ_Msk = 0x4
	// Bit RWREQ.
	SDHI0_SDIO_MODE_RWREQ = 0x4
	// Allow SD/MMC to exit read wait state
	SDHI0_SDIO_MODE_RWREQ_0 = 0x0
	// Request for SD/MMC to enter read wait state.
	SDHI0_SDIO_MODE_RWREQ_1 = 0x1
	// Position of INTEN field.
	SDHI0_SDIO_MODE_INTEN_Pos = 0x0
	// Bit mask of INTEN field.
	SDHI0_SDIO_MODE_INTEN_Msk = 0x1
	// Bit INTEN.
	SDHI0_SDIO_MODE_INTEN = 0x1
	// Enables the SD host interface to receive SDIO interrupt from the SDIO card
	SDHI0_SDIO_MODE_INTEN_1 = 0x1
	// Disables the SD host interface to receive SDIO interrupt from the SDIO card
	SDHI0_SDIO_MODE_INTEN_0 = 0x0

	// SDIO_INFO1: SDIO Interrupt Flag Register 1
	// Position of EXWT field.
	SDHI0_SDIO_INFO1_EXWT_Pos = 0xf
	// Bit mask of EXWT field.
	SDHI0_SDIO_INFO1_EXWT_Msk = 0x8000
	// Bit EXWT.
	SDHI0_SDIO_INFO1_EXWT = 0x8000
	// Position of EXPUB52 field.
	SDHI0_SDIO_INFO1_EXPUB52_Pos = 0xe
	// Bit mask of EXPUB52 field.
	SDHI0_SDIO_INFO1_EXPUB52_Msk = 0x4000
	// Bit EXPUB52.
	SDHI0_SDIO_INFO1_EXPUB52 = 0x4000
	// Position of IOIRQ field.
	SDHI0_SDIO_INFO1_IOIRQ_Pos = 0x0
	// Bit mask of IOIRQ field.
	SDHI0_SDIO_INFO1_IOIRQ_Msk = 0x1
	// Bit IOIRQ.
	SDHI0_SDIO_INFO1_IOIRQ = 0x1
	// SDIO interrupt not accepted
	SDHI0_SDIO_INFO1_IOIRQ_0 = 0x0
	// SDIO interrupt accepted
	SDHI0_SDIO_INFO1_IOIRQ_1 = 0x1

	// SDIO_INFO1_MASK: SDIO_INFO1 Interrupt Mask Register
	// Position of EXWTM field.
	SDHI0_SDIO_INFO1_MASK_EXWTM_Pos = 0xf
	// Bit mask of EXWTM field.
	SDHI0_SDIO_INFO1_MASK_EXWTM_Msk = 0x8000
	// Bit EXWTM.
	SDHI0_SDIO_INFO1_MASK_EXWTM = 0x8000
	// EXWT interrupt request not masked
	SDHI0_SDIO_INFO1_MASK_EXWTM_0 = 0x0
	// EXWT interrupt request masked
	SDHI0_SDIO_INFO1_MASK_EXWTM_1 = 0x1
	// Position of EXPUB52M field.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_Pos = 0xe
	// Bit mask of EXPUB52M field.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_Msk = 0x4000
	// Bit EXPUB52M.
	SDHI0_SDIO_INFO1_MASK_EXPUB52M = 0x4000
	// EXPUB52 interrupt request not masked
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_0 = 0x0
	// EXPUB52 interrupt request masked
	SDHI0_SDIO_INFO1_MASK_EXPUB52M_1 = 0x1
	// Position of IOIRQM field.
	SDHI0_SDIO_INFO1_MASK_IOIRQM_Pos = 0x0
	// Bit mask of IOIRQM field.
	SDHI0_SDIO_INFO1_MASK_IOIRQM_Msk = 0x1
	// Bit IOIRQM.
	SDHI0_SDIO_INFO1_MASK_IOIRQM = 0x1
	// IOIRQ interrupt not masked
	SDHI0_SDIO_INFO1_MASK_IOIRQM_0 = 0x0
	// IOIRQ interrupt masked
	SDHI0_SDIO_INFO1_MASK_IOIRQM_1 = 0x1

	// SD_DMAEN: DMA Mode Enable Register
	// Position of DMAEN field.
	SDHI0_SD_DMAEN_DMAEN_Pos = 0x1
	// Bit mask of DMAEN field.
	SDHI0_SD_DMAEN_DMAEN_Msk = 0x2
	// Bit DMAEN.
	SDHI0_SD_DMAEN_DMAEN = 0x2
	// The SD_BUF read/write DMA transfer is disabled.
	SDHI0_SD_DMAEN_DMAEN_0 = 0x0
	// The SD_BUF read/write DMA transfer is enabled.
	SDHI0_SD_DMAEN_DMAEN_1 = 0x1

	// SOFT_RST: Software Reset Register
	// Position of SDRST field.
	SDHI0_SOFT_RST_SDRST_Pos = 0x0
	// Bit mask of SDRST field.
	SDHI0_SOFT_RST_SDRST_Msk = 0x1
	// Bit SDRST.
	SDHI0_SOFT_RST_SDRST = 0x1
	// Reset
	SDHI0_SOFT_RST_SDRST_0 = 0x0
	// Reset released
	SDHI0_SOFT_RST_SDRST_1 = 0x1

	// SDIF_MODE: SD Interface Mode Setting Register
	// Position of NOCHKCR field.
	SDHI0_SDIF_MODE_NOCHKCR_Pos = 0x8
	// Bit mask of NOCHKCR field.
	SDHI0_SDIF_MODE_NOCHKCR_Msk = 0x100
	// Bit NOCHKCR.
	SDHI0_SDIF_MODE_NOCHKCR = 0x100
	// CRC check is valid
	SDHI0_SDIF_MODE_NOCHKCR_0 = 0x0
	// CRC check is invalid(CRC16 value is ignored when read and CRC Status value is ignored when write)
	SDHI0_SDIF_MODE_NOCHKCR_1 = 0x1

	// EXT_SWAP: Swap Control Register
	// Position of BRSWP field.
	SDHI0_EXT_SWAP_BRSWP_Pos = 0x7
	// Bit mask of BRSWP field.
	SDHI0_EXT_SWAP_BRSWP_Msk = 0x80
	// Bit BRSWP.
	SDHI0_EXT_SWAP_BRSWP = 0x80
	// The current data are read without swapping.
	SDHI0_EXT_SWAP_BRSWP_0 = 0x0
	// Swapping of the positions of the higher- and lower-order bytes of data for reading proceeds.
	SDHI0_EXT_SWAP_BRSWP_1 = 0x1
	// Position of BWSWP field.
	SDHI0_EXT_SWAP_BWSWP_Pos = 0x6
	// Bit mask of BWSWP field.
	SDHI0_EXT_SWAP_BWSWP_Msk = 0x40
	// Bit BWSWP.
	SDHI0_EXT_SWAP_BWSWP = 0x40
	// The current data are written without swapping.
	SDHI0_EXT_SWAP_BWSWP_0 = 0x0
	// Swapping of the positions of the higher- and lower-order bytes of data for writing proceeds.
	SDHI0_EXT_SWAP_BWSWP_1 = 0x1
)

// Constants for CRC: CRC Calculator
const (
	// CRCCR0: CRC Control Register0
	// Position of DORCLR field.
	CRC_CRCCR0_DORCLR_Pos = 0x7
	// Bit mask of DORCLR field.
	CRC_CRCCR0_DORCLR_Msk = 0x80
	// Bit DORCLR.
	CRC_CRCCR0_DORCLR = 0x80
	// No effect.
	CRC_CRCCR0_DORCLR_0 = 0x0
	// Clears the CRCDOR register.
	CRC_CRCCR0_DORCLR_1 = 0x1
	// Position of LMS field.
	CRC_CRCCR0_LMS_Pos = 0x6
	// Bit mask of LMS field.
	CRC_CRCCR0_LMS_Msk = 0x40
	// Bit LMS.
	CRC_CRCCR0_LMS = 0x40
	// Generates CRC for LSB first communication.
	CRC_CRCCR0_LMS_0 = 0x0
	// Generates CRC for MSB first communication.
	CRC_CRCCR0_LMS_1 = 0x1
	// Position of GPS field.
	CRC_CRCCR0_GPS_Pos = 0x0
	// Bit mask of GPS field.
	CRC_CRCCR0_GPS_Msk = 0x7
	// No calculation is executed.
	CRC_CRCCR0_GPS_000 = 0x0
	// 8-bit CRC-8 (X8 + X2 + X + 1)
	CRC_CRCCR0_GPS_001 = 0x1
	// 16-bit CRC-16 (X16 + X15 + X2 + 1)
	CRC_CRCCR0_GPS_010 = 0x2
	// 16-bit CRC-CCITT (X16 + X12 + X5 + 1)
	CRC_CRCCR0_GPS_011 = 0x3
	// 32-bit CRC-32 (X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1)
	CRC_CRCCR0_GPS_100 = 0x4
	// 32-bit CRC-32C (X32+X28+X27+X26+ X25+X23+X22+X20+X19+X18+X14+X13+X11+X10+X9+X8+X6+1)
	CRC_CRCCR0_GPS_101 = 0x5

	// CRCCR1: CRC Control Register1
	// Position of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Pos = 0x7
	// Bit mask of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Msk = 0x80
	// Bit CRCSEN.
	CRC_CRCCR1_CRCSEN = 0x80
	// Disabled
	CRC_CRCCR1_CRCSEN_0 = 0x0
	// Enabled
	CRC_CRCCR1_CRCSEN_1 = 0x1
	// Position of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Pos = 0x6
	// Bit mask of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Msk = 0x40
	// Bit CRCSWR.
	CRC_CRCCR1_CRCSWR = 0x40
	// Snoop-on-read
	CRC_CRCCR1_CRCSWR_0 = 0x0
	// Snoop-on-write
	CRC_CRCCR1_CRCSWR_1 = 0x1

	// CRCDIR: CRC Data Input Register
	// Position of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Pos = 0x0
	// Bit mask of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Msk = 0xffffffff

	// CRCDIR_BY: CRC Data Input Register (byte access)
	// Position of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Pos = 0x0
	// Bit mask of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Msk = 0xff

	// CRCDOR: CRC Data Output Register
	// Position of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Pos = 0x0
	// Bit mask of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Msk = 0xffffffff

	// CRCDOR_HA: CRC Data Output Register (halfword access)
	// Position of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Pos = 0x0
	// Bit mask of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Msk = 0xffff

	// CRCDOR_BY: CRC Data Output Register(byte access)
	// Position of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Pos = 0x0
	// Bit mask of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Msk = 0xff

	// CRCSAR: Snoop Address Register
	// Position of CRCSA field.
	CRC_CRCSAR_CRCSA_Pos = 0x0
	// Bit mask of CRCSA field.
	CRC_CRCSAR_CRCSA_Msk = 0x3fff
	// SCI0.TDR
	CRC_CRCSAR_CRCSA_0x0003 = 0x3
	// SCI0.RDR
	CRC_CRCSAR_CRCSA_0x0005 = 0x5
	// SCI1.TDR
	CRC_CRCSAR_CRCSA_0x0023 = 0x23
	// SCI1.RDR
	CRC_CRCSAR_CRCSA_0x0025 = 0x25
	// SCI2.TDR
	CRC_CRCSAR_CRCSA_0x0043 = 0x43
	// SCI2.RDR
	CRC_CRCSAR_CRCSA_0x0045 = 0x45
	// SCI3.TDR
	CRC_CRCSAR_CRCSA_0x0063 = 0x63
	// SCI3.RDR
	CRC_CRCSAR_CRCSA_0x0065 = 0x65
	// SCI4.TDR
	CRC_CRCSAR_CRCSA_0x0083 = 0x83
	// SCI4.RDR
	CRC_CRCSAR_CRCSA_0x0085 = 0x85
	// SCI5.TDR
	CRC_CRCSAR_CRCSA_0x00A3 = 0xa3
	// SCI5.RDR
	CRC_CRCSAR_CRCSA_0x00A5 = 0xa5
	// SCI6.TDR
	CRC_CRCSAR_CRCSA_0x00C3 = 0xc3
	// SCI6.RDR
	CRC_CRCSAR_CRCSA_0x00C5 = 0xc5
	// SCI7.TDR
	CRC_CRCSAR_CRCSA_0x00E3 = 0xe3
	// SCI7.RDR
	CRC_CRCSAR_CRCSA_0x00E5 = 0xe5
	// SCI8.TDR
	CRC_CRCSAR_CRCSA_0x0103 = 0x103
	// SCI8.RDR
	CRC_CRCSAR_CRCSA_0x0105 = 0x105
	// SCI9.TDR
	CRC_CRCSAR_CRCSA_0x0123 = 0x123
	// SCI9.RDR
	CRC_CRCSAR_CRCSA_0x0125 = 0x125
)

// Constants for CTSU: Capacitive Touch Sensing Unit
const (
	// CTSUCR0: CTSU Control Register 0
	// Position of CTSUTXVSEL field.
	CTSU_CTSUCR0_CTSUTXVSEL_Pos = 0x7
	// Bit mask of CTSUTXVSEL field.
	CTSU_CTSUCR0_CTSUTXVSEL_Msk = 0x80
	// Bit CTSUTXVSEL.
	CTSU_CTSUCR0_CTSUTXVSEL = 0x80
	// Select Vcc
	CTSU_CTSUCR0_CTSUTXVSEL_0 = 0x0
	// Select internal logic power supply
	CTSU_CTSUCR0_CTSUTXVSEL_1 = 0x1
	// Position of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Pos = 0x4
	// Bit mask of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Msk = 0x10
	// Bit CTSUINIT.
	CTSU_CTSUCR0_CTSUINIT = 0x10
	// Writing a 0 has no effect, this bit is read as 0.
	CTSU_CTSUCR0_CTSUINIT_0 = 0x0
	// initializes the CTSU control block and registers.
	CTSU_CTSUCR0_CTSUINIT_1 = 0x1
	// Position of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Pos = 0x2
	// Bit mask of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Msk = 0x4
	// Bit CTSUSNZ.
	CTSU_CTSUCR0_CTSUSNZ = 0x4
	// Power-saving function during wait state is disabled.
	CTSU_CTSUCR0_CTSUSNZ_0 = 0x0
	// Power-saving function during wait state is enabled.
	CTSU_CTSUCR0_CTSUSNZ_1 = 0x1
	// Position of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Pos = 0x1
	// Bit mask of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Msk = 0x2
	// Bit CTSUCAP.
	CTSU_CTSUCR0_CTSUCAP = 0x2
	// Software trigger.
	CTSU_CTSUCR0_CTSUCAP_0 = 0x0
	// External trigger.
	CTSU_CTSUCR0_CTSUCAP_1 = 0x1
	// Position of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Pos = 0x0
	// Bit mask of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Msk = 0x1
	// Bit CTSUSTRT.
	CTSU_CTSUCR0_CTSUSTRT = 0x1
	// Measurement operation stops.
	CTSU_CTSUCR0_CTSUSTRT_0 = 0x0
	// Measurement operation starts.
	CTSU_CTSUCR0_CTSUSTRT_1 = 0x1

	// CTSUCR1: CTSU Control Register 1
	// Position of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Pos = 0x6
	// Bit mask of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Msk = 0xc0
	// Self-capacitance single scan mode
	CTSU_CTSUCR1_CTSUMD_00 = 0x0
	// Self-capacitance multi-scan mode
	CTSU_CTSUCR1_CTSUMD_01 = 0x1
	// Mutual capacitance simple scan mode
	CTSU_CTSUCR1_CTSUMD_10 = 0x2
	// Mutual capacitance full scan mode
	CTSU_CTSUCR1_CTSUMD_11 = 0x3
	// Position of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Pos = 0x4
	// Bit mask of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Msk = 0x30
	// PCLK
	CTSU_CTSUCR1_CTSUCLK_00 = 0x0
	// PCLK/2 (PCLK divided by 2)
	CTSU_CTSUCR1_CTSUCLK_01 = 0x1
	// PCLK/2 (PCLK divided by 4)
	CTSU_CTSUCR1_CTSUCLK_10 = 0x2
	// Setting prohibited
	CTSU_CTSUCR1_CTSUCLK_11 = 0x3
	// Position of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Pos = 0x3
	// Bit mask of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Msk = 0x8
	// Bit CTSUATUNE1.
	CTSU_CTSUCR1_CTSUATUNE1 = 0x8
	// Normal output
	CTSU_CTSUCR1_CTSUATUNE1_0 = 0x0
	// High-current output
	CTSU_CTSUCR1_CTSUATUNE1_1 = 0x1
	// Position of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Pos = 0x1
	// Bit mask of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Msk = 0x2
	// Bit CTSUCSW.
	CTSU_CTSUCR1_CTSUCSW = 0x2
	// Turned off capacitance switch
	CTSU_CTSUCR1_CTSUCSW_0 = 0x0
	// Turned on capacitance switch
	CTSU_CTSUCR1_CTSUCSW_1 = 0x1
	// Position of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Pos = 0x0
	// Bit mask of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Msk = 0x1
	// Bit CTSUPON.
	CTSU_CTSUCR1_CTSUPON = 0x1
	// Powered off the CTSU
	CTSU_CTSUCR1_CTSUPON_0 = 0x0
	// Powered on the CTSU
	CTSU_CTSUCR1_CTSUPON_1 = 0x1

	// CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
	// Position of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Pos = 0x6
	// Bit mask of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Msk = 0x40
	// Bit CTSUSOFF.
	CTSU_CTSUSDPRS_CTSUSOFF = 0x40
	// High-pass noise reduction function turned on
	CTSU_CTSUSDPRS_CTSUSOFF_0 = 0x0
	// High-pass noise reduction function turned off
	CTSU_CTSUSDPRS_CTSUSOFF_1 = 0x1
	// Position of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Pos = 0x4
	// Bit mask of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Msk = 0x30
	// 510 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_00 = 0x0
	// 126 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_01 = 0x1
	// 62 pulses (recommended setting value)
	CTSU_CTSUSDPRS_CTSUPRMODE_10 = 0x2
	// Setting prohibited
	CTSU_CTSUSDPRS_CTSUPRMODE_11 = 0x3
	// Position of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Pos = 0x0
	// Bit mask of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Msk = 0xf

	// CTSUSST: CTSU Sensor Stabilization Wait Control Register
	// Position of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Pos = 0x0
	// Bit mask of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Msk = 0xff

	// CTSUMCH0: CTSU Measurement Channel Register 0
	// Position of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Pos = 0x0
	// Bit mask of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Msk = 0x1f

	// CTSUMCH1: CTSU Measurement Channel Register 1
	// Position of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Pos = 0x0
	// Bit mask of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Msk = 0x1f

	// CTSUCHAC0: CTSU Channel Enable Control Register 0
	// Position of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Pos = 0x0
	// Bit mask of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Msk = 0xff

	// CTSUCHAC1: CTSU Channel Enable Control Register 1
	// Position of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Pos = 0x0
	// Bit mask of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Msk = 0xff

	// CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
	// Position of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Pos = 0x0
	// Bit mask of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Msk = 0xff

	// CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
	// Position of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Pos = 0x0
	// Bit mask of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Msk = 0xff

	// CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
	// Position of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Pos = 0x4
	// Bit mask of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Msk = 0x30
	// Position of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Pos = 0x0
	// Bit mask of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Msk = 0x3

	// CTSUST: CTSU Status Register
	// Position of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Pos = 0x7
	// Bit mask of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Msk = 0x80
	// Bit CTSUPS.
	CTSU_CTSUST_CTSUPS = 0x80
	// First measurement
	CTSU_CTSUST_CTSUPS_0 = 0x0
	// Second measurement
	CTSU_CTSUST_CTSUPS_1 = 0x1
	// Position of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Pos = 0x6
	// Bit mask of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Msk = 0x40
	// Bit CTSUROVF.
	CTSU_CTSUST_CTSUROVF = 0x40
	// No overflow
	CTSU_CTSUST_CTSUROVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUROVF_1 = 0x1
	// Position of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Pos = 0x5
	// Bit mask of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Msk = 0x20
	// Bit CTSUSOVF.
	CTSU_CTSUST_CTSUSOVF = 0x20
	// No overflow
	CTSU_CTSUST_CTSUSOVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUSOVF_1 = 0x1
	// Position of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Pos = 0x4
	// Bit mask of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Msk = 0x10
	// Bit CTSUDTSR.
	CTSU_CTSUST_CTSUDTSR = 0x10
	// Measurement result has been read
	CTSU_CTSUST_CTSUDTSR_0 = 0x0
	// Measurement result has not been read
	CTSU_CTSUST_CTSUDTSR_1 = 0x1
	// Position of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Pos = 0x0
	// Bit mask of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Msk = 0x7
	// Status 0
	CTSU_CTSUST_CTSUSTC_000 = 0x0
	// Status 1
	CTSU_CTSUST_CTSUSTC_001 = 0x1
	// Status 2
	CTSU_CTSUST_CTSUSTC_010 = 0x2
	// Status 3
	CTSU_CTSUST_CTSUSTC_011 = 0x3
	// Status 4
	CTSU_CTSUST_CTSUSTC_100 = 0x4
	// Status 5
	CTSU_CTSUST_CTSUSTC_101 = 0x5

	// CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
	// Position of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Pos = 0x8
	// Bit mask of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Msk = 0xf00
	// 4.00 <= fb
	CTSU_CTSUSSC_CTSUSSDIV_0000 = 0x0
	// 2.00 <= fb < 4.00
	CTSU_CTSUSSC_CTSUSSDIV_0001 = 0x1
	// 1.33 <= fb < 2.00
	CTSU_CTSUSSC_CTSUSSDIV_0010 = 0x2
	// 1.00 <= fb < 1.33
	CTSU_CTSUSSC_CTSUSSDIV_0011 = 0x3
	// 0.80 <= fb < 1.00
	CTSU_CTSUSSC_CTSUSSDIV_0100 = 0x4
	// 0.67 <= fb < 0.80
	CTSU_CTSUSSC_CTSUSSDIV_0101 = 0x5
	// 0.57 <= fb < 0.67
	CTSU_CTSUSSC_CTSUSSDIV_0110 = 0x6
	// 0.50 <= fb < 0.57
	CTSU_CTSUSSC_CTSUSSDIV_0111 = 0x7
	// 0.44 <= fb < 0.50
	CTSU_CTSUSSC_CTSUSSDIV_1000 = 0x8
	// 0.40 <= fb < 0.44
	CTSU_CTSUSSC_CTSUSSDIV_1001 = 0x9
	// 0.36 <= fb < 0.40
	CTSU_CTSUSSC_CTSUSSDIV_1010 = 0xa
	// 0.33 <= fb < 0.36
	CTSU_CTSUSSC_CTSUSSDIV_1011 = 0xb
	// 0.31 <= fb < 0.33
	CTSU_CTSUSSC_CTSUSSDIV_1100 = 0xc
	// 0.29 <= fb < 0.31
	CTSU_CTSUSSC_CTSUSSDIV_1101 = 0xd
	// 0.27 <= fb < 0.29
	CTSU_CTSUSSC_CTSUSSDIV_1110 = 0xe
	// fb < 0.27
	CTSU_CTSUSSC_CTSUSSDIV_1111 = 0xf

	// CTSUSO0: CTSU Sensor Offset Register 0
	// Position of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Pos = 0xa
	// Bit mask of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Msk = 0xfc00
	// Position of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Pos = 0x0
	// Bit mask of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Msk = 0x3ff

	// CTSUSO1: CTSU Sensor Offset Register 1
	// Position of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Pos = 0xd
	// Bit mask of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Msk = 0x6000
	// 100% gain
	CTSU_CTSUSO1_CTSUICOG_00 = 0x0
	// 66% gain
	CTSU_CTSUSO1_CTSUICOG_01 = 0x1
	// 50% gain
	CTSU_CTSUSO1_CTSUICOG_10 = 0x2
	// 40% gain
	CTSU_CTSUSO1_CTSUICOG_11 = 0x3
	// Position of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Pos = 0x8
	// Bit mask of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Msk = 0x1f00
	// Position of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Pos = 0x0
	// Bit mask of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Msk = 0xff

	// CTSUSC: CTSU Sensor Counter
	// Position of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Pos = 0x0
	// Bit mask of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Msk = 0xffff

	// CTSURC: CTSU Reference Counter
	// Position of CTSURC field.
	CTSU_CTSURC_CTSURC_Pos = 0x0
	// Bit mask of CTSURC field.
	CTSU_CTSURC_CTSURC_Msk = 0xffff

	// CTSUERRS: CTSU Error Status Register
	// Position of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Pos = 0xf
	// Bit mask of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Msk = 0x8000
	// Bit CTSUICOMP.
	CTSU_CTSUERRS_CTSUICOMP = 0x8000
	// Normal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_0 = 0x0
	// Abnormal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_1 = 0x1
)

// Constants for MMPU: Bus Master MPU
const (
	// MMPUCTLA: Bus Master MPU Control Register
	// Position of KEY field.
	MMPU_MMPUCTL_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUCTL_KEY_Msk = 0xff00
	// Writing to the OAD and ENABLE bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUCTL_KEY_0xA5 = 0xa5
	// Position of OAD field.
	MMPU_MMPUCTL_OAD_Pos = 0x1
	// Bit mask of OAD field.
	MMPU_MMPUCTL_OAD_Msk = 0x2
	// Bit OAD.
	MMPU_MMPUCTL_OAD = 0x2
	// Non-maskable interrupt.
	MMPU_MMPUCTL_OAD_0 = 0x0
	// Internal reset.
	MMPU_MMPUCTL_OAD_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUCTL_ENABLE = 0x1
	// Master Group is disabled. Permission of all regions.
	MMPU_MMPUCTL_ENABLE_0 = 0x0
	// Master Group is enabled. Protection of all regions.
	MMPU_MMPUCTL_ENABLE_1 = 0x1

	// MMPUPTA: Group A Protection of Register
	// Position of KEY field.
	MMPU_MMPUPTA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUPTA_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUPTA_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Msk = 0x1
	// Bit PROTECT.
	MMPU_MMPUPTA_PROTECT = 0x1
	// All Bus Master MPU Group A register writing is possible.
	MMPU_MMPUPTA_PROTECT_0 = 0x0
	// All Bus Master MPU Group A register writing is protected. Read is possible.
	MMPU_MMPUPTA_PROTECT_1 = 0x1

	// MMPUACA0: Group A Region %s Access Control Register
	// Position of WP field.
	MMPU_MMPUACA_WP_Pos = 0x2
	// Bit mask of WP field.
	MMPU_MMPUACA_WP_Msk = 0x4
	// Bit WP.
	MMPU_MMPUACA_WP = 0x4
	// Write permission
	MMPU_MMPUACA_WP_0 = 0x0
	// Write protection
	MMPU_MMPUACA_WP_1 = 0x1
	// Position of RP field.
	MMPU_MMPUACA_RP_Pos = 0x1
	// Bit mask of RP field.
	MMPU_MMPUACA_RP_Msk = 0x2
	// Bit RP.
	MMPU_MMPUACA_RP = 0x2
	// Read permission
	MMPU_MMPUACA_RP_0 = 0x0
	// Read protection
	MMPU_MMPUACA_RP_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUACA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUACA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUACA_ENABLE = 0x1
	// Group m Region n unit is disabled
	MMPU_MMPUACA_ENABLE_0 = 0x0
	// Group m Region n unit is enabled
	MMPU_MMPUACA_ENABLE_1 = 0x1

	// MMPUSA0: Group A Region %s Start Address Register
	// Position of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Pos = 0x0
	// Bit mask of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Msk = 0xffffffff

	// MMPUEA0: Group A Region %s End Address Register
	// Position of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Pos = 0x0
	// Bit mask of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Msk = 0xffffffff

	// MMPUPTB: Group B Protection of Register
	// Position of KEY field.
	MMPU_MMPUPTB_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUPTB_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUPTB_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	MMPU_MMPUPTB_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	MMPU_MMPUPTB_PROTECT_Msk = 0x1
	// Bit PROTECT.
	MMPU_MMPUPTB_PROTECT = 0x1
	// All Bus Master MPU Group B register writing is possible.
	MMPU_MMPUPTB_PROTECT_0 = 0x0
	// All Bus Master MPU Group B register writing is protected. Read is possible.
	MMPU_MMPUPTB_PROTECT_1 = 0x1

	// MMPUACB0: Group B Region %s Access Control Register
	// Position of WP field.
	MMPU_MMPUACB_WP_Pos = 0x2
	// Bit mask of WP field.
	MMPU_MMPUACB_WP_Msk = 0x4
	// Bit WP.
	MMPU_MMPUACB_WP = 0x4
	// Write permission
	MMPU_MMPUACB_WP_0 = 0x0
	// Write protection
	MMPU_MMPUACB_WP_1 = 0x1
	// Position of RP field.
	MMPU_MMPUACB_RP_Pos = 0x1
	// Bit mask of RP field.
	MMPU_MMPUACB_RP_Msk = 0x2
	// Bit RP.
	MMPU_MMPUACB_RP = 0x2
	// Read permission
	MMPU_MMPUACB_RP_0 = 0x0
	// Read protection
	MMPU_MMPUACB_RP_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUACB_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUACB_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUACB_ENABLE = 0x1
	// Group m Region n unit is disabled
	MMPU_MMPUACB_ENABLE_0 = 0x0
	// Group m Region n unit is enabled
	MMPU_MMPUACB_ENABLE_1 = 0x1

	// MMPUSB0: Group B Region %s Start Address Register
	// Position of MMPUSB field.
	MMPU_MMPUSB_MMPUSB_Pos = 0x0
	// Bit mask of MMPUSB field.
	MMPU_MMPUSB_MMPUSB_Msk = 0xffffffff

	// MMPUEB0: Group B Region %s End Address Register
	// Position of MMPUEB field.
	MMPU_MMPUEB_MMPUEB_Pos = 0x0
	// Bit mask of MMPUEB field.
	MMPU_MMPUEB_MMPUEB_Msk = 0xffffffff

	// MMPUPTC: Group C protection of register
	// Position of KEY field.
	MMPU_MMPUPTC_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUPTC_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUPTC_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	MMPU_MMPUPTC_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	MMPU_MMPUPTC_PROTECT_Msk = 0x1
	// Bit PROTECT.
	MMPU_MMPUPTC_PROTECT = 0x1
	// All Bus Master MPU Group C register writing is possible.
	MMPU_MMPUPTC_PROTECT_0 = 0x0
	// All Bus Master MPU Group C register writing is protected. Read is possible.
	MMPU_MMPUPTC_PROTECT_1 = 0x1

	// MMPUACC0: Group C Region %s Access Control Register
	// Position of WP field.
	MMPU_MMPUACC_WP_Pos = 0x2
	// Bit mask of WP field.
	MMPU_MMPUACC_WP_Msk = 0x4
	// Bit WP.
	MMPU_MMPUACC_WP = 0x4
	// Write permission
	MMPU_MMPUACC_WP_0 = 0x0
	// Write protection
	MMPU_MMPUACC_WP_1 = 0x1
	// Position of RP field.
	MMPU_MMPUACC_RP_Pos = 0x1
	// Bit mask of RP field.
	MMPU_MMPUACC_RP_Msk = 0x2
	// Bit RP.
	MMPU_MMPUACC_RP = 0x2
	// Read permission
	MMPU_MMPUACC_RP_0 = 0x0
	// Read protection
	MMPU_MMPUACC_RP_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUACC_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUACC_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUACC_ENABLE = 0x1
	// Group m Region n unit is disabled
	MMPU_MMPUACC_ENABLE_0 = 0x0
	// Group m Region n unit is enabled
	MMPU_MMPUACC_ENABLE_1 = 0x1

	// MMPUSC0: Group C Region %s Start Address Register
	// Position of MMPUSC field.
	MMPU_MMPUSC_MMPUSC_Pos = 0x0
	// Bit mask of MMPUSC field.
	MMPU_MMPUSC_MMPUSC_Msk = 0xffffffff

	// MMPUEC0: Group C Region %s End Address Register
	// Position of MMPUEC field.
	MMPU_MMPUEC_MMPUEC_Pos = 0x0
	// Bit mask of MMPUEC field.
	MMPU_MMPUEC_MMPUEC_Msk = 0xffffffff
)

// Constants for SMPU: Bus Slave MPU
const (
	// SMPUCTL: Slave MPU Control Register
	// Position of KEY field.
	SMPU_SMPUCTL_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SMPU_SMPUCTL_KEY_Msk = 0xff00
	// Writing to the PROTECT and OAD bit is valid, when the KEY bits are written 0xA5.
	SMPU_SMPUCTL_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Pos = 0x1
	// Bit mask of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Msk = 0x2
	// Bit PROTECT.
	SMPU_SMPUCTL_PROTECT = 0x2
	// All Bus Slave register writing is possible.
	SMPU_SMPUCTL_PROTECT_0 = 0x0
	// All Bus Slave register writing is protected. Read is possible.
	SMPU_SMPUCTL_PROTECT_1 = 0x1
	// Position of OAD field.
	SMPU_SMPUCTL_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SMPU_SMPUCTL_OAD_Msk = 0x1
	// Bit OAD.
	SMPU_SMPUCTL_OAD = 0x1
	// Non-maskable interrupt.
	SMPU_SMPUCTL_OAD_0 = 0x0
	// Internal reset.
	SMPU_SMPUCTL_OAD_1 = 0x1

	// SMPUMBIU: Access Control Register for MBIU
	// Position of WPSRAMHS field.
	SMPU_SMPUMBIU_WPSRAMHS_Pos = 0xf
	// Bit mask of WPSRAMHS field.
	SMPU_SMPUMBIU_WPSRAMHS_Msk = 0x8000
	// Bit WPSRAMHS.
	SMPU_SMPUMBIU_WPSRAMHS = 0x8000
	// Memory protection for SRAMHS writes from master group A, B, and C disabled
	SMPU_SMPUMBIU_WPSRAMHS_0 = 0x0
	// Memory protection for SRAMHS writes from master group A, B, and C enabled.
	SMPU_SMPUMBIU_WPSRAMHS_1 = 0x1
	// Position of RPSRAMHS field.
	SMPU_SMPUMBIU_RPSRAMHS_Pos = 0xe
	// Bit mask of RPSRAMHS field.
	SMPU_SMPUMBIU_RPSRAMHS_Msk = 0x4000
	// Bit RPSRAMHS.
	SMPU_SMPUMBIU_RPSRAMHS = 0x4000
	// Memory protection for SRAMHS reads from master group A, B, and C disabled
	SMPU_SMPUMBIU_RPSRAMHS_0 = 0x0
	// Memory protection for SRAMHS reads from master group A, B, and C enabled.
	SMPU_SMPUMBIU_RPSRAMHS_1 = 0x1
	// Position of WPFLI field.
	SMPU_SMPUMBIU_WPFLI_Pos = 0xd
	// Bit mask of WPFLI field.
	SMPU_SMPUMBIU_WPFLI_Msk = 0x2000
	// Bit WPFLI.
	SMPU_SMPUMBIU_WPFLI = 0x2000
	// Setting prohibited
	SMPU_SMPUMBIU_WPFLI_0 = 0x0
	// Memory protection for code flash memory writes from master group A, B, and C enabled.
	SMPU_SMPUMBIU_WPFLI_1 = 0x1
	// Position of RPFLI field.
	SMPU_SMPUMBIU_RPFLI_Pos = 0xc
	// Bit mask of RPFLI field.
	SMPU_SMPUMBIU_RPFLI_Msk = 0x1000
	// Bit RPFLI.
	SMPU_SMPUMBIU_RPFLI = 0x1000
	// Memory protection for code flash memory reads from master group A, B, and C disabled
	SMPU_SMPUMBIU_RPFLI_0 = 0x0
	// Memory protection for code flash memory reads from master group A, B, and C enabled.
	SMPU_SMPUMBIU_RPFLI_1 = 0x1
	// Position of WPGRPC field.
	SMPU_SMPUMBIU_WPGRPC_Pos = 0x7
	// Bit mask of WPGRPC field.
	SMPU_SMPUMBIU_WPGRPC_Msk = 0x80
	// Bit WPGRPC.
	SMPU_SMPUMBIU_WPGRPC = 0x80
	// Memory protection for master group C writes disabled
	SMPU_SMPUMBIU_WPGRPC_0 = 0x0
	// Memory protection for master group C writes enabled.
	SMPU_SMPUMBIU_WPGRPC_1 = 0x1
	// Position of RPGRPC field.
	SMPU_SMPUMBIU_RPGRPC_Pos = 0x6
	// Bit mask of RPGRPC field.
	SMPU_SMPUMBIU_RPGRPC_Msk = 0x40
	// Bit RPGRPC.
	SMPU_SMPUMBIU_RPGRPC = 0x40
	// Memory protection for master group C reads disabled
	SMPU_SMPUMBIU_RPGRPC_0 = 0x0
	// Memory protection for master group C reads enabled.
	SMPU_SMPUMBIU_RPGRPC_1 = 0x1
	// Position of WPGRPB field.
	SMPU_SMPUMBIU_WPGRPB_Pos = 0x5
	// Bit mask of WPGRPB field.
	SMPU_SMPUMBIU_WPGRPB_Msk = 0x20
	// Bit WPGRPB.
	SMPU_SMPUMBIU_WPGRPB = 0x20
	// Memory protection for master group B writes disabled
	SMPU_SMPUMBIU_WPGRPB_0 = 0x0
	// Memory protection for master group B writes enabled.
	SMPU_SMPUMBIU_WPGRPB_1 = 0x1
	// Position of RPGRPB field.
	SMPU_SMPUMBIU_RPGRPB_Pos = 0x4
	// Bit mask of RPGRPB field.
	SMPU_SMPUMBIU_RPGRPB_Msk = 0x10
	// Bit RPGRPB.
	SMPU_SMPUMBIU_RPGRPB = 0x10
	// Memory protection for master group B reads disabled
	SMPU_SMPUMBIU_RPGRPB_0 = 0x0
	// Memory protection for master group B reads enabled.
	SMPU_SMPUMBIU_RPGRPB_1 = 0x1
	// Position of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUMBIU_WPGRPA = 0x8
	// Memory protection for master group A writes disabled
	SMPU_SMPUMBIU_WPGRPA_0 = 0x0
	// Memory protection for master group A writes enabled.
	SMPU_SMPUMBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUMBIU_RPGRPA = 0x4
	// Memory protection for master group A reads disabled
	SMPU_SMPUMBIU_RPGRPA_0 = 0x0
	// Memory protection for master group A reads enabled.
	SMPU_SMPUMBIU_RPGRPA_1 = 0x1

	// SMPUFBIU: Access Control Register for FBIU
	// Position of WP_GRPC field.
	SMPU_SMPUFBIU_WP_GRPC_Pos = 0x7
	// Bit mask of WP_GRPC field.
	SMPU_SMPUFBIU_WP_GRPC_Msk = 0x80
	// Bit WP_GRPC.
	SMPU_SMPUFBIU_WP_GRPC = 0x80
	// Setting prohibited
	SMPU_SMPUFBIU_WP_GRPC_0 = 0x0
	// Master group C write of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUFBIU_WP_GRPC_1 = 0x1
	// Position of RP_GRPC field.
	SMPU_SMPUFBIU_RP_GRPC_Pos = 0x6
	// Bit mask of RP_GRPC field.
	SMPU_SMPUFBIU_RP_GRPC_Msk = 0x40
	// Bit RP_GRPC.
	SMPU_SMPUFBIU_RP_GRPC = 0x40
	// Setting prohibited
	SMPU_SMPUFBIU_RP_GRPC_0 = 0x0
	// Master group C read of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUFBIU_RP_GRPC_1 = 0x1
	// Position of WP_GRPB field.
	SMPU_SMPUFBIU_WP_GRPB_Pos = 0x5
	// Bit mask of WP_GRPB field.
	SMPU_SMPUFBIU_WP_GRPB_Msk = 0x20
	// Bit WP_GRPB.
	SMPU_SMPUFBIU_WP_GRPB = 0x20
	// Master group B write of memory protection is disabled.
	SMPU_SMPUFBIU_WP_GRPB_0 = 0x0
	// Master group B write of memory protection is enabled.
	SMPU_SMPUFBIU_WP_GRPB_1 = 0x1
	// Position of RP_GRPB field.
	SMPU_SMPUFBIU_RP_GRPB_Pos = 0x4
	// Bit mask of RP_GRPB field.
	SMPU_SMPUFBIU_RP_GRPB_Msk = 0x10
	// Bit RP_GRPB.
	SMPU_SMPUFBIU_RP_GRPB = 0x10
	// Master group B read of memory protection is disabled.
	SMPU_SMPUFBIU_RP_GRPB_0 = 0x0
	// Master group B read of memory protection is enabled.
	SMPU_SMPUFBIU_RP_GRPB_1 = 0x1
	// Position of WP_GRPA field.
	SMPU_SMPUFBIU_WP_GRPA_Pos = 0x3
	// Bit mask of WP_GRPA field.
	SMPU_SMPUFBIU_WP_GRPA_Msk = 0x8
	// Bit WP_GRPA.
	SMPU_SMPUFBIU_WP_GRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUFBIU_WP_GRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUFBIU_WP_GRPA_1 = 0x1
	// Position of RP_GRPA field.
	SMPU_SMPUFBIU_RP_GRPA_Pos = 0x2
	// Bit mask of RP_GRPA field.
	SMPU_SMPUFBIU_RP_GRPA_Msk = 0x4
	// Bit RP_GRPA.
	SMPU_SMPUFBIU_RP_GRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUFBIU_RP_GRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUFBIU_RP_GRPA_1 = 0x1
	// Position of WP_CPU field.
	SMPU_SMPUFBIU_WP_CPU_Pos = 0x1
	// Bit mask of WP_CPU field.
	SMPU_SMPUFBIU_WP_CPU_Msk = 0x2
	// Bit WP_CPU.
	SMPU_SMPUFBIU_WP_CPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUFBIU_WP_CPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUFBIU_WP_CPU_1 = 0x1
	// Position of RP_CPU field.
	SMPU_SMPUFBIU_RP_CPU_Pos = 0x0
	// Bit mask of RP_CPU field.
	SMPU_SMPUFBIU_RP_CPU_Msk = 0x1
	// Bit RP_CPU.
	SMPU_SMPUFBIU_RP_CPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUFBIU_RP_CPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUFBIU_RP_CPU_1 = 0x1

	// SMPUSRAM0: Access Control Register for SRAM%s
	// Position of WP_GRPC field.
	SMPU_SMPUSRAM_WP_GRPC_Pos = 0x7
	// Bit mask of WP_GRPC field.
	SMPU_SMPUSRAM_WP_GRPC_Msk = 0x80
	// Bit WP_GRPC.
	SMPU_SMPUSRAM_WP_GRPC = 0x80
	// Master group C write of memory protection is disabled.
	SMPU_SMPUSRAM_WP_GRPC_0 = 0x0
	// Master group C write of memory protection is enabled.
	SMPU_SMPUSRAM_WP_GRPC_1 = 0x1
	// Position of RP_GRPC field.
	SMPU_SMPUSRAM_RP_GRPC_Pos = 0x6
	// Bit mask of RP_GRPC field.
	SMPU_SMPUSRAM_RP_GRPC_Msk = 0x40
	// Bit RP_GRPC.
	SMPU_SMPUSRAM_RP_GRPC = 0x40
	// Master group C read of memory protection is disabled.
	SMPU_SMPUSRAM_RP_GRPC_0 = 0x0
	// Master group C read of memory protection is enabled.
	SMPU_SMPUSRAM_RP_GRPC_1 = 0x1
	// Position of WP_GRPB field.
	SMPU_SMPUSRAM_WP_GRPB_Pos = 0x5
	// Bit mask of WP_GRPB field.
	SMPU_SMPUSRAM_WP_GRPB_Msk = 0x20
	// Bit WP_GRPB.
	SMPU_SMPUSRAM_WP_GRPB = 0x20
	// Master group B write of memory protection is disabled.
	SMPU_SMPUSRAM_WP_GRPB_0 = 0x0
	// Master group B write of memory protection is enabled.
	SMPU_SMPUSRAM_WP_GRPB_1 = 0x1
	// Position of RP_GRPB field.
	SMPU_SMPUSRAM_RP_GRPB_Pos = 0x4
	// Bit mask of RP_GRPB field.
	SMPU_SMPUSRAM_RP_GRPB_Msk = 0x10
	// Bit RP_GRPB.
	SMPU_SMPUSRAM_RP_GRPB = 0x10
	// Master group B read of memory protection is disabled.
	SMPU_SMPUSRAM_RP_GRPB_0 = 0x0
	// Master group B read of memory protection is enabled.
	SMPU_SMPUSRAM_RP_GRPB_1 = 0x1
	// Position of WP_GRPA field.
	SMPU_SMPUSRAM_WP_GRPA_Pos = 0x3
	// Bit mask of WP_GRPA field.
	SMPU_SMPUSRAM_WP_GRPA_Msk = 0x8
	// Bit WP_GRPA.
	SMPU_SMPUSRAM_WP_GRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUSRAM_WP_GRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUSRAM_WP_GRPA_1 = 0x1
	// Position of RP_GRPA field.
	SMPU_SMPUSRAM_RP_GRPA_Pos = 0x2
	// Bit mask of RP_GRPA field.
	SMPU_SMPUSRAM_RP_GRPA_Msk = 0x4
	// Bit RP_GRPA.
	SMPU_SMPUSRAM_RP_GRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUSRAM_RP_GRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUSRAM_RP_GRPA_1 = 0x1
	// Position of WP_CPU field.
	SMPU_SMPUSRAM_WP_CPU_Pos = 0x1
	// Bit mask of WP_CPU field.
	SMPU_SMPUSRAM_WP_CPU_Msk = 0x2
	// Bit WP_CPU.
	SMPU_SMPUSRAM_WP_CPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUSRAM_WP_CPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUSRAM_WP_CPU_1 = 0x1
	// Position of RP_CPU field.
	SMPU_SMPUSRAM_RP_CPU_Pos = 0x0
	// Bit mask of RP_CPU field.
	SMPU_SMPUSRAM_RP_CPU_Msk = 0x1
	// Bit RP_CPU.
	SMPU_SMPUSRAM_RP_CPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUSRAM_RP_CPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUSRAM_RP_CPU_1 = 0x1

	// SMPUP0BIU: Access Control Register for P%sBIU
	// Position of WP_GRPC field.
	SMPU_SMPUPBIU_WP_GRPC_Pos = 0x7
	// Bit mask of WP_GRPC field.
	SMPU_SMPUPBIU_WP_GRPC_Msk = 0x80
	// Bit WP_GRPC.
	SMPU_SMPUPBIU_WP_GRPC = 0x80
	// Setting prohibited
	SMPU_SMPUPBIU_WP_GRPC_0 = 0x0
	// Master group C write of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUPBIU_WP_GRPC_1 = 0x1
	// Position of RP_GRPC field.
	SMPU_SMPUPBIU_RP_GRPC_Pos = 0x6
	// Bit mask of RP_GRPC field.
	SMPU_SMPUPBIU_RP_GRPC_Msk = 0x40
	// Bit RP_GRPC.
	SMPU_SMPUPBIU_RP_GRPC = 0x40
	// Setting prohibited
	SMPU_SMPUPBIU_RP_GRPC_0 = 0x0
	// Master group C read of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUPBIU_RP_GRPC_1 = 0x1
	// Position of WP_GRPB field.
	SMPU_SMPUPBIU_WP_GRPB_Pos = 0x5
	// Bit mask of WP_GRPB field.
	SMPU_SMPUPBIU_WP_GRPB_Msk = 0x20
	// Bit WP_GRPB.
	SMPU_SMPUPBIU_WP_GRPB = 0x20
	// Setting prohibited
	SMPU_SMPUPBIU_WP_GRPB_0 = 0x0
	// Master group B write of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUPBIU_WP_GRPB_1 = 0x1
	// Position of RP_GRPB field.
	SMPU_SMPUPBIU_RP_GRPB_Pos = 0x4
	// Bit mask of RP_GRPB field.
	SMPU_SMPUPBIU_RP_GRPB_Msk = 0x10
	// Bit RP_GRPB.
	SMPU_SMPUPBIU_RP_GRPB = 0x10
	// Setting prohibited
	SMPU_SMPUPBIU_RP_GRPB_0 = 0x0
	// Master group B read of memory protection is enabled. The write value should always be 1.
	SMPU_SMPUPBIU_RP_GRPB_1 = 0x1
	// Position of WP_GRPA field.
	SMPU_SMPUPBIU_WP_GRPA_Pos = 0x3
	// Bit mask of WP_GRPA field.
	SMPU_SMPUPBIU_WP_GRPA_Msk = 0x8
	// Bit WP_GRPA.
	SMPU_SMPUPBIU_WP_GRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUPBIU_WP_GRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUPBIU_WP_GRPA_1 = 0x1
	// Position of RP_GRPA field.
	SMPU_SMPUPBIU_RP_GRPA_Pos = 0x2
	// Bit mask of RP_GRPA field.
	SMPU_SMPUPBIU_RP_GRPA_Msk = 0x4
	// Bit RP_GRPA.
	SMPU_SMPUPBIU_RP_GRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUPBIU_RP_GRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUPBIU_RP_GRPA_1 = 0x1
	// Position of WP_CPU field.
	SMPU_SMPUPBIU_WP_CPU_Pos = 0x1
	// Bit mask of WP_CPU field.
	SMPU_SMPUPBIU_WP_CPU_Msk = 0x2
	// Bit WP_CPU.
	SMPU_SMPUPBIU_WP_CPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUPBIU_WP_CPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUPBIU_WP_CPU_1 = 0x1
	// Position of RP_CPU field.
	SMPU_SMPUPBIU_RP_CPU_Pos = 0x0
	// Bit mask of RP_CPU field.
	SMPU_SMPUPBIU_RP_CPU_Msk = 0x1
	// Bit RP_CPU.
	SMPU_SMPUPBIU_RP_CPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUPBIU_RP_CPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUPBIU_RP_CPU_1 = 0x1

	// SMPUEXBIU: Access Control Register for EXBIU
	// Position of WP_GRPC field.
	SMPU_SMPUEXBIU_WP_GRPC_Pos = 0x7
	// Bit mask of WP_GRPC field.
	SMPU_SMPUEXBIU_WP_GRPC_Msk = 0x80
	// Bit WP_GRPC.
	SMPU_SMPUEXBIU_WP_GRPC = 0x80
	// Master group C write of memory protection is disabled.
	SMPU_SMPUEXBIU_WP_GRPC_0 = 0x0
	// Master group C write of memory protection is enabled.
	SMPU_SMPUEXBIU_WP_GRPC_1 = 0x1
	// Position of RP_GRPC field.
	SMPU_SMPUEXBIU_RP_GRPC_Pos = 0x6
	// Bit mask of RP_GRPC field.
	SMPU_SMPUEXBIU_RP_GRPC_Msk = 0x40
	// Bit RP_GRPC.
	SMPU_SMPUEXBIU_RP_GRPC = 0x40
	// Master group C read of memory protection is disabled.
	SMPU_SMPUEXBIU_RP_GRPC_0 = 0x0
	// Master group C read of memory protection is enabled.
	SMPU_SMPUEXBIU_RP_GRPC_1 = 0x1
	// Position of WP_GRPB field.
	SMPU_SMPUEXBIU_WP_GRPB_Pos = 0x5
	// Bit mask of WP_GRPB field.
	SMPU_SMPUEXBIU_WP_GRPB_Msk = 0x20
	// Bit WP_GRPB.
	SMPU_SMPUEXBIU_WP_GRPB = 0x20
	// Master group B write of memory protection is disabled.
	SMPU_SMPUEXBIU_WP_GRPB_0 = 0x0
	// Master group B write of memory protection is enabled.
	SMPU_SMPUEXBIU_WP_GRPB_1 = 0x1
	// Position of RP_GRPB field.
	SMPU_SMPUEXBIU_RP_GRPB_Pos = 0x4
	// Bit mask of RP_GRPB field.
	SMPU_SMPUEXBIU_RP_GRPB_Msk = 0x10
	// Bit RP_GRPB.
	SMPU_SMPUEXBIU_RP_GRPB = 0x10
	// Master group B read of memory protection is disabled.
	SMPU_SMPUEXBIU_RP_GRPB_0 = 0x0
	// Master group B read of memory protection is enabled.
	SMPU_SMPUEXBIU_RP_GRPB_1 = 0x1
	// Position of WP_GRPA field.
	SMPU_SMPUEXBIU_WP_GRPA_Pos = 0x3
	// Bit mask of WP_GRPA field.
	SMPU_SMPUEXBIU_WP_GRPA_Msk = 0x8
	// Bit WP_GRPA.
	SMPU_SMPUEXBIU_WP_GRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUEXBIU_WP_GRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUEXBIU_WP_GRPA_1 = 0x1
	// Position of RP_GRPA field.
	SMPU_SMPUEXBIU_RP_GRPA_Pos = 0x2
	// Bit mask of RP_GRPA field.
	SMPU_SMPUEXBIU_RP_GRPA_Msk = 0x4
	// Bit RP_GRPA.
	SMPU_SMPUEXBIU_RP_GRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUEXBIU_RP_GRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUEXBIU_RP_GRPA_1 = 0x1
	// Position of WP_CPU field.
	SMPU_SMPUEXBIU_WP_CPU_Pos = 0x1
	// Bit mask of WP_CPU field.
	SMPU_SMPUEXBIU_WP_CPU_Msk = 0x2
	// Bit WP_CPU.
	SMPU_SMPUEXBIU_WP_CPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUEXBIU_WP_CPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUEXBIU_WP_CPU_1 = 0x1
	// Position of RP_CPU field.
	SMPU_SMPUEXBIU_RP_CPU_Pos = 0x0
	// Bit mask of RP_CPU field.
	SMPU_SMPUEXBIU_RP_CPU_Msk = 0x1
	// Bit RP_CPU.
	SMPU_SMPUEXBIU_RP_CPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUEXBIU_RP_CPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUEXBIU_RP_CPU_1 = 0x1

	// SMPUEXBIU2: Access Control Register for EXBIU2
	// Position of WP_GRPC field.
	SMPU_SMPUEXBIU2_WP_GRPC_Pos = 0x7
	// Bit mask of WP_GRPC field.
	SMPU_SMPUEXBIU2_WP_GRPC_Msk = 0x80
	// Bit WP_GRPC.
	SMPU_SMPUEXBIU2_WP_GRPC = 0x80
	// Master group C write of memory protection is disabled.
	SMPU_SMPUEXBIU2_WP_GRPC_0 = 0x0
	// Master group C write of memory protection is enabled.
	SMPU_SMPUEXBIU2_WP_GRPC_1 = 0x1
	// Position of RP_GRPC field.
	SMPU_SMPUEXBIU2_RP_GRPC_Pos = 0x6
	// Bit mask of RP_GRPC field.
	SMPU_SMPUEXBIU2_RP_GRPC_Msk = 0x40
	// Bit RP_GRPC.
	SMPU_SMPUEXBIU2_RP_GRPC = 0x40
	// Master group C read of memory protection is disabled.
	SMPU_SMPUEXBIU2_RP_GRPC_0 = 0x0
	// Master group C read of memory protection is enabled.
	SMPU_SMPUEXBIU2_RP_GRPC_1 = 0x1
	// Position of WP_GRPB field.
	SMPU_SMPUEXBIU2_WP_GRPB_Pos = 0x5
	// Bit mask of WP_GRPB field.
	SMPU_SMPUEXBIU2_WP_GRPB_Msk = 0x20
	// Bit WP_GRPB.
	SMPU_SMPUEXBIU2_WP_GRPB = 0x20
	// Master group B write of memory protection is disabled.
	SMPU_SMPUEXBIU2_WP_GRPB_0 = 0x0
	// Master group B write of memory protection is enabled.
	SMPU_SMPUEXBIU2_WP_GRPB_1 = 0x1
	// Position of RP_GRPB field.
	SMPU_SMPUEXBIU2_RP_GRPB_Pos = 0x4
	// Bit mask of RP_GRPB field.
	SMPU_SMPUEXBIU2_RP_GRPB_Msk = 0x10
	// Bit RP_GRPB.
	SMPU_SMPUEXBIU2_RP_GRPB = 0x10
	// Master group B read of memory protection is disabled.
	SMPU_SMPUEXBIU2_RP_GRPB_0 = 0x0
	// Master group B read of memory protection is enabled.
	SMPU_SMPUEXBIU2_RP_GRPB_1 = 0x1
	// Position of WP_GRPA field.
	SMPU_SMPUEXBIU2_WP_GRPA_Pos = 0x3
	// Bit mask of WP_GRPA field.
	SMPU_SMPUEXBIU2_WP_GRPA_Msk = 0x8
	// Bit WP_GRPA.
	SMPU_SMPUEXBIU2_WP_GRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUEXBIU2_WP_GRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUEXBIU2_WP_GRPA_1 = 0x1
	// Position of RP_GRPA field.
	SMPU_SMPUEXBIU2_RP_GRPA_Pos = 0x2
	// Bit mask of RP_GRPA field.
	SMPU_SMPUEXBIU2_RP_GRPA_Msk = 0x4
	// Bit RP_GRPA.
	SMPU_SMPUEXBIU2_RP_GRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUEXBIU2_RP_GRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUEXBIU2_RP_GRPA_1 = 0x1
	// Position of WP_CPU field.
	SMPU_SMPUEXBIU2_WP_CPU_Pos = 0x1
	// Bit mask of WP_CPU field.
	SMPU_SMPUEXBIU2_WP_CPU_Msk = 0x2
	// Bit WP_CPU.
	SMPU_SMPUEXBIU2_WP_CPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUEXBIU2_WP_CPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUEXBIU2_WP_CPU_1 = 0x1
	// Position of RP_CPU field.
	SMPU_SMPUEXBIU2_RP_CPU_Pos = 0x0
	// Bit mask of RP_CPU field.
	SMPU_SMPUEXBIU2_RP_CPU_Msk = 0x1
	// Bit RP_CPU.
	SMPU_SMPUEXBIU2_RP_CPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUEXBIU2_RP_CPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUEXBIU2_RP_CPU_1 = 0x1
)

// Constants for SPMON: CPU Stack Pointer Monitor
const (
	// MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_MSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of OAD field.
	SPMON_MSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_MSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_MSPMPUOAD_OAD = 0x1
	// Internal reset.
	SPMON_MSPMPUOAD_OAD_1 = 0x1
	// Non-maskable interrupt.
	SPMON_MSPMPUOAD_OAD_0 = 0x0

	// MSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_MSPMPUCTL_ERROR = 0x100
	// SP_main has not overflowed or underflowed.
	SPMON_MSPMPUCTL_ERROR_0 = 0x0
	// SP_main has overflowed or underflowed.
	SPMON_MSPMPUCTL_ERROR_1 = 0x1
	// Position of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_MSPMPUCTL_ENABLE = 0x1
	// SP_main monitor is disabled.
	SPMON_MSPMPUCTL_ENABLE_0 = 0x0
	// SP_main monitor is enabled.
	SPMON_MSPMPUCTL_ENABLE_1 = 0x1

	// MSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_MSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUPT_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_MSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_MSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_MSPMPUPT_PROTECT_1 = 0x1

	// MSPMPUSA: Main Stack Pointer Monitor Start Address Register
	// Position of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Pos = 0x2
	// Bit mask of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Msk = 0xfffffffc

	// MSPMPUEA: Main Stack Pointer Monitor End Address Register
	// Position of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Pos = 0x2
	// Bit mask of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Msk = 0xfffffffc

	// PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_PSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of OAD field.
	SPMON_PSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_PSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_PSPMPUOAD_OAD = 0x1
	// Internal reset.
	SPMON_PSPMPUOAD_OAD_1 = 0x1
	// Non-maskable interrupt.
	SPMON_PSPMPUOAD_OAD_0 = 0x0

	// PSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_PSPMPUCTL_ERROR = 0x100
	// SP_process has not overflowed or underflowed.
	SPMON_PSPMPUCTL_ERROR_0 = 0x0
	// SP_process has overflowed or underflowed.
	SPMON_PSPMPUCTL_ERROR_1 = 0x1
	// Position of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_PSPMPUCTL_ENABLE = 0x1
	// SP_process monitor is disabled.
	SPMON_PSPMPUCTL_ENABLE_0 = 0x0
	// SP_process monitor is enabled.
	SPMON_PSPMPUCTL_ENABLE_1 = 0x1

	// PSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_PSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUPT_KEY_0xA5 = 0xa5
	// Position of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_PSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_PSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_PSPMPUPT_PROTECT_1 = 0x1

	// PSPMPUSA: Process Stack Pointer Monitor Start Address Register
	// Position of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Pos = 0x2
	// Bit mask of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Msk = 0xfffffffc

	// PSPMPUEA: Process Stack Pointer Monitor End Address Register
	// Position of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Pos = 0x2
	// Bit mask of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Msk = 0xfffffffc
)

// Constants for ADC120: 12bit A/D Converter 0
const (
	// ADCSR: A/D Control Register
	// Position of ADST field.
	ADC120_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC120_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC120_ADCSR_ADST = 0x8000
	// Stops A/D conversion process.
	ADC120_ADCSR_ADST_0 = 0x0
	// Starts A/D conversion process.
	ADC120_ADCSR_ADST_1 = 0x1
	// Position of ADCS field.
	ADC120_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC120_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC120_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC120_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC120_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC120_ADCSR_ADCS_11 = 0x3
	// Position of TRGE field.
	ADC120_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC120_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC120_ADCSR_TRGE = 0x200
	// Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC120_ADCSR_TRGE_0 = 0x0
	// Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC120_ADCSR_TRGE_1 = 0x1
	// Position of EXTRG field.
	ADC120_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC120_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC120_ADCSR_EXTRG = 0x100
	// A/D conversion is started by the synchronous trigger (ELCTRG0).
	ADC120_ADCSR_EXTRG_0 = 0x0
	// A/D conversion is started by the asynchronous trigger (ADTRG0#).
	ADC120_ADCSR_EXTRG_1 = 0x1
	// Position of DBLE field.
	ADC120_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC120_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC120_ADCSR_DBLE = 0x80
	// Double trigger mode non-selection
	ADC120_ADCSR_DBLE_0 = 0x0
	// Double trigger mode selection
	ADC120_ADCSR_DBLE_1 = 0x1
	// Position of GBADIE field.
	ADC120_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC120_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC120_ADCSR_GBADIE = 0x40
	// Disables S12GBADI0 interrupt generation upon group B scan completion.
	ADC120_ADCSR_GBADIE_0 = 0x0
	// Enables S12GBADI0 interrupt generation upon group B scan completion.
	ADC120_ADCSR_GBADIE_1 = 0x1
	// Position of DBLANS field.
	ADC120_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC120_ADCSR_DBLANS_Msk = 0x1f

	// ADANSA0: A/D Channel Select Register A0
	// Position of ANSA07 field.
	ADC120_ADANSA0_ANSA07_Pos = 0x7
	// Bit mask of ANSA07 field.
	ADC120_ADANSA0_ANSA07_Msk = 0x80
	// Bit ANSA07.
	ADC120_ADANSA0_ANSA07 = 0x80
	// AN007 is not subjected to conversion.
	ADC120_ADANSA0_ANSA07_0 = 0x0
	// AN007 is subjected to conversion.
	ADC120_ADANSA0_ANSA07_1 = 0x1
	// Position of ANSA06 field.
	ADC120_ADANSA0_ANSA06_Pos = 0x6
	// Bit mask of ANSA06 field.
	ADC120_ADANSA0_ANSA06_Msk = 0x40
	// Bit ANSA06.
	ADC120_ADANSA0_ANSA06 = 0x40
	// AN006 is not subjected to conversion.
	ADC120_ADANSA0_ANSA06_0 = 0x0
	// AN006 is subjected to conversion.
	ADC120_ADANSA0_ANSA06_1 = 0x1
	// Position of ANSA05 field.
	ADC120_ADANSA0_ANSA05_Pos = 0x5
	// Bit mask of ANSA05 field.
	ADC120_ADANSA0_ANSA05_Msk = 0x20
	// Bit ANSA05.
	ADC120_ADANSA0_ANSA05 = 0x20
	// AN005 is not subjected to conversion.
	ADC120_ADANSA0_ANSA05_0 = 0x0
	// AN005 is subjected to conversion.
	ADC120_ADANSA0_ANSA05_1 = 0x1
	// Position of ANSA04 field.
	ADC120_ADANSA0_ANSA04_Pos = 0x4
	// Bit mask of ANSA04 field.
	ADC120_ADANSA0_ANSA04_Msk = 0x10
	// Bit ANSA04.
	ADC120_ADANSA0_ANSA04 = 0x10
	// AN004 is not subjected to conversion.
	ADC120_ADANSA0_ANSA04_0 = 0x0
	// AN004 is subjected to conversion.
	ADC120_ADANSA0_ANSA04_1 = 0x1
	// Position of ANSA03 field.
	ADC120_ADANSA0_ANSA03_Pos = 0x3
	// Bit mask of ANSA03 field.
	ADC120_ADANSA0_ANSA03_Msk = 0x8
	// Bit ANSA03.
	ADC120_ADANSA0_ANSA03 = 0x8
	// AN003 is not subjected to conversion.
	ADC120_ADANSA0_ANSA03_0 = 0x0
	// AN003 is subjected to conversion.
	ADC120_ADANSA0_ANSA03_1 = 0x1
	// Position of ANSA02 field.
	ADC120_ADANSA0_ANSA02_Pos = 0x2
	// Bit mask of ANSA02 field.
	ADC120_ADANSA0_ANSA02_Msk = 0x4
	// Bit ANSA02.
	ADC120_ADANSA0_ANSA02 = 0x4
	// AN002 is not subjected to conversion.
	ADC120_ADANSA0_ANSA02_0 = 0x0
	// AN002 is subjected to conversion.
	ADC120_ADANSA0_ANSA02_1 = 0x1
	// Position of ANSA01 field.
	ADC120_ADANSA0_ANSA01_Pos = 0x1
	// Bit mask of ANSA01 field.
	ADC120_ADANSA0_ANSA01_Msk = 0x2
	// Bit ANSA01.
	ADC120_ADANSA0_ANSA01 = 0x2
	// AN001 is not subjected to conversion.
	ADC120_ADANSA0_ANSA01_0 = 0x0
	// AN001 is subjected to conversion.
	ADC120_ADANSA0_ANSA01_1 = 0x1
	// Position of ANSA00 field.
	ADC120_ADANSA0_ANSA00_Pos = 0x0
	// Bit mask of ANSA00 field.
	ADC120_ADANSA0_ANSA00_Msk = 0x1
	// Bit ANSA00.
	ADC120_ADANSA0_ANSA00 = 0x1
	// AN000 is not subjected to conversion.
	ADC120_ADANSA0_ANSA00_0 = 0x0
	// AN000 is subjected to conversion.
	ADC120_ADANSA0_ANSA00_1 = 0x1

	// ADANSA1: A/D Channel Select Register A1
	// Position of ANSA20 field.
	ADC120_ADANSA1_ANSA20_Pos = 0x4
	// Bit mask of ANSA20 field.
	ADC120_ADANSA1_ANSA20_Msk = 0x10
	// Bit ANSA20.
	ADC120_ADANSA1_ANSA20 = 0x10
	// AN020 is not subjected to conversion.
	ADC120_ADANSA1_ANSA20_0 = 0x0
	// AN020 is subjected to conversion.
	ADC120_ADANSA1_ANSA20_1 = 0x1
	// Position of ANSA19 field.
	ADC120_ADANSA1_ANSA19_Pos = 0x3
	// Bit mask of ANSA19 field.
	ADC120_ADANSA1_ANSA19_Msk = 0x8
	// Bit ANSA19.
	ADC120_ADANSA1_ANSA19 = 0x8
	// AN019 is not subjected to conversion.
	ADC120_ADANSA1_ANSA19_0 = 0x0
	// AN019 is subjected to conversion.
	ADC120_ADANSA1_ANSA19_1 = 0x1
	// Position of ANSA18 field.
	ADC120_ADANSA1_ANSA18_Pos = 0x2
	// Bit mask of ANSA18 field.
	ADC120_ADANSA1_ANSA18_Msk = 0x4
	// Bit ANSA18.
	ADC120_ADANSA1_ANSA18 = 0x4
	// AN018 is not subjected to conversion.
	ADC120_ADANSA1_ANSA18_0 = 0x0
	// AN018 is subjected to conversion.
	ADC120_ADANSA1_ANSA18_1 = 0x1
	// Position of ANSA17 field.
	ADC120_ADANSA1_ANSA17_Pos = 0x1
	// Bit mask of ANSA17 field.
	ADC120_ADANSA1_ANSA17_Msk = 0x2
	// Bit ANSA17.
	ADC120_ADANSA1_ANSA17 = 0x2
	// AN017 is not subjected to conversion.
	ADC120_ADANSA1_ANSA17_0 = 0x0
	// AN017 is subjected to conversion.
	ADC120_ADANSA1_ANSA17_1 = 0x1
	// Position of ANSA16 field.
	ADC120_ADANSA1_ANSA16_Pos = 0x0
	// Bit mask of ANSA16 field.
	ADC120_ADANSA1_ANSA16_Msk = 0x1
	// Bit ANSA16.
	ADC120_ADANSA1_ANSA16 = 0x1
	// AN016 is not subjected to conversion.
	ADC120_ADANSA1_ANSA16_0 = 0x0
	// AN016 is subjected to conversion.
	ADC120_ADANSA1_ANSA16_1 = 0x1

	// ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
	// Position of ADS07 field.
	ADC120_ADADS0_ADS07_Pos = 0x7
	// Bit mask of ADS07 field.
	ADC120_ADADS0_ADS07_Msk = 0x80
	// Bit ADS07.
	ADC120_ADADS0_ADS07 = 0x80
	// AN007 is not selected.
	ADC120_ADADS0_ADS07_0 = 0x0
	// AN007 is selected.
	ADC120_ADADS0_ADS07_1 = 0x1
	// Position of ADS06 field.
	ADC120_ADADS0_ADS06_Pos = 0x6
	// Bit mask of ADS06 field.
	ADC120_ADADS0_ADS06_Msk = 0x40
	// Bit ADS06.
	ADC120_ADADS0_ADS06 = 0x40
	// AN006 is not selected.
	ADC120_ADADS0_ADS06_0 = 0x0
	// AN006 is selected.
	ADC120_ADADS0_ADS06_1 = 0x1
	// Position of ADS05 field.
	ADC120_ADADS0_ADS05_Pos = 0x5
	// Bit mask of ADS05 field.
	ADC120_ADADS0_ADS05_Msk = 0x20
	// Bit ADS05.
	ADC120_ADADS0_ADS05 = 0x20
	// AN005 is not selected.
	ADC120_ADADS0_ADS05_0 = 0x0
	// AN005 is selected.
	ADC120_ADADS0_ADS05_1 = 0x1
	// Position of ADS04 field.
	ADC120_ADADS0_ADS04_Pos = 0x4
	// Bit mask of ADS04 field.
	ADC120_ADADS0_ADS04_Msk = 0x10
	// Bit ADS04.
	ADC120_ADADS0_ADS04 = 0x10
	// AN004 is not selected.
	ADC120_ADADS0_ADS04_0 = 0x0
	// AN004 is selected.
	ADC120_ADADS0_ADS04_1 = 0x1
	// Position of ADS03 field.
	ADC120_ADADS0_ADS03_Pos = 0x3
	// Bit mask of ADS03 field.
	ADC120_ADADS0_ADS03_Msk = 0x8
	// Bit ADS03.
	ADC120_ADADS0_ADS03 = 0x8
	// AN003 is not selected.
	ADC120_ADADS0_ADS03_0 = 0x0
	// AN003 is selected.
	ADC120_ADADS0_ADS03_1 = 0x1
	// Position of ADS02 field.
	ADC120_ADADS0_ADS02_Pos = 0x2
	// Bit mask of ADS02 field.
	ADC120_ADADS0_ADS02_Msk = 0x4
	// Bit ADS02.
	ADC120_ADADS0_ADS02 = 0x4
	// AN002 is not selected.
	ADC120_ADADS0_ADS02_0 = 0x0
	// AN002 is selected.
	ADC120_ADADS0_ADS02_1 = 0x1
	// Position of ADS01 field.
	ADC120_ADADS0_ADS01_Pos = 0x1
	// Bit mask of ADS01 field.
	ADC120_ADADS0_ADS01_Msk = 0x2
	// Bit ADS01.
	ADC120_ADADS0_ADS01 = 0x2
	// AN001 is not selected.
	ADC120_ADADS0_ADS01_0 = 0x0
	// AN001 is selected.
	ADC120_ADADS0_ADS01_1 = 0x1
	// Position of ADS00 field.
	ADC120_ADADS0_ADS00_Pos = 0x0
	// Bit mask of ADS00 field.
	ADC120_ADADS0_ADS00_Msk = 0x1
	// Bit ADS00.
	ADC120_ADADS0_ADS00 = 0x1
	// AN000 is not selected.
	ADC120_ADADS0_ADS00_0 = 0x0
	// AN000 is selected.
	ADC120_ADADS0_ADS00_1 = 0x1

	// ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
	// Position of ADS20 field.
	ADC120_ADADS1_ADS20_Pos = 0x4
	// Bit mask of ADS20 field.
	ADC120_ADADS1_ADS20_Msk = 0x10
	// Bit ADS20.
	ADC120_ADADS1_ADS20 = 0x10
	// AN020 is not selected.
	ADC120_ADADS1_ADS20_0 = 0x0
	// AN020 is selected.
	ADC120_ADADS1_ADS20_1 = 0x1
	// Position of ADS19 field.
	ADC120_ADADS1_ADS19_Pos = 0x3
	// Bit mask of ADS19 field.
	ADC120_ADADS1_ADS19_Msk = 0x8
	// Bit ADS19.
	ADC120_ADADS1_ADS19 = 0x8
	// AN019 is not selected.
	ADC120_ADADS1_ADS19_0 = 0x0
	// AN019 is selected.
	ADC120_ADADS1_ADS19_1 = 0x1
	// Position of ADS18 field.
	ADC120_ADADS1_ADS18_Pos = 0x2
	// Bit mask of ADS18 field.
	ADC120_ADADS1_ADS18_Msk = 0x4
	// Bit ADS18.
	ADC120_ADADS1_ADS18 = 0x4
	// AN018 is not selected.
	ADC120_ADADS1_ADS18_0 = 0x0
	// AN018 is selected.
	ADC120_ADADS1_ADS18_1 = 0x1
	// Position of ADS17 field.
	ADC120_ADADS1_ADS17_Pos = 0x1
	// Bit mask of ADS17 field.
	ADC120_ADADS1_ADS17_Msk = 0x2
	// Bit ADS17.
	ADC120_ADADS1_ADS17 = 0x2
	// AN017 is not selected.
	ADC120_ADADS1_ADS17_0 = 0x0
	// AN017 is selected.
	ADC120_ADADS1_ADS17_1 = 0x1
	// Position of ADS16 field.
	ADC120_ADADS1_ADS16_Pos = 0x0
	// Bit mask of ADS16 field.
	ADC120_ADADS1_ADS16_Msk = 0x1
	// Bit ADS16.
	ADC120_ADADS1_ADS16 = 0x1
	// AN016 is not selected.
	ADC120_ADADS1_ADS16_0 = 0x0
	// AN016 is selected.
	ADC120_ADADS1_ADS16_1 = 0x1

	// ADADC: A/D-Converted Value Addition/Average Count Select Register
	// Position of AVEE field.
	ADC120_ADADC_AVEE_Pos = 0x7
	// Bit mask of AVEE field.
	ADC120_ADADC_AVEE_Msk = 0x80
	// Bit AVEE.
	ADC120_ADADC_AVEE = 0x80
	// Disabled
	ADC120_ADADC_AVEE_0 = 0x0
	// Enabled
	ADC120_ADADC_AVEE_1 = 0x1
	// Position of ADC field.
	ADC120_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC120_ADADC_ADC_Msk = 0x7
	// 1-time conversion (no addition; same as normal conversion)
	ADC120_ADADC_ADC_000 = 0x0
	// 2-time conversion (addition once)
	ADC120_ADADC_ADC_001 = 0x1
	// 3-time conversion (addition twice)
	ADC120_ADADC_ADC_010 = 0x2
	// 4-time conversion (addition three times)
	ADC120_ADADC_ADC_011 = 0x3
	// 16-time conversion (addition 15 times), can be set when selecting 12-bit accuracy.
	ADC120_ADADC_ADC_101 = 0x5

	// ADCER: A/D Control Extended Register
	// Position of ADRFMT field.
	ADC120_ADCER_ADRFMT_Pos = 0xf
	// Bit mask of ADRFMT field.
	ADC120_ADCER_ADRFMT_Msk = 0x8000
	// Bit ADRFMT.
	ADC120_ADCER_ADRFMT = 0x8000
	// Flush-right is selected for the A/D data register format.
	ADC120_ADCER_ADRFMT_0 = 0x0
	// Flush-left is selected for the A/D data register format.
	ADC120_ADCER_ADRFMT_1 = 0x1
	// Position of DIAGM field.
	ADC120_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC120_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC120_ADCER_DIAGM = 0x800
	// Disables self-diagnosis of ADC12.
	ADC120_ADCER_DIAGM_0 = 0x0
	// Enables self-diagnosis of ADC12.
	ADC120_ADCER_DIAGM_1 = 0x1
	// Position of DIAGLD field.
	ADC120_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC120_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC120_ADCER_DIAGLD = 0x400
	// Rotation mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_0 = 0x0
	// Fixed mode for self-diagnosis voltage
	ADC120_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC120_ADCER_DIAGVAL_Msk = 0x300
	// When the self-diagnosis fixation mode is selected, it set prohibits it.
	ADC120_ADCER_DIAGVAL_00 = 0x0
	// The self-diagnosis by using the voltage of 0V.
	ADC120_ADCER_DIAGVAL_01 = 0x1
	// The self-diagnosis by using the voltage of reference supply x 1/2.
	ADC120_ADCER_DIAGVAL_10 = 0x2
	// The self-diagnosis by using the voltage of the reference supply.
	ADC120_ADCER_DIAGVAL_11 = 0x3
	// Position of ACE field.
	ADC120_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC120_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC120_ADCER_ACE = 0x20
	// Disables automatic clearing.
	ADC120_ADCER_ACE_0 = 0x0
	// Enables automatic clearing.
	ADC120_ADCER_ACE_1 = 0x1
	// Position of ADPRC field.
	ADC120_ADCER_ADPRC_Pos = 0x1
	// Bit mask of ADPRC field.
	ADC120_ADCER_ADPRC_Msk = 0x6
	// A/D conversion is performed with 12-bit accuracy.
	ADC120_ADCER_ADPRC_00 = 0x0
	// A/D conversion is performed with 10-bit accuracy.
	ADC120_ADCER_ADPRC_01 = 0x1
	// A/D conversion is performed with 8-bit accuracy.
	ADC120_ADCER_ADPRC_10 = 0x2
	// Setting prohibited
	ADC120_ADCER_ADPRC_11 = 0x3

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of TRSA field.
	ADC120_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC120_ADSTRGR_TRSA_Msk = 0x3f00
	// Position of TRSB field.
	ADC120_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC120_ADSTRGR_TRSB_Msk = 0x3f

	// ADEXICR: A/D Conversion Extended Input Control Register
	// Position of OCSB field.
	ADC120_ADEXICR_OCSB_Pos = 0xb
	// Bit mask of OCSB field.
	ADC120_ADEXICR_OCSB_Msk = 0x800
	// Bit OCSB.
	ADC120_ADEXICR_OCSB = 0x800
	// The internal reference voltage is not selected.
	ADC120_ADEXICR_OCSB_0 = 0x0
	// The internal reference voltage is selected for group B in group scan mode.
	ADC120_ADEXICR_OCSB_1 = 0x1
	// Position of TSSB field.
	ADC120_ADEXICR_TSSB_Pos = 0xa
	// Bit mask of TSSB field.
	ADC120_ADEXICR_TSSB_Msk = 0x400
	// Bit TSSB.
	ADC120_ADEXICR_TSSB = 0x400
	// The temperature sensor output is not selected.
	ADC120_ADEXICR_TSSB_0 = 0x0
	// The temperature sensor output is not selected for group B in group scan mode.
	ADC120_ADEXICR_TSSB_1 = 0x1
	// Position of OCSA field.
	ADC120_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC120_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC120_ADEXICR_OCSA = 0x200
	// The internal reference voltage is not selected.
	ADC120_ADEXICR_OCSA_0 = 0x0
	// The internal reference voltage is selected for group A in single scan mode, continuous scan mode, or group scan mode.
	ADC120_ADEXICR_OCSA_1 = 0x1
	// Position of TSSA field.
	ADC120_ADEXICR_TSSA_Pos = 0x8
	// Bit mask of TSSA field.
	ADC120_ADEXICR_TSSA_Msk = 0x100
	// Bit TSSA.
	ADC120_ADEXICR_TSSA = 0x100
	// The temperature sensor output is not selected.
	ADC120_ADEXICR_TSSA_0 = 0x0
	// The temperature sensor output is selected.
	ADC120_ADEXICR_TSSA_1 = 0x1
	// Position of OCSAD field.
	ADC120_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC120_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC120_ADEXICR_OCSAD = 0x2
	// Internal reference voltage A/D-converted value addition/average mode is not selected.
	ADC120_ADEXICR_OCSAD_0 = 0x0
	// Internal reference voltage A/D-converted value addition/average mode is selected.
	ADC120_ADEXICR_OCSAD_1 = 0x1
	// Position of TSSAD field.
	ADC120_ADEXICR_TSSAD_Pos = 0x0
	// Bit mask of TSSAD field.
	ADC120_ADEXICR_TSSAD_Msk = 0x1
	// Bit TSSAD.
	ADC120_ADEXICR_TSSAD = 0x1
	// Temperature sensor output A/D-converted value addition/average mode is not selected.
	ADC120_ADEXICR_TSSAD_0 = 0x0
	// Temperature sensor output A/D-converted value addition/average mode is selected.
	ADC120_ADEXICR_TSSAD_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of ANSB07 field.
	ADC120_ADANSB0_ANSB07_Pos = 0x7
	// Bit mask of ANSB07 field.
	ADC120_ADANSB0_ANSB07_Msk = 0x80
	// Bit ANSB07.
	ADC120_ADANSB0_ANSB07 = 0x80
	// AN007 is not subjected to conversion.
	ADC120_ADANSB0_ANSB07_0 = 0x0
	// AN007 is subjected to conversion.
	ADC120_ADANSB0_ANSB07_1 = 0x1
	// Position of ANSB06 field.
	ADC120_ADANSB0_ANSB06_Pos = 0x6
	// Bit mask of ANSB06 field.
	ADC120_ADANSB0_ANSB06_Msk = 0x40
	// Bit ANSB06.
	ADC120_ADANSB0_ANSB06 = 0x40
	// AN006 is not subjected to conversion.
	ADC120_ADANSB0_ANSB06_0 = 0x0
	// AN006 is subjected to conversion.
	ADC120_ADANSB0_ANSB06_1 = 0x1
	// Position of ANSB05 field.
	ADC120_ADANSB0_ANSB05_Pos = 0x5
	// Bit mask of ANSB05 field.
	ADC120_ADANSB0_ANSB05_Msk = 0x20
	// Bit ANSB05.
	ADC120_ADANSB0_ANSB05 = 0x20
	// AN005 is not subjected to conversion.
	ADC120_ADANSB0_ANSB05_0 = 0x0
	// AN005 is subjected to conversion.
	ADC120_ADANSB0_ANSB05_1 = 0x1
	// Position of ANSB04 field.
	ADC120_ADANSB0_ANSB04_Pos = 0x4
	// Bit mask of ANSB04 field.
	ADC120_ADANSB0_ANSB04_Msk = 0x10
	// Bit ANSB04.
	ADC120_ADANSB0_ANSB04 = 0x10
	// AN004 is not subjected to conversion.
	ADC120_ADANSB0_ANSB04_0 = 0x0
	// AN004 is subjected to conversion.
	ADC120_ADANSB0_ANSB04_1 = 0x1
	// Position of ANSB03 field.
	ADC120_ADANSB0_ANSB03_Pos = 0x3
	// Bit mask of ANSB03 field.
	ADC120_ADANSB0_ANSB03_Msk = 0x8
	// Bit ANSB03.
	ADC120_ADANSB0_ANSB03 = 0x8
	// AN003 is not subjected to conversion.
	ADC120_ADANSB0_ANSB03_0 = 0x0
	// AN003 is subjected to conversion.
	ADC120_ADANSB0_ANSB03_1 = 0x1
	// Position of ANSB02 field.
	ADC120_ADANSB0_ANSB02_Pos = 0x2
	// Bit mask of ANSB02 field.
	ADC120_ADANSB0_ANSB02_Msk = 0x4
	// Bit ANSB02.
	ADC120_ADANSB0_ANSB02 = 0x4
	// AN002 is not subjected to conversion.
	ADC120_ADANSB0_ANSB02_0 = 0x0
	// AN002 is subjected to conversion.
	ADC120_ADANSB0_ANSB02_1 = 0x1
	// Position of ANSB01 field.
	ADC120_ADANSB0_ANSB01_Pos = 0x1
	// Bit mask of ANSB01 field.
	ADC120_ADANSB0_ANSB01_Msk = 0x2
	// Bit ANSB01.
	ADC120_ADANSB0_ANSB01 = 0x2
	// AN001 is not subjected to conversion.
	ADC120_ADANSB0_ANSB01_0 = 0x0
	// AN001 is subjected to conversion.
	ADC120_ADANSB0_ANSB01_1 = 0x1
	// Position of ANSB00 field.
	ADC120_ADANSB0_ANSB00_Pos = 0x0
	// Bit mask of ANSB00 field.
	ADC120_ADANSB0_ANSB00_Msk = 0x1
	// Bit ANSB00.
	ADC120_ADANSB0_ANSB00 = 0x1
	// AN000 is not subjected to conversion.
	ADC120_ADANSB0_ANSB00_0 = 0x0
	// AN000 is subjected to conversion.
	ADC120_ADANSB0_ANSB00_1 = 0x1

	// ADANSB1: A/D Channel Select Register B1
	// Position of ANSB20 field.
	ADC120_ADANSB1_ANSB20_Pos = 0x4
	// Bit mask of ANSB20 field.
	ADC120_ADANSB1_ANSB20_Msk = 0x10
	// Bit ANSB20.
	ADC120_ADANSB1_ANSB20 = 0x10
	// AN020 is not subjected to conversion.
	ADC120_ADANSB1_ANSB20_0 = 0x0
	// AN020 is subjected to conversion.
	ADC120_ADANSB1_ANSB20_1 = 0x1
	// Position of ANSB19 field.
	ADC120_ADANSB1_ANSB19_Pos = 0x3
	// Bit mask of ANSB19 field.
	ADC120_ADANSB1_ANSB19_Msk = 0x8
	// Bit ANSB19.
	ADC120_ADANSB1_ANSB19 = 0x8
	// AN019 is not subjected to conversion.
	ADC120_ADANSB1_ANSB19_0 = 0x0
	// AN019 is subjected to conversion.
	ADC120_ADANSB1_ANSB19_1 = 0x1
	// Position of ANSB18 field.
	ADC120_ADANSB1_ANSB18_Pos = 0x2
	// Bit mask of ANSB18 field.
	ADC120_ADANSB1_ANSB18_Msk = 0x4
	// Bit ANSB18.
	ADC120_ADANSB1_ANSB18 = 0x4
	// AN018 is not subjected to conversion.
	ADC120_ADANSB1_ANSB18_0 = 0x0
	// AN018 is subjected to conversion.
	ADC120_ADANSB1_ANSB18_1 = 0x1
	// Position of ANSB17 field.
	ADC120_ADANSB1_ANSB17_Pos = 0x1
	// Bit mask of ANSB17 field.
	ADC120_ADANSB1_ANSB17_Msk = 0x2
	// Bit ANSB17.
	ADC120_ADANSB1_ANSB17 = 0x2
	// AN017 is not subjected to conversion.
	ADC120_ADANSB1_ANSB17_0 = 0x0
	// AN017 is subjected to conversion.
	ADC120_ADANSB1_ANSB17_1 = 0x1
	// Position of ANSB16 field.
	ADC120_ADANSB1_ANSB16_Pos = 0x0
	// Bit mask of ANSB16 field.
	ADC120_ADANSB1_ANSB16_Msk = 0x1
	// Bit ANSB16.
	ADC120_ADANSB1_ANSB16 = 0x1
	// AN016 is not subjected to conversion.
	ADC120_ADANSB1_ANSB16_0 = 0x0
	// AN016 is subjected to conversion.
	ADC120_ADANSB1_ANSB16_1 = 0x1

	// ADDBLDR: A/D Data Duplication Register
	// Position of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC120_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADTSDR: A/D Temperature Sensor Data Register
	// Position of ADTSDR field.
	ADC120_ADTSDR_ADTSDR_Pos = 0x0
	// Bit mask of ADTSDR field.
	ADC120_ADTSDR_ADTSDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC120_ADOCDR_ADOCDR_Msk = 0xffff

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of DIAGST field.
	ADC120_ADRD_DIAGST_Pos = 0xe
	// Bit mask of DIAGST field.
	ADC120_ADRD_DIAGST_Msk = 0xc000
	// Self-diagnosis has never been executed since power-on.
	ADC120_ADRD_DIAGST_00 = 0x0
	// Self-diagnosis using the voltage of 0 V has been executed.
	ADC120_ADRD_DIAGST_01 = 0x1
	// Self-diagnosis using the voltage of reference power supply(VREFH) x 1/2 has been executed.
	ADC120_ADRD_DIAGST_10 = 0x2
	// Self-diagnosis using the voltage of reference power supply(VREFH) has been executed.
	ADC120_ADRD_DIAGST_11 = 0x3
	// Position of AD field.
	ADC120_ADRD_AD_Pos = 0x0
	// Bit mask of AD field.
	ADC120_ADRD_AD_Msk = 0xfff

	// ADDR0: A/D Data Register %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADDR16: A/D Data Register %s
	// Position of ADDR field.
	ADC120_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC120_ADDR_ADDR_Msk = 0xffff

	// ADSHCR: A/D Sample and Hold Circuit Control Register
	// Position of SHANS2 field.
	ADC120_ADSHCR_SHANS2_Pos = 0xa
	// Bit mask of SHANS2 field.
	ADC120_ADSHCR_SHANS2_Msk = 0x400
	// Bit SHANS2.
	ADC120_ADSHCR_SHANS2 = 0x400
	// Bypass the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS2_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS2_1 = 0x1
	// Position of SHANS1 field.
	ADC120_ADSHCR_SHANS1_Pos = 0x9
	// Bit mask of SHANS1 field.
	ADC120_ADSHCR_SHANS1_Msk = 0x200
	// Bit SHANS1.
	ADC120_ADSHCR_SHANS1 = 0x200
	// Bypass the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS1_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS1_1 = 0x1
	// Position of SHANS0 field.
	ADC120_ADSHCR_SHANS0_Pos = 0x8
	// Bit mask of SHANS0 field.
	ADC120_ADSHCR_SHANS0_Msk = 0x100
	// Bit SHANS0.
	ADC120_ADSHCR_SHANS0 = 0x100
	// Bypass the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS0_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC120_ADSHCR_SHANS0_1 = 0x1
	// Position of SSTSH field.
	ADC120_ADSHCR_SSTSH_Pos = 0x0
	// Bit mask of SSTSH field.
	ADC120_ADSHCR_SSTSH_Msk = 0xff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of CHARGE field.
	ADC120_ADDISCR_CHARGE_Pos = 0x4
	// Bit mask of CHARGE field.
	ADC120_ADDISCR_CHARGE_Msk = 0x10
	// Bit CHARGE.
	ADC120_ADDISCR_CHARGE = 0x10
	// Discharge
	ADC120_ADDISCR_CHARGE_0 = 0x0
	// Precharge
	ADC120_ADDISCR_CHARGE_1 = 0x1
	// Position of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC120_ADDISCR_ADNDIS_Msk = 0xf
	// Disconnection detection is disabled
	ADC120_ADDISCR_ADNDIS_0000 = 0x0
	// Setting prohibited
	ADC120_ADDISCR_ADNDIS_0001 = 0x1

	// ADSHMSR: A/D Sample and Hold Operation Mode Select Register
	// Position of SHMD field.
	ADC120_ADSHMSR_SHMD_Pos = 0x0
	// Bit mask of SHMD field.
	ADC120_ADSHMSR_SHMD_Msk = 0x1
	// Bit SHMD.
	ADC120_ADSHMSR_SHMD = 0x1
	// Sampling by channel-dedicated sample-and-hold circuit is disable.
	ADC120_ADSHMSR_SHMD_0 = 0x0
	// Sampling by channel-dedicated sample-and-hold circuit is enable.
	ADC120_ADSHMSR_SHMD_1 = 0x1

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of GBRP field.
	ADC120_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC120_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC120_ADGSPCR_GBRP = 0x8000
	// Single scan for group B is not continuously activated.
	ADC120_ADGSPCR_GBRP_0 = 0x0
	// Single scan for group B is continuously activated.
	ADC120_ADGSPCR_GBRP_1 = 0x1
	// Position of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC120_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC120_ADGSPCR_GBRSCN = 0x2
	// Scanning for group B is not restarted after having been discontinued due to group A priority control.
	ADC120_ADGSPCR_GBRSCN_0 = 0x0
	// Scanning for group B is restarted after having been discontinued due to group A priority control.
	ADC120_ADGSPCR_GBRSCN_1 = 0x1
	// Position of PGS field.
	ADC120_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC120_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC120_ADGSPCR_PGS = 0x1
	// Operation is without group A priority control
	ADC120_ADGSPCR_PGS_0 = 0x0
	// Operation is with group A priority control
	ADC120_ADGSPCR_PGS_1 = 0x1

	// ADDBLDRA: A/D Data Duplication Register A
	// Position of ADDBLDRA field.
	ADC120_ADDBLDRA_ADDBLDRA_Pos = 0x0
	// Bit mask of ADDBLDRA field.
	ADC120_ADDBLDRA_ADDBLDRA_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplication Register B
	// Position of ADDBLDRB field.
	ADC120_ADDBLDRB_ADDBLDRB_Pos = 0x0
	// Bit mask of ADDBLDRB field.
	ADC120_ADDBLDRB_ADDBLDRB_Msk = 0xffff

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC120_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC120_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC120_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC120_ADWINMON_MONCMPB_1 = 0x1
	// Position of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC120_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC120_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC120_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC120_ADWINMON_MONCMPA_1 = 0x1
	// Position of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC120_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC120_ADWINMON_MONCOMB = 0x1
	// Window A / window B composite conditions are not met.
	ADC120_ADWINMON_MONCOMB_0 = 0x0
	// Window A / window B composite conditions are met.
	ADC120_ADWINMON_MONCOMB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC120_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC120_ADCMPCR_CMPAIE = 0x8000
	// S12ADCMPAIi interrupt is disabled when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_0 = 0x0
	// S12ADCMPAIi interrupt is enabled when comparison conditions (window A) are met.
	ADC120_ADCMPCR_CMPAIE_1 = 0x1
	// Position of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC120_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC120_ADCMPCR_WCMPE = 0x4000
	// Window function is disabled. Window A and window B operate as a comparator to comparator the single value on the lower side with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_0 = 0x0
	// Window function is enabled. Window A and window B operate as a comparator to comparator the two values on the upper and lower sides with the A/D conversion result.
	ADC120_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC120_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC120_ADCMPCR_CMPBIE = 0x2000
	// S12ADCMPBIi interrupt is disabled when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_0 = 0x0
	// S12ADCMPBIi interrupt is enabled when comparison conditions (window B) are met.
	ADC120_ADCMPCR_CMPBIE_1 = 0x1
	// Position of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC120_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC120_ADCMPCR_CMPAE = 0x800
	// Compare window A operation is disabled. S12ADWMELC and S12ADWUMELC outputs are disabled.
	ADC120_ADCMPCR_CMPAE_0 = 0x0
	// Compare window A operation is enabled.
	ADC120_ADCMPCR_CMPAE_1 = 0x1
	// Position of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC120_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC120_ADCMPCR_CMPBE = 0x200
	// Compare window B operation is disabled. S12ADWMELC and S12ADWUMELC outputs are disabled.
	ADC120_ADCMPCR_CMPBE_0 = 0x0
	// Compare window B operation is enabled.
	ADC120_ADCMPCR_CMPBE_1 = 0x1
	// Position of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC120_ADCMPCR_CMPAB_Msk = 0x3
	// S12ADWMELC is output when window A comparison conditions are met OR window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC120_ADCMPCR_CMPAB_00 = 0x0
	// S12ADWMELC is output when window A comparison conditions are met EXOR window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC120_ADCMPCR_CMPAB_01 = 0x1
	// S12ADWMELC is output when window A comparison conditions are met and window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC120_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC120_ADCMPCR_CMPAB_11 = 0x3

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC120_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC120_ADCMPANSER_CMPOCA = 0x2
	// Excludes the internal reference voltage from the compare window A target range.
	ADC120_ADCMPANSER_CMPOCA_0 = 0x0
	// Includes the internal reference voltage in the compare window A target range.
	ADC120_ADCMPANSER_CMPOCA_1 = 0x1
	// Position of CMPTSA field.
	ADC120_ADCMPANSER_CMPTSA_Pos = 0x0
	// Bit mask of CMPTSA field.
	ADC120_ADCMPANSER_CMPTSA_Msk = 0x1
	// Bit CMPTSA.
	ADC120_ADCMPANSER_CMPTSA = 0x1
	// Excludes the temperature sensor output from the compare window A target range.
	ADC120_ADCMPANSER_CMPTSA_0 = 0x0
	// Includes the temperature sensor output in the compare window A target range.
	ADC120_ADCMPANSER_CMPTSA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC120_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC120_ADCMPLER_CMPLOCA = 0x2
	// ADCMPDR0 value > A/D converted value(ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or A/D converted value > ADCMPDR1 value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLER_CMPLOCA_0 = 0x0
	// ADCMPDR0 value < A/D converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 value < A/D converted value < ADCMPDR1 value(ADCMPCR.WCMPE=1)
	ADC120_ADCMPLER_CMPLOCA_1 = 0x1
	// Position of CMPLTSA field.
	ADC120_ADCMPLER_CMPLTSA_Pos = 0x0
	// Bit mask of CMPLTSA field.
	ADC120_ADCMPLER_CMPLTSA_Msk = 0x1
	// Bit CMPLTSA.
	ADC120_ADCMPLER_CMPLTSA = 0x1
	// ADCMPDR0 register value > A/D-converted value(ADCMPCR.WCMPE=0) / AD-converted value < ADCMPDR0 register value or A/D-converted value > ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC120_ADCMPLER_CMPLTSA_0 = 0x0
	// ADCMPDR0 register value < A/D-converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 register value < A/D-converted value < ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC120_ADCMPLER_CMPLTSA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of CMPCHA07 field.
	ADC120_ADCMPANSR0_CMPCHA07_Pos = 0x7
	// Bit mask of CMPCHA07 field.
	ADC120_ADCMPANSR0_CMPCHA07_Msk = 0x80
	// Bit CMPCHA07.
	ADC120_ADCMPANSR0_CMPCHA07 = 0x80
	// Disable compare function for AN007
	ADC120_ADCMPANSR0_CMPCHA07_0 = 0x0
	// Enable compare function for AN007
	ADC120_ADCMPANSR0_CMPCHA07_1 = 0x1
	// Position of CMPCHA06 field.
	ADC120_ADCMPANSR0_CMPCHA06_Pos = 0x6
	// Bit mask of CMPCHA06 field.
	ADC120_ADCMPANSR0_CMPCHA06_Msk = 0x40
	// Bit CMPCHA06.
	ADC120_ADCMPANSR0_CMPCHA06 = 0x40
	// Disable compare function for AN006
	ADC120_ADCMPANSR0_CMPCHA06_0 = 0x0
	// Enable compare function for AN006
	ADC120_ADCMPANSR0_CMPCHA06_1 = 0x1
	// Position of CMPCHA05 field.
	ADC120_ADCMPANSR0_CMPCHA05_Pos = 0x5
	// Bit mask of CMPCHA05 field.
	ADC120_ADCMPANSR0_CMPCHA05_Msk = 0x20
	// Bit CMPCHA05.
	ADC120_ADCMPANSR0_CMPCHA05 = 0x20
	// Disable compare function for AN005
	ADC120_ADCMPANSR0_CMPCHA05_0 = 0x0
	// Enable compare function for AN005
	ADC120_ADCMPANSR0_CMPCHA05_1 = 0x1
	// Position of CMPCHA04 field.
	ADC120_ADCMPANSR0_CMPCHA04_Pos = 0x4
	// Bit mask of CMPCHA04 field.
	ADC120_ADCMPANSR0_CMPCHA04_Msk = 0x10
	// Bit CMPCHA04.
	ADC120_ADCMPANSR0_CMPCHA04 = 0x10
	// Disable compare function for AN004
	ADC120_ADCMPANSR0_CMPCHA04_0 = 0x0
	// Enable compare function for AN004
	ADC120_ADCMPANSR0_CMPCHA04_1 = 0x1
	// Position of CMPCHA03 field.
	ADC120_ADCMPANSR0_CMPCHA03_Pos = 0x3
	// Bit mask of CMPCHA03 field.
	ADC120_ADCMPANSR0_CMPCHA03_Msk = 0x8
	// Bit CMPCHA03.
	ADC120_ADCMPANSR0_CMPCHA03 = 0x8
	// Disable compare function for AN003
	ADC120_ADCMPANSR0_CMPCHA03_0 = 0x0
	// Enable compare function for AN003
	ADC120_ADCMPANSR0_CMPCHA03_1 = 0x1
	// Position of CMPCHA02 field.
	ADC120_ADCMPANSR0_CMPCHA02_Pos = 0x2
	// Bit mask of CMPCHA02 field.
	ADC120_ADCMPANSR0_CMPCHA02_Msk = 0x4
	// Bit CMPCHA02.
	ADC120_ADCMPANSR0_CMPCHA02 = 0x4
	// Disable compare function for AN002
	ADC120_ADCMPANSR0_CMPCHA02_0 = 0x0
	// Enable compare function for AN002
	ADC120_ADCMPANSR0_CMPCHA02_1 = 0x1
	// Position of CMPCHA01 field.
	ADC120_ADCMPANSR0_CMPCHA01_Pos = 0x1
	// Bit mask of CMPCHA01 field.
	ADC120_ADCMPANSR0_CMPCHA01_Msk = 0x2
	// Bit CMPCHA01.
	ADC120_ADCMPANSR0_CMPCHA01 = 0x2
	// Disable compare function for AN001
	ADC120_ADCMPANSR0_CMPCHA01_0 = 0x0
	// Enable compare function for AN001
	ADC120_ADCMPANSR0_CMPCHA01_1 = 0x1
	// Position of CMPCHA00 field.
	ADC120_ADCMPANSR0_CMPCHA00_Pos = 0x0
	// Bit mask of CMPCHA00 field.
	ADC120_ADCMPANSR0_CMPCHA00_Msk = 0x1
	// Bit CMPCHA00.
	ADC120_ADCMPANSR0_CMPCHA00 = 0x1
	// Disable compare function for AN000
	ADC120_ADCMPANSR0_CMPCHA00_0 = 0x0
	// Enable compare function for AN000
	ADC120_ADCMPANSR0_CMPCHA00_1 = 0x1

	// ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
	// Position of CMPCHA20 field.
	ADC120_ADCMPANSR1_CMPCHA20_Pos = 0x4
	// Bit mask of CMPCHA20 field.
	ADC120_ADCMPANSR1_CMPCHA20_Msk = 0x10
	// Bit CMPCHA20.
	ADC120_ADCMPANSR1_CMPCHA20 = 0x10
	// Excludes AN020 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA20_0 = 0x0
	// Includes AN020 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA20_1 = 0x1
	// Position of CMPCHA19 field.
	ADC120_ADCMPANSR1_CMPCHA19_Pos = 0x3
	// Bit mask of CMPCHA19 field.
	ADC120_ADCMPANSR1_CMPCHA19_Msk = 0x8
	// Bit CMPCHA19.
	ADC120_ADCMPANSR1_CMPCHA19 = 0x8
	// Excludes AN019 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA19_0 = 0x0
	// Includes AN019 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA19_1 = 0x1
	// Position of CMPCHA18 field.
	ADC120_ADCMPANSR1_CMPCHA18_Pos = 0x2
	// Bit mask of CMPCHA18 field.
	ADC120_ADCMPANSR1_CMPCHA18_Msk = 0x4
	// Bit CMPCHA18.
	ADC120_ADCMPANSR1_CMPCHA18 = 0x4
	// Excludes AN018 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA18_0 = 0x0
	// Includes AN018 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA18_1 = 0x1
	// Position of CMPCHA17 field.
	ADC120_ADCMPANSR1_CMPCHA17_Pos = 0x1
	// Bit mask of CMPCHA17 field.
	ADC120_ADCMPANSR1_CMPCHA17_Msk = 0x2
	// Bit CMPCHA17.
	ADC120_ADCMPANSR1_CMPCHA17 = 0x2
	// Excludes AN017 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA17_0 = 0x0
	// Includes AN017 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA17_1 = 0x1
	// Position of CMPCHA16 field.
	ADC120_ADCMPANSR1_CMPCHA16_Pos = 0x0
	// Bit mask of CMPCHA16 field.
	ADC120_ADCMPANSR1_CMPCHA16_Msk = 0x1
	// Bit CMPCHA16.
	ADC120_ADCMPANSR1_CMPCHA16 = 0x1
	// Excludes AN016 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA16_0 = 0x0
	// Includes AN016 from the compare window A target range.
	ADC120_ADCMPANSR1_CMPCHA16_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of CMPLCHA07 field.
	ADC120_ADCMPLR0_CMPLCHA07_Pos = 0x7
	// Bit mask of CMPLCHA07 field.
	ADC120_ADCMPLR0_CMPLCHA07_Msk = 0x80
	// Bit CMPLCHA07.
	ADC120_ADCMPLR0_CMPLCHA07 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA07_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA07_1 = 0x1
	// Position of CMPLCHA06 field.
	ADC120_ADCMPLR0_CMPLCHA06_Pos = 0x6
	// Bit mask of CMPLCHA06 field.
	ADC120_ADCMPLR0_CMPLCHA06_Msk = 0x40
	// Bit CMPLCHA06.
	ADC120_ADCMPLR0_CMPLCHA06 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA06_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA06_1 = 0x1
	// Position of CMPLCHA05 field.
	ADC120_ADCMPLR0_CMPLCHA05_Pos = 0x5
	// Bit mask of CMPLCHA05 field.
	ADC120_ADCMPLR0_CMPLCHA05_Msk = 0x20
	// Bit CMPLCHA05.
	ADC120_ADCMPLR0_CMPLCHA05 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA05_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA05_1 = 0x1
	// Position of CMPLCHA04 field.
	ADC120_ADCMPLR0_CMPLCHA04_Pos = 0x4
	// Bit mask of CMPLCHA04 field.
	ADC120_ADCMPLR0_CMPLCHA04_Msk = 0x10
	// Bit CMPLCHA04.
	ADC120_ADCMPLR0_CMPLCHA04 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA04_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA04_1 = 0x1
	// Position of CMPLCHA03 field.
	ADC120_ADCMPLR0_CMPLCHA03_Pos = 0x3
	// Bit mask of CMPLCHA03 field.
	ADC120_ADCMPLR0_CMPLCHA03_Msk = 0x8
	// Bit CMPLCHA03.
	ADC120_ADCMPLR0_CMPLCHA03 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA03_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA03_1 = 0x1
	// Position of CMPLCHA02 field.
	ADC120_ADCMPLR0_CMPLCHA02_Pos = 0x2
	// Bit mask of CMPLCHA02 field.
	ADC120_ADCMPLR0_CMPLCHA02_Msk = 0x4
	// Bit CMPLCHA02.
	ADC120_ADCMPLR0_CMPLCHA02 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA02_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA02_1 = 0x1
	// Position of CMPLCHA01 field.
	ADC120_ADCMPLR0_CMPLCHA01_Pos = 0x1
	// Bit mask of CMPLCHA01 field.
	ADC120_ADCMPLR0_CMPLCHA01_Msk = 0x2
	// Bit CMPLCHA01.
	ADC120_ADCMPLR0_CMPLCHA01 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA01_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA01_1 = 0x1
	// Position of CMPLCHA00 field.
	ADC120_ADCMPLR0_CMPLCHA00_Pos = 0x0
	// Bit mask of CMPLCHA00 field.
	ADC120_ADCMPLR0_CMPLCHA00_Msk = 0x1
	// Bit CMPLCHA00.
	ADC120_ADCMPLR0_CMPLCHA00 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR0_CMPLCHA00_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR0_CMPLCHA00_1 = 0x1

	// ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
	// Position of CMPLCHA20 field.
	ADC120_ADCMPLR1_CMPLCHA20_Pos = 0x4
	// Bit mask of CMPLCHA20 field.
	ADC120_ADCMPLR1_CMPLCHA20_Msk = 0x10
	// Bit CMPLCHA20.
	ADC120_ADCMPLR1_CMPLCHA20 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR1_CMPLCHA20_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR1_CMPLCHA20_1 = 0x1
	// Position of CMPLCHA19 field.
	ADC120_ADCMPLR1_CMPLCHA19_Pos = 0x3
	// Bit mask of CMPLCHA19 field.
	ADC120_ADCMPLR1_CMPLCHA19_Msk = 0x8
	// Bit CMPLCHA19.
	ADC120_ADCMPLR1_CMPLCHA19 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR1_CMPLCHA19_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR1_CMPLCHA19_1 = 0x1
	// Position of CMPLCHA18 field.
	ADC120_ADCMPLR1_CMPLCHA18_Pos = 0x2
	// Bit mask of CMPLCHA18 field.
	ADC120_ADCMPLR1_CMPLCHA18_Msk = 0x4
	// Bit CMPLCHA18.
	ADC120_ADCMPLR1_CMPLCHA18 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR1_CMPLCHA18_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR1_CMPLCHA18_1 = 0x1
	// Position of CMPLCHA17 field.
	ADC120_ADCMPLR1_CMPLCHA17_Pos = 0x1
	// Bit mask of CMPLCHA17 field.
	ADC120_ADCMPLR1_CMPLCHA17_Msk = 0x2
	// Bit CMPLCHA17.
	ADC120_ADCMPLR1_CMPLCHA17 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR1_CMPLCHA17_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR1_CMPLCHA17_1 = 0x1
	// Position of CMPLCHA16 field.
	ADC120_ADCMPLR1_CMPLCHA16_Pos = 0x0
	// Bit mask of CMPLCHA16 field.
	ADC120_ADCMPLR1_CMPLCHA16_Msk = 0x1
	// Bit CMPLCHA16.
	ADC120_ADCMPLR1_CMPLCHA16 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPLR1_CMPLCHA16_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC120_ADCMPLR1_CMPLCHA16_1 = 0x1

	// ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
	// Position of ADCMPDR0 field.
	ADC120_ADCMPDR0_ADCMPDR0_Pos = 0x0
	// Bit mask of ADCMPDR0 field.
	ADC120_ADCMPDR0_ADCMPDR0_Msk = 0xffff

	// ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
	// Position of ADCMPDR1 field.
	ADC120_ADCMPDR1_ADCMPDR1_Pos = 0x0
	// Bit mask of ADCMPDR1 field.
	ADC120_ADCMPDR1_ADCMPDR1_Msk = 0xffff

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of CMPSTCHA07 field.
	ADC120_ADCMPSR0_CMPSTCHA07_Pos = 0x7
	// Bit mask of CMPSTCHA07 field.
	ADC120_ADCMPSR0_CMPSTCHA07_Msk = 0x80
	// Bit CMPSTCHA07.
	ADC120_ADCMPSR0_CMPSTCHA07 = 0x80
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA07_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA07_1 = 0x1
	// Position of CMPSTCHA06 field.
	ADC120_ADCMPSR0_CMPSTCHA06_Pos = 0x6
	// Bit mask of CMPSTCHA06 field.
	ADC120_ADCMPSR0_CMPSTCHA06_Msk = 0x40
	// Bit CMPSTCHA06.
	ADC120_ADCMPSR0_CMPSTCHA06 = 0x40
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA06_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA06_1 = 0x1
	// Position of CMPSTCHA05 field.
	ADC120_ADCMPSR0_CMPSTCHA05_Pos = 0x5
	// Bit mask of CMPSTCHA05 field.
	ADC120_ADCMPSR0_CMPSTCHA05_Msk = 0x20
	// Bit CMPSTCHA05.
	ADC120_ADCMPSR0_CMPSTCHA05 = 0x20
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA05_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA05_1 = 0x1
	// Position of CMPSTCHA04 field.
	ADC120_ADCMPSR0_CMPSTCHA04_Pos = 0x4
	// Bit mask of CMPSTCHA04 field.
	ADC120_ADCMPSR0_CMPSTCHA04_Msk = 0x10
	// Bit CMPSTCHA04.
	ADC120_ADCMPSR0_CMPSTCHA04 = 0x10
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA04_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA04_1 = 0x1
	// Position of CMPSTCHA03 field.
	ADC120_ADCMPSR0_CMPSTCHA03_Pos = 0x3
	// Bit mask of CMPSTCHA03 field.
	ADC120_ADCMPSR0_CMPSTCHA03_Msk = 0x8
	// Bit CMPSTCHA03.
	ADC120_ADCMPSR0_CMPSTCHA03 = 0x8
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA03_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA03_1 = 0x1
	// Position of CMPSTCHA02 field.
	ADC120_ADCMPSR0_CMPSTCHA02_Pos = 0x2
	// Bit mask of CMPSTCHA02 field.
	ADC120_ADCMPSR0_CMPSTCHA02_Msk = 0x4
	// Bit CMPSTCHA02.
	ADC120_ADCMPSR0_CMPSTCHA02 = 0x4
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA02_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA02_1 = 0x1
	// Position of CMPSTCHA01 field.
	ADC120_ADCMPSR0_CMPSTCHA01_Pos = 0x1
	// Bit mask of CMPSTCHA01 field.
	ADC120_ADCMPSR0_CMPSTCHA01_Msk = 0x2
	// Bit CMPSTCHA01.
	ADC120_ADCMPSR0_CMPSTCHA01 = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA01_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA01_1 = 0x1
	// Position of CMPSTCHA00 field.
	ADC120_ADCMPSR0_CMPSTCHA00_Pos = 0x0
	// Bit mask of CMPSTCHA00 field.
	ADC120_ADCMPSR0_CMPSTCHA00_Msk = 0x1
	// Bit CMPSTCHA00.
	ADC120_ADCMPSR0_CMPSTCHA00 = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSR0_CMPSTCHA00_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR0_CMPSTCHA00_1 = 0x1

	// ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
	// Position of CMPSTCHA20 field.
	ADC120_ADCMPSR1_CMPSTCHA20_Pos = 0x4
	// Bit mask of CMPSTCHA20 field.
	ADC120_ADCMPSR1_CMPSTCHA20_Msk = 0x10
	// Bit CMPSTCHA20.
	ADC120_ADCMPSR1_CMPSTCHA20 = 0x10
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA20_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA20_1 = 0x1
	// Position of CMPSTCHA19 field.
	ADC120_ADCMPSR1_CMPSTCHA19_Pos = 0x3
	// Bit mask of CMPSTCHA19 field.
	ADC120_ADCMPSR1_CMPSTCHA19_Msk = 0x8
	// Bit CMPSTCHA19.
	ADC120_ADCMPSR1_CMPSTCHA19 = 0x8
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA19_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA19_1 = 0x1
	// Position of CMPSTCHA18 field.
	ADC120_ADCMPSR1_CMPSTCHA18_Pos = 0x2
	// Bit mask of CMPSTCHA18 field.
	ADC120_ADCMPSR1_CMPSTCHA18_Msk = 0x4
	// Bit CMPSTCHA18.
	ADC120_ADCMPSR1_CMPSTCHA18 = 0x4
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA18_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA18_1 = 0x1
	// Position of CMPSTCHA17 field.
	ADC120_ADCMPSR1_CMPSTCHA17_Pos = 0x1
	// Bit mask of CMPSTCHA17 field.
	ADC120_ADCMPSR1_CMPSTCHA17_Msk = 0x2
	// Bit CMPSTCHA17.
	ADC120_ADCMPSR1_CMPSTCHA17 = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA17_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA17_1 = 0x1
	// Position of CMPSTCHA16 field.
	ADC120_ADCMPSR1_CMPSTCHA16_Pos = 0x0
	// Bit mask of CMPSTCHA16 field.
	ADC120_ADCMPSR1_CMPSTCHA16_Msk = 0x1
	// Bit CMPSTCHA16.
	ADC120_ADCMPSR1_CMPSTCHA16 = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSR1_CMPSTCHA16_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSR1_CMPSTCHA16_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC120_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC120_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC120_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSER_CMPSTOCA_1 = 0x1
	// Position of CMPSTTSA field.
	ADC120_ADCMPSER_CMPSTTSA_Pos = 0x0
	// Bit mask of CMPSTTSA field.
	ADC120_ADCMPSER_CMPSTTSA_Msk = 0x1
	// Bit CMPSTTSA.
	ADC120_ADCMPSER_CMPSTTSA = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPSER_CMPSTTSA_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPSER_CMPSTTSA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
	// Position of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC120_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC120_ADCMPBNSR_CMPLB = 0x80
	// CMPLLB value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < CMPLLB value or CMPULB value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPBNSR_CMPLB_0 = 0x0
	// CMPLLB value < A/D converted value(ADCMPCR.WCMPE=0) / CMPLLB value < A/D converted value < CMPULB value (ADCMPCR.WCMPE=1)
	ADC120_ADCMPBNSR_CMPLB_1 = 0x1
	// Position of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC120_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// AN000
	ADC120_ADCMPBNSR_CMPCHB_0x00 = 0x0
	// AN001
	ADC120_ADCMPBNSR_CMPCHB_0x01 = 0x1
	// AN002
	ADC120_ADCMPBNSR_CMPCHB_0x02 = 0x2
	// AN003
	ADC120_ADCMPBNSR_CMPCHB_0x03 = 0x3
	// AN004
	ADC120_ADCMPBNSR_CMPCHB_0x04 = 0x4
	// AN005
	ADC120_ADCMPBNSR_CMPCHB_0x05 = 0x5
	// AN006
	ADC120_ADCMPBNSR_CMPCHB_0x06 = 0x6
	// AN007
	ADC120_ADCMPBNSR_CMPCHB_0x07 = 0x7
	// AN016
	ADC120_ADCMPBNSR_CMPCHB_0x10 = 0x10
	// AN017
	ADC120_ADCMPBNSR_CMPCHB_0x11 = 0x11
	// AN018
	ADC120_ADCMPBNSR_CMPCHB_0x12 = 0x12
	// AN019
	ADC120_ADCMPBNSR_CMPCHB_0x13 = 0x13
	// AN020
	ADC120_ADCMPBNSR_CMPCHB_0x14 = 0x14
	// Temperature sensor
	ADC120_ADCMPBNSR_CMPCHB_0x20 = 0x20
	// Internal reference voltage
	ADC120_ADCMPBNSR_CMPCHB_0x21 = 0x21
	// No channel is selected
	ADC120_ADCMPBNSR_CMPCHB_0x3F = 0x3f

	// ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
	// Position of ADWINLLB field.
	ADC120_ADWINLLB_ADWINLLB_Pos = 0x0
	// Bit mask of ADWINLLB field.
	ADC120_ADWINLLB_ADWINLLB_Msk = 0xffff

	// ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
	// Position of ADWINULB field.
	ADC120_ADWINULB_ADWINULB_Pos = 0x0
	// Bit mask of ADWINULB field.
	ADC120_ADWINULB_ADWINULB_Msk = 0xffff

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC120_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC120_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC120_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC120_ADCMPBSR_CMPSTB_1 = 0x1

	// ADSSTRL: A/D Sampling State Register L
	// Position of SST field.
	ADC120_ADSSTRL_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRL_SST_Msk = 0xff

	// ADSSTRT: A/D Sampling State Register T
	// Position of SST field.
	ADC120_ADSSTRT_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRT_SST_Msk = 0xff

	// ADSSTRO: A/D Sampling State Register O
	// Position of SST field.
	ADC120_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTRO_SST_Msk = 0xff

	// ADSSTR00: A/D Sampling State Register %s (Corresponding Channel is AN00%s )
	// Position of SST field.
	ADC120_ADSSTR0_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC120_ADSSTR0_SST_Msk = 0xff

	// ADPGACR: A/D Programmable Gain Amplifier Control Register
	// Position of P002GEN field.
	ADC120_ADPGACR_P002GEN_Pos = 0xb
	// Bit mask of P002GEN field.
	ADC120_ADPGACR_P002GEN_Msk = 0x800
	// Bit P002GEN.
	ADC120_ADPGACR_P002GEN = 0x800
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC120_ADPGACR_P002GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC120_ADPGACR_P002GEN_1 = 0x1
	// Position of P002ENAMP field.
	ADC120_ADPGACR_P002ENAMP_Pos = 0xa
	// Bit mask of P002ENAMP field.
	ADC120_ADPGACR_P002ENAMP_Msk = 0x400
	// Bit P002ENAMP.
	ADC120_ADPGACR_P002ENAMP = 0x400
	// The amplifier in PGA is not used.
	ADC120_ADPGACR_P002ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC120_ADPGACR_P002ENAMP_1 = 0x1
	// Position of P002SEL1 field.
	ADC120_ADPGACR_P002SEL1_Pos = 0x9
	// Bit mask of P002SEL1 field.
	ADC120_ADPGACR_P002SEL1_Msk = 0x200
	// Bit P002SEL1.
	ADC120_ADPGACR_P002SEL1 = 0x200
	// By way of the amplifier in PGA.
	ADC120_ADPGACR_P002SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC120_ADPGACR_P002SEL1_1 = 0x1
	// Position of P002SEL0 field.
	ADC120_ADPGACR_P002SEL0_Pos = 0x8
	// Bit mask of P002SEL0 field.
	ADC120_ADPGACR_P002SEL0_Msk = 0x100
	// Bit P002SEL0.
	ADC120_ADPGACR_P002SEL0 = 0x100
	// Not through the PGA in amplifier
	ADC120_ADPGACR_P002SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC120_ADPGACR_P002SEL0_1 = 0x1
	// Position of P001GEN field.
	ADC120_ADPGACR_P001GEN_Pos = 0x7
	// Bit mask of P001GEN field.
	ADC120_ADPGACR_P001GEN_Msk = 0x80
	// Bit P001GEN.
	ADC120_ADPGACR_P001GEN = 0x80
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC120_ADPGACR_P001GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC120_ADPGACR_P001GEN_1 = 0x1
	// Position of P001ENAMP field.
	ADC120_ADPGACR_P001ENAMP_Pos = 0x6
	// Bit mask of P001ENAMP field.
	ADC120_ADPGACR_P001ENAMP_Msk = 0x40
	// Bit P001ENAMP.
	ADC120_ADPGACR_P001ENAMP = 0x40
	// The amplifier in PGA is not used.
	ADC120_ADPGACR_P001ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC120_ADPGACR_P001ENAMP_1 = 0x1
	// Position of P001SEL1 field.
	ADC120_ADPGACR_P001SEL1_Pos = 0x5
	// Bit mask of P001SEL1 field.
	ADC120_ADPGACR_P001SEL1_Msk = 0x20
	// Bit P001SEL1.
	ADC120_ADPGACR_P001SEL1 = 0x20
	// By way of the amplifier in PGA.
	ADC120_ADPGACR_P001SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC120_ADPGACR_P001SEL1_1 = 0x1
	// Position of P001SEL0 field.
	ADC120_ADPGACR_P001SEL0_Pos = 0x4
	// Bit mask of P001SEL0 field.
	ADC120_ADPGACR_P001SEL0_Msk = 0x10
	// Bit P001SEL0.
	ADC120_ADPGACR_P001SEL0 = 0x10
	// Not through the PGA in amplifier
	ADC120_ADPGACR_P001SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC120_ADPGACR_P001SEL0_1 = 0x1
	// Position of P000GEN field.
	ADC120_ADPGACR_P000GEN_Pos = 0x3
	// Bit mask of P000GEN field.
	ADC120_ADPGACR_P000GEN_Msk = 0x8
	// Bit P000GEN.
	ADC120_ADPGACR_P000GEN = 0x8
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC120_ADPGACR_P000GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC120_ADPGACR_P000GEN_1 = 0x1
	// Position of P000ENAMP field.
	ADC120_ADPGACR_P000ENAMP_Pos = 0x2
	// Bit mask of P000ENAMP field.
	ADC120_ADPGACR_P000ENAMP_Msk = 0x4
	// Bit P000ENAMP.
	ADC120_ADPGACR_P000ENAMP = 0x4
	// The amplifier in PGA is not used.
	ADC120_ADPGACR_P000ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC120_ADPGACR_P000ENAMP_1 = 0x1
	// Position of P000SEL1 field.
	ADC120_ADPGACR_P000SEL1_Pos = 0x1
	// Bit mask of P000SEL1 field.
	ADC120_ADPGACR_P000SEL1_Msk = 0x2
	// Bit P000SEL1.
	ADC120_ADPGACR_P000SEL1 = 0x2
	// By way of the amplifier in PGA.
	ADC120_ADPGACR_P000SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC120_ADPGACR_P000SEL1_1 = 0x1
	// Position of P000SEL0 field.
	ADC120_ADPGACR_P000SEL0_Pos = 0x0
	// Bit mask of P000SEL0 field.
	ADC120_ADPGACR_P000SEL0_Msk = 0x1
	// Bit P000SEL0.
	ADC120_ADPGACR_P000SEL0 = 0x1
	// Not through the PGA in amplifier
	ADC120_ADPGACR_P000SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC120_ADPGACR_P000SEL0_1 = 0x1

	// ADPGAGS0: A/D Programmable Gain Amplifier Gain Setting Register 0
	// Position of P002GAIN field.
	ADC120_ADPGAGS0_P002GAIN_Pos = 0x8
	// Bit mask of P002GAIN field.
	ADC120_ADPGAGS0_P002GAIN_Msk = 0xf00
	// x 2.000 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P002DEN=0) / x 1.500 (ADPGADDCR0.P002DEN=1)
	ADC120_ADPGAGS0_P002GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P002DEN=0) / x 2.333 (ADPGADDCR0.P002DEN=1)
	ADC120_ADPGAGS0_P002GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P002DEN=0) / x 4.00 (ADPGADDCR0.P002DEN=1)
	ADC120_ADPGAGS0_P002GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P002DEN=0) / x 5.667 (ADPGADDCR0.P002DEN=1)
	ADC120_ADPGAGS0_P002GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P002DEN=0)
	ADC120_ADPGAGS0_P002GAIN_1111 = 0xf
	// Position of P001GAIN field.
	ADC120_ADPGAGS0_P001GAIN_Pos = 0x4
	// Bit mask of P001GAIN field.
	ADC120_ADPGAGS0_P001GAIN_Msk = 0xf0
	// x 2.000 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P001DEN=0) / x 1.500 (ADPGADDCR0.P001DEN=1)
	ADC120_ADPGAGS0_P001GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P001DEN=0) / x 2.333 (ADPGADDCR0.P001DEN=1)
	ADC120_ADPGAGS0_P001GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P001DEN=0) / x 4.00 (ADPGADDCR0.P001DEN=1)
	ADC120_ADPGAGS0_P001GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P001DEN=0) / x 5.667 (ADPGADDCR0.P001DEN=1)
	ADC120_ADPGAGS0_P001GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P001DEN=0)
	ADC120_ADPGAGS0_P001GAIN_1111 = 0xf
	// Position of P000GAIN field.
	ADC120_ADPGAGS0_P000GAIN_Pos = 0x0
	// Bit mask of P000GAIN field.
	ADC120_ADPGAGS0_P000GAIN_Msk = 0xf
	// x 2.000 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P000DEN=0) / x 1.500 (ADPGADDCR0.P000DEN=1)
	ADC120_ADPGAGS0_P000GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P000DEN=0) / x 2.333 (ADPGADDCR0.P000DEN=1)
	ADC120_ADPGAGS0_P000GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P000DEN=0) / x 4.00 (ADPGADDCR0.P000DEN=1)
	ADC120_ADPGAGS0_P000GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P000DEN=0) / x 5.667 (ADPGADDCR0.P000DEN=1)
	ADC120_ADPGAGS0_P000GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P000DEN=0)
	ADC120_ADPGAGS0_P000GAIN_1111 = 0xf

	// ADPGADCR0: A/D Programmable Gain Amplifier Differential Input Control Register
	// Position of P003DG field.
	ADC120_ADPGADCR0_P003DG_Pos = 0xc
	// Bit mask of P003DG field.
	ADC120_ADPGADCR0_P003DG_Msk = 0x3000
	// x 1.5
	ADC120_ADPGADCR0_P003DG_00 = 0x0
	// x 2.333
	ADC120_ADPGADCR0_P003DG_01 = 0x1
	// x 4.0
	ADC120_ADPGADCR0_P003DG_10 = 0x2
	// x 5.667
	ADC120_ADPGADCR0_P003DG_11 = 0x3
	// Position of P002DEN field.
	ADC120_ADPGADCR0_P002DEN_Pos = 0xb
	// Bit mask of P002DEN field.
	ADC120_ADPGADCR0_P002DEN_Msk = 0x800
	// Bit P002DEN.
	ADC120_ADPGADCR0_P002DEN = 0x800
	// Differential input is disabled.
	ADC120_ADPGADCR0_P002DEN_0 = 0x0
	// Differential input is enabled.
	ADC120_ADPGADCR0_P002DEN_1 = 0x1
	// Position of P002DG field.
	ADC120_ADPGADCR0_P002DG_Pos = 0x8
	// Bit mask of P002DG field.
	ADC120_ADPGADCR0_P002DG_Msk = 0x300
	// x 1.5
	ADC120_ADPGADCR0_P002DG_00 = 0x0
	// x 2.333
	ADC120_ADPGADCR0_P002DG_01 = 0x1
	// x 4.0
	ADC120_ADPGADCR0_P002DG_10 = 0x2
	// x 5.667
	ADC120_ADPGADCR0_P002DG_11 = 0x3
	// Position of P001DEN field.
	ADC120_ADPGADCR0_P001DEN_Pos = 0x7
	// Bit mask of P001DEN field.
	ADC120_ADPGADCR0_P001DEN_Msk = 0x80
	// Bit P001DEN.
	ADC120_ADPGADCR0_P001DEN = 0x80
	// Differential input is disabled.
	ADC120_ADPGADCR0_P001DEN_0 = 0x0
	// Differential input is enabled.
	ADC120_ADPGADCR0_P001DEN_1 = 0x1
	// Position of P001DG field.
	ADC120_ADPGADCR0_P001DG_Pos = 0x4
	// Bit mask of P001DG field.
	ADC120_ADPGADCR0_P001DG_Msk = 0x30
	// x 1.5
	ADC120_ADPGADCR0_P001DG_00 = 0x0
	// x 2.333
	ADC120_ADPGADCR0_P001DG_01 = 0x1
	// x 4.0
	ADC120_ADPGADCR0_P001DG_10 = 0x2
	// x 5.667
	ADC120_ADPGADCR0_P001DG_11 = 0x3
	// Position of P000DEN field.
	ADC120_ADPGADCR0_P000DEN_Pos = 0x3
	// Bit mask of P000DEN field.
	ADC120_ADPGADCR0_P000DEN_Msk = 0x8
	// Bit P000DEN.
	ADC120_ADPGADCR0_P000DEN = 0x8
	// Differential input is disabled.
	ADC120_ADPGADCR0_P000DEN_0 = 0x0
	// Differential input is enabled.
	ADC120_ADPGADCR0_P000DEN_1 = 0x1
	// Position of P000DG field.
	ADC120_ADPGADCR0_P000DG_Pos = 0x0
	// Bit mask of P000DG field.
	ADC120_ADPGADCR0_P000DG_Msk = 0x3
	// x 1.5
	ADC120_ADPGADCR0_P000DG_00 = 0x0
	// x 2.333
	ADC120_ADPGADCR0_P000DG_01 = 0x1
	// x 4.0
	ADC120_ADPGADCR0_P000DG_10 = 0x2
	// x 5.667
	ADC120_ADPGADCR0_P000DG_11 = 0x3
)

// Constants for ADC121: 12bit A/D Converter 1
const (
	// ADCSR: A/D Control Register
	// Position of ADST field.
	ADC121_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC121_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC121_ADCSR_ADST = 0x8000
	// Stops A/D conversion process.
	ADC121_ADCSR_ADST_0 = 0x0
	// Starts A/D conversion process.
	ADC121_ADCSR_ADST_1 = 0x1
	// Position of ADCS field.
	ADC121_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC121_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC121_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC121_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC121_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC121_ADCSR_ADCS_11 = 0x3
	// Position of TRGE field.
	ADC121_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC121_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC121_ADCSR_TRGE = 0x200
	// Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC121_ADCSR_TRGE_0 = 0x0
	// Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC121_ADCSR_TRGE_1 = 0x1
	// Position of EXTRG field.
	ADC121_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC121_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC121_ADCSR_EXTRG = 0x100
	// A/D conversion is started by the synchronous trigger (ELCTRG1).
	ADC121_ADCSR_EXTRG_0 = 0x0
	// A/D conversion is started by the asynchronous trigger (ADTRG1#).
	ADC121_ADCSR_EXTRG_1 = 0x1
	// Position of DBLE field.
	ADC121_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC121_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC121_ADCSR_DBLE = 0x80
	// Double trigger mode non-selection
	ADC121_ADCSR_DBLE_0 = 0x0
	// Double trigger mode selection
	ADC121_ADCSR_DBLE_1 = 0x1
	// Position of GBADIE field.
	ADC121_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC121_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC121_ADCSR_GBADIE = 0x40
	// Disables S12GBADI1 interrupt generation upon group B scan completion.
	ADC121_ADCSR_GBADIE_0 = 0x0
	// Enables S12GBADI1 interrupt generation upon group B scan completion.
	ADC121_ADCSR_GBADIE_1 = 0x1
	// Position of DBLANS field.
	ADC121_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC121_ADCSR_DBLANS_Msk = 0x1f

	// ADANSA0: A/D Channel Select Register A0
	// Position of ANSA07 field.
	ADC121_ADANSA0_ANSA07_Pos = 0x7
	// Bit mask of ANSA07 field.
	ADC121_ADANSA0_ANSA07_Msk = 0x80
	// Bit ANSA07.
	ADC121_ADANSA0_ANSA07 = 0x80
	// AN107 is not subjected to conversion.
	ADC121_ADANSA0_ANSA07_0 = 0x0
	// AN107 is subjected to conversion.
	ADC121_ADANSA0_ANSA07_1 = 0x1
	// Position of ANSA06 field.
	ADC121_ADANSA0_ANSA06_Pos = 0x6
	// Bit mask of ANSA06 field.
	ADC121_ADANSA0_ANSA06_Msk = 0x40
	// Bit ANSA06.
	ADC121_ADANSA0_ANSA06 = 0x40
	// AN106 is not subjected to conversion.
	ADC121_ADANSA0_ANSA06_0 = 0x0
	// AN106 is subjected to conversion.
	ADC121_ADANSA0_ANSA06_1 = 0x1
	// Position of ANSA05 field.
	ADC121_ADANSA0_ANSA05_Pos = 0x5
	// Bit mask of ANSA05 field.
	ADC121_ADANSA0_ANSA05_Msk = 0x20
	// Bit ANSA05.
	ADC121_ADANSA0_ANSA05 = 0x20
	// AN105 is not subjected to conversion.
	ADC121_ADANSA0_ANSA05_0 = 0x0
	// AN105 is subjected to conversion.
	ADC121_ADANSA0_ANSA05_1 = 0x1
	// Position of ANSA03 field.
	ADC121_ADANSA0_ANSA03_Pos = 0x3
	// Bit mask of ANSA03 field.
	ADC121_ADANSA0_ANSA03_Msk = 0x8
	// Bit ANSA03.
	ADC121_ADANSA0_ANSA03 = 0x8
	// AN103 is not subjected to conversion.
	ADC121_ADANSA0_ANSA03_0 = 0x0
	// AN103 is subjected to conversion.
	ADC121_ADANSA0_ANSA03_1 = 0x1
	// Position of ANSA02 field.
	ADC121_ADANSA0_ANSA02_Pos = 0x2
	// Bit mask of ANSA02 field.
	ADC121_ADANSA0_ANSA02_Msk = 0x4
	// Bit ANSA02.
	ADC121_ADANSA0_ANSA02 = 0x4
	// AN102 is not subjected to conversion.
	ADC121_ADANSA0_ANSA02_0 = 0x0
	// AN102 is subjected to conversion.
	ADC121_ADANSA0_ANSA02_1 = 0x1
	// Position of ANSA01 field.
	ADC121_ADANSA0_ANSA01_Pos = 0x1
	// Bit mask of ANSA01 field.
	ADC121_ADANSA0_ANSA01_Msk = 0x2
	// Bit ANSA01.
	ADC121_ADANSA0_ANSA01 = 0x2
	// AN101 is not subjected to conversion.
	ADC121_ADANSA0_ANSA01_0 = 0x0
	// AN101 is subjected to conversion.
	ADC121_ADANSA0_ANSA01_1 = 0x1
	// Position of ANSA00 field.
	ADC121_ADANSA0_ANSA00_Pos = 0x0
	// Bit mask of ANSA00 field.
	ADC121_ADANSA0_ANSA00_Msk = 0x1
	// Bit ANSA00.
	ADC121_ADANSA0_ANSA00 = 0x1
	// AN100 is not subjected to conversion.
	ADC121_ADANSA0_ANSA00_0 = 0x0
	// AN100 is subjected to conversion.
	ADC121_ADANSA0_ANSA00_1 = 0x1

	// ADANSA1: A/D Channel Select Register A1
	// Position of ANSA19 field.
	ADC121_ADANSA1_ANSA19_Pos = 0x3
	// Bit mask of ANSA19 field.
	ADC121_ADANSA1_ANSA19_Msk = 0x8
	// Bit ANSA19.
	ADC121_ADANSA1_ANSA19 = 0x8
	// AN119 is not subjected to conversion.
	ADC121_ADANSA1_ANSA19_0 = 0x0
	// AN119 is subjected to conversion.
	ADC121_ADANSA1_ANSA19_1 = 0x1
	// Position of ANSA18 field.
	ADC121_ADANSA1_ANSA18_Pos = 0x2
	// Bit mask of ANSA18 field.
	ADC121_ADANSA1_ANSA18_Msk = 0x4
	// Bit ANSA18.
	ADC121_ADANSA1_ANSA18 = 0x4
	// AN118 is not subjected to conversion.
	ADC121_ADANSA1_ANSA18_0 = 0x0
	// AN118 is subjected to conversion.
	ADC121_ADANSA1_ANSA18_1 = 0x1
	// Position of ANSA17 field.
	ADC121_ADANSA1_ANSA17_Pos = 0x1
	// Bit mask of ANSA17 field.
	ADC121_ADANSA1_ANSA17_Msk = 0x2
	// Bit ANSA17.
	ADC121_ADANSA1_ANSA17 = 0x2
	// AN117 is not subjected to conversion.
	ADC121_ADANSA1_ANSA17_0 = 0x0
	// AN117 is subjected to conversion.
	ADC121_ADANSA1_ANSA17_1 = 0x1
	// Position of ANSA16 field.
	ADC121_ADANSA1_ANSA16_Pos = 0x0
	// Bit mask of ANSA16 field.
	ADC121_ADANSA1_ANSA16_Msk = 0x1
	// Bit ANSA16.
	ADC121_ADANSA1_ANSA16 = 0x1
	// AN116 is not subjected to conversion.
	ADC121_ADANSA1_ANSA16_0 = 0x0
	// AN116 is subjected to conversion.
	ADC121_ADANSA1_ANSA16_1 = 0x1

	// ADADS0: A/D-Converted Value Addition/Average Channel Select Register 0
	// Position of ADS07 field.
	ADC121_ADADS0_ADS07_Pos = 0x7
	// Bit mask of ADS07 field.
	ADC121_ADADS0_ADS07_Msk = 0x80
	// Bit ADS07.
	ADC121_ADADS0_ADS07 = 0x80
	// AN107 is not selected.
	ADC121_ADADS0_ADS07_0 = 0x0
	// AN107 is selected.
	ADC121_ADADS0_ADS07_1 = 0x1
	// Position of ADS06 field.
	ADC121_ADADS0_ADS06_Pos = 0x6
	// Bit mask of ADS06 field.
	ADC121_ADADS0_ADS06_Msk = 0x40
	// Bit ADS06.
	ADC121_ADADS0_ADS06 = 0x40
	// AN106 is not selected.
	ADC121_ADADS0_ADS06_0 = 0x0
	// AN106 is selected.
	ADC121_ADADS0_ADS06_1 = 0x1
	// Position of ADS05 field.
	ADC121_ADADS0_ADS05_Pos = 0x5
	// Bit mask of ADS05 field.
	ADC121_ADADS0_ADS05_Msk = 0x20
	// Bit ADS05.
	ADC121_ADADS0_ADS05 = 0x20
	// AN105 is not selected.
	ADC121_ADADS0_ADS05_0 = 0x0
	// AN105 is selected.
	ADC121_ADADS0_ADS05_1 = 0x1
	// Position of ADS03 field.
	ADC121_ADADS0_ADS03_Pos = 0x3
	// Bit mask of ADS03 field.
	ADC121_ADADS0_ADS03_Msk = 0x8
	// Bit ADS03.
	ADC121_ADADS0_ADS03 = 0x8
	// AN103 is not selected.
	ADC121_ADADS0_ADS03_0 = 0x0
	// AN103 is selected.
	ADC121_ADADS0_ADS03_1 = 0x1
	// Position of ADS02 field.
	ADC121_ADADS0_ADS02_Pos = 0x2
	// Bit mask of ADS02 field.
	ADC121_ADADS0_ADS02_Msk = 0x4
	// Bit ADS02.
	ADC121_ADADS0_ADS02 = 0x4
	// AN102 is not selected.
	ADC121_ADADS0_ADS02_0 = 0x0
	// AN102 is selected.
	ADC121_ADADS0_ADS02_1 = 0x1
	// Position of ADS01 field.
	ADC121_ADADS0_ADS01_Pos = 0x1
	// Bit mask of ADS01 field.
	ADC121_ADADS0_ADS01_Msk = 0x2
	// Bit ADS01.
	ADC121_ADADS0_ADS01 = 0x2
	// AN101 is not selected.
	ADC121_ADADS0_ADS01_0 = 0x0
	// AN101 is selected.
	ADC121_ADADS0_ADS01_1 = 0x1
	// Position of ADS00 field.
	ADC121_ADADS0_ADS00_Pos = 0x0
	// Bit mask of ADS00 field.
	ADC121_ADADS0_ADS00_Msk = 0x1
	// Bit ADS00.
	ADC121_ADADS0_ADS00 = 0x1
	// AN100 is not selected.
	ADC121_ADADS0_ADS00_0 = 0x0
	// AN100 is selected.
	ADC121_ADADS0_ADS00_1 = 0x1

	// ADADS1: A/D-Converted Value Addition/Average Channel Select Register 1
	// Position of ADS19 field.
	ADC121_ADADS1_ADS19_Pos = 0x3
	// Bit mask of ADS19 field.
	ADC121_ADADS1_ADS19_Msk = 0x8
	// Bit ADS19.
	ADC121_ADADS1_ADS19 = 0x8
	// AN119 is not selected.
	ADC121_ADADS1_ADS19_0 = 0x0
	// AN119 is selected.
	ADC121_ADADS1_ADS19_1 = 0x1
	// Position of ADS18 field.
	ADC121_ADADS1_ADS18_Pos = 0x2
	// Bit mask of ADS18 field.
	ADC121_ADADS1_ADS18_Msk = 0x4
	// Bit ADS18.
	ADC121_ADADS1_ADS18 = 0x4
	// AN118 is not selected.
	ADC121_ADADS1_ADS18_0 = 0x0
	// AN118 is selected.
	ADC121_ADADS1_ADS18_1 = 0x1
	// Position of ADS17 field.
	ADC121_ADADS1_ADS17_Pos = 0x1
	// Bit mask of ADS17 field.
	ADC121_ADADS1_ADS17_Msk = 0x2
	// Bit ADS17.
	ADC121_ADADS1_ADS17 = 0x2
	// AN117 is not selected.
	ADC121_ADADS1_ADS17_0 = 0x0
	// AN117 is selected.
	ADC121_ADADS1_ADS17_1 = 0x1
	// Position of ADS16 field.
	ADC121_ADADS1_ADS16_Pos = 0x0
	// Bit mask of ADS16 field.
	ADC121_ADADS1_ADS16_Msk = 0x1
	// Bit ADS16.
	ADC121_ADADS1_ADS16 = 0x1
	// AN116 is not selected.
	ADC121_ADADS1_ADS16_0 = 0x0
	// AN116 is selected.
	ADC121_ADADS1_ADS16_1 = 0x1

	// ADADC: A/D-Converted Value Addition/Average Count Select Register
	// Position of AVEE field.
	ADC121_ADADC_AVEE_Pos = 0x7
	// Bit mask of AVEE field.
	ADC121_ADADC_AVEE_Msk = 0x80
	// Bit AVEE.
	ADC121_ADADC_AVEE = 0x80
	// Disabled
	ADC121_ADADC_AVEE_0 = 0x0
	// Enabled
	ADC121_ADADC_AVEE_1 = 0x1
	// Position of ADC field.
	ADC121_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC121_ADADC_ADC_Msk = 0x7
	// 1-time conversion (no addition; same as normal conversion)
	ADC121_ADADC_ADC_000 = 0x0
	// 2-time conversion (addition once)
	ADC121_ADADC_ADC_001 = 0x1
	// 3-time conversion (addition twice)
	ADC121_ADADC_ADC_010 = 0x2
	// 4-time conversion (addition three times)
	ADC121_ADADC_ADC_011 = 0x3
	// 16-time conversion (addition 15 times), can be set when selecting 12-bit accuracy.
	ADC121_ADADC_ADC_101 = 0x5

	// ADCER: A/D Control Extended Register
	// Position of ADRFMT field.
	ADC121_ADCER_ADRFMT_Pos = 0xf
	// Bit mask of ADRFMT field.
	ADC121_ADCER_ADRFMT_Msk = 0x8000
	// Bit ADRFMT.
	ADC121_ADCER_ADRFMT = 0x8000
	// Flush-right is selected for the A/D data register format.
	ADC121_ADCER_ADRFMT_0 = 0x0
	// Flush-left is selected for the A/D data register format.
	ADC121_ADCER_ADRFMT_1 = 0x1
	// Position of DIAGM field.
	ADC121_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC121_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC121_ADCER_DIAGM = 0x800
	// Disables self-diagnosis of ADC12.
	ADC121_ADCER_DIAGM_0 = 0x0
	// Enables self-diagnosis of ADC12.
	ADC121_ADCER_DIAGM_1 = 0x1
	// Position of DIAGLD field.
	ADC121_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC121_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC121_ADCER_DIAGLD = 0x400
	// Rotation mode for self-diagnosis voltage
	ADC121_ADCER_DIAGLD_0 = 0x0
	// Fixed mode for self-diagnosis voltage
	ADC121_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGVAL field.
	ADC121_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC121_ADCER_DIAGVAL_Msk = 0x300
	// When the self-diagnosis fixation mode is selected, it set prohibits it.
	ADC121_ADCER_DIAGVAL_00 = 0x0
	// The self-diagnosis by using the voltage of 0V.
	ADC121_ADCER_DIAGVAL_01 = 0x1
	// The self-diagnosis by using the voltage of reference supply x 1/2.
	ADC121_ADCER_DIAGVAL_10 = 0x2
	// The self-diagnosis by using the voltage of the reference supply.
	ADC121_ADCER_DIAGVAL_11 = 0x3
	// Position of ACE field.
	ADC121_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC121_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC121_ADCER_ACE = 0x20
	// Disables automatic clearing.
	ADC121_ADCER_ACE_0 = 0x0
	// Enables automatic clearing.
	ADC121_ADCER_ACE_1 = 0x1
	// Position of ADPRC field.
	ADC121_ADCER_ADPRC_Pos = 0x1
	// Bit mask of ADPRC field.
	ADC121_ADCER_ADPRC_Msk = 0x6
	// A/D conversion is performed with 12-bit accuracy.
	ADC121_ADCER_ADPRC_00 = 0x0
	// A/D conversion is performed with 10-bit accuracy.
	ADC121_ADCER_ADPRC_01 = 0x1
	// A/D conversion is performed with 8-bit accuracy.
	ADC121_ADCER_ADPRC_10 = 0x2
	// Setting prohibited
	ADC121_ADCER_ADPRC_11 = 0x3

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of TRSA field.
	ADC121_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC121_ADSTRGR_TRSA_Msk = 0x3f00
	// Position of TRSB field.
	ADC121_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC121_ADSTRGR_TRSB_Msk = 0x3f

	// ADEXICR: A/D Conversion Extended Input Control Register
	// Position of OCSB field.
	ADC121_ADEXICR_OCSB_Pos = 0xb
	// Bit mask of OCSB field.
	ADC121_ADEXICR_OCSB_Msk = 0x800
	// Bit OCSB.
	ADC121_ADEXICR_OCSB = 0x800
	// The internal reference voltage is not selected.
	ADC121_ADEXICR_OCSB_0 = 0x0
	// The internal reference voltage is selected for group B in group scan mode.
	ADC121_ADEXICR_OCSB_1 = 0x1
	// Position of TSSB field.
	ADC121_ADEXICR_TSSB_Pos = 0xa
	// Bit mask of TSSB field.
	ADC121_ADEXICR_TSSB_Msk = 0x400
	// Bit TSSB.
	ADC121_ADEXICR_TSSB = 0x400
	// The temperature sensor output is not selected.
	ADC121_ADEXICR_TSSB_0 = 0x0
	// The temperature sensor output is not selected for group B in group scan mode.
	ADC121_ADEXICR_TSSB_1 = 0x1
	// Position of OCSA field.
	ADC121_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC121_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC121_ADEXICR_OCSA = 0x200
	// The internal reference voltage is not selected.
	ADC121_ADEXICR_OCSA_0 = 0x0
	// The internal reference voltage is selected for group A in single scan mode, continuous scan mode, or group scan mode.
	ADC121_ADEXICR_OCSA_1 = 0x1
	// Position of TSSA field.
	ADC121_ADEXICR_TSSA_Pos = 0x8
	// Bit mask of TSSA field.
	ADC121_ADEXICR_TSSA_Msk = 0x100
	// Bit TSSA.
	ADC121_ADEXICR_TSSA = 0x100
	// The temperature sensor output is not selected.
	ADC121_ADEXICR_TSSA_0 = 0x0
	// The temperature sensor output is selected.
	ADC121_ADEXICR_TSSA_1 = 0x1
	// Position of OCSAD field.
	ADC121_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC121_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC121_ADEXICR_OCSAD = 0x2
	// Internal reference voltage A/D-converted value addition/average mode is not selected.
	ADC121_ADEXICR_OCSAD_0 = 0x0
	// Internal reference voltage A/D-converted value addition/average mode is selected.
	ADC121_ADEXICR_OCSAD_1 = 0x1
	// Position of TSSAD field.
	ADC121_ADEXICR_TSSAD_Pos = 0x0
	// Bit mask of TSSAD field.
	ADC121_ADEXICR_TSSAD_Msk = 0x1
	// Bit TSSAD.
	ADC121_ADEXICR_TSSAD = 0x1
	// Temperature sensor output A/D-converted value addition/average mode is not selected.
	ADC121_ADEXICR_TSSAD_0 = 0x0
	// Temperature sensor output A/D-converted value addition/average mode is selected.
	ADC121_ADEXICR_TSSAD_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of ANSB07 field.
	ADC121_ADANSB0_ANSB07_Pos = 0x7
	// Bit mask of ANSB07 field.
	ADC121_ADANSB0_ANSB07_Msk = 0x80
	// Bit ANSB07.
	ADC121_ADANSB0_ANSB07 = 0x80
	// AN107 is not subjected to conversion.
	ADC121_ADANSB0_ANSB07_0 = 0x0
	// AN107 is subjected to conversion.
	ADC121_ADANSB0_ANSB07_1 = 0x1
	// Position of ANSB06 field.
	ADC121_ADANSB0_ANSB06_Pos = 0x6
	// Bit mask of ANSB06 field.
	ADC121_ADANSB0_ANSB06_Msk = 0x40
	// Bit ANSB06.
	ADC121_ADANSB0_ANSB06 = 0x40
	// AN106 is not subjected to conversion.
	ADC121_ADANSB0_ANSB06_0 = 0x0
	// AN106 is subjected to conversion.
	ADC121_ADANSB0_ANSB06_1 = 0x1
	// Position of ANSB05 field.
	ADC121_ADANSB0_ANSB05_Pos = 0x5
	// Bit mask of ANSB05 field.
	ADC121_ADANSB0_ANSB05_Msk = 0x20
	// Bit ANSB05.
	ADC121_ADANSB0_ANSB05 = 0x20
	// AN105 is not subjected to conversion.
	ADC121_ADANSB0_ANSB05_0 = 0x0
	// AN105 is subjected to conversion.
	ADC121_ADANSB0_ANSB05_1 = 0x1
	// Position of ANSB03 field.
	ADC121_ADANSB0_ANSB03_Pos = 0x3
	// Bit mask of ANSB03 field.
	ADC121_ADANSB0_ANSB03_Msk = 0x8
	// Bit ANSB03.
	ADC121_ADANSB0_ANSB03 = 0x8
	// AN103 is not subjected to conversion.
	ADC121_ADANSB0_ANSB03_0 = 0x0
	// AN103 is subjected to conversion.
	ADC121_ADANSB0_ANSB03_1 = 0x1
	// Position of ANSB02 field.
	ADC121_ADANSB0_ANSB02_Pos = 0x2
	// Bit mask of ANSB02 field.
	ADC121_ADANSB0_ANSB02_Msk = 0x4
	// Bit ANSB02.
	ADC121_ADANSB0_ANSB02 = 0x4
	// AN102 is not subjected to conversion.
	ADC121_ADANSB0_ANSB02_0 = 0x0
	// AN102 is subjected to conversion.
	ADC121_ADANSB0_ANSB02_1 = 0x1
	// Position of ANSB01 field.
	ADC121_ADANSB0_ANSB01_Pos = 0x1
	// Bit mask of ANSB01 field.
	ADC121_ADANSB0_ANSB01_Msk = 0x2
	// Bit ANSB01.
	ADC121_ADANSB0_ANSB01 = 0x2
	// AN101 is not subjected to conversion.
	ADC121_ADANSB0_ANSB01_0 = 0x0
	// AN101 is subjected to conversion.
	ADC121_ADANSB0_ANSB01_1 = 0x1
	// Position of ANSB00 field.
	ADC121_ADANSB0_ANSB00_Pos = 0x0
	// Bit mask of ANSB00 field.
	ADC121_ADANSB0_ANSB00_Msk = 0x1
	// Bit ANSB00.
	ADC121_ADANSB0_ANSB00 = 0x1
	// AN100 is not subjected to conversion.
	ADC121_ADANSB0_ANSB00_0 = 0x0
	// AN100 is subjected to conversion.
	ADC121_ADANSB0_ANSB00_1 = 0x1

	// ADANSB1: A/D Channel Select Register B1
	// Position of ANSB19 field.
	ADC121_ADANSB1_ANSB19_Pos = 0x3
	// Bit mask of ANSB19 field.
	ADC121_ADANSB1_ANSB19_Msk = 0x8
	// Bit ANSB19.
	ADC121_ADANSB1_ANSB19 = 0x8
	// AN119 is not subjected to conversion.
	ADC121_ADANSB1_ANSB19_0 = 0x0
	// AN119 is subjected to conversion.
	ADC121_ADANSB1_ANSB19_1 = 0x1
	// Position of ANSB18 field.
	ADC121_ADANSB1_ANSB18_Pos = 0x2
	// Bit mask of ANSB18 field.
	ADC121_ADANSB1_ANSB18_Msk = 0x4
	// Bit ANSB18.
	ADC121_ADANSB1_ANSB18 = 0x4
	// AN118 is not subjected to conversion.
	ADC121_ADANSB1_ANSB18_0 = 0x0
	// AN118 is subjected to conversion.
	ADC121_ADANSB1_ANSB18_1 = 0x1
	// Position of ANSB17 field.
	ADC121_ADANSB1_ANSB17_Pos = 0x1
	// Bit mask of ANSB17 field.
	ADC121_ADANSB1_ANSB17_Msk = 0x2
	// Bit ANSB17.
	ADC121_ADANSB1_ANSB17 = 0x2
	// AN117 is not subjected to conversion.
	ADC121_ADANSB1_ANSB17_0 = 0x0
	// AN117 is subjected to conversion.
	ADC121_ADANSB1_ANSB17_1 = 0x1
	// Position of ANSB16 field.
	ADC121_ADANSB1_ANSB16_Pos = 0x0
	// Bit mask of ANSB16 field.
	ADC121_ADANSB1_ANSB16_Msk = 0x1
	// Bit ANSB16.
	ADC121_ADANSB1_ANSB16 = 0x1
	// AN116 is not subjected to conversion.
	ADC121_ADANSB1_ANSB16_0 = 0x0
	// AN116 is subjected to conversion.
	ADC121_ADANSB1_ANSB16_1 = 0x1

	// ADDBLDR: A/D Data Duplication Register
	// Position of ADDBLDR field.
	ADC121_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC121_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADTSDR: A/D Temperature Sensor Data Register
	// Position of ADTSDR field.
	ADC121_ADTSDR_ADTSDR_Pos = 0x0
	// Bit mask of ADTSDR field.
	ADC121_ADTSDR_ADTSDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC121_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC121_ADOCDR_ADOCDR_Msk = 0xffff

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of DIAGST field.
	ADC121_ADRD_DIAGST_Pos = 0xe
	// Bit mask of DIAGST field.
	ADC121_ADRD_DIAGST_Msk = 0xc000
	// Self-diagnosis has never been executed since power-on.
	ADC121_ADRD_DIAGST_00 = 0x0
	// Self-diagnosis using the voltage of 0 V has been executed.
	ADC121_ADRD_DIAGST_01 = 0x1
	// Self-diagnosis using the voltage of reference power supply(VREFH) x 1/2 has been executed.
	ADC121_ADRD_DIAGST_10 = 0x2
	// Self-diagnosis using the voltage of reference power supply(VREFH) has been executed.
	ADC121_ADRD_DIAGST_11 = 0x3
	// Position of AD field.
	ADC121_ADRD_AD_Pos = 0x0
	// Bit mask of AD field.
	ADC121_ADRD_AD_Msk = 0xfff

	// ADDR0: A/D Data Register %s
	// Position of ADDR field.
	ADC121_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC121_ADDR_ADDR_Msk = 0xffff

	// ADDR5: A/D Data Register %s
	// Position of ADDR field.
	ADC121_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC121_ADDR_ADDR_Msk = 0xffff

	// ADDR16: A/D Data Register %s
	// Position of ADDR field.
	ADC121_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC121_ADDR_ADDR_Msk = 0xffff

	// ADSHCR: A/D Sample and Hold Circuit Control Register
	// Position of SHANS2 field.
	ADC121_ADSHCR_SHANS2_Pos = 0xa
	// Bit mask of SHANS2 field.
	ADC121_ADSHCR_SHANS2_Msk = 0x400
	// Bit SHANS2.
	ADC121_ADSHCR_SHANS2 = 0x400
	// Bypass the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS2_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS2_1 = 0x1
	// Position of SHANS1 field.
	ADC121_ADSHCR_SHANS1_Pos = 0x9
	// Bit mask of SHANS1 field.
	ADC121_ADSHCR_SHANS1_Msk = 0x200
	// Bit SHANS1.
	ADC121_ADSHCR_SHANS1 = 0x200
	// Bypass the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS1_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS1_1 = 0x1
	// Position of SHANS0 field.
	ADC121_ADSHCR_SHANS0_Pos = 0x8
	// Bit mask of SHANS0 field.
	ADC121_ADSHCR_SHANS0_Msk = 0x100
	// Bit SHANS0.
	ADC121_ADSHCR_SHANS0 = 0x100
	// Bypass the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS0_0 = 0x0
	// Use the sample-and-hold circuit.
	ADC121_ADSHCR_SHANS0_1 = 0x1
	// Position of SSTSH field.
	ADC121_ADSHCR_SSTSH_Pos = 0x0
	// Bit mask of SSTSH field.
	ADC121_ADSHCR_SSTSH_Msk = 0xff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of CHARGE field.
	ADC121_ADDISCR_CHARGE_Pos = 0x4
	// Bit mask of CHARGE field.
	ADC121_ADDISCR_CHARGE_Msk = 0x10
	// Bit CHARGE.
	ADC121_ADDISCR_CHARGE = 0x10
	// Discharge
	ADC121_ADDISCR_CHARGE_0 = 0x0
	// Precharge
	ADC121_ADDISCR_CHARGE_1 = 0x1
	// Position of ADNDIS field.
	ADC121_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC121_ADDISCR_ADNDIS_Msk = 0xf
	// Disconnection detection is disabled
	ADC121_ADDISCR_ADNDIS_0000 = 0x0
	// Setting prohibited
	ADC121_ADDISCR_ADNDIS_0001 = 0x1

	// ADSHMSR: A/D Sample and Hold Operation Mode Select Register
	// Position of SHMD field.
	ADC121_ADSHMSR_SHMD_Pos = 0x0
	// Bit mask of SHMD field.
	ADC121_ADSHMSR_SHMD_Msk = 0x1
	// Bit SHMD.
	ADC121_ADSHMSR_SHMD = 0x1
	// Sampling by channel-dedicated sample-and-hold circuit is disable.
	ADC121_ADSHMSR_SHMD_0 = 0x0
	// Sampling by channel-dedicated sample-and-hold circuit is enable.
	ADC121_ADSHMSR_SHMD_1 = 0x1

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of GBRP field.
	ADC121_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC121_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC121_ADGSPCR_GBRP = 0x8000
	// Single scan for group B is not continuously activated.
	ADC121_ADGSPCR_GBRP_0 = 0x0
	// Single scan for group B is continuously activated.
	ADC121_ADGSPCR_GBRP_1 = 0x1
	// Position of GBRSCN field.
	ADC121_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC121_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC121_ADGSPCR_GBRSCN = 0x2
	// Scanning for group B is not restarted after having been discontinued due to group A priority control.
	ADC121_ADGSPCR_GBRSCN_0 = 0x0
	// Scanning for group B is restarted after having been discontinued due to group A priority control.
	ADC121_ADGSPCR_GBRSCN_1 = 0x1
	// Position of PGS field.
	ADC121_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC121_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC121_ADGSPCR_PGS = 0x1
	// Operation is without group A priority control
	ADC121_ADGSPCR_PGS_0 = 0x0
	// Operation is with group A priority control
	ADC121_ADGSPCR_PGS_1 = 0x1

	// ADDBLDRA: A/D Data Duplication Register A
	// Position of ADDBLDRA field.
	ADC121_ADDBLDRA_ADDBLDRA_Pos = 0x0
	// Bit mask of ADDBLDRA field.
	ADC121_ADDBLDRA_ADDBLDRA_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplication Register B
	// Position of ADDBLDRB field.
	ADC121_ADDBLDRB_ADDBLDRB_Pos = 0x0
	// Bit mask of ADDBLDRB field.
	ADC121_ADDBLDRB_ADDBLDRB_Msk = 0xffff

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of MONCMPB field.
	ADC121_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC121_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC121_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC121_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC121_ADWINMON_MONCMPB_1 = 0x1
	// Position of MONCMPA field.
	ADC121_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC121_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC121_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC121_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC121_ADWINMON_MONCMPA_1 = 0x1
	// Position of MONCOMB field.
	ADC121_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC121_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC121_ADWINMON_MONCOMB = 0x1
	// Window A / window B composite conditions are not met.
	ADC121_ADWINMON_MONCOMB_0 = 0x0
	// Window A / window B composite conditions are met.
	ADC121_ADWINMON_MONCOMB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAIE field.
	ADC121_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC121_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC121_ADCMPCR_CMPAIE = 0x8000
	// S12ADCMPAIi interrupt is disabled when comparison conditions (window A) are met.
	ADC121_ADCMPCR_CMPAIE_0 = 0x0
	// S12ADCMPAIi interrupt is enabled when comparison conditions (window A) are met.
	ADC121_ADCMPCR_CMPAIE_1 = 0x1
	// Position of WCMPE field.
	ADC121_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC121_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC121_ADCMPCR_WCMPE = 0x4000
	// Window function is disabled. Window A and window B operate as a comparator to comparator the single value on the lower side with the A/D conversion result.
	ADC121_ADCMPCR_WCMPE_0 = 0x0
	// Window function is enabled. Window A and window B operate as a comparator to comparator the two values on the upper and lower sides with the A/D conversion result.
	ADC121_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPBIE field.
	ADC121_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC121_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC121_ADCMPCR_CMPBIE = 0x2000
	// S12ADCMPBIi interrupt is disabled when comparison conditions (window B) are met.
	ADC121_ADCMPCR_CMPBIE_0 = 0x0
	// S12ADCMPBIi interrupt is enabled when comparison conditions (window B) are met.
	ADC121_ADCMPCR_CMPBIE_1 = 0x1
	// Position of CMPAE field.
	ADC121_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC121_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC121_ADCMPCR_CMPAE = 0x800
	// Compare window A operation is disabled. S12ADWMELC and S12ADWUMELC outputs are disabled.
	ADC121_ADCMPCR_CMPAE_0 = 0x0
	// Compare window A operation is enabled.
	ADC121_ADCMPCR_CMPAE_1 = 0x1
	// Position of CMPBE field.
	ADC121_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC121_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC121_ADCMPCR_CMPBE = 0x200
	// Compare window B operation is disabled. S12ADWMELC and S12ADWUMELC outputs are disabled.
	ADC121_ADCMPCR_CMPBE_0 = 0x0
	// Compare window B operation is enabled.
	ADC121_ADCMPCR_CMPBE_1 = 0x1
	// Position of CMPAB field.
	ADC121_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC121_ADCMPCR_CMPAB_Msk = 0x3
	// S12ADWMELC is output when window A comparison conditions are met OR window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC121_ADCMPCR_CMPAB_00 = 0x0
	// S12ADWMELC is output when window A comparison conditions are met EXOR window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC121_ADCMPCR_CMPAB_01 = 0x1
	// S12ADWMELC is output when window A comparison conditions are met and window B comparison conditions are met. S12ADWUMELC is output in other cases.
	ADC121_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC121_ADCMPCR_CMPAB_11 = 0x3

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of CMPOCA field.
	ADC121_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC121_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC121_ADCMPANSER_CMPOCA = 0x2
	// Excludes the internal reference voltage from the compare window A target range.
	ADC121_ADCMPANSER_CMPOCA_0 = 0x0
	// Includes the internal reference voltage in the compare window A target range.
	ADC121_ADCMPANSER_CMPOCA_1 = 0x1
	// Position of CMPTSA field.
	ADC121_ADCMPANSER_CMPTSA_Pos = 0x0
	// Bit mask of CMPTSA field.
	ADC121_ADCMPANSER_CMPTSA_Msk = 0x1
	// Bit CMPTSA.
	ADC121_ADCMPANSER_CMPTSA = 0x1
	// Excludes the temperature sensor output from the compare window A target range.
	ADC121_ADCMPANSER_CMPTSA_0 = 0x0
	// Includes the temperature sensor output in the compare window A target range.
	ADC121_ADCMPANSER_CMPTSA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of CMPLOCA field.
	ADC121_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC121_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC121_ADCMPLER_CMPLOCA = 0x2
	// ADCMPDR0 value > A/D converted value(ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or A/D converted value > ADCMPDR1 value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLER_CMPLOCA_0 = 0x0
	// ADCMPDR0 value < A/D converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 value < A/D converted value < ADCMPDR1 value(ADCMPCR.WCMPE=1)
	ADC121_ADCMPLER_CMPLOCA_1 = 0x1
	// Position of CMPLTSA field.
	ADC121_ADCMPLER_CMPLTSA_Pos = 0x0
	// Bit mask of CMPLTSA field.
	ADC121_ADCMPLER_CMPLTSA_Msk = 0x1
	// Bit CMPLTSA.
	ADC121_ADCMPLER_CMPLTSA = 0x1
	// ADCMPDR0 register value > A/D-converted value(ADCMPCR.WCMPE=0) / AD-converted value < ADCMPDR0 register value or A/D-converted value > ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC121_ADCMPLER_CMPLTSA_0 = 0x0
	// ADCMPDR0 register value < A/D-converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 register value < A/D-converted value < ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC121_ADCMPLER_CMPLTSA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of CMPCHA05 field.
	ADC121_ADCMPANSR0_CMPCHA05_Pos = 0x5
	// Bit mask of CMPCHA05 field.
	ADC121_ADCMPANSR0_CMPCHA05_Msk = 0x20
	// Bit CMPCHA05.
	ADC121_ADCMPANSR0_CMPCHA05 = 0x20
	// Disable compare function for AN105
	ADC121_ADCMPANSR0_CMPCHA05_0 = 0x0
	// Enable compare function for AN105
	ADC121_ADCMPANSR0_CMPCHA05_1 = 0x1
	// Position of CMPCHA03 field.
	ADC121_ADCMPANSR0_CMPCHA03_Pos = 0x3
	// Bit mask of CMPCHA03 field.
	ADC121_ADCMPANSR0_CMPCHA03_Msk = 0x8
	// Bit CMPCHA03.
	ADC121_ADCMPANSR0_CMPCHA03 = 0x8
	// Disable compare function for AN103
	ADC121_ADCMPANSR0_CMPCHA03_0 = 0x0
	// Enable compare function for AN103
	ADC121_ADCMPANSR0_CMPCHA03_1 = 0x1
	// Position of CMPCHA02 field.
	ADC121_ADCMPANSR0_CMPCHA02_Pos = 0x2
	// Bit mask of CMPCHA02 field.
	ADC121_ADCMPANSR0_CMPCHA02_Msk = 0x4
	// Bit CMPCHA02.
	ADC121_ADCMPANSR0_CMPCHA02 = 0x4
	// Disable compare function for AN102
	ADC121_ADCMPANSR0_CMPCHA02_0 = 0x0
	// Enable compare function for AN102
	ADC121_ADCMPANSR0_CMPCHA02_1 = 0x1
	// Position of CMPCHA01 field.
	ADC121_ADCMPANSR0_CMPCHA01_Pos = 0x1
	// Bit mask of CMPCHA01 field.
	ADC121_ADCMPANSR0_CMPCHA01_Msk = 0x2
	// Bit CMPCHA01.
	ADC121_ADCMPANSR0_CMPCHA01 = 0x2
	// Disable compare function for AN101
	ADC121_ADCMPANSR0_CMPCHA01_0 = 0x0
	// Enable compare function for AN101
	ADC121_ADCMPANSR0_CMPCHA01_1 = 0x1
	// Position of CMPCHA00 field.
	ADC121_ADCMPANSR0_CMPCHA00_Pos = 0x0
	// Bit mask of CMPCHA00 field.
	ADC121_ADCMPANSR0_CMPCHA00_Msk = 0x1
	// Bit CMPCHA00.
	ADC121_ADCMPANSR0_CMPCHA00 = 0x1
	// Disable compare function for AN100
	ADC121_ADCMPANSR0_CMPCHA00_0 = 0x0
	// Enable compare function for AN100
	ADC121_ADCMPANSR0_CMPCHA00_1 = 0x1

	// ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
	// Position of CMPCHA20 field.
	ADC121_ADCMPANSR1_CMPCHA20_Pos = 0x4
	// Bit mask of CMPCHA20 field.
	ADC121_ADCMPANSR1_CMPCHA20_Msk = 0x10
	// Bit CMPCHA20.
	ADC121_ADCMPANSR1_CMPCHA20 = 0x10
	// Excludes AN120 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA20_0 = 0x0
	// Includes AN120 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA20_1 = 0x1
	// Position of CMPCHA19 field.
	ADC121_ADCMPANSR1_CMPCHA19_Pos = 0x3
	// Bit mask of CMPCHA19 field.
	ADC121_ADCMPANSR1_CMPCHA19_Msk = 0x8
	// Bit CMPCHA19.
	ADC121_ADCMPANSR1_CMPCHA19 = 0x8
	// Excludes AN119 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA19_0 = 0x0
	// Includes AN119 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA19_1 = 0x1
	// Position of CMPCHA18 field.
	ADC121_ADCMPANSR1_CMPCHA18_Pos = 0x2
	// Bit mask of CMPCHA18 field.
	ADC121_ADCMPANSR1_CMPCHA18_Msk = 0x4
	// Bit CMPCHA18.
	ADC121_ADCMPANSR1_CMPCHA18 = 0x4
	// Excludes AN118 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA18_0 = 0x0
	// Includes AN118 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA18_1 = 0x1
	// Position of CMPCHA17 field.
	ADC121_ADCMPANSR1_CMPCHA17_Pos = 0x1
	// Bit mask of CMPCHA17 field.
	ADC121_ADCMPANSR1_CMPCHA17_Msk = 0x2
	// Bit CMPCHA17.
	ADC121_ADCMPANSR1_CMPCHA17 = 0x2
	// Excludes AN117 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA17_0 = 0x0
	// Includes AN117 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA17_1 = 0x1
	// Position of CMPCHA16 field.
	ADC121_ADCMPANSR1_CMPCHA16_Pos = 0x0
	// Bit mask of CMPCHA16 field.
	ADC121_ADCMPANSR1_CMPCHA16_Msk = 0x1
	// Bit CMPCHA16.
	ADC121_ADCMPANSR1_CMPCHA16 = 0x1
	// Excludes AN116 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA16_0 = 0x0
	// Includes AN116 from the compare window A target range.
	ADC121_ADCMPANSR1_CMPCHA16_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of CMPLCHA07 field.
	ADC121_ADCMPLR0_CMPLCHA07_Pos = 0x7
	// Bit mask of CMPLCHA07 field.
	ADC121_ADCMPLR0_CMPLCHA07_Msk = 0x80
	// Bit CMPLCHA07.
	ADC121_ADCMPLR0_CMPLCHA07 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA07_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA07_1 = 0x1
	// Position of CMPLCHA06 field.
	ADC121_ADCMPLR0_CMPLCHA06_Pos = 0x6
	// Bit mask of CMPLCHA06 field.
	ADC121_ADCMPLR0_CMPLCHA06_Msk = 0x40
	// Bit CMPLCHA06.
	ADC121_ADCMPLR0_CMPLCHA06 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA06_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA06_1 = 0x1
	// Position of CMPLCHA05 field.
	ADC121_ADCMPLR0_CMPLCHA05_Pos = 0x5
	// Bit mask of CMPLCHA05 field.
	ADC121_ADCMPLR0_CMPLCHA05_Msk = 0x20
	// Bit CMPLCHA05.
	ADC121_ADCMPLR0_CMPLCHA05 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA05_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA05_1 = 0x1
	// Position of CMPLCHA03 field.
	ADC121_ADCMPLR0_CMPLCHA03_Pos = 0x3
	// Bit mask of CMPLCHA03 field.
	ADC121_ADCMPLR0_CMPLCHA03_Msk = 0x8
	// Bit CMPLCHA03.
	ADC121_ADCMPLR0_CMPLCHA03 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA03_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA03_1 = 0x1
	// Position of CMPLCHA02 field.
	ADC121_ADCMPLR0_CMPLCHA02_Pos = 0x2
	// Bit mask of CMPLCHA02 field.
	ADC121_ADCMPLR0_CMPLCHA02_Msk = 0x4
	// Bit CMPLCHA02.
	ADC121_ADCMPLR0_CMPLCHA02 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA02_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA02_1 = 0x1
	// Position of CMPLCHA01 field.
	ADC121_ADCMPLR0_CMPLCHA01_Pos = 0x1
	// Bit mask of CMPLCHA01 field.
	ADC121_ADCMPLR0_CMPLCHA01_Msk = 0x2
	// Bit CMPLCHA01.
	ADC121_ADCMPLR0_CMPLCHA01 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA01_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA01_1 = 0x1
	// Position of CMPLCHA00 field.
	ADC121_ADCMPLR0_CMPLCHA00_Pos = 0x0
	// Bit mask of CMPLCHA00 field.
	ADC121_ADCMPLR0_CMPLCHA00_Msk = 0x1
	// Bit CMPLCHA00.
	ADC121_ADCMPLR0_CMPLCHA00 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR0_CMPLCHA00_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR0_CMPLCHA00_1 = 0x1

	// ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
	// Position of CMPLCHA19 field.
	ADC121_ADCMPLR1_CMPLCHA19_Pos = 0x3
	// Bit mask of CMPLCHA19 field.
	ADC121_ADCMPLR1_CMPLCHA19_Msk = 0x8
	// Bit CMPLCHA19.
	ADC121_ADCMPLR1_CMPLCHA19 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR1_CMPLCHA19_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR1_CMPLCHA19_1 = 0x1
	// Position of CMPLCHA18 field.
	ADC121_ADCMPLR1_CMPLCHA18_Pos = 0x2
	// Bit mask of CMPLCHA18 field.
	ADC121_ADCMPLR1_CMPLCHA18_Msk = 0x4
	// Bit CMPLCHA18.
	ADC121_ADCMPLR1_CMPLCHA18 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR1_CMPLCHA18_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR1_CMPLCHA18_1 = 0x1
	// Position of CMPLCHA17 field.
	ADC121_ADCMPLR1_CMPLCHA17_Pos = 0x1
	// Bit mask of CMPLCHA17 field.
	ADC121_ADCMPLR1_CMPLCHA17_Msk = 0x2
	// Bit CMPLCHA17.
	ADC121_ADCMPLR1_CMPLCHA17 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR1_CMPLCHA17_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR1_CMPLCHA17_1 = 0x1
	// Position of CMPLCHA16 field.
	ADC121_ADCMPLR1_CMPLCHA16_Pos = 0x0
	// Bit mask of CMPLCHA16 field.
	ADC121_ADCMPLR1_CMPLCHA16_Msk = 0x1
	// Bit CMPLCHA16.
	ADC121_ADCMPLR1_CMPLCHA16 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPLR1_CMPLCHA16_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC121_ADCMPLR1_CMPLCHA16_1 = 0x1

	// ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
	// Position of ADCMPDR0 field.
	ADC121_ADCMPDR0_ADCMPDR0_Pos = 0x0
	// Bit mask of ADCMPDR0 field.
	ADC121_ADCMPDR0_ADCMPDR0_Msk = 0xffff

	// ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
	// Position of ADCMPDR1 field.
	ADC121_ADCMPDR1_ADCMPDR1_Pos = 0x0
	// Bit mask of ADCMPDR1 field.
	ADC121_ADCMPDR1_ADCMPDR1_Msk = 0xffff

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of CMPSTCHA07 field.
	ADC121_ADCMPSR0_CMPSTCHA07_Pos = 0x7
	// Bit mask of CMPSTCHA07 field.
	ADC121_ADCMPSR0_CMPSTCHA07_Msk = 0x80
	// Bit CMPSTCHA07.
	ADC121_ADCMPSR0_CMPSTCHA07 = 0x80
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA07_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA07_1 = 0x1
	// Position of CMPSTCHA06 field.
	ADC121_ADCMPSR0_CMPSTCHA06_Pos = 0x6
	// Bit mask of CMPSTCHA06 field.
	ADC121_ADCMPSR0_CMPSTCHA06_Msk = 0x40
	// Bit CMPSTCHA06.
	ADC121_ADCMPSR0_CMPSTCHA06 = 0x40
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA06_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA06_1 = 0x1
	// Position of CMPSTCHA05 field.
	ADC121_ADCMPSR0_CMPSTCHA05_Pos = 0x5
	// Bit mask of CMPSTCHA05 field.
	ADC121_ADCMPSR0_CMPSTCHA05_Msk = 0x20
	// Bit CMPSTCHA05.
	ADC121_ADCMPSR0_CMPSTCHA05 = 0x20
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA05_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA05_1 = 0x1
	// Position of CMPSTCHA03 field.
	ADC121_ADCMPSR0_CMPSTCHA03_Pos = 0x3
	// Bit mask of CMPSTCHA03 field.
	ADC121_ADCMPSR0_CMPSTCHA03_Msk = 0x8
	// Bit CMPSTCHA03.
	ADC121_ADCMPSR0_CMPSTCHA03 = 0x8
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA03_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA03_1 = 0x1
	// Position of CMPSTCHA02 field.
	ADC121_ADCMPSR0_CMPSTCHA02_Pos = 0x2
	// Bit mask of CMPSTCHA02 field.
	ADC121_ADCMPSR0_CMPSTCHA02_Msk = 0x4
	// Bit CMPSTCHA02.
	ADC121_ADCMPSR0_CMPSTCHA02 = 0x4
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA02_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA02_1 = 0x1
	// Position of CMPSTCHA01 field.
	ADC121_ADCMPSR0_CMPSTCHA01_Pos = 0x1
	// Bit mask of CMPSTCHA01 field.
	ADC121_ADCMPSR0_CMPSTCHA01_Msk = 0x2
	// Bit CMPSTCHA01.
	ADC121_ADCMPSR0_CMPSTCHA01 = 0x2
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA01_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA01_1 = 0x1
	// Position of CMPSTCHA00 field.
	ADC121_ADCMPSR0_CMPSTCHA00_Pos = 0x0
	// Bit mask of CMPSTCHA00 field.
	ADC121_ADCMPSR0_CMPSTCHA00_Msk = 0x1
	// Bit CMPSTCHA00.
	ADC121_ADCMPSR0_CMPSTCHA00 = 0x1
	// Comparison conditions are not met.
	ADC121_ADCMPSR0_CMPSTCHA00_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR0_CMPSTCHA00_1 = 0x1

	// ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
	// Position of CMPSTCHA19 field.
	ADC121_ADCMPSR1_CMPSTCHA19_Pos = 0x3
	// Bit mask of CMPSTCHA19 field.
	ADC121_ADCMPSR1_CMPSTCHA19_Msk = 0x8
	// Bit CMPSTCHA19.
	ADC121_ADCMPSR1_CMPSTCHA19 = 0x8
	// Comparison conditions are not met.
	ADC121_ADCMPSR1_CMPSTCHA19_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR1_CMPSTCHA19_1 = 0x1
	// Position of CMPSTCHA18 field.
	ADC121_ADCMPSR1_CMPSTCHA18_Pos = 0x2
	// Bit mask of CMPSTCHA18 field.
	ADC121_ADCMPSR1_CMPSTCHA18_Msk = 0x4
	// Bit CMPSTCHA18.
	ADC121_ADCMPSR1_CMPSTCHA18 = 0x4
	// Comparison conditions are not met.
	ADC121_ADCMPSR1_CMPSTCHA18_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR1_CMPSTCHA18_1 = 0x1
	// Position of CMPSTCHA17 field.
	ADC121_ADCMPSR1_CMPSTCHA17_Pos = 0x1
	// Bit mask of CMPSTCHA17 field.
	ADC121_ADCMPSR1_CMPSTCHA17_Msk = 0x2
	// Bit CMPSTCHA17.
	ADC121_ADCMPSR1_CMPSTCHA17 = 0x2
	// Comparison conditions are not met.
	ADC121_ADCMPSR1_CMPSTCHA17_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR1_CMPSTCHA17_1 = 0x1
	// Position of CMPSTCHA16 field.
	ADC121_ADCMPSR1_CMPSTCHA16_Pos = 0x0
	// Bit mask of CMPSTCHA16 field.
	ADC121_ADCMPSR1_CMPSTCHA16_Msk = 0x1
	// Bit CMPSTCHA16.
	ADC121_ADCMPSR1_CMPSTCHA16 = 0x1
	// Comparison conditions are not met.
	ADC121_ADCMPSR1_CMPSTCHA16_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSR1_CMPSTCHA16_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of CMPSTOCA field.
	ADC121_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC121_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC121_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC121_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSER_CMPSTOCA_1 = 0x1
	// Position of CMPSTTSA field.
	ADC121_ADCMPSER_CMPSTTSA_Pos = 0x0
	// Bit mask of CMPSTTSA field.
	ADC121_ADCMPSER_CMPSTTSA_Msk = 0x1
	// Bit CMPSTTSA.
	ADC121_ADCMPSER_CMPSTTSA = 0x1
	// Comparison conditions are not met.
	ADC121_ADCMPSER_CMPSTTSA_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPSER_CMPSTTSA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
	// Position of CMPLB field.
	ADC121_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC121_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC121_ADCMPBNSR_CMPLB = 0x80
	// CMPLLB value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < CMPLLB value or CMPULB value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPBNSR_CMPLB_0 = 0x0
	// CMPLLB value < A/D converted value(ADCMPCR.WCMPE=0) / CMPLLB value < A/D converted value < CMPULB value (ADCMPCR.WCMPE=1)
	ADC121_ADCMPBNSR_CMPLB_1 = 0x1
	// Position of CMPCHB field.
	ADC121_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC121_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// AN100
	ADC121_ADCMPBNSR_CMPCHB_0x00 = 0x0
	// AN101
	ADC121_ADCMPBNSR_CMPCHB_0x01 = 0x1
	// AN102
	ADC121_ADCMPBNSR_CMPCHB_0x02 = 0x2
	// AN103
	ADC121_ADCMPBNSR_CMPCHB_0x03 = 0x3
	// AN105
	ADC121_ADCMPBNSR_CMPCHB_0x05 = 0x5
	// AN106
	ADC121_ADCMPBNSR_CMPCHB_0x06 = 0x6
	// AN107
	ADC121_ADCMPBNSR_CMPCHB_0x07 = 0x7
	// AN116
	ADC121_ADCMPBNSR_CMPCHB_0x10 = 0x10
	// AN117
	ADC121_ADCMPBNSR_CMPCHB_0x11 = 0x11
	// AN118
	ADC121_ADCMPBNSR_CMPCHB_0x12 = 0x12
	// AN119
	ADC121_ADCMPBNSR_CMPCHB_0x13 = 0x13
	// Temperature sensor
	ADC121_ADCMPBNSR_CMPCHB_0x20 = 0x20
	// Internal reference voltage
	ADC121_ADCMPBNSR_CMPCHB_0x21 = 0x21
	// No channel is selected
	ADC121_ADCMPBNSR_CMPCHB_0x3F = 0x3f

	// ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
	// Position of ADWINLLB field.
	ADC121_ADWINLLB_ADWINLLB_Pos = 0x0
	// Bit mask of ADWINLLB field.
	ADC121_ADWINLLB_ADWINLLB_Msk = 0xffff

	// ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
	// Position of ADWINULB field.
	ADC121_ADWINULB_ADWINULB_Pos = 0x0
	// Bit mask of ADWINULB field.
	ADC121_ADWINULB_ADWINULB_Msk = 0xffff

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of CMPSTB field.
	ADC121_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC121_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC121_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC121_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC121_ADCMPBSR_CMPSTB_1 = 0x1

	// ADSSTRL: A/D Sampling State Register L
	// Position of SST field.
	ADC121_ADSSTRL_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC121_ADSSTRL_SST_Msk = 0xff

	// ADSSTRT: A/D Sampling State Register T
	// Position of SST field.
	ADC121_ADSSTRT_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC121_ADSSTRT_SST_Msk = 0xff

	// ADSSTRO: A/D Sampling State Register O
	// Position of SST field.
	ADC121_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC121_ADSSTRO_SST_Msk = 0xff

	// ADSSTR00: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
	// Position of SST field.
	ADC121_ADSSTR0_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC121_ADSSTR0_SST_Msk = 0xff

	// ADSSTR05: A/D Sampling State Register %s (Corresponding Channel is AN10%s )
	// Position of SST field.
	ADC121_ADSSTR0_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC121_ADSSTR0_SST_Msk = 0xff

	// ADPGACR: A/D Programmable Gain Amplifier Control Register
	// Position of P002GEN field.
	ADC121_ADPGACR_P002GEN_Pos = 0xb
	// Bit mask of P002GEN field.
	ADC121_ADPGACR_P002GEN_Msk = 0x800
	// Bit P002GEN.
	ADC121_ADPGACR_P002GEN = 0x800
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC121_ADPGACR_P002GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC121_ADPGACR_P002GEN_1 = 0x1
	// Position of P002ENAMP field.
	ADC121_ADPGACR_P002ENAMP_Pos = 0xa
	// Bit mask of P002ENAMP field.
	ADC121_ADPGACR_P002ENAMP_Msk = 0x400
	// Bit P002ENAMP.
	ADC121_ADPGACR_P002ENAMP = 0x400
	// The amplifier in PGA is not used.
	ADC121_ADPGACR_P002ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC121_ADPGACR_P002ENAMP_1 = 0x1
	// Position of P002SEL1 field.
	ADC121_ADPGACR_P002SEL1_Pos = 0x9
	// Bit mask of P002SEL1 field.
	ADC121_ADPGACR_P002SEL1_Msk = 0x200
	// Bit P002SEL1.
	ADC121_ADPGACR_P002SEL1 = 0x200
	// By way of the amplifier in PGA.
	ADC121_ADPGACR_P002SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC121_ADPGACR_P002SEL1_1 = 0x1
	// Position of P002SEL0 field.
	ADC121_ADPGACR_P002SEL0_Pos = 0x8
	// Bit mask of P002SEL0 field.
	ADC121_ADPGACR_P002SEL0_Msk = 0x100
	// Bit P002SEL0.
	ADC121_ADPGACR_P002SEL0 = 0x100
	// Not through the PGA in amplifier
	ADC121_ADPGACR_P002SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC121_ADPGACR_P002SEL0_1 = 0x1
	// Position of P001GEN field.
	ADC121_ADPGACR_P001GEN_Pos = 0x7
	// Bit mask of P001GEN field.
	ADC121_ADPGACR_P001GEN_Msk = 0x80
	// Bit P001GEN.
	ADC121_ADPGACR_P001GEN = 0x80
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC121_ADPGACR_P001GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC121_ADPGACR_P001GEN_1 = 0x1
	// Position of P001ENAMP field.
	ADC121_ADPGACR_P001ENAMP_Pos = 0x6
	// Bit mask of P001ENAMP field.
	ADC121_ADPGACR_P001ENAMP_Msk = 0x40
	// Bit P001ENAMP.
	ADC121_ADPGACR_P001ENAMP = 0x40
	// The amplifier in PGA is not used.
	ADC121_ADPGACR_P001ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC121_ADPGACR_P001ENAMP_1 = 0x1
	// Position of P001SEL1 field.
	ADC121_ADPGACR_P001SEL1_Pos = 0x5
	// Bit mask of P001SEL1 field.
	ADC121_ADPGACR_P001SEL1_Msk = 0x20
	// Bit P001SEL1.
	ADC121_ADPGACR_P001SEL1 = 0x20
	// By way of the amplifier in PGA.
	ADC121_ADPGACR_P001SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC121_ADPGACR_P001SEL1_1 = 0x1
	// Position of P001SEL0 field.
	ADC121_ADPGACR_P001SEL0_Pos = 0x4
	// Bit mask of P001SEL0 field.
	ADC121_ADPGACR_P001SEL0_Msk = 0x10
	// Bit P001SEL0.
	ADC121_ADPGACR_P001SEL0 = 0x10
	// Not through the PGA in amplifier
	ADC121_ADPGACR_P001SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC121_ADPGACR_P001SEL0_1 = 0x1
	// Position of P000GEN field.
	ADC121_ADPGACR_P000GEN_Pos = 0x3
	// Bit mask of P000GEN field.
	ADC121_ADPGACR_P000GEN_Msk = 0x8
	// Bit P000GEN.
	ADC121_ADPGACR_P000GEN = 0x8
	// The gain setting is invalidated (AIN is not input in PGA).
	ADC121_ADPGACR_P000GEN_0 = 0x0
	// The gain setting is effectively done (AIN is input in PGA).
	ADC121_ADPGACR_P000GEN_1 = 0x1
	// Position of P000ENAMP field.
	ADC121_ADPGACR_P000ENAMP_Pos = 0x2
	// Bit mask of P000ENAMP field.
	ADC121_ADPGACR_P000ENAMP_Msk = 0x4
	// Bit P000ENAMP.
	ADC121_ADPGACR_P000ENAMP = 0x4
	// The amplifier in PGA is not used.
	ADC121_ADPGACR_P000ENAMP_0 = 0x0
	// The amplifier in PGA is used.
	ADC121_ADPGACR_P000ENAMP_1 = 0x1
	// Position of P000SEL1 field.
	ADC121_ADPGACR_P000SEL1_Pos = 0x1
	// Bit mask of P000SEL1 field.
	ADC121_ADPGACR_P000SEL1_Msk = 0x2
	// Bit P000SEL1.
	ADC121_ADPGACR_P000SEL1 = 0x2
	// By way of the amplifier in PGA.
	ADC121_ADPGACR_P000SEL1_0 = 0x0
	// Note 1 that by way of amplifier in PGA
	ADC121_ADPGACR_P000SEL1_1 = 0x1
	// Position of P000SEL0 field.
	ADC121_ADPGACR_P000SEL0_Pos = 0x0
	// Bit mask of P000SEL0 field.
	ADC121_ADPGACR_P000SEL0_Msk = 0x1
	// Bit P000SEL0.
	ADC121_ADPGACR_P000SEL0 = 0x1
	// Not through the PGA in amplifier
	ADC121_ADPGACR_P000SEL0_0 = 0x0
	// I will through in the PGA amplifier.
	ADC121_ADPGACR_P000SEL0_1 = 0x1

	// ADPGAGS0: A/D Programmable Gain Amplifier Gain Setting Register 0
	// Position of P002GAIN field.
	ADC121_ADPGAGS0_P002GAIN_Pos = 0x8
	// Bit mask of P002GAIN field.
	ADC121_ADPGAGS0_P002GAIN_Msk = 0xf00
	// x 2.000 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P002DEN=0) / x 1.500 (ADPGADDCR0.P002DEN=1)
	ADC121_ADPGAGS0_P002GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P002DEN=0) / x 2.333 (ADPGADDCR0.P002DEN=1)
	ADC121_ADPGAGS0_P002GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P002DEN=0) / x 4.00 (ADPGADDCR0.P002DEN=1)
	ADC121_ADPGAGS0_P002GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P002DEN=0) / x 5.667 (ADPGADDCR0.P002DEN=1)
	ADC121_ADPGAGS0_P002GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P002DEN=0)
	ADC121_ADPGAGS0_P002GAIN_1111 = 0xf
	// Position of P001GAIN field.
	ADC121_ADPGAGS0_P001GAIN_Pos = 0x4
	// Bit mask of P001GAIN field.
	ADC121_ADPGAGS0_P001GAIN_Msk = 0xf0
	// x 2.000 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P001DEN=0) / x 1.500 (ADPGADDCR0.P001DEN=1)
	ADC121_ADPGAGS0_P001GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P001DEN=0) / x 2.333 (ADPGADDCR0.P001DEN=1)
	ADC121_ADPGAGS0_P001GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P001DEN=0) / x 4.00 (ADPGADDCR0.P001DEN=1)
	ADC121_ADPGAGS0_P001GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P001DEN=0) / x 5.667 (ADPGADDCR0.P001DEN=1)
	ADC121_ADPGAGS0_P001GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P001DEN=0)
	ADC121_ADPGAGS0_P001GAIN_1111 = 0xf
	// Position of P000GAIN field.
	ADC121_ADPGAGS0_P000GAIN_Pos = 0x0
	// Bit mask of P000GAIN field.
	ADC121_ADPGAGS0_P000GAIN_Msk = 0xf
	// x 2.000 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0000 = 0x0
	// x 2.500 (ADPGADDCR0.P000DEN=0) / x 1.500 (ADPGADDCR0.P000DEN=1)
	ADC121_ADPGAGS0_P000GAIN_0001 = 0x1
	// x 2.667 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0010 = 0x2
	// x 2.857 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0011 = 0x3
	// x 3.077 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0100 = 0x4
	// x 3.333 (ADPGADDCR0.P000DEN=0) / x 2.333 (ADPGADDCR0.P000DEN=1)
	ADC121_ADPGAGS0_P000GAIN_0101 = 0x5
	// x 3.636 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0110 = 0x6
	// x 4.000 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_0111 = 0x7
	// x 4.444 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1000 = 0x8
	// x 5.000 (ADPGADDCR0.P000DEN=0) / x 4.00 (ADPGADDCR0.P000DEN=1)
	ADC121_ADPGAGS0_P000GAIN_1001 = 0x9
	// x 5.714 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1010 = 0xa
	// x 6.667 (ADPGADDCR0.P000DEN=0) / x 5.667 (ADPGADDCR0.P000DEN=1)
	ADC121_ADPGAGS0_P000GAIN_1011 = 0xb
	// x 8.000 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1100 = 0xc
	// x 10.000 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1101 = 0xd
	// x 13.333 (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1110 = 0xe
	// x 1.000 (for offset measurement) (ADPGADDCR0.P000DEN=0)
	ADC121_ADPGAGS0_P000GAIN_1111 = 0xf

	// ADPGADCR0: A/D Programmable Gain Amplifier Differential Input Control Register
	// Position of P003DG field.
	ADC121_ADPGADCR0_P003DG_Pos = 0xc
	// Bit mask of P003DG field.
	ADC121_ADPGADCR0_P003DG_Msk = 0x3000
	// x 1.5
	ADC121_ADPGADCR0_P003DG_00 = 0x0
	// x 2.333
	ADC121_ADPGADCR0_P003DG_01 = 0x1
	// x 4.0
	ADC121_ADPGADCR0_P003DG_10 = 0x2
	// x 5.667
	ADC121_ADPGADCR0_P003DG_11 = 0x3
	// Position of P002DEN field.
	ADC121_ADPGADCR0_P002DEN_Pos = 0xb
	// Bit mask of P002DEN field.
	ADC121_ADPGADCR0_P002DEN_Msk = 0x800
	// Bit P002DEN.
	ADC121_ADPGADCR0_P002DEN = 0x800
	// Differential input is disabled.
	ADC121_ADPGADCR0_P002DEN_0 = 0x0
	// Differential input is enabled.
	ADC121_ADPGADCR0_P002DEN_1 = 0x1
	// Position of P002DG field.
	ADC121_ADPGADCR0_P002DG_Pos = 0x8
	// Bit mask of P002DG field.
	ADC121_ADPGADCR0_P002DG_Msk = 0x300
	// x 1.5
	ADC121_ADPGADCR0_P002DG_00 = 0x0
	// x 2.333
	ADC121_ADPGADCR0_P002DG_01 = 0x1
	// x 4.0
	ADC121_ADPGADCR0_P002DG_10 = 0x2
	// x 5.667
	ADC121_ADPGADCR0_P002DG_11 = 0x3
	// Position of P001DEN field.
	ADC121_ADPGADCR0_P001DEN_Pos = 0x7
	// Bit mask of P001DEN field.
	ADC121_ADPGADCR0_P001DEN_Msk = 0x80
	// Bit P001DEN.
	ADC121_ADPGADCR0_P001DEN = 0x80
	// Differential input is disabled.
	ADC121_ADPGADCR0_P001DEN_0 = 0x0
	// Differential input is enabled.
	ADC121_ADPGADCR0_P001DEN_1 = 0x1
	// Position of P001DG field.
	ADC121_ADPGADCR0_P001DG_Pos = 0x4
	// Bit mask of P001DG field.
	ADC121_ADPGADCR0_P001DG_Msk = 0x30
	// x 1.5
	ADC121_ADPGADCR0_P001DG_00 = 0x0
	// x 2.333
	ADC121_ADPGADCR0_P001DG_01 = 0x1
	// x 4.0
	ADC121_ADPGADCR0_P001DG_10 = 0x2
	// x 5.667
	ADC121_ADPGADCR0_P001DG_11 = 0x3
	// Position of P000DEN field.
	ADC121_ADPGADCR0_P000DEN_Pos = 0x3
	// Bit mask of P000DEN field.
	ADC121_ADPGADCR0_P000DEN_Msk = 0x8
	// Bit P000DEN.
	ADC121_ADPGADCR0_P000DEN = 0x8
	// Differential input is disabled.
	ADC121_ADPGADCR0_P000DEN_0 = 0x0
	// Differential input is enabled.
	ADC121_ADPGADCR0_P000DEN_1 = 0x1
	// Position of P000DG field.
	ADC121_ADPGADCR0_P000DG_Pos = 0x0
	// Bit mask of P000DG field.
	ADC121_ADPGADCR0_P000DG_Msk = 0x3
	// x 1.5
	ADC121_ADPGADCR0_P000DG_00 = 0x0
	// x 2.333
	ADC121_ADPGADCR0_P000DG_01 = 0x1
	// x 4.0
	ADC121_ADPGADCR0_P000DG_10 = 0x2
	// x 5.667
	ADC121_ADPGADCR0_P000DG_11 = 0x3
)

// Constants for MSTP: Module Stop Control B,C,D
const (
	// MSTPCRB: Module Stop Control Register B
	// Position of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Pos = 0x1f
	// Bit mask of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Msk = 0x80000000
	// Bit MSTPB31.
	MSTP_MSTPCRB_MSTPB31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB31_1 = 0x1
	// Position of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Pos = 0x1e
	// Bit mask of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Msk = 0x40000000
	// Bit MSTPB30.
	MSTP_MSTPCRB_MSTPB30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB30_1 = 0x1
	// Position of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Pos = 0x1d
	// Bit mask of MSTPB29 field.
	MSTP_MSTPCRB_MSTPB29_Msk = 0x20000000
	// Bit MSTPB29.
	MSTP_MSTPCRB_MSTPB29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB29_1 = 0x1
	// Position of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Pos = 0x1c
	// Bit mask of MSTPB28 field.
	MSTP_MSTPCRB_MSTPB28_Msk = 0x10000000
	// Bit MSTPB28.
	MSTP_MSTPCRB_MSTPB28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB28_1 = 0x1
	// Position of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Pos = 0x1b
	// Bit mask of MSTPB27 field.
	MSTP_MSTPCRB_MSTPB27_Msk = 0x8000000
	// Bit MSTPB27.
	MSTP_MSTPCRB_MSTPB27 = 0x8000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB27_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB27_1 = 0x1
	// Position of MSTPB26 field.
	MSTP_MSTPCRB_MSTPB26_Pos = 0x1a
	// Bit mask of MSTPB26 field.
	MSTP_MSTPCRB_MSTPB26_Msk = 0x4000000
	// Bit MSTPB26.
	MSTP_MSTPCRB_MSTPB26 = 0x4000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB26_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB26_1 = 0x1
	// Position of MSTPB25 field.
	MSTP_MSTPCRB_MSTPB25_Pos = 0x19
	// Bit mask of MSTPB25 field.
	MSTP_MSTPCRB_MSTPB25_Msk = 0x2000000
	// Bit MSTPB25.
	MSTP_MSTPCRB_MSTPB25 = 0x2000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB25_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB25_1 = 0x1
	// Position of MSTPB24 field.
	MSTP_MSTPCRB_MSTPB24_Pos = 0x18
	// Bit mask of MSTPB24 field.
	MSTP_MSTPCRB_MSTPB24_Msk = 0x1000000
	// Bit MSTPB24.
	MSTP_MSTPCRB_MSTPB24 = 0x1000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB24_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB24_1 = 0x1
	// Position of MSTPB23 field.
	MSTP_MSTPCRB_MSTPB23_Pos = 0x17
	// Bit mask of MSTPB23 field.
	MSTP_MSTPCRB_MSTPB23_Msk = 0x800000
	// Bit MSTPB23.
	MSTP_MSTPCRB_MSTPB23 = 0x800000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB23_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB23_1 = 0x1
	// Position of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Pos = 0x16
	// Bit mask of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Msk = 0x400000
	// Bit MSTPB22.
	MSTP_MSTPCRB_MSTPB22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB22_1 = 0x1
	// Position of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Pos = 0x13
	// Bit mask of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Msk = 0x80000
	// Bit MSTPB19.
	MSTP_MSTPCRB_MSTPB19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB19_1 = 0x1
	// Position of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Pos = 0x12
	// Bit mask of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Msk = 0x40000
	// Bit MSTPB18.
	MSTP_MSTPCRB_MSTPB18 = 0x40000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB18_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB18_1 = 0x1
	// Position of MSTPB15 field.
	MSTP_MSTPCRB_MSTPB15_Pos = 0xf
	// Bit mask of MSTPB15 field.
	MSTP_MSTPCRB_MSTPB15_Msk = 0x8000
	// Bit MSTPB15.
	MSTP_MSTPCRB_MSTPB15 = 0x8000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB15_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB15_1 = 0x1
	// Position of MSTPB13 field.
	MSTP_MSTPCRB_MSTPB13_Pos = 0xd
	// Bit mask of MSTPB13 field.
	MSTP_MSTPCRB_MSTPB13_Msk = 0x2000
	// Bit MSTPB13.
	MSTP_MSTPCRB_MSTPB13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB13_1 = 0x1
	// Position of MSTPB12 field.
	MSTP_MSTPCRB_MSTPB12_Pos = 0xc
	// Bit mask of MSTPB12 field.
	MSTP_MSTPCRB_MSTPB12_Msk = 0x1000
	// Bit MSTPB12.
	MSTP_MSTPCRB_MSTPB12 = 0x1000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB12_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB12_1 = 0x1
	// Position of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Pos = 0xb
	// Bit mask of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Msk = 0x800
	// Bit MSTPB11.
	MSTP_MSTPCRB_MSTPB11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB11_1 = 0x1
	// Position of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Pos = 0x9
	// Bit mask of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Msk = 0x200
	// Bit MSTPB9.
	MSTP_MSTPCRB_MSTPB9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB9_1 = 0x1
	// Position of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Pos = 0x8
	// Bit mask of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Msk = 0x100
	// Bit MSTPB8.
	MSTP_MSTPCRB_MSTPB8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB8_1 = 0x1
	// Position of MSTPB7 field.
	MSTP_MSTPCRB_MSTPB7_Pos = 0x7
	// Bit mask of MSTPB7 field.
	MSTP_MSTPCRB_MSTPB7_Msk = 0x80
	// Bit MSTPB7.
	MSTP_MSTPCRB_MSTPB7 = 0x80
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB7_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB7_1 = 0x1
	// Position of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Pos = 0x6
	// Bit mask of MSTPB6 field.
	MSTP_MSTPCRB_MSTPB6_Msk = 0x40
	// Bit MSTPB6.
	MSTP_MSTPCRB_MSTPB6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB6_1 = 0x1
	// Position of MSTPB5 field.
	MSTP_MSTPCRB_MSTPB5_Pos = 0x5
	// Bit mask of MSTPB5 field.
	MSTP_MSTPCRB_MSTPB5_Msk = 0x20
	// Bit MSTPB5.
	MSTP_MSTPCRB_MSTPB5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB5_1 = 0x1
	// Position of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Pos = 0x2
	// Bit mask of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Msk = 0x4
	// Bit MSTPB2.
	MSTP_MSTPCRB_MSTPB2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB2_1 = 0x1
	// Position of MSTPB1 field.
	MSTP_MSTPCRB_MSTPB1_Pos = 0x1
	// Bit mask of MSTPB1 field.
	MSTP_MSTPCRB_MSTPB1_Msk = 0x2
	// Bit MSTPB1.
	MSTP_MSTPCRB_MSTPB1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB1_1 = 0x1

	// MSTPCRC: Module Stop Control Register C
	// Position of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Pos = 0x1f
	// Bit mask of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Msk = 0x80000000
	// Bit MSTPC31.
	MSTP_MSTPCRC_MSTPC31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC31_1 = 0x1
	// Position of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Pos = 0xe
	// Bit mask of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Msk = 0x4000
	// Bit MSTPC14.
	MSTP_MSTPCRC_MSTPC14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC14_1 = 0x1
	// Position of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Pos = 0xd
	// Bit mask of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Msk = 0x2000
	// Bit MSTPC13.
	MSTP_MSTPCRC_MSTPC13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC13_1 = 0x1
	// Position of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Pos = 0xc
	// Bit mask of MSTPC12 field.
	MSTP_MSTPCRC_MSTPC12_Msk = 0x1000
	// Bit MSTPC12.
	MSTP_MSTPCRC_MSTPC12 = 0x1000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC12_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC12_1 = 0x1
	// Position of MSTPC11 field.
	MSTP_MSTPCRC_MSTPC11_Pos = 0xb
	// Bit mask of MSTPC11 field.
	MSTP_MSTPCRC_MSTPC11_Msk = 0x800
	// Bit MSTPC11.
	MSTP_MSTPCRC_MSTPC11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC11_1 = 0x1
	// Position of MSTPC9 field.
	MSTP_MSTPCRC_MSTPC9_Pos = 0x9
	// Bit mask of MSTPC9 field.
	MSTP_MSTPCRC_MSTPC9_Msk = 0x200
	// Bit MSTPC9.
	MSTP_MSTPCRC_MSTPC9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC9_1 = 0x1
	// Position of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Pos = 0x8
	// Bit mask of MSTPC8 field.
	MSTP_MSTPCRC_MSTPC8_Msk = 0x100
	// Bit MSTPC8.
	MSTP_MSTPCRC_MSTPC8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC8_1 = 0x1
	// Position of MSTPC7 field.
	MSTP_MSTPCRC_MSTPC7_Pos = 0x7
	// Bit mask of MSTPC7 field.
	MSTP_MSTPCRC_MSTPC7_Msk = 0x80
	// Bit MSTPC7.
	MSTP_MSTPCRC_MSTPC7 = 0x80
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC7_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC7_1 = 0x1
	// Position of MSTPC6 field.
	MSTP_MSTPCRC_MSTPC6_Pos = 0x6
	// Bit mask of MSTPC6 field.
	MSTP_MSTPCRC_MSTPC6_Msk = 0x40
	// Bit MSTPC6.
	MSTP_MSTPCRC_MSTPC6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC6_1 = 0x1
	// Position of MSTPC5 field.
	MSTP_MSTPCRC_MSTPC5_Pos = 0x5
	// Bit mask of MSTPC5 field.
	MSTP_MSTPCRC_MSTPC5_Msk = 0x20
	// Bit MSTPC5.
	MSTP_MSTPCRC_MSTPC5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC5_1 = 0x1
	// Position of MSTPC4 field.
	MSTP_MSTPCRC_MSTPC4_Pos = 0x4
	// Bit mask of MSTPC4 field.
	MSTP_MSTPCRC_MSTPC4_Msk = 0x10
	// Bit MSTPC4.
	MSTP_MSTPCRC_MSTPC4 = 0x10
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC4_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC4_1 = 0x1
	// Position of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Pos = 0x3
	// Bit mask of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Msk = 0x8
	// Bit MSTPC3.
	MSTP_MSTPCRC_MSTPC3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC3_1 = 0x1
	// Position of MSTPC2 field.
	MSTP_MSTPCRC_MSTPC2_Pos = 0x2
	// Bit mask of MSTPC2 field.
	MSTP_MSTPCRC_MSTPC2_Msk = 0x4
	// Bit MSTPC2.
	MSTP_MSTPCRC_MSTPC2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC2_1 = 0x1
	// Position of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Pos = 0x1
	// Bit mask of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Msk = 0x2
	// Bit MSTPC1.
	MSTP_MSTPCRC_MSTPC1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC1_1 = 0x1
	// Position of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Pos = 0x0
	// Bit mask of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Msk = 0x1
	// Bit MSTPC0.
	MSTP_MSTPCRC_MSTPC0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC0_1 = 0x1

	// MSTPCRD: Module Stop Control Register D
	// Position of MSTPD28 field.
	MSTP_MSTPCRD_MSTPD28_Pos = 0x1c
	// Bit mask of MSTPD28 field.
	MSTP_MSTPCRD_MSTPD28_Msk = 0x10000000
	// Bit MSTPD28.
	MSTP_MSTPCRD_MSTPD28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD28_1 = 0x1
	// Position of MSTPD27 field.
	MSTP_MSTPCRD_MSTPD27_Pos = 0x1b
	// Bit mask of MSTPD27 field.
	MSTP_MSTPCRD_MSTPD27_Msk = 0x8000000
	// Bit MSTPD27.
	MSTP_MSTPCRD_MSTPD27 = 0x8000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD27_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD27_1 = 0x1
	// Position of MSTPD26 field.
	MSTP_MSTPCRD_MSTPD26_Pos = 0x1a
	// Bit mask of MSTPD26 field.
	MSTP_MSTPCRD_MSTPD26_Msk = 0x4000000
	// Bit MSTPD26.
	MSTP_MSTPCRD_MSTPD26 = 0x4000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD26_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD26_1 = 0x1
	// Position of MSTPD25 field.
	MSTP_MSTPCRD_MSTPD25_Pos = 0x19
	// Bit mask of MSTPD25 field.
	MSTP_MSTPCRD_MSTPD25_Msk = 0x2000000
	// Bit MSTPD25.
	MSTP_MSTPCRD_MSTPD25 = 0x2000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD25_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD25_1 = 0x1
	// Position of MSTPD24 field.
	MSTP_MSTPCRD_MSTPD24_Pos = 0x18
	// Bit mask of MSTPD24 field.
	MSTP_MSTPCRD_MSTPD24_Msk = 0x1000000
	// Bit MSTPD24.
	MSTP_MSTPCRD_MSTPD24 = 0x1000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD24_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD24_1 = 0x1
	// Position of MSTPD23 field.
	MSTP_MSTPCRD_MSTPD23_Pos = 0x17
	// Bit mask of MSTPD23 field.
	MSTP_MSTPCRD_MSTPD23_Msk = 0x800000
	// Bit MSTPD23.
	MSTP_MSTPCRD_MSTPD23 = 0x800000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD23_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD23_1 = 0x1
	// Position of MSTPD22 field.
	MSTP_MSTPCRD_MSTPD22_Pos = 0x16
	// Bit mask of MSTPD22 field.
	MSTP_MSTPCRD_MSTPD22_Msk = 0x400000
	// Bit MSTPD22.
	MSTP_MSTPCRD_MSTPD22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD22_1 = 0x1
	// Position of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Pos = 0x14
	// Bit mask of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Msk = 0x100000
	// Bit MSTPD20.
	MSTP_MSTPCRD_MSTPD20 = 0x100000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD20_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD20_1 = 0x1
	// Position of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Pos = 0x10
	// Bit mask of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Msk = 0x10000
	// Bit MSTPD16.
	MSTP_MSTPCRD_MSTPD16 = 0x10000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD16_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD16_1 = 0x1
	// Position of MSTPD15 field.
	MSTP_MSTPCRD_MSTPD15_Pos = 0xf
	// Bit mask of MSTPD15 field.
	MSTP_MSTPCRD_MSTPD15_Msk = 0x8000
	// Bit MSTPD15.
	MSTP_MSTPCRD_MSTPD15 = 0x8000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD15_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD15_1 = 0x1
	// Position of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Pos = 0xe
	// Bit mask of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Msk = 0x4000
	// Bit MSTPD14.
	MSTP_MSTPCRD_MSTPD14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD14_1 = 0x1
	// Position of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Pos = 0x6
	// Bit mask of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Msk = 0x40
	// Bit MSTPD6.
	MSTP_MSTPCRD_MSTPD6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD6_1 = 0x1
	// Position of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Pos = 0x5
	// Bit mask of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Msk = 0x20
	// Bit MSTPD5.
	MSTP_MSTPCRD_MSTPD5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD5_1 = 0x1
	// Position of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Pos = 0x3
	// Bit mask of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Msk = 0x8
	// Bit MSTPD3.
	MSTP_MSTPCRD_MSTPD3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD3_1 = 0x1
	// Position of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Pos = 0x2
	// Bit mask of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Msk = 0x4
	// Bit MSTPD2.
	MSTP_MSTPCRD_MSTPD2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD2_1 = 0x1
)

// Constants for GPT328: General PWM Timer 8 (32-bit Enhanced)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of PRKEY field.
	GPT328_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT328_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT328_GTWP_PRKEY_0xA5 = 0xa5
	// Position of WP field.
	GPT328_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT328_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT328_GTWP_WP = 0x1
	// Enable writes to the register
	GPT328_GTWP_WP_0 = 0x0
	// Disable writes to the register
	GPT328_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of CSTRT13 field.
	GPT328_GTSTR_CSTRT13_Pos = 0xd
	// Bit mask of CSTRT13 field.
	GPT328_GTSTR_CSTRT13_Msk = 0x2000
	// Bit CSTRT13.
	GPT328_GTSTR_CSTRT13 = 0x2000
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT13_0 = 0x0
	// GPT3213.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT13_1 = 0x1
	// Position of CSTRT12 field.
	GPT328_GTSTR_CSTRT12_Pos = 0xc
	// Bit mask of CSTRT12 field.
	GPT328_GTSTR_CSTRT12_Msk = 0x1000
	// Bit CSTRT12.
	GPT328_GTSTR_CSTRT12 = 0x1000
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT12_0 = 0x0
	// GPT3212.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT12_1 = 0x1
	// Position of CSTRT11 field.
	GPT328_GTSTR_CSTRT11_Pos = 0xb
	// Bit mask of CSTRT11 field.
	GPT328_GTSTR_CSTRT11_Msk = 0x800
	// Bit CSTRT11.
	GPT328_GTSTR_CSTRT11 = 0x800
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT11_0 = 0x0
	// GPT3211.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT11_1 = 0x1
	// Position of CSTRT10 field.
	GPT328_GTSTR_CSTRT10_Pos = 0xa
	// Bit mask of CSTRT10 field.
	GPT328_GTSTR_CSTRT10_Msk = 0x400
	// Bit CSTRT10.
	GPT328_GTSTR_CSTRT10 = 0x400
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT10_0 = 0x0
	// GPT3210.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT10_1 = 0x1
	// Position of CSTRT9 field.
	GPT328_GTSTR_CSTRT9_Pos = 0x9
	// Bit mask of CSTRT9 field.
	GPT328_GTSTR_CSTRT9_Msk = 0x200
	// Bit CSTRT9.
	GPT328_GTSTR_CSTRT9 = 0x200
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT9_0 = 0x0
	// GPT329.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT9_1 = 0x1
	// Position of CSTRT8 field.
	GPT328_GTSTR_CSTRT8_Pos = 0x8
	// Bit mask of CSTRT8 field.
	GPT328_GTSTR_CSTRT8_Msk = 0x100
	// Bit CSTRT8.
	GPT328_GTSTR_CSTRT8 = 0x100
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT8_0 = 0x0
	// GPT328.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT8_1 = 0x1
	// Position of CSTRT7 field.
	GPT328_GTSTR_CSTRT7_Pos = 0x7
	// Bit mask of CSTRT7 field.
	GPT328_GTSTR_CSTRT7_Msk = 0x80
	// Bit CSTRT7.
	GPT328_GTSTR_CSTRT7 = 0x80
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT7_0 = 0x0
	// GPT32E7.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT7_1 = 0x1
	// Position of CSTRT6 field.
	GPT328_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT328_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT328_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT6_0 = 0x0
	// GPT32E6.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT328_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT328_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT328_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT5_0 = 0x0
	// GPT32E5.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT328_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT328_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT328_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT4_0 = 0x0
	// GPT32E4.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT328_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT328_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT328_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT3_0 = 0x0
	// GPT32EH3.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT328_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT328_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT328_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT2_0 = 0x0
	// GPT32EH2.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT328_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT328_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT328_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT1_0 = 0x0
	// GPT32EH1.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT328_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT328_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT328_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT328_GTSTR_CSTRT0_0 = 0x0
	// GPT32EH0.GTCNT counter starts (write) / Counter running (read)
	GPT328_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of CSTOP13 field.
	GPT328_GTSTP_CSTOP13_Pos = 0xd
	// Bit mask of CSTOP13 field.
	GPT328_GTSTP_CSTOP13_Msk = 0x2000
	// Bit CSTOP13.
	GPT328_GTSTP_CSTOP13 = 0x2000
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP13_0 = 0x0
	// GPT3213.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP13_1 = 0x1
	// Position of CSTOP12 field.
	GPT328_GTSTP_CSTOP12_Pos = 0xc
	// Bit mask of CSTOP12 field.
	GPT328_GTSTP_CSTOP12_Msk = 0x1000
	// Bit CSTOP12.
	GPT328_GTSTP_CSTOP12 = 0x1000
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP12_0 = 0x0
	// GPT3212.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP12_1 = 0x1
	// Position of CSTOP11 field.
	GPT328_GTSTP_CSTOP11_Pos = 0xb
	// Bit mask of CSTOP11 field.
	GPT328_GTSTP_CSTOP11_Msk = 0x800
	// Bit CSTOP11.
	GPT328_GTSTP_CSTOP11 = 0x800
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP11_0 = 0x0
	// GPT3211.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP11_1 = 0x1
	// Position of CSTOP10 field.
	GPT328_GTSTP_CSTOP10_Pos = 0xa
	// Bit mask of CSTOP10 field.
	GPT328_GTSTP_CSTOP10_Msk = 0x400
	// Bit CSTOP10.
	GPT328_GTSTP_CSTOP10 = 0x400
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP10_0 = 0x0
	// GPT3210.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP10_1 = 0x1
	// Position of CSTOP9 field.
	GPT328_GTSTP_CSTOP9_Pos = 0x9
	// Bit mask of CSTOP9 field.
	GPT328_GTSTP_CSTOP9_Msk = 0x200
	// Bit CSTOP9.
	GPT328_GTSTP_CSTOP9 = 0x200
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP9_0 = 0x0
	// GPT329.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP9_1 = 0x1
	// Position of CSTOP8 field.
	GPT328_GTSTP_CSTOP8_Pos = 0x8
	// Bit mask of CSTOP8 field.
	GPT328_GTSTP_CSTOP8_Msk = 0x100
	// Bit CSTOP8.
	GPT328_GTSTP_CSTOP8 = 0x100
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP8_0 = 0x0
	// GPT328.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP8_1 = 0x1
	// Position of CSTOP7 field.
	GPT328_GTSTP_CSTOP7_Pos = 0x7
	// Bit mask of CSTOP7 field.
	GPT328_GTSTP_CSTOP7_Msk = 0x80
	// Bit CSTOP7.
	GPT328_GTSTP_CSTOP7 = 0x80
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP7_0 = 0x0
	// GPT32E7.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP7_1 = 0x1
	// Position of CSTOP6 field.
	GPT328_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT328_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT328_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP6_0 = 0x0
	// GPT32E6.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT328_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT328_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT328_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP5_0 = 0x0
	// GPT32E5.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT328_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT328_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT328_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP4_0 = 0x0
	// GPT32E4.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT328_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT328_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT328_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP3_0 = 0x0
	// GPT32EH3.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT328_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT328_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT328_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP2_0 = 0x0
	// GPT32EH2.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT328_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT328_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT328_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP1_0 = 0x0
	// GPT32EH1.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT328_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT328_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT328_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT328_GTSTP_CSTOP0_0 = 0x0
	// GPT32EH0.GTCNT counter stops (write) / Counter stop (read)
	GPT328_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of CCLR13 field.
	GPT328_GTCLR_CCLR13_Pos = 0xd
	// Bit mask of CCLR13 field.
	GPT328_GTCLR_CCLR13_Msk = 0x2000
	// Bit CCLR13.
	GPT328_GTCLR_CCLR13 = 0x2000
	// No effect
	GPT328_GTCLR_CCLR13_0 = 0x0
	// GPT3213.GTCNT counter clears
	GPT328_GTCLR_CCLR13_1 = 0x1
	// Position of CCLR12 field.
	GPT328_GTCLR_CCLR12_Pos = 0xc
	// Bit mask of CCLR12 field.
	GPT328_GTCLR_CCLR12_Msk = 0x1000
	// Bit CCLR12.
	GPT328_GTCLR_CCLR12 = 0x1000
	// No effect
	GPT328_GTCLR_CCLR12_0 = 0x0
	// GPT3212.GTCNT counter clears
	GPT328_GTCLR_CCLR12_1 = 0x1
	// Position of CCLR11 field.
	GPT328_GTCLR_CCLR11_Pos = 0xb
	// Bit mask of CCLR11 field.
	GPT328_GTCLR_CCLR11_Msk = 0x800
	// Bit CCLR11.
	GPT328_GTCLR_CCLR11 = 0x800
	// No effect
	GPT328_GTCLR_CCLR11_0 = 0x0
	// GPT3211.GTCNT counter clears
	GPT328_GTCLR_CCLR11_1 = 0x1
	// Position of CCLR10 field.
	GPT328_GTCLR_CCLR10_Pos = 0xa
	// Bit mask of CCLR10 field.
	GPT328_GTCLR_CCLR10_Msk = 0x400
	// Bit CCLR10.
	GPT328_GTCLR_CCLR10 = 0x400
	// No effect
	GPT328_GTCLR_CCLR10_0 = 0x0
	// GPT3210.GTCNT counter clears
	GPT328_GTCLR_CCLR10_1 = 0x1
	// Position of CCLR9 field.
	GPT328_GTCLR_CCLR9_Pos = 0x9
	// Bit mask of CCLR9 field.
	GPT328_GTCLR_CCLR9_Msk = 0x200
	// Bit CCLR9.
	GPT328_GTCLR_CCLR9 = 0x200
	// No effect
	GPT328_GTCLR_CCLR9_0 = 0x0
	// GPT329.GTCNT counter clears
	GPT328_GTCLR_CCLR9_1 = 0x1
	// Position of CCLR8 field.
	GPT328_GTCLR_CCLR8_Pos = 0x8
	// Bit mask of CCLR8 field.
	GPT328_GTCLR_CCLR8_Msk = 0x100
	// Bit CCLR8.
	GPT328_GTCLR_CCLR8 = 0x100
	// No effect
	GPT328_GTCLR_CCLR8_0 = 0x0
	// GPT328.GTCNT counter clears
	GPT328_GTCLR_CCLR8_1 = 0x1
	// Position of CCLR7 field.
	GPT328_GTCLR_CCLR7_Pos = 0x7
	// Bit mask of CCLR7 field.
	GPT328_GTCLR_CCLR7_Msk = 0x80
	// Bit CCLR7.
	GPT328_GTCLR_CCLR7 = 0x80
	// No effect
	GPT328_GTCLR_CCLR7_0 = 0x0
	// GPT32E7.GTCNT counter clears
	GPT328_GTCLR_CCLR7_1 = 0x1
	// Position of CCLR6 field.
	GPT328_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT328_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT328_GTCLR_CCLR6 = 0x40
	// No effect
	GPT328_GTCLR_CCLR6_0 = 0x0
	// GPT32E6.GTCNT counter clears
	GPT328_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT328_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT328_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT328_GTCLR_CCLR5 = 0x20
	// No effect
	GPT328_GTCLR_CCLR5_0 = 0x0
	// GPT32E5.GTCNT counter clears
	GPT328_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT328_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT328_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT328_GTCLR_CCLR4 = 0x10
	// No effect
	GPT328_GTCLR_CCLR4_0 = 0x0
	// GPT32E4.GTCNT counter clears
	GPT328_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT328_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT328_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT328_GTCLR_CCLR3 = 0x8
	// No effect
	GPT328_GTCLR_CCLR3_0 = 0x0
	// GPT32EH3.GTCNT counter clears
	GPT328_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT328_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT328_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT328_GTCLR_CCLR2 = 0x4
	// No effect
	GPT328_GTCLR_CCLR2_0 = 0x0
	// GPT32EH2.GTCNT counter clears
	GPT328_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT328_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT328_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT328_GTCLR_CCLR1 = 0x2
	// No effect
	GPT328_GTCLR_CCLR1_0 = 0x0
	// GPT32EH1.GTCNT counter clears
	GPT328_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT328_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT328_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT328_GTCLR_CCLR0 = 0x1
	// No effect
	GPT328_GTCLR_CCLR0_0 = 0x0
	// GPT32EH0.GTCNT counter clears
	GPT328_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT328_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT328_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT328_GTSSR_CSTRT = 0x80000000
	// Disable counter start by the GTSTR register
	GPT328_GTSSR_CSTRT_0 = 0x0
	// Enable counter start by the GTSTR register
	GPT328_GTSSR_CSTRT_1 = 0x1
	// Position of SSELCH field.
	GPT328_GTSSR_SSELCH_Pos = 0x17
	// Bit mask of SSELCH field.
	GPT328_GTSSR_SSELCH_Msk = 0x800000
	// Bit SSELCH.
	GPT328_GTSSR_SSELCH = 0x800000
	// Disable counter start on ELC_GPTH input
	GPT328_GTSSR_SSELCH_0 = 0x0
	// Enable counter start on ELC_GPTH input.
	GPT328_GTSSR_SSELCH_1 = 0x1
	// Position of SSELCG field.
	GPT328_GTSSR_SSELCG_Pos = 0x16
	// Bit mask of SSELCG field.
	GPT328_GTSSR_SSELCG_Msk = 0x400000
	// Bit SSELCG.
	GPT328_GTSSR_SSELCG = 0x400000
	// Disable counter start on ELC_GPTG input
	GPT328_GTSSR_SSELCG_0 = 0x0
	// Enable counter start on ELC_GPTG input.
	GPT328_GTSSR_SSELCG_1 = 0x1
	// Position of SSELCF field.
	GPT328_GTSSR_SSELCF_Pos = 0x15
	// Bit mask of SSELCF field.
	GPT328_GTSSR_SSELCF_Msk = 0x200000
	// Bit SSELCF.
	GPT328_GTSSR_SSELCF = 0x200000
	// Disable counter start on ELC_GPTF input
	GPT328_GTSSR_SSELCF_0 = 0x0
	// Enable counter start on ELC_GPTF input
	GPT328_GTSSR_SSELCF_1 = 0x1
	// Position of SSELCE field.
	GPT328_GTSSR_SSELCE_Pos = 0x14
	// Bit mask of SSELCE field.
	GPT328_GTSSR_SSELCE_Msk = 0x100000
	// Bit SSELCE.
	GPT328_GTSSR_SSELCE = 0x100000
	// Disable counter start on ELC_GPTE input
	GPT328_GTSSR_SSELCE_0 = 0x0
	// Enable counter start on ELC_GPTE input
	GPT328_GTSSR_SSELCE_1 = 0x1
	// Position of SSELCD field.
	GPT328_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT328_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT328_GTSSR_SSELCD = 0x80000
	// Disable counter start on ELC_GPTD input
	GPT328_GTSSR_SSELCD_0 = 0x0
	// Enable counter start on ELC_GPTD input.
	GPT328_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT328_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT328_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT328_GTSSR_SSELCC = 0x40000
	// Disable counter start on ELC_GPTC input
	GPT328_GTSSR_SSELCC_0 = 0x0
	// Enable counter start on ELC_GPTC input.
	GPT328_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT328_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT328_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT328_GTSSR_SSELCB = 0x20000
	// Disable counter start on ELC_GPTB input
	GPT328_GTSSR_SSELCB_0 = 0x0
	// Enable counter start on ELC_GPTB input.
	GPT328_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT328_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT328_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT328_GTSSR_SSELCA = 0x10000
	// Disable counter start on ELC_GPTA input
	GPT328_GTSSR_SSELCA_0 = 0x0
	// Enable counter start on ELC_GPTA input.
	GPT328_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT328_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT328_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT328_GTSSR_SSCBFAH = 0x8000
	// Disable counter start on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTSSR_SSCBFAH_0 = 0x0
	// Enable counter start on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT328_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT328_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT328_GTSSR_SSCBFAL = 0x4000
	// Disable counter start on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTSSR_SSCBFAL_0 = 0x0
	// Enable counter start on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT328_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT328_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT328_GTSSR_SSCBRAH = 0x2000
	// Disable counter start on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTSSR_SSCBRAH_0 = 0x0
	// Enable counter start on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT328_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT328_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT328_GTSSR_SSCBRAL = 0x1000
	// Disable counter start on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTSSR_SSCBRAL_0 = 0x0
	// Enable counter start on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT328_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT328_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT328_GTSSR_SSCAFBH = 0x800
	// Disable counter start on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTSSR_SSCAFBH_0 = 0x0
	// Enable counter start on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT328_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT328_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT328_GTSSR_SSCAFBL = 0x400
	// Disable counter start on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTSSR_SSCAFBL_0 = 0x0
	// Enable counter start on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT328_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT328_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT328_GTSSR_SSCARBH = 0x200
	// Disable counter start on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTSSR_SSCARBH_0 = 0x0
	// Enable counter start on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT328_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT328_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT328_GTSSR_SSCARBL = 0x100
	// Disable counter start on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTSSR_SSCARBL_0 = 0x0
	// Enable counter start on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTSSR_SSCARBL_1 = 0x1
	// Position of SSGTRGDF field.
	GPT328_GTSSR_SSGTRGDF_Pos = 0x7
	// Bit mask of SSGTRGDF field.
	GPT328_GTSSR_SSGTRGDF_Msk = 0x80
	// Bit SSGTRGDF.
	GPT328_GTSSR_SSGTRGDF = 0x80
	// Disable counter start on the falling edge of GTETRGD input
	GPT328_GTSSR_SSGTRGDF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGD input.
	GPT328_GTSSR_SSGTRGDF_1 = 0x1
	// Position of SSGTRGDR field.
	GPT328_GTSSR_SSGTRGDR_Pos = 0x6
	// Bit mask of SSGTRGDR field.
	GPT328_GTSSR_SSGTRGDR_Msk = 0x40
	// Bit SSGTRGDR.
	GPT328_GTSSR_SSGTRGDR = 0x40
	// Disable counter start on the rising edge of GTETRGD input
	GPT328_GTSSR_SSGTRGDR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGD input
	GPT328_GTSSR_SSGTRGDR_1 = 0x1
	// Position of SSGTRGCF field.
	GPT328_GTSSR_SSGTRGCF_Pos = 0x5
	// Bit mask of SSGTRGCF field.
	GPT328_GTSSR_SSGTRGCF_Msk = 0x20
	// Bit SSGTRGCF.
	GPT328_GTSSR_SSGTRGCF = 0x20
	// Disable counter start on the falling edge of GTETRGC input
	GPT328_GTSSR_SSGTRGCF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGC input
	GPT328_GTSSR_SSGTRGCF_1 = 0x1
	// Position of SSGTRGCR field.
	GPT328_GTSSR_SSGTRGCR_Pos = 0x4
	// Bit mask of SSGTRGCR field.
	GPT328_GTSSR_SSGTRGCR_Msk = 0x10
	// Bit SSGTRGCR.
	GPT328_GTSSR_SSGTRGCR = 0x10
	// Disable counter start on the rising edge of GTETRGC input
	GPT328_GTSSR_SSGTRGCR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGC input
	GPT328_GTSSR_SSGTRGCR_1 = 0x1
	// Position of SSGTRGBF field.
	GPT328_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT328_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT328_GTSSR_SSGTRGBF = 0x8
	// Disable counter start on the falling edge of GTETRGB input
	GPT328_GTSSR_SSGTRGBF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGB input
	GPT328_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT328_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT328_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT328_GTSSR_SSGTRGBR = 0x4
	// Disable counter start on the rising edge of GTETRGB input
	GPT328_GTSSR_SSGTRGBR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGB input.
	GPT328_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT328_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT328_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT328_GTSSR_SSGTRGAF = 0x2
	// Disable counter start on the falling edge of GTETRGA input
	GPT328_GTSSR_SSGTRGAF_0 = 0x0
	// Enable counter start on the falling edge of GTETRGA input
	GPT328_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT328_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT328_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT328_GTSSR_SSGTRGAR = 0x1
	// Disable counter start on the rising edge of GTETRGA input
	GPT328_GTSSR_SSGTRGAR_0 = 0x0
	// Enable counter start on the rising edge of GTETRGA input.
	GPT328_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT328_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT328_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT328_GTPSR_CSTOP = 0x80000000
	// Disable counter stop by the GTSTP register
	GPT328_GTPSR_CSTOP_0 = 0x0
	// Enable counter stop by the GTSTP register
	GPT328_GTPSR_CSTOP_1 = 0x1
	// Position of PSELCH field.
	GPT328_GTPSR_PSELCH_Pos = 0x17
	// Bit mask of PSELCH field.
	GPT328_GTPSR_PSELCH_Msk = 0x800000
	// Bit PSELCH.
	GPT328_GTPSR_PSELCH = 0x800000
	// Disable counter stop on ELC_GPTH input
	GPT328_GTPSR_PSELCH_0 = 0x0
	// Enable counter stop on ELCH event inpu
	GPT328_GTPSR_PSELCH_1 = 0x1
	// Position of PSELCG field.
	GPT328_GTPSR_PSELCG_Pos = 0x16
	// Bit mask of PSELCG field.
	GPT328_GTPSR_PSELCG_Msk = 0x400000
	// Bit PSELCG.
	GPT328_GTPSR_PSELCG = 0x400000
	// Disable counter stop on ELC_GPTG input
	GPT328_GTPSR_PSELCG_0 = 0x0
	// Enable counter stop on ELC_GPTG input
	GPT328_GTPSR_PSELCG_1 = 0x1
	// Position of PSELCF field.
	GPT328_GTPSR_PSELCF_Pos = 0x15
	// Bit mask of PSELCF field.
	GPT328_GTPSR_PSELCF_Msk = 0x200000
	// Bit PSELCF.
	GPT328_GTPSR_PSELCF = 0x200000
	// Disable counter stop on ELC_GPTF input
	GPT328_GTPSR_PSELCF_0 = 0x0
	// Enable counter stop on ELC_GPTF input
	GPT328_GTPSR_PSELCF_1 = 0x1
	// Position of PSELCE field.
	GPT328_GTPSR_PSELCE_Pos = 0x14
	// Bit mask of PSELCE field.
	GPT328_GTPSR_PSELCE_Msk = 0x100000
	// Bit PSELCE.
	GPT328_GTPSR_PSELCE = 0x100000
	// Disable counter stop on ELC_GPTE input
	GPT328_GTPSR_PSELCE_0 = 0x0
	// Enable counter stop on ELC_GPTE input
	GPT328_GTPSR_PSELCE_1 = 0x1
	// Position of PSELCD field.
	GPT328_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT328_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT328_GTPSR_PSELCD = 0x80000
	// Disable counter stop on ELC_GPTD input
	GPT328_GTPSR_PSELCD_0 = 0x0
	// Enable counter stop on ELC_GPTD input
	GPT328_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT328_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT328_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT328_GTPSR_PSELCC = 0x40000
	// Disable counter stop on ELC_GPTC input
	GPT328_GTPSR_PSELCC_0 = 0x0
	// Enable counter stop on ELC_GPTC input
	GPT328_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT328_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT328_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT328_GTPSR_PSELCB = 0x20000
	// Disable counter stop on ELC_GPTB input
	GPT328_GTPSR_PSELCB_0 = 0x0
	// Enable counter stop on ELC_GPTB input
	GPT328_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT328_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT328_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT328_GTPSR_PSELCA = 0x10000
	// Disable counter stop on ELC_GPTA input
	GPT328_GTPSR_PSELCA_0 = 0x0
	// Enable counter stop on ELC_GPTA input
	GPT328_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT328_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT328_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT328_GTPSR_PSCBFAH = 0x8000
	// Disable counter stop on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTPSR_PSCBFAH_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT328_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT328_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT328_GTPSR_PSCBFAL = 0x4000
	// Disable counter stop on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTPSR_PSCBFAL_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT328_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT328_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT328_GTPSR_PSCBRAH = 0x2000
	// Disable counter stop on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTPSR_PSCBRAH_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT328_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT328_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT328_GTPSR_PSCBRAL = 0x1000
	// Disable counter stop on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTPSR_PSCBRAL_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT328_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT328_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT328_GTPSR_PSCAFBH = 0x800
	// Disable counter stop on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTPSR_PSCAFBH_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT328_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT328_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT328_GTPSR_PSCAFBL = 0x400
	// Disable counter stop on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTPSR_PSCAFBL_0 = 0x0
	// Enable counter stop on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT328_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT328_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT328_GTPSR_PSCARBH = 0x200
	// Disable counter stop on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTPSR_PSCARBH_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT328_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT328_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT328_GTPSR_PSCARBL = 0x100
	// Disable counter stop on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTPSR_PSCARBL_0 = 0x0
	// Enable counter stop on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTPSR_PSCARBL_1 = 0x1
	// Position of PSGTRGDF field.
	GPT328_GTPSR_PSGTRGDF_Pos = 0x7
	// Bit mask of PSGTRGDF field.
	GPT328_GTPSR_PSGTRGDF_Msk = 0x80
	// Bit PSGTRGDF.
	GPT328_GTPSR_PSGTRGDF = 0x80
	// Disable counter stop on the falling edge of GTETRGD input
	GPT328_GTPSR_PSGTRGDF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGD input
	GPT328_GTPSR_PSGTRGDF_1 = 0x1
	// Position of PSGTRGDR field.
	GPT328_GTPSR_PSGTRGDR_Pos = 0x6
	// Bit mask of PSGTRGDR field.
	GPT328_GTPSR_PSGTRGDR_Msk = 0x40
	// Bit PSGTRGDR.
	GPT328_GTPSR_PSGTRGDR = 0x40
	// Disable counter stop on the rising edge of GTETRGD input
	GPT328_GTPSR_PSGTRGDR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGD input
	GPT328_GTPSR_PSGTRGDR_1 = 0x1
	// Position of PSGTRGCF field.
	GPT328_GTPSR_PSGTRGCF_Pos = 0x5
	// Bit mask of PSGTRGCF field.
	GPT328_GTPSR_PSGTRGCF_Msk = 0x20
	// Bit PSGTRGCF.
	GPT328_GTPSR_PSGTRGCF = 0x20
	// Disable counter stop on the falling edge of GTETRGC input
	GPT328_GTPSR_PSGTRGCF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGC input
	GPT328_GTPSR_PSGTRGCF_1 = 0x1
	// Position of PSGTRGCR field.
	GPT328_GTPSR_PSGTRGCR_Pos = 0x4
	// Bit mask of PSGTRGCR field.
	GPT328_GTPSR_PSGTRGCR_Msk = 0x10
	// Bit PSGTRGCR.
	GPT328_GTPSR_PSGTRGCR = 0x10
	// Disable counter stop on the rising edge of GTETRGC input
	GPT328_GTPSR_PSGTRGCR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGC input
	GPT328_GTPSR_PSGTRGCR_1 = 0x1
	// Position of PSGTRGBF field.
	GPT328_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT328_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT328_GTPSR_PSGTRGBF = 0x8
	// Disable counter stop on the falling edge of GTETRGB input
	GPT328_GTPSR_PSGTRGBF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGB input
	GPT328_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT328_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT328_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT328_GTPSR_PSGTRGBR = 0x4
	// Disable counter stop on the rising edge of GTETRGB input
	GPT328_GTPSR_PSGTRGBR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGB input
	GPT328_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT328_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT328_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT328_GTPSR_PSGTRGAF = 0x2
	// Disable counter stop on the falling edge of GTETRGA input
	GPT328_GTPSR_PSGTRGAF_0 = 0x0
	// Enable counter stop on the falling edge of GTETRGA input
	GPT328_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT328_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT328_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT328_GTPSR_PSGTRGAR = 0x1
	// Disable counter stop on the rising edge of GTETRGA input
	GPT328_GTPSR_PSGTRGAR_0 = 0x0
	// Enable counter stop on the rising edge of GTETRGA input
	GPT328_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT328_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT328_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT328_GTCSR_CCLR = 0x80000000
	// Disable counter clear by the GTCLR register
	GPT328_GTCSR_CCLR_0 = 0x0
	// Enable counter clear by the GTCLR register
	GPT328_GTCSR_CCLR_1 = 0x1
	// Position of CSELCH field.
	GPT328_GTCSR_CSELCH_Pos = 0x17
	// Bit mask of CSELCH field.
	GPT328_GTCSR_CSELCH_Msk = 0x800000
	// Bit CSELCH.
	GPT328_GTCSR_CSELCH = 0x800000
	// Disable counter clear on ELC_GPTH input
	GPT328_GTCSR_CSELCH_0 = 0x0
	// Enable counter clear on ELC_GPTH input
	GPT328_GTCSR_CSELCH_1 = 0x1
	// Position of CSELCG field.
	GPT328_GTCSR_CSELCG_Pos = 0x16
	// Bit mask of CSELCG field.
	GPT328_GTCSR_CSELCG_Msk = 0x400000
	// Bit CSELCG.
	GPT328_GTCSR_CSELCG = 0x400000
	// Disable counter clear on ELC_GPTG input
	GPT328_GTCSR_CSELCG_0 = 0x0
	// Enable counter clear on ELC_GPTG input
	GPT328_GTCSR_CSELCG_1 = 0x1
	// Position of CSELCF field.
	GPT328_GTCSR_CSELCF_Pos = 0x15
	// Bit mask of CSELCF field.
	GPT328_GTCSR_CSELCF_Msk = 0x200000
	// Bit CSELCF.
	GPT328_GTCSR_CSELCF = 0x200000
	// Disable counter clear on ELC_GPTF input
	GPT328_GTCSR_CSELCF_0 = 0x0
	// Enable counter clear on ELC_GPTF input
	GPT328_GTCSR_CSELCF_1 = 0x1
	// Position of CSELCE field.
	GPT328_GTCSR_CSELCE_Pos = 0x14
	// Bit mask of CSELCE field.
	GPT328_GTCSR_CSELCE_Msk = 0x100000
	// Bit CSELCE.
	GPT328_GTCSR_CSELCE = 0x100000
	// Disable counter clear on ELC_GPTE input
	GPT328_GTCSR_CSELCE_0 = 0x0
	// Enable counter clear on ELC_GPTE input
	GPT328_GTCSR_CSELCE_1 = 0x1
	// Position of CSELCD field.
	GPT328_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT328_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT328_GTCSR_CSELCD = 0x80000
	// Disable counter clear on ELC_GPTD input
	GPT328_GTCSR_CSELCD_0 = 0x0
	// Enable counter clear on ELC_GPTD input
	GPT328_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT328_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT328_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT328_GTCSR_CSELCC = 0x40000
	// Disable counter clear on ELC_GPTC input
	GPT328_GTCSR_CSELCC_0 = 0x0
	// Enable counter clear on ELC_GPTC input
	GPT328_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT328_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT328_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT328_GTCSR_CSELCB = 0x20000
	// Disable counter clear on ELC_GPTB input
	GPT328_GTCSR_CSELCB_0 = 0x0
	// Enable counter clear on ELC_GPTB input
	GPT328_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT328_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT328_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT328_GTCSR_CSELCA = 0x10000
	// Disable counter clear on ELC_GPTA input
	GPT328_GTCSR_CSELCA_0 = 0x0
	// Enable counter clear on ELC_GPTA input
	GPT328_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT328_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT328_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT328_GTCSR_CSCBFAH = 0x8000
	// Disable counter clear on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTCSR_CSCBFAH_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT328_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT328_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT328_GTCSR_CSCBFAL = 0x4000
	// Disable counter clear on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTCSR_CSCBFAL_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT328_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT328_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT328_GTCSR_CSCBRAH = 0x2000
	// Disable counter clear on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTCSR_CSCBRAH_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT328_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT328_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT328_GTCSR_CSCBRAL = 0x1000
	// Disable counter clear on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTCSR_CSCBRAL_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT328_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT328_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT328_GTCSR_CSCAFBH = 0x800
	// Disable counter clear on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTCSR_CSCAFBH_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT328_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT328_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT328_GTCSR_CSCAFBL = 0x400
	// Disable counter clear on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTCSR_CSCAFBL_0 = 0x0
	// Enable counter clear on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT328_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT328_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT328_GTCSR_CSCARBH = 0x200
	// Disable counter clear on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTCSR_CSCARBH_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT328_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT328_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT328_GTCSR_CSCARBL = 0x100
	// Disable counter clear on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTCSR_CSCARBL_0 = 0x0
	// Enable counter clear on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTCSR_CSCARBL_1 = 0x1
	// Position of CSGTRGDF field.
	GPT328_GTCSR_CSGTRGDF_Pos = 0x7
	// Bit mask of CSGTRGDF field.
	GPT328_GTCSR_CSGTRGDF_Msk = 0x80
	// Bit CSGTRGDF.
	GPT328_GTCSR_CSGTRGDF = 0x80
	// Disable counter clear on the falling edge of GTETRGD input
	GPT328_GTCSR_CSGTRGDF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGD input
	GPT328_GTCSR_CSGTRGDF_1 = 0x1
	// Position of CSGTRGDR field.
	GPT328_GTCSR_CSGTRGDR_Pos = 0x6
	// Bit mask of CSGTRGDR field.
	GPT328_GTCSR_CSGTRGDR_Msk = 0x40
	// Bit CSGTRGDR.
	GPT328_GTCSR_CSGTRGDR = 0x40
	// Disable counter clear on the rising edge of GTETRGD input
	GPT328_GTCSR_CSGTRGDR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGD input
	GPT328_GTCSR_CSGTRGDR_1 = 0x1
	// Position of CSGTRGCF field.
	GPT328_GTCSR_CSGTRGCF_Pos = 0x5
	// Bit mask of CSGTRGCF field.
	GPT328_GTCSR_CSGTRGCF_Msk = 0x20
	// Bit CSGTRGCF.
	GPT328_GTCSR_CSGTRGCF = 0x20
	// Disable counter clear on the falling edge of GTETRGC input
	GPT328_GTCSR_CSGTRGCF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGC input
	GPT328_GTCSR_CSGTRGCF_1 = 0x1
	// Position of CSGTRGCR field.
	GPT328_GTCSR_CSGTRGCR_Pos = 0x4
	// Bit mask of CSGTRGCR field.
	GPT328_GTCSR_CSGTRGCR_Msk = 0x10
	// Bit CSGTRGCR.
	GPT328_GTCSR_CSGTRGCR = 0x10
	// Disable counter clear on the rising edge of GTETRGC input
	GPT328_GTCSR_CSGTRGCR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGC input
	GPT328_GTCSR_CSGTRGCR_1 = 0x1
	// Position of CSGTRGBF field.
	GPT328_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT328_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT328_GTCSR_CSGTRGBF = 0x8
	// Disable counter clear on the falling edge of GTETRGB input
	GPT328_GTCSR_CSGTRGBF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGB input
	GPT328_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT328_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT328_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT328_GTCSR_CSGTRGBR = 0x4
	// Disable counter clear on the rising edge of GTETRGB input
	GPT328_GTCSR_CSGTRGBR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGB input
	GPT328_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT328_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT328_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT328_GTCSR_CSGTRGAF = 0x2
	// Disable counter clear on the falling edge of GTETRGA input
	GPT328_GTCSR_CSGTRGAF_0 = 0x0
	// Enable counter clear on the falling edge of GTETRGA input
	GPT328_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT328_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT328_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT328_GTCSR_CSGTRGAR = 0x1
	// Disable counter clear on the rising edge of GTETRGA input
	GPT328_GTCSR_CSGTRGAR_0 = 0x0
	// Enable counter clear on the rising edge of GTETRGA input
	GPT328_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCH field.
	GPT328_GTUPSR_USELCH_Pos = 0x17
	// Bit mask of USELCH field.
	GPT328_GTUPSR_USELCH_Msk = 0x800000
	// Bit USELCH.
	GPT328_GTUPSR_USELCH = 0x800000
	// Disable counter count up on ELC_GPTH input
	GPT328_GTUPSR_USELCH_0 = 0x0
	// Enable counter count up on ELC_GPTH input.
	GPT328_GTUPSR_USELCH_1 = 0x1
	// Position of USELCG field.
	GPT328_GTUPSR_USELCG_Pos = 0x16
	// Bit mask of USELCG field.
	GPT328_GTUPSR_USELCG_Msk = 0x400000
	// Bit USELCG.
	GPT328_GTUPSR_USELCG = 0x400000
	// Disable counter count up on ELC_GPTG input
	GPT328_GTUPSR_USELCG_0 = 0x0
	// Enable counter count up on ELC_GPTG input.
	GPT328_GTUPSR_USELCG_1 = 0x1
	// Position of USELCF field.
	GPT328_GTUPSR_USELCF_Pos = 0x15
	// Bit mask of USELCF field.
	GPT328_GTUPSR_USELCF_Msk = 0x200000
	// Bit USELCF.
	GPT328_GTUPSR_USELCF = 0x200000
	// Disable counter count up on ELC_GPTF input
	GPT328_GTUPSR_USELCF_0 = 0x0
	// Enable counter count up on ELC_GPTF input.
	GPT328_GTUPSR_USELCF_1 = 0x1
	// Position of USELCE field.
	GPT328_GTUPSR_USELCE_Pos = 0x14
	// Bit mask of USELCE field.
	GPT328_GTUPSR_USELCE_Msk = 0x100000
	// Bit USELCE.
	GPT328_GTUPSR_USELCE = 0x100000
	// Disable counter count up on ELC_GPTE input
	GPT328_GTUPSR_USELCE_0 = 0x0
	// Enable counter count up on ELC_GPTE input.put
	GPT328_GTUPSR_USELCE_1 = 0x1
	// Position of USELCD field.
	GPT328_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT328_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT328_GTUPSR_USELCD = 0x80000
	// Disable counter count up on ELC_GPTD input
	GPT328_GTUPSR_USELCD_0 = 0x0
	// Enable counter count up on ELC_GPTD input
	GPT328_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT328_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT328_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT328_GTUPSR_USELCC = 0x40000
	// Disable counter count up on ELC_GPTC input
	GPT328_GTUPSR_USELCC_0 = 0x0
	// Enable counter count up on ELC_GPTC input.
	GPT328_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT328_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT328_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT328_GTUPSR_USELCB = 0x20000
	// Disable counter count up on ELC_GPTB input
	GPT328_GTUPSR_USELCB_0 = 0x0
	// Enable counter count up on ELC_GPTB input.
	GPT328_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT328_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT328_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT328_GTUPSR_USELCA = 0x10000
	// Disable counter count up on ELC_GPTA input
	GPT328_GTUPSR_USELCA_0 = 0x0
	// Enable counter count up on ELC_GPTA input.
	GPT328_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT328_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT328_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT328_GTUPSR_USCBFAH = 0x8000
	// Disable counter count up on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTUPSR_USCBFAH_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT328_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT328_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT328_GTUPSR_USCBFAL = 0x4000
	// Disable counter count up on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTUPSR_USCBFAL_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT328_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT328_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT328_GTUPSR_USCBRAH = 0x2000
	// Disable counter count up on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTUPSR_USCBRAH_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT328_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT328_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT328_GTUPSR_USCBRAL = 0x1000
	// Disable counter count up on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTUPSR_USCBRAL_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT328_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT328_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT328_GTUPSR_USCAFBH = 0x800
	// Disable counter count up on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTUPSR_USCAFBH_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT328_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT328_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT328_GTUPSR_USCAFBL = 0x400
	// Disable counter count up on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTUPSR_USCAFBL_0 = 0x0
	// Enable counter count up on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT328_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT328_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT328_GTUPSR_USCARBH = 0x200
	// Disable counter count up on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTUPSR_USCARBH_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT328_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT328_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT328_GTUPSR_USCARBL = 0x100
	// Disable counter count up on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTUPSR_USCARBL_0 = 0x0
	// Enable counter count up on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGDF field.
	GPT328_GTUPSR_USGTRGDF_Pos = 0x7
	// Bit mask of USGTRGDF field.
	GPT328_GTUPSR_USGTRGDF_Msk = 0x80
	// Bit USGTRGDF.
	GPT328_GTUPSR_USGTRGDF = 0x80
	// Disable counter count up on the falling edge of GTETRGD input
	GPT328_GTUPSR_USGTRGDF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGD input.
	GPT328_GTUPSR_USGTRGDF_1 = 0x1
	// Position of USGTRGDR field.
	GPT328_GTUPSR_USGTRGDR_Pos = 0x6
	// Bit mask of USGTRGDR field.
	GPT328_GTUPSR_USGTRGDR_Msk = 0x40
	// Bit USGTRGDR.
	GPT328_GTUPSR_USGTRGDR = 0x40
	// Disable counter count up on the rising edge of GTETRGD input
	GPT328_GTUPSR_USGTRGDR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGD input
	GPT328_GTUPSR_USGTRGDR_1 = 0x1
	// Position of USGTRGCF field.
	GPT328_GTUPSR_USGTRGCF_Pos = 0x5
	// Bit mask of USGTRGCF field.
	GPT328_GTUPSR_USGTRGCF_Msk = 0x20
	// Bit USGTRGCF.
	GPT328_GTUPSR_USGTRGCF = 0x20
	// Disable counter count up on the falling edge of GTETRGC input
	GPT328_GTUPSR_USGTRGCF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGC input.
	GPT328_GTUPSR_USGTRGCF_1 = 0x1
	// Position of USGTRGCR field.
	GPT328_GTUPSR_USGTRGCR_Pos = 0x4
	// Bit mask of USGTRGCR field.
	GPT328_GTUPSR_USGTRGCR_Msk = 0x10
	// Bit USGTRGCR.
	GPT328_GTUPSR_USGTRGCR = 0x10
	// Disable counter count up on the rising edge of GTETRGC input
	GPT328_GTUPSR_USGTRGCR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGC input
	GPT328_GTUPSR_USGTRGCR_1 = 0x1
	// Position of USGTRGBF field.
	GPT328_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT328_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT328_GTUPSR_USGTRGBF = 0x8
	// Disable counter count up on the falling edge of GTETRGB input
	GPT328_GTUPSR_USGTRGBF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGB input.
	GPT328_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT328_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT328_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT328_GTUPSR_USGTRGBR = 0x4
	// Disable counter count up on the rising edge of GTETRGB input
	GPT328_GTUPSR_USGTRGBR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGB input.
	GPT328_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT328_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT328_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT328_GTUPSR_USGTRGAF = 0x2
	// Disable counter count up on the falling edge of GTETRGA input
	GPT328_GTUPSR_USGTRGAF_0 = 0x0
	// Enable counter count up on the falling edge of GTETRGA input.
	GPT328_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT328_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT328_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT328_GTUPSR_USGTRGAR = 0x1
	// Disable counter count up on the rising edge of GTETRGA input
	GPT328_GTUPSR_USGTRGAR_0 = 0x0
	// Enable counter count up on the rising edge of GTETRGA input
	GPT328_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCH field.
	GPT328_GTDNSR_DSELCH_Pos = 0x17
	// Bit mask of DSELCH field.
	GPT328_GTDNSR_DSELCH_Msk = 0x800000
	// Bit DSELCH.
	GPT328_GTDNSR_DSELCH = 0x800000
	// Disable counter count down on ELC_GPTH input
	GPT328_GTDNSR_DSELCH_0 = 0x0
	// Enable counter count down on ELC_GPTH input.
	GPT328_GTDNSR_DSELCH_1 = 0x1
	// Position of DSELCG field.
	GPT328_GTDNSR_DSELCG_Pos = 0x16
	// Bit mask of DSELCG field.
	GPT328_GTDNSR_DSELCG_Msk = 0x400000
	// Bit DSELCG.
	GPT328_GTDNSR_DSELCG = 0x400000
	// Disable counter count down on ELC_GPTG input
	GPT328_GTDNSR_DSELCG_0 = 0x0
	// Enable counter count down on ELC_GPTG input.
	GPT328_GTDNSR_DSELCG_1 = 0x1
	// Position of DSELCF field.
	GPT328_GTDNSR_DSELCF_Pos = 0x15
	// Bit mask of DSELCF field.
	GPT328_GTDNSR_DSELCF_Msk = 0x200000
	// Bit DSELCF.
	GPT328_GTDNSR_DSELCF = 0x200000
	// Disable counter count down on ELC_GPTF input
	GPT328_GTDNSR_DSELCF_0 = 0x0
	// Enable counter count down on ELC_GPTF input.
	GPT328_GTDNSR_DSELCF_1 = 0x1
	// Position of DSELCE field.
	GPT328_GTDNSR_DSELCE_Pos = 0x14
	// Bit mask of DSELCE field.
	GPT328_GTDNSR_DSELCE_Msk = 0x100000
	// Bit DSELCE.
	GPT328_GTDNSR_DSELCE = 0x100000
	// Disable counter count down on ELC_GPTE input
	GPT328_GTDNSR_DSELCE_0 = 0x0
	// Enable counter count down on ELC_GPTE input.
	GPT328_GTDNSR_DSELCE_1 = 0x1
	// Position of DSELCD field.
	GPT328_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT328_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT328_GTDNSR_DSELCD = 0x80000
	// Disable counter count down on ELC_GPTD input
	GPT328_GTDNSR_DSELCD_0 = 0x0
	// Enable counter count down on ELC_GPTD input.
	GPT328_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT328_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT328_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT328_GTDNSR_DSELCC = 0x40000
	// Disable counter count down on ELC_GPTC input
	GPT328_GTDNSR_DSELCC_0 = 0x0
	// Enable counter count down on ELC_GPTC input.
	GPT328_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT328_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT328_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT328_GTDNSR_DSELCB = 0x20000
	// Disable counter count down on ELC_GPTB input
	GPT328_GTDNSR_DSELCB_0 = 0x0
	// Enable counter count down on ELC_GPTB input.
	GPT328_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT328_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT328_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT328_GTDNSR_DSELCA = 0x10000
	// Disable counter count down on ELC_GPTA input
	GPT328_GTDNSR_DSELCA_0 = 0x0
	// Enable counter count down on ELC_GPTA input.
	GPT328_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT328_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT328_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT328_GTDNSR_DSCBFAH = 0x8000
	// Disable counter count down on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTDNSR_DSCBFAH_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT328_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT328_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT328_GTDNSR_DSCBFAL = 0x4000
	// Disable counter count down on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTDNSR_DSCBFAL_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT328_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT328_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT328_GTDNSR_DSCBRAH = 0x2000
	// Disable counter count down on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTDNSR_DSCBRAH_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT328_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT328_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT328_GTDNSR_DSCBRAL = 0x1000
	// Disable counter count down on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTDNSR_DSCBRAL_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT328_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT328_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT328_GTDNSR_DSCAFBH = 0x800
	// Disable counter count down on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTDNSR_DSCAFBH_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT328_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT328_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT328_GTDNSR_DSCAFBL = 0x400
	// Disable counter count down on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTDNSR_DSCAFBL_0 = 0x0
	// Enable counter count down on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT328_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT328_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT328_GTDNSR_DSCARBH = 0x200
	// Disable counter count down on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTDNSR_DSCARBH_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT328_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT328_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT328_GTDNSR_DSCARBL = 0x100
	// Disable counter count down on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTDNSR_DSCARBL_0 = 0x0
	// Enable counter count down on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGDF field.
	GPT328_GTDNSR_DSGTRGDF_Pos = 0x7
	// Bit mask of DSGTRGDF field.
	GPT328_GTDNSR_DSGTRGDF_Msk = 0x80
	// Bit DSGTRGDF.
	GPT328_GTDNSR_DSGTRGDF = 0x80
	// Disable counter count down on the falling edge of GTETRGD input
	GPT328_GTDNSR_DSGTRGDF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGD input.
	GPT328_GTDNSR_DSGTRGDF_1 = 0x1
	// Position of DSGTRGDR field.
	GPT328_GTDNSR_DSGTRGDR_Pos = 0x6
	// Bit mask of DSGTRGDR field.
	GPT328_GTDNSR_DSGTRGDR_Msk = 0x40
	// Bit DSGTRGDR.
	GPT328_GTDNSR_DSGTRGDR = 0x40
	// Disable counter count down on the rising edge of GTETRGD input
	GPT328_GTDNSR_DSGTRGDR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGD input.
	GPT328_GTDNSR_DSGTRGDR_1 = 0x1
	// Position of DSGTRGCF field.
	GPT328_GTDNSR_DSGTRGCF_Pos = 0x5
	// Bit mask of DSGTRGCF field.
	GPT328_GTDNSR_DSGTRGCF_Msk = 0x20
	// Bit DSGTRGCF.
	GPT328_GTDNSR_DSGTRGCF = 0x20
	// Disable counter count down on the falling edge of GTETRGC input
	GPT328_GTDNSR_DSGTRGCF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGC input.
	GPT328_GTDNSR_DSGTRGCF_1 = 0x1
	// Position of DSGTRGCR field.
	GPT328_GTDNSR_DSGTRGCR_Pos = 0x4
	// Bit mask of DSGTRGCR field.
	GPT328_GTDNSR_DSGTRGCR_Msk = 0x10
	// Bit DSGTRGCR.
	GPT328_GTDNSR_DSGTRGCR = 0x10
	// Disable counter count down on the rising edge of GTETRGC input
	GPT328_GTDNSR_DSGTRGCR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGC input
	GPT328_GTDNSR_DSGTRGCR_1 = 0x1
	// Position of DSGTRGBF field.
	GPT328_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT328_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT328_GTDNSR_DSGTRGBF = 0x8
	// Disable counter count down on the falling edge of GTETRGB input
	GPT328_GTDNSR_DSGTRGBF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGB input.
	GPT328_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT328_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT328_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT328_GTDNSR_DSGTRGBR = 0x4
	// Disable counter count down on the rising edge of GTETRGB input
	GPT328_GTDNSR_DSGTRGBR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGB input.
	GPT328_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT328_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT328_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT328_GTDNSR_DSGTRGAF = 0x2
	// Disable counter count down on the falling edge of GTETRGA input
	GPT328_GTDNSR_DSGTRGAF_0 = 0x0
	// Enable counter count down on the falling edge of GTETRGA input.
	GPT328_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT328_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT328_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT328_GTDNSR_DSGTRGAR = 0x1
	// Disable counter count down on the rising edge of GTETRGA input
	GPT328_GTDNSR_DSGTRGAR_0 = 0x0
	// Enable counter count down on the rising edge of GTETRGA input
	GPT328_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCH field.
	GPT328_GTICASR_ASELCH_Pos = 0x17
	// Bit mask of ASELCH field.
	GPT328_GTICASR_ASELCH_Msk = 0x800000
	// Bit ASELCH.
	GPT328_GTICASR_ASELCH = 0x800000
	// Disable GTCCRA input capture on ELC_GPTH input
	GPT328_GTICASR_ASELCH_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTH input
	GPT328_GTICASR_ASELCH_1 = 0x1
	// Position of ASELCG field.
	GPT328_GTICASR_ASELCG_Pos = 0x16
	// Bit mask of ASELCG field.
	GPT328_GTICASR_ASELCG_Msk = 0x400000
	// Bit ASELCG.
	GPT328_GTICASR_ASELCG = 0x400000
	// Disable GTCCRA input capture on ELC_GPTG input
	GPT328_GTICASR_ASELCG_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTG input.
	GPT328_GTICASR_ASELCG_1 = 0x1
	// Position of ASELCF field.
	GPT328_GTICASR_ASELCF_Pos = 0x15
	// Bit mask of ASELCF field.
	GPT328_GTICASR_ASELCF_Msk = 0x200000
	// Bit ASELCF.
	GPT328_GTICASR_ASELCF = 0x200000
	// Disable GTCCRA input capture on ELC_GPTF input
	GPT328_GTICASR_ASELCF_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTF input.
	GPT328_GTICASR_ASELCF_1 = 0x1
	// Position of ASELCE field.
	GPT328_GTICASR_ASELCE_Pos = 0x14
	// Bit mask of ASELCE field.
	GPT328_GTICASR_ASELCE_Msk = 0x100000
	// Bit ASELCE.
	GPT328_GTICASR_ASELCE = 0x100000
	// Disable GTCCRA input capture on ELC_GPTE input
	GPT328_GTICASR_ASELCE_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTE input.
	GPT328_GTICASR_ASELCE_1 = 0x1
	// Position of ASELCD field.
	GPT328_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT328_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT328_GTICASR_ASELCD = 0x80000
	// Disable GTCCRA input capture on ELC_GPTD input
	GPT328_GTICASR_ASELCD_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTD input.
	GPT328_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT328_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT328_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT328_GTICASR_ASELCC = 0x40000
	// Disable GTCCRA input capture on ELC_GPTC input
	GPT328_GTICASR_ASELCC_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTC input.
	GPT328_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT328_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT328_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT328_GTICASR_ASELCB = 0x20000
	// Disable GTCCRA input capture on ELC_GPTB input
	GPT328_GTICASR_ASELCB_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTB input
	GPT328_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT328_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT328_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT328_GTICASR_ASELCA = 0x10000
	// Disable GTCCRA input capture on ELC_GPTA input
	GPT328_GTICASR_ASELCA_0 = 0x0
	// Enable GTCCRA input capture on ELC_GPTA input.
	GPT328_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT328_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT328_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT328_GTICASR_ASCBFAH = 0x8000
	// Disable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTICASR_ASCBFAH_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT328_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT328_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT328_GTICASR_ASCBFAL = 0x4000
	// Disable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTICASR_ASCBFAL_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT328_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT328_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT328_GTICASR_ASCBRAH = 0x2000
	// Disable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTICASR_ASCBRAH_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT328_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT328_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT328_GTICASR_ASCBRAL = 0x1000
	// Disable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTICASR_ASCBRAL_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT328_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT328_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT328_GTICASR_ASCAFBH = 0x800
	// Disable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTICASR_ASCAFBH_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT328_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT328_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT328_GTICASR_ASCAFBL = 0x400
	// Disable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTICASR_ASCAFBL_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT328_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT328_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT328_GTICASR_ASCARBH = 0x200
	// Disable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTICASR_ASCARBH_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT328_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT328_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT328_GTICASR_ASCARBL = 0x100
	// Disable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTICASR_ASCARBL_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGDF field.
	GPT328_GTICASR_ASGTRGDF_Pos = 0x7
	// Bit mask of ASGTRGDF field.
	GPT328_GTICASR_ASGTRGDF_Msk = 0x80
	// Bit ASGTRGDF.
	GPT328_GTICASR_ASGTRGDF = 0x80
	// Disable GTCCRA input capture on the falling edge of GTETRGD input
	GPT328_GTICASR_ASGTRGDF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGD input.
	GPT328_GTICASR_ASGTRGDF_1 = 0x1
	// Position of ASGTRGDR field.
	GPT328_GTICASR_ASGTRGDR_Pos = 0x6
	// Bit mask of ASGTRGDR field.
	GPT328_GTICASR_ASGTRGDR_Msk = 0x40
	// Bit ASGTRGDR.
	GPT328_GTICASR_ASGTRGDR = 0x40
	// Disable GTCCRA input capture on the rising edge of GTETRGD input
	GPT328_GTICASR_ASGTRGDR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGD input.
	GPT328_GTICASR_ASGTRGDR_1 = 0x1
	// Position of ASGTRGCF field.
	GPT328_GTICASR_ASGTRGCF_Pos = 0x5
	// Bit mask of ASGTRGCF field.
	GPT328_GTICASR_ASGTRGCF_Msk = 0x20
	// Bit ASGTRGCF.
	GPT328_GTICASR_ASGTRGCF = 0x20
	// Disable GTCCRA input capture on the falling edge of GTETRGC input
	GPT328_GTICASR_ASGTRGCF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGC input
	GPT328_GTICASR_ASGTRGCF_1 = 0x1
	// Position of ASGTRGCR field.
	GPT328_GTICASR_ASGTRGCR_Pos = 0x4
	// Bit mask of ASGTRGCR field.
	GPT328_GTICASR_ASGTRGCR_Msk = 0x10
	// Bit ASGTRGCR.
	GPT328_GTICASR_ASGTRGCR = 0x10
	// Disable GTCCRA input capture on the rising edge of GTETRGC input
	GPT328_GTICASR_ASGTRGCR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGC input.
	GPT328_GTICASR_ASGTRGCR_1 = 0x1
	// Position of ASGTRGBF field.
	GPT328_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT328_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT328_GTICASR_ASGTRGBF = 0x8
	// Disable GTCCRA input capture on the falling edge of GTETRGB input
	GPT328_GTICASR_ASGTRGBF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGB input.
	GPT328_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT328_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT328_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT328_GTICASR_ASGTRGBR = 0x4
	// Disable GTCCRA input capture on the rising edge of GTETRGB input
	GPT328_GTICASR_ASGTRGBR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGB input.
	GPT328_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT328_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT328_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT328_GTICASR_ASGTRGAF = 0x2
	// Disable GTCCRA input capture on the falling edge of GTETRGA input
	GPT328_GTICASR_ASGTRGAF_0 = 0x0
	// Enable GTCCRA input capture on the falling edge of GTETRGA input.
	GPT328_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT328_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT328_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT328_GTICASR_ASGTRGAR = 0x1
	// Disable GTCCRA input capture on the rising edge of GTETRGA input
	GPT328_GTICASR_ASGTRGAR_0 = 0x0
	// Enable GTCCRA input capture on the rising edge of GTETRGA input.
	GPT328_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCH field.
	GPT328_GTICBSR_BSELCH_Pos = 0x17
	// Bit mask of BSELCH field.
	GPT328_GTICBSR_BSELCH_Msk = 0x800000
	// Bit BSELCH.
	GPT328_GTICBSR_BSELCH = 0x800000
	// Disable GTCCRB input capture on ELC_GPTH input
	GPT328_GTICBSR_BSELCH_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTH input.
	GPT328_GTICBSR_BSELCH_1 = 0x1
	// Position of BSELCG field.
	GPT328_GTICBSR_BSELCG_Pos = 0x16
	// Bit mask of BSELCG field.
	GPT328_GTICBSR_BSELCG_Msk = 0x400000
	// Bit BSELCG.
	GPT328_GTICBSR_BSELCG = 0x400000
	// Disable GTCCRB input capture on ELC_GPTG input
	GPT328_GTICBSR_BSELCG_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTG input.
	GPT328_GTICBSR_BSELCG_1 = 0x1
	// Position of BSELCF field.
	GPT328_GTICBSR_BSELCF_Pos = 0x15
	// Bit mask of BSELCF field.
	GPT328_GTICBSR_BSELCF_Msk = 0x200000
	// Bit BSELCF.
	GPT328_GTICBSR_BSELCF = 0x200000
	// Disable GTCCRB input capture on ELC_GPTF input
	GPT328_GTICBSR_BSELCF_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTF input.
	GPT328_GTICBSR_BSELCF_1 = 0x1
	// Position of BSELCE field.
	GPT328_GTICBSR_BSELCE_Pos = 0x14
	// Bit mask of BSELCE field.
	GPT328_GTICBSR_BSELCE_Msk = 0x100000
	// Bit BSELCE.
	GPT328_GTICBSR_BSELCE = 0x100000
	// Disable GTCCRB input capture on ELC_GPTE input
	GPT328_GTICBSR_BSELCE_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTE input
	GPT328_GTICBSR_BSELCE_1 = 0x1
	// Position of BSELCD field.
	GPT328_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT328_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT328_GTICBSR_BSELCD = 0x80000
	// Disable GTCCRB input capture on ELC_GPTD input
	GPT328_GTICBSR_BSELCD_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTD input.
	GPT328_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT328_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT328_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT328_GTICBSR_BSELCC = 0x40000
	// Disable GTCCRB input capture on ELC_GPTC input
	GPT328_GTICBSR_BSELCC_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTC input
	GPT328_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT328_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT328_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT328_GTICBSR_BSELCB = 0x20000
	// Disable GTCCRB input capture on ELC_GPTB input
	GPT328_GTICBSR_BSELCB_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTB input.
	GPT328_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT328_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT328_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT328_GTICBSR_BSELCA = 0x10000
	// Disable GTCCRB input capture on ELC_GPTA input
	GPT328_GTICBSR_BSELCA_0 = 0x0
	// Enable GTCCRB input capture on ELC_GPTA input.
	GPT328_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT328_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT328_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT328_GTICBSR_BSCBFAH = 0x8000
	// Disable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTICBSR_BSCBFAH_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT328_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT328_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT328_GTICBSR_BSCBFAL = 0x4000
	// Disable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTICBSR_BSCBFAL_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT328_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT328_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT328_GTICBSR_BSCBRAH = 0x2000
	// Disable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 1
	GPT328_GTICBSR_BSCBRAH_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 1.
	GPT328_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT328_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT328_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT328_GTICBSR_BSCBRAL = 0x1000
	// Disable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 0
	GPT328_GTICBSR_BSCBRAL_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCB input when GTIOCA input is 0.
	GPT328_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT328_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT328_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT328_GTICBSR_BSCAFBH = 0x800
	// Disable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTICBSR_BSCAFBH_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT328_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT328_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT328_GTICBSR_BSCAFBL = 0x400
	// Disable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTICBSR_BSCAFBL_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT328_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT328_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT328_GTICBSR_BSCARBH = 0x200
	// Disable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 1
	GPT328_GTICBSR_BSCARBH_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 1.
	GPT328_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT328_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT328_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT328_GTICBSR_BSCARBL = 0x100
	// Disable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 0
	GPT328_GTICBSR_BSCARBL_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTIOCA input when GTIOCB input is 0.
	GPT328_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGDF field.
	GPT328_GTICBSR_BSGTRGDF_Pos = 0x7
	// Bit mask of BSGTRGDF field.
	GPT328_GTICBSR_BSGTRGDF_Msk = 0x80
	// Bit BSGTRGDF.
	GPT328_GTICBSR_BSGTRGDF = 0x80
	// Disable GTCCRB input capture on the falling edge of GTETRGD input
	GPT328_GTICBSR_BSGTRGDF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGD input.
	GPT328_GTICBSR_BSGTRGDF_1 = 0x1
	// Position of BSGTRGDR field.
	GPT328_GTICBSR_BSGTRGDR_Pos = 0x6
	// Bit mask of BSGTRGDR field.
	GPT328_GTICBSR_BSGTRGDR_Msk = 0x40
	// Bit BSGTRGDR.
	GPT328_GTICBSR_BSGTRGDR = 0x40
	// Disable GTCCRB input capture on the rising edge of GTETRGD input
	GPT328_GTICBSR_BSGTRGDR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGD input.
	GPT328_GTICBSR_BSGTRGDR_1 = 0x1
	// Position of BSGTRGCF field.
	GPT328_GTICBSR_BSGTRGCF_Pos = 0x5
	// Bit mask of BSGTRGCF field.
	GPT328_GTICBSR_BSGTRGCF_Msk = 0x20
	// Bit BSGTRGCF.
	GPT328_GTICBSR_BSGTRGCF = 0x20
	// Disable GTCCRB input capture on the falling edge of GTETRGC input
	GPT328_GTICBSR_BSGTRGCF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGC input.
	GPT328_GTICBSR_BSGTRGCF_1 = 0x1
	// Position of BSGTRGCR field.
	GPT328_GTICBSR_BSGTRGCR_Pos = 0x4
	// Bit mask of BSGTRGCR field.
	GPT328_GTICBSR_BSGTRGCR_Msk = 0x10
	// Bit BSGTRGCR.
	GPT328_GTICBSR_BSGTRGCR = 0x10
	// Disable GTCCRB input capture on the rising edge of GTETRGC input
	GPT328_GTICBSR_BSGTRGCR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGC input.
	GPT328_GTICBSR_BSGTRGCR_1 = 0x1
	// Position of BSGTRGBF field.
	GPT328_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT328_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT328_GTICBSR_BSGTRGBF = 0x8
	// Disable GTCCRB input capture on the falling edge of GTETRGB input
	GPT328_GTICBSR_BSGTRGBF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGB input.
	GPT328_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT328_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT328_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT328_GTICBSR_BSGTRGBR = 0x4
	// Disable GTCCRB input capture on the rising edge of GTETRGB input
	GPT328_GTICBSR_BSGTRGBR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGB input.
	GPT328_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT328_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT328_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT328_GTICBSR_BSGTRGAF = 0x2
	// Disable GTCCRB input capture on the falling edge of GTETRGA input
	GPT328_GTICBSR_BSGTRGAF_0 = 0x0
	// Enable GTCCRB input capture on the falling edge of GTETRGA input.
	GPT328_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT328_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT328_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT328_GTICBSR_BSGTRGAR = 0x1
	// Disable GTCCRB input capture on the rising edge of GTETRGA input
	GPT328_GTICBSR_BSGTRGAR_0 = 0x0
	// Enable GTCCRB input capture on the rising edge of GTETRGA input.
	GPT328_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT328_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT328_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT328_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT328_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT328_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT328_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT328_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT328_GTCR_TPCS_101 = 0x5
	// Position of MD field.
	GPT328_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT328_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT328_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT328_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT328_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT328_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (32-bit transfer at crest) (single buffer or double buffer possible)
	GPT328_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (32-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT328_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (64-bit transfer at trough) fixed buffer operation)
	GPT328_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT328_GTCR_MD_111 = 0x7
	// Position of CST field.
	GPT328_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT328_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT328_GTCR_CST = 0x1
	// Count operation is stopped
	GPT328_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT328_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT328_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT328_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT328_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0percent/100percent duty setting.
	GPT328_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0percent/100percent duty setting.
	GPT328_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT328_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT328_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT328_GTUDDTYC_OBDTYF = 0x4000000
	// Do not force setting
	GPT328_GTUDDTYC_OBDTYF_0 = 0x0
	// Force setting
	GPT328_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT328_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT328_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT328_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT328_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0percent
	GPT328_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100percent
	GPT328_GTUDDTYC_OBDTY_11 = 0x3
	// Position of OADTYR field.
	GPT328_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT328_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT328_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT328_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT328_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT328_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT328_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT328_GTUDDTYC_OADTYF = 0x40000
	// Do not force setting
	GPT328_GTUDDTYC_OADTYF_0 = 0x0
	// Force setting
	GPT328_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT328_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT328_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT328_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT328_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT328_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT328_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT328_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT328_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT328_GTUDDTYC_UDF = 0x2
	// Do not force setting
	GPT328_GTUDDTYC_UDF_0 = 0x0
	// Force setting
	GPT328_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT328_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT328_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT328_GTUDDTYC_UD = 0x1
	// Count down on GTCNT
	GPT328_GTUDDTYC_UD_0 = 0x0
	// Counts up on GTCNT
	GPT328_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT328_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT328_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT328_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT328_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT328_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT328_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT328_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT328_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT328_GTIOR_NFBEN = 0x20000000
	// Disable noise filter for GTIOCB pin
	GPT328_GTIOR_NFBEN_0 = 0x0
	// Enable noise filter for GTIOCB pin
	GPT328_GTIOR_NFBEN_1 = 0x1
	// Position of OBDF field.
	GPT328_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT328_GTIOR_OBDF_Msk = 0x6000000
	// Prohibit output disable
	GPT328_GTIOR_OBDF_00 = 0x0
	// Set GTIOCB pin to Hi-Z on output disable
	GPT328_GTIOR_OBDF_01 = 0x1
	// Set GTIOCB pin to 0 on output disable
	GPT328_GTIOR_OBDF_10 = 0x2
	// Set GTIOCB pin to 1 on output disable.
	GPT328_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT328_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT328_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT328_GTIOR_OBE = 0x1000000
	// Disable output
	GPT328_GTIOR_OBE_0 = 0x0
	// Enable output
	GPT328_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT328_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT328_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT328_GTIOR_OBHLD = 0x800000
	// Set GTIOCB pin output level on counting start and stop based on the register setting
	GPT328_GTIOR_OBHLD_0 = 0x0
	// Retain GTIOCB pin output level on counting start and stop
	GPT328_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT328_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT328_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT328_GTIOR_OBDFLT = 0x400000
	// Output low on GTIOCB pin when counting stops
	GPT328_GTIOR_OBDFLT_0 = 0x0
	// Output high on GTIOCB pin when counting stops
	GPT328_GTIOR_OBDFLT_1 = 0x1
	// Position of GTIOB field.
	GPT328_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT328_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT328_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT328_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT328_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT328_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT328_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT328_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT328_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT328_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT328_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT328_GTIOR_NFAEN = 0x2000
	// Disable noise filter for GTIOCA pin
	GPT328_GTIOR_NFAEN_0 = 0x0
	// Enable noise filter for GTIOCA pin.
	GPT328_GTIOR_NFAEN_1 = 0x1
	// Position of OADF field.
	GPT328_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT328_GTIOR_OADF_Msk = 0x600
	// Prohibit output disable
	GPT328_GTIOR_OADF_00 = 0x0
	// Set GTIOCA pin to Hi-Z on output disable
	GPT328_GTIOR_OADF_01 = 0x1
	// Set GTIOCA pin to 0 on output disable
	GPT328_GTIOR_OADF_10 = 0x2
	// Set GTIOCA pin to 1 on output disable.
	GPT328_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT328_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT328_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT328_GTIOR_OAE = 0x100
	// Disable output
	GPT328_GTIOR_OAE_0 = 0x0
	// Enable output.
	GPT328_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT328_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT328_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT328_GTIOR_OAHLD = 0x80
	// Set GTIOCA pin output level on counting start and stop based on the register setting.
	GPT328_GTIOR_OAHLD_0 = 0x0
	// Retain GTIOCA pin output level on counting start and stop
	GPT328_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT328_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT328_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT328_GTIOR_OADFLT = 0x40
	// Output low on GTIOCA pin when counting stops
	GPT328_GTIOR_OADFLT_0 = 0x0
	// Output high on GTIOCA pin when counting stops.
	GPT328_GTIOR_OADFLT_1 = 0x1
	// Position of GTIOA field.
	GPT328_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT328_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT328_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT328_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT328_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT328_GTINTAD_GRPABL = 0x40000000
	// Disable same time output level low disable request
	GPT328_GTINTAD_GRPABL_0 = 0x0
	// Enable same time output level low disable request
	GPT328_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT328_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT328_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT328_GTINTAD_GRPABH = 0x20000000
	// Disable same time output level high disable request
	GPT328_GTINTAD_GRPABH_0 = 0x0
	// Enable same time output level high disable request
	GPT328_GTINTAD_GRPABH_1 = 0x1
	// Position of GRP field.
	GPT328_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT328_GTINTAD_GRP_Msk = 0x3000000
	// Select Group A output disable request
	GPT328_GTINTAD_GRP_00 = 0x0
	// Select Group B output disable request
	GPT328_GTINTAD_GRP_01 = 0x1
	// Select Group C output disable request
	GPT328_GTINTAD_GRP_10 = 0x2
	// Select Group D output disable request.
	GPT328_GTINTAD_GRP_11 = 0x3

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT328_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT328_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT328_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT328_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT328_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT328_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT328_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT328_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT328_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT328_GTST_OABHF_1 = 0x1
	// Position of ODF field.
	GPT328_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT328_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT328_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT328_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT328_GTST_ODF_1 = 0x1
	// Position of TUCF field.
	GPT328_GTST_TUCF_Pos = 0xf
	// Bit mask of TUCF field.
	GPT328_GTST_TUCF_Msk = 0x8000
	// Bit TUCF.
	GPT328_GTST_TUCF = 0x8000
	// GTCNT counter is counting down
	GPT328_GTST_TUCF_0 = 0x0
	// GTCNT counter is counting up.
	GPT328_GTST_TUCF_1 = 0x1
	// Position of TCFPU field.
	GPT328_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT328_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT328_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT328_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT328_GTST_TCFPU_1 = 0x1
	// Position of TCPFO field.
	GPT328_GTST_TCPFO_Pos = 0x6
	// Bit mask of TCPFO field.
	GPT328_GTST_TCPFO_Msk = 0x40
	// Bit TCPFO.
	GPT328_GTST_TCPFO = 0x40
	// No overflow (crest) has occurred.
	GPT328_GTST_TCPFO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT328_GTST_TCPFO_1 = 0x1
	// Position of TCFF field.
	GPT328_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT328_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT328_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated.
	GPT328_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT328_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT328_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT328_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT328_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated.
	GPT328_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT328_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT328_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT328_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT328_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT328_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT328_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT328_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT328_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT328_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT328_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT328_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT328_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT328_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT328_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT328_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT328_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT328_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT328_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT328_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT328_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT328_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of CCRSWT field.
	GPT328_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT328_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT328_GTBER_CCRSWT = 0x400000
	// no effect
	GPT328_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT328_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT328_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT328_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT328_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT328_GTBER_PR_01 = 0x1
	// Position of CCRB field.
	GPT328_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT328_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT328_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT328_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT328_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT328_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT328_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT328_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT328_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT328_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT328_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT328_GTBER_CCRA_11 = 0x3
	// Position of BD1 field.
	GPT328_GTBER_BD1_Pos = 0x1
	// Bit mask of BD1 field.
	GPT328_GTBER_BD1_Msk = 0x2
	// Bit BD1.
	GPT328_GTBER_BD1 = 0x2
	// Enable buffer operation
	GPT328_GTBER_BD1_0 = 0x0
	// Disable buffer operation.
	GPT328_GTBER_BD1_1 = 0x1
	// Position of BD2 field.
	GPT328_GTBER_BD2_Pos = 0x0
	// Bit mask of BD2 field.
	GPT328_GTBER_BD2_Msk = 0x1
	// Bit BD2.
	GPT328_GTBER_BD2 = 0x1
	// Enable buffer operation
	GPT328_GTBER_BD2_0 = 0x0
	// Disable buffer operation.
	GPT328_GTBER_BD2_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT328_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT328_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of GTCCRA field.
	GPT328_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT328_GTCCRA_GTCCRA_Msk = 0xffffffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of GTCCRB field.
	GPT328_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT328_GTCCRB_GTCCRB_Msk = 0xffffffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of GTCCRC field.
	GPT328_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT328_GTCCRC_GTCCRC_Msk = 0xffffffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of GTCCRE field.
	GPT328_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT328_GTCCRE_GTCCRE_Msk = 0xffffffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of GTCCRD field.
	GPT328_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT328_GTCCRD_GTCCRD_Msk = 0xffffffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of GTCCRF field.
	GPT328_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT328_GTCCRF_GTCCRF_Msk = 0xffffffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of GTPR field.
	GPT328_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT328_GTPR_GTPR_Msk = 0xffffffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of GTPBR field.
	GPT328_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT328_GTPBR_GTPBR_Msk = 0xffffffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of TDE field.
	GPT328_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT328_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT328_GTDTCR_TDE = 0x1
	// Set GTCCRB without using GTDVU and GTDVD.
	GPT328_GTDTCR_TDE_0 = 0x0
	// Use GTDVU and GTDVD to set the compare match value for negative-phase waveform with automatic dead time in GTCCRB.
	GPT328_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of GTDVU field.
	GPT328_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT328_GTDVU_GTDVU_Msk = 0xffffffff
)

// Constants for RTC: Realtime Clock
const (
	// R64CNT: 64-Hz Counter
	// Position of F1HZ field.
	RTC_R64CNT_F1HZ_Pos = 0x6
	// Bit mask of F1HZ field.
	RTC_R64CNT_F1HZ_Msk = 0x40
	// Bit F1HZ.
	RTC_R64CNT_F1HZ = 0x40
	// Position of F2HZ field.
	RTC_R64CNT_F2HZ_Pos = 0x5
	// Bit mask of F2HZ field.
	RTC_R64CNT_F2HZ_Msk = 0x20
	// Bit F2HZ.
	RTC_R64CNT_F2HZ = 0x20
	// Position of F4HZ field.
	RTC_R64CNT_F4HZ_Pos = 0x4
	// Bit mask of F4HZ field.
	RTC_R64CNT_F4HZ_Msk = 0x10
	// Bit F4HZ.
	RTC_R64CNT_F4HZ = 0x10
	// Position of F8HZ field.
	RTC_R64CNT_F8HZ_Pos = 0x3
	// Bit mask of F8HZ field.
	RTC_R64CNT_F8HZ_Msk = 0x8
	// Bit F8HZ.
	RTC_R64CNT_F8HZ = 0x8
	// Position of F16HZ field.
	RTC_R64CNT_F16HZ_Pos = 0x2
	// Bit mask of F16HZ field.
	RTC_R64CNT_F16HZ_Msk = 0x4
	// Bit F16HZ.
	RTC_R64CNT_F16HZ = 0x4
	// Position of F32HZ field.
	RTC_R64CNT_F32HZ_Pos = 0x1
	// Bit mask of F32HZ field.
	RTC_R64CNT_F32HZ_Msk = 0x2
	// Bit F32HZ.
	RTC_R64CNT_F32HZ = 0x2
	// Position of F64HZ field.
	RTC_R64CNT_F64HZ_Pos = 0x0
	// Bit mask of F64HZ field.
	RTC_R64CNT_F64HZ_Msk = 0x1
	// Bit F64HZ.
	RTC_R64CNT_F64HZ = 0x1

	// RSECCNT: Second Counter
	// Position of SEC10 field.
	RTC_RSECCNT_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCNT_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECCNT_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCNT_SEC1_Msk = 0xf

	// BCNT0: Binary Counter 0
	// Position of BCNT0 field.
	RTC_BCNT0_BCNT0_Pos = 0x0
	// Bit mask of BCNT0 field.
	RTC_BCNT0_BCNT0_Msk = 0xff

	// RMINCNT: Minute Counter
	// Position of MIN10 field.
	RTC_RMINCNT_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCNT_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINCNT_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCNT_MIN1_Msk = 0xf

	// BCNT1: Binary Counter 1
	// Position of BCNT1 field.
	RTC_BCNT1_BCNT1_Pos = 0x0
	// Bit mask of BCNT1 field.
	RTC_BCNT1_BCNT1_Msk = 0xff

	// RHRCNT: Hour Counter
	// Position of PM field.
	RTC_RHRCNT_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCNT_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCNT_PM = 0x40
	// a.m.
	RTC_RHRCNT_PM_0 = 0x0
	// p.m.
	RTC_RHRCNT_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRCNT_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCNT_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRCNT_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCNT_HR1_Msk = 0xf

	// BCNT2: Binary Counter 2
	// Position of BCNT2 field.
	RTC_BCNT2_BCNT2_Pos = 0x0
	// Bit mask of BCNT2 field.
	RTC_BCNT2_BCNT2_Msk = 0xff

	// RWKCNT: Day-of-Week Counter
	// Position of DAYW field.
	RTC_RWKCNT_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKCNT_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKCNT_DAYW_000 = 0x0
	// Monday
	RTC_RWKCNT_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKCNT_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKCNT_DAYW_011 = 0x3
	// Thursday
	RTC_RWKCNT_DAYW_100 = 0x4
	// Friday
	RTC_RWKCNT_DAYW_101 = 0x5
	// Saturday
	RTC_RWKCNT_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKCNT_DAYW_111 = 0x7

	// BCNT3: Binary Counter 3
	// Position of BCNT3 field.
	RTC_BCNT3_BCNT3_Pos = 0x0
	// Bit mask of BCNT3 field.
	RTC_BCNT3_BCNT3_Msk = 0xff

	// RDAYCNT: Day Counter
	// Position of DATE10 field.
	RTC_RDAYCNT_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCNT_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYCNT_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCNT_DATE1_Msk = 0xf

	// RMONCNT: Month Counter
	// Position of MON10 field.
	RTC_RMONCNT_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCNT_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCNT_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONCNT_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCNT_MON1_Msk = 0xf

	// RYRCNT: Year Counter
	// Position of YR10 field.
	RTC_RYRCNT_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRCNT_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRCNT_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRCNT_YR1_Msk = 0xf

	// RSECAR: Second Alarm Register
	// Position of ENB field.
	RTC_RSECAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RSECAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RSECAR_ENB = 0x80
	// The register value is not compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_0 = 0x0
	// The register value is compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_1 = 0x1
	// Position of SEC10 field.
	RTC_RSECAR_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECAR_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECAR_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECAR_SEC1_Msk = 0xf

	// BCNT0AR: Binary Counter 0 Alarm Register
	// Position of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Pos = 0x0
	// Bit mask of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Msk = 0xff

	// RMINAR: Minute Alarm Register
	// Position of ENB field.
	RTC_RMINAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMINAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMINAR_ENB = 0x80
	// The register value is not compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_0 = 0x0
	// The register value is compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_1 = 0x1
	// Position of MIN10 field.
	RTC_RMINAR_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINAR_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINAR_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINAR_MIN1_Msk = 0xf

	// BCNT1AR: Binary Counter 1 Alarm Register
	// Position of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Pos = 0x0
	// Bit mask of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Msk = 0xff

	// RHRAR: Hour Alarm Register
	// Position of ENB field.
	RTC_RHRAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RHRAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RHRAR_ENB = 0x80
	// The register value is not compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_0 = 0x0
	// The register value is compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_1 = 0x1
	// Position of PM field.
	RTC_RHRAR_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRAR_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRAR_PM = 0x40
	// a.m.
	RTC_RHRAR_PM_0 = 0x0
	// p.m.
	RTC_RHRAR_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRAR_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRAR_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRAR_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRAR_HR1_Msk = 0xf

	// BCNT2AR: Binary Counter 2 Alarm Register
	// Position of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Pos = 0x0
	// Bit mask of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Msk = 0xff

	// RWKAR: Day-of-Week Alarm Register
	// Position of ENB field.
	RTC_RWKAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RWKAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RWKAR_ENB = 0x80
	// The register value is not compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_0 = 0x0
	// The register value is compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_1 = 0x1
	// Position of DAYW field.
	RTC_RWKAR_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKAR_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKAR_DAYW_000 = 0x0
	// Monday
	RTC_RWKAR_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKAR_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKAR_DAYW_011 = 0x3
	// Thursday
	RTC_RWKAR_DAYW_100 = 0x4
	// Friday
	RTC_RWKAR_DAYW_101 = 0x5
	// Saturday
	RTC_RWKAR_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKAR_DAYW_111 = 0x7

	// BCNT3AR: Binary Counter 3 Alarm Register
	// Position of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Pos = 0x0
	// Bit mask of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Msk = 0xff

	// RDAYAR: Date Alarm Register
	// Position of ENB field.
	RTC_RDAYAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RDAYAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RDAYAR_ENB = 0x80
	// The register value is not compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_0 = 0x0
	// The register value is compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_1 = 0x1
	// Position of DATE10 field.
	RTC_RDAYAR_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYAR_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYAR_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYAR_DATE1_Msk = 0xf

	// BCNT0AER: Binary Counter 0 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT0AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT0AER_ENB_Msk = 0xff

	// RMONAR: Month Alarm Register
	// Position of ENB field.
	RTC_RMONAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMONAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMONAR_ENB = 0x80
	// The register value is not compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_0 = 0x0
	// The register value is compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_1 = 0x1
	// Position of MON10 field.
	RTC_RMONAR_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONAR_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONAR_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONAR_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONAR_MON1_Msk = 0xf

	// BCNT1AER: Binary Counter 1 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT1AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT1AER_ENB_Msk = 0xff

	// RYRAR: Year Alarm Register
	// Position of YR10 field.
	RTC_RYRAR_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRAR_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRAR_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRAR_YR1_Msk = 0xf

	// BCNT2AER: Binary Counter 2 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT2AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT2AER_ENB_Msk = 0xff

	// RYRAREN: Year Alarm Enable Register
	// Position of ENB field.
	RTC_RYRAREN_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RYRAREN_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RYRAREN_ENB = 0x80
	// The register value is not compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_0 = 0x0
	// The register value is compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_1 = 0x1

	// BCNT3AER: Binary Counter 3 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT3AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT3AER_ENB_Msk = 0xff

	// RCR1: RTC Control Register 1
	// Position of PES field.
	RTC_RCR1_PES_Pos = 0x4
	// Bit mask of PES field.
	RTC_RCR1_PES_Msk = 0xf0
	// A periodic interrupt is generated every 1/256 second((RCR4.RCKSEL = 0)./A periodic interrupt is generated every 1/128 second((RCR4.RCKSEL = 1).
	RTC_RCR1_PES_0110 = 0x6
	// A periodic interrupt is generated every 1/128 second.
	RTC_RCR1_PES_0111 = 0x7
	// A periodic interrupt is generated every 1/64 second.
	RTC_RCR1_PES_1000 = 0x8
	// A periodic interrupt is generated every 1/32 second.
	RTC_RCR1_PES_1001 = 0x9
	// A periodic interrupt is generated every 1/16 second.
	RTC_RCR1_PES_1010 = 0xa
	// A periodic interrupt is generated every 1/8 second.
	RTC_RCR1_PES_1011 = 0xb
	// A periodic interrupt is generated every 1/4 second.
	RTC_RCR1_PES_1100 = 0xc
	// A periodic interrupt is generated every 1/2 second.
	RTC_RCR1_PES_1101 = 0xd
	// A periodic interrupt is generated every 1 second.
	RTC_RCR1_PES_1110 = 0xe
	// A periodic interrupt is generated every 2 seconds.
	RTC_RCR1_PES_1111 = 0xf
	// Position of RTCOS field.
	RTC_RCR1_RTCOS_Pos = 0x3
	// Bit mask of RTCOS field.
	RTC_RCR1_RTCOS_Msk = 0x8
	// Bit RTCOS.
	RTC_RCR1_RTCOS = 0x8
	// RTCOUT outputs 1 Hz.
	RTC_RCR1_RTCOS_0 = 0x0
	// RTCOUT outputs 64 Hz.
	RTC_RCR1_RTCOS_1 = 0x1
	// Position of PIE field.
	RTC_RCR1_PIE_Pos = 0x2
	// Bit mask of PIE field.
	RTC_RCR1_PIE_Msk = 0x4
	// Bit PIE.
	RTC_RCR1_PIE = 0x4
	// A periodic interrupt request is disabled.
	RTC_RCR1_PIE_0 = 0x0
	// A periodic interrupt request is enabled.
	RTC_RCR1_PIE_1 = 0x1
	// Position of CIE field.
	RTC_RCR1_CIE_Pos = 0x1
	// Bit mask of CIE field.
	RTC_RCR1_CIE_Msk = 0x2
	// Bit CIE.
	RTC_RCR1_CIE = 0x2
	// A carry interrupt request is disabled.
	RTC_RCR1_CIE_0 = 0x0
	// A carry interrupt request is enabled.
	RTC_RCR1_CIE_1 = 0x1
	// Position of AIE field.
	RTC_RCR1_AIE_Pos = 0x0
	// Bit mask of AIE field.
	RTC_RCR1_AIE_Msk = 0x1
	// Bit AIE.
	RTC_RCR1_AIE = 0x1
	// An alarm interrupt request is disabled.
	RTC_RCR1_AIE_0 = 0x0
	// An alarm interrupt request is enabled.
	RTC_RCR1_AIE_1 = 0x1

	// RCR2: RTC Control Register 2
	// Position of CNTMD field.
	RTC_RCR2_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_CNTMD = 0x80
	// The calendar count mode.
	RTC_RCR2_CNTMD_0 = 0x0
	// The binary count mode.
	RTC_RCR2_CNTMD_1 = 0x1
	// Position of HR24 field.
	RTC_RCR2_HR24_Pos = 0x6
	// Bit mask of HR24 field.
	RTC_RCR2_HR24_Msk = 0x40
	// Bit HR24.
	RTC_RCR2_HR24 = 0x40
	// The RTC operates in 12-hour mode.
	RTC_RCR2_HR24_0 = 0x0
	// The RTC operates in 24-hour mode.
	RTC_RCR2_HR24_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_AADJP = 0x20
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every minute.
	RTC_RCR2_AADJP_0 = 0x0
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every 10 seconds.
	RTC_RCR2_AADJP_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_AADJE = 0x10
	// Automatic adjustment is disabled.
	RTC_RCR2_AADJE_0 = 0x0
	// Automatic adjustment is enabled.
	RTC_RCR2_AADJE_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_RTCOE = 0x8
	// RTCOUT output disabled.
	RTC_RCR2_RTCOE_0 = 0x0
	// RTCOUT output enabled.
	RTC_RCR2_RTCOE_1 = 0x1
	// Position of ADJ30 field.
	RTC_RCR2_ADJ30_Pos = 0x2
	// Bit mask of ADJ30 field.
	RTC_RCR2_ADJ30_Msk = 0x4
	// Bit ADJ30.
	RTC_RCR2_ADJ30 = 0x4
	// Writing is invalid.(write) / In normal time operation, or 30-second adjustment has completed.(read)
	RTC_RCR2_ADJ30_0 = 0x0
	// 30-second adjustment is executed.(write) / During 30-second adjustment.(read)
	RTC_RCR2_ADJ30_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_RESET = 0x2
	// Writing is invalid.(write) / In normal time operation, or an RTC software reset has completed.(read)
	RTC_RCR2_RESET_0 = 0x0
	// The prescaler and the target registers for RTC software reset *1 are initialized.(write) / During an RTC software reset.(read)
	RTC_RCR2_RESET_1 = 0x1
	// Position of START field.
	RTC_RCR2_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_START = 0x1
	// Prescaler and time counter are stopped.
	RTC_RCR2_START_0 = 0x0
	// Prescaler and time counter operate normally.
	RTC_RCR2_START_1 = 0x1

	// RCR4: RTC Control Register 4
	// Position of RCKSEL field.
	RTC_RCR4_RCKSEL_Pos = 0x0
	// Bit mask of RCKSEL field.
	RTC_RCR4_RCKSEL_Msk = 0x1
	// Bit RCKSEL.
	RTC_RCR4_RCKSEL = 0x1
	// Sub-clock oscillator is selected.
	RTC_RCR4_RCKSEL_0 = 0x0
	// LOCO clock oscillator is selected.
	RTC_RCR4_RCKSEL_1 = 0x1

	// RFRH: Frequency Register H
	// Position of RFC16 field.
	RTC_RFRH_RFC16_Pos = 0x0
	// Bit mask of RFC16 field.
	RTC_RFRH_RFC16_Msk = 0x1
	// Bit RFC16.
	RTC_RFRH_RFC16 = 0x1

	// RFRL: Frequency Register L
	// Position of RFC field.
	RTC_RFRL_RFC_Pos = 0x0
	// Bit mask of RFC field.
	RTC_RFRL_RFC_Msk = 0xffff

	// RADJ: Time Error Adjustment Register
	// Position of PMADJ field.
	RTC_RADJ_PMADJ_Pos = 0x6
	// Bit mask of PMADJ field.
	RTC_RADJ_PMADJ_Msk = 0xc0
	// Adjustment is not performed.
	RTC_RADJ_PMADJ_00 = 0x0
	// Adjustment is performed by the addition to the prescaler.
	RTC_RADJ_PMADJ_01 = 0x1
	// Adjustment is performed by the subtraction from the prescaler.
	RTC_RADJ_PMADJ_10 = 0x2
	// Setting prohibited
	RTC_RADJ_PMADJ_11 = 0x3
	// Position of ADJ field.
	RTC_RADJ_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	RTC_RADJ_ADJ_Msk = 0x3f

	// RTCCR0: Time Capture Control Register %s
	// Position of TCNF field.
	RTC_RTCCR_TCNF_Pos = 0x4
	// Bit mask of TCNF field.
	RTC_RTCCR_TCNF_Msk = 0x30
	// The noise filter is off.
	RTC_RTCCR_TCNF_00 = 0x0
	// Setting prohibited
	RTC_RTCCR_TCNF_01 = 0x1
	// The noise filter is on (count source).
	RTC_RTCCR_TCNF_10 = 0x2
	// The noise filter is on (count source by divided by 32).
	RTC_RTCCR_TCNF_11 = 0x3
	// Position of TCST field.
	RTC_RTCCR_TCST_Pos = 0x2
	// Bit mask of TCST field.
	RTC_RTCCR_TCST_Msk = 0x4
	// Bit TCST.
	RTC_RTCCR_TCST = 0x4
	// No event is detected.
	RTC_RTCCR_TCST_0 = 0x0
	// An event is detected.
	RTC_RTCCR_TCST_1 = 0x1
	// Position of TCCT field.
	RTC_RTCCR_TCCT_Pos = 0x0
	// Bit mask of TCCT field.
	RTC_RTCCR_TCCT_Msk = 0x3
	// No event is detected.
	RTC_RTCCR_TCCT_00 = 0x0
	// Rising edge is detected.
	RTC_RTCCR_TCCT_01 = 0x1
	// Falling edge is detected.
	RTC_RTCCR_TCCT_10 = 0x2
	// Both edges are detected.
	RTC_RTCCR_TCCT_11 = 0x3

	// RSECCP0: Second Capture Register %s
	// Position of SEC10 field.
	RTC_RSECCP_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCP_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECCP_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCP_SEC1_Msk = 0xf

	// BCNT0CP0: BCNT0 Capture Register %s
	// Position of BCNT0CP field.
	RTC_BCNT0CP_BCNT0CP_Pos = 0x0
	// Bit mask of BCNT0CP field.
	RTC_BCNT0CP_BCNT0CP_Msk = 0xff

	// RMINCP0: Minute Capture Register %s
	// Position of MIN10 field.
	RTC_RMINCP_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCP_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINCP_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCP_MIN1_Msk = 0xf

	// BCNT1CP0: BCNT1 Capture Register %s
	// Position of BCNT1CP field.
	RTC_BCNT1CP_BCNT1CP_Pos = 0x0
	// Bit mask of BCNT1CP field.
	RTC_BCNT1CP_BCNT1CP_Msk = 0xff

	// RHRCP0: Hour Capture Register %s
	// Position of PM field.
	RTC_RHRCP_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCP_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCP_PM = 0x40
	// a.m.
	RTC_RHRCP_PM_0 = 0x0
	// p.m.
	RTC_RHRCP_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRCP_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCP_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRCP_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCP_HR1_Msk = 0xf

	// BCNT2CP0: BCNT2 Capture Register %s
	// Position of BCNT2CP field.
	RTC_BCNT2CP_BCNT2CP_Pos = 0x0
	// Bit mask of BCNT2CP field.
	RTC_BCNT2CP_BCNT2CP_Msk = 0xff

	// RDAYCP0: Date Capture Register %s
	// Position of DATE10 field.
	RTC_RDAYCP_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCP_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYCP_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCP_DATE1_Msk = 0xf

	// BCNT3CP0: BCNT3 Capture Register %s
	// Position of BCNT3CP field.
	RTC_BCNT3CP_BCNT3CP_Pos = 0x0
	// Bit mask of BCNT3CP field.
	RTC_BCNT3CP_BCNT3CP_Msk = 0xff

	// RMONCP0: Month Capture Register %s
	// Position of MON10 field.
	RTC_RMONCP_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCP_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCP_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONCP_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCP_MON1_Msk = 0xf
)

// Constants for SSIE0: Serial Sound Interface Enhanced (SSIE)
const (
	// SSICR: Control Register
	// Position of CKS field.
	SSIE0_SSICR_CKS_Pos = 0x1e
	// Bit mask of CKS field.
	SSIE0_SSICR_CKS_Msk = 0x40000000
	// Bit CKS.
	SSIE0_SSICR_CKS = 0x40000000
	// AUDIO_CLK input
	SSIE0_SSICR_CKS_0 = 0x0
	// Setting prohibited
	SSIE0_SSICR_CKS_1 = 0x1
	// Position of TUIEN field.
	SSIE0_SSICR_TUIEN_Pos = 0x1d
	// Bit mask of TUIEN field.
	SSIE0_SSICR_TUIEN_Msk = 0x20000000
	// Bit TUIEN.
	SSIE0_SSICR_TUIEN = 0x20000000
	// Disables an underflow interrupt.
	SSIE0_SSICR_TUIEN_0 = 0x0
	// Enables an underflow interrupt.
	SSIE0_SSICR_TUIEN_1 = 0x1
	// Position of TOIEN field.
	SSIE0_SSICR_TOIEN_Pos = 0x1c
	// Bit mask of TOIEN field.
	SSIE0_SSICR_TOIEN_Msk = 0x10000000
	// Bit TOIEN.
	SSIE0_SSICR_TOIEN = 0x10000000
	// Disables an overflow interrupt.
	SSIE0_SSICR_TOIEN_0 = 0x0
	// Enables an overflow interrupt.
	SSIE0_SSICR_TOIEN_1 = 0x1
	// Position of RUIEN field.
	SSIE0_SSICR_RUIEN_Pos = 0x1b
	// Bit mask of RUIEN field.
	SSIE0_SSICR_RUIEN_Msk = 0x8000000
	// Bit RUIEN.
	SSIE0_SSICR_RUIEN = 0x8000000
	// Disables an underflow interrupt.
	SSIE0_SSICR_RUIEN_0 = 0x0
	// Enables an underflow interrupt.
	SSIE0_SSICR_RUIEN_1 = 0x1
	// Position of ROIEN field.
	SSIE0_SSICR_ROIEN_Pos = 0x1a
	// Bit mask of ROIEN field.
	SSIE0_SSICR_ROIEN_Msk = 0x4000000
	// Bit ROIEN.
	SSIE0_SSICR_ROIEN = 0x4000000
	// Disables an overflow interrupt.
	SSIE0_SSICR_ROIEN_0 = 0x0
	// Enables an overflow interrupt.
	SSIE0_SSICR_ROIEN_1 = 0x1
	// Position of IIEN field.
	SSIE0_SSICR_IIEN_Pos = 0x19
	// Bit mask of IIEN field.
	SSIE0_SSICR_IIEN_Msk = 0x2000000
	// Bit IIEN.
	SSIE0_SSICR_IIEN = 0x2000000
	// Disables an idle mode interrupt.
	SSIE0_SSICR_IIEN_0 = 0x0
	// Enables an idle mode interrupt.
	SSIE0_SSICR_IIEN_1 = 0x1
	// Position of CHNL field.
	SSIE0_SSICR_CHNL_Pos = 0x16
	// Bit mask of CHNL field.
	SSIE0_SSICR_CHNL_Msk = 0xc00000
	// One channel
	SSIE0_SSICR_CHNL_00 = 0x0
	// Position of DWL field.
	SSIE0_SSICR_DWL_Pos = 0x13
	// Bit mask of DWL field.
	SSIE0_SSICR_DWL_Msk = 0x380000
	// 8 bits
	SSIE0_SSICR_DWL_000 = 0x0
	// 16 bits
	SSIE0_SSICR_DWL_001 = 0x1
	// 18 bits
	SSIE0_SSICR_DWL_010 = 0x2
	// 20 bits
	SSIE0_SSICR_DWL_011 = 0x3
	// 22 bits
	SSIE0_SSICR_DWL_100 = 0x4
	// 24 bits
	SSIE0_SSICR_DWL_101 = 0x5
	// Position of SWL field.
	SSIE0_SSICR_SWL_Pos = 0x10
	// Bit mask of SWL field.
	SSIE0_SSICR_SWL_Msk = 0x70000
	// 8 bits (serial bit clock frequency = 16fs )
	SSIE0_SSICR_SWL_000 = 0x0
	// 16 bits (serial bit clock frequency = 32fs )
	SSIE0_SSICR_SWL_001 = 0x1
	// 24 bits (serial bit clock frequency = 48fs )
	SSIE0_SSICR_SWL_010 = 0x2
	// 32 bits (serial bit clock frequency = 64fs )
	SSIE0_SSICR_SWL_011 = 0x3
	// Position of SWSD field.
	SSIE0_SSICR_SWSD_Pos = 0xe
	// Bit mask of SWSD field.
	SSIE0_SSICR_SWSD_Msk = 0x4000
	// Bit SWSD.
	SSIE0_SSICR_SWSD = 0x4000
	// Serial word select is input, slave mode.
	SSIE0_SSICR_SWSD_0 = 0x0
	// Serial word select is output, master mode.
	SSIE0_SSICR_SWSD_1 = 0x1
	// Position of SCKP field.
	SSIE0_SSICR_SCKP_Pos = 0xd
	// Bit mask of SCKP field.
	SSIE0_SSICR_SCKP_Msk = 0x2000
	// Bit SCKP.
	SSIE0_SSICR_SCKP = 0x2000
	// SSIWS and SSIDATA change at the SSISCK falling edge (sampled at the SCK rising edge).
	SSIE0_SSICR_SCKP_0 = 0x0
	// SSIWS and SSIDATA change at the SSISCK rising edge (sampled at the SCK falling edge).
	SSIE0_SSICR_SCKP_1 = 0x1
	// Position of SWSP field.
	SSIE0_SSICR_SWSP_Pos = 0xc
	// Bit mask of SWSP field.
	SSIE0_SSICR_SWSP_Msk = 0x1000
	// Bit SWSP.
	SSIE0_SSICR_SWSP = 0x1000
	// SSIWS is low for 1st channel, high for 2nd channel.
	SSIE0_SSICR_SWSP_0 = 0x0
	// SSIWS is high for 1st channel, low for 2nd channel.
	SSIE0_SSICR_SWSP_1 = 0x1
	// Position of SPDP field.
	SSIE0_SSICR_SPDP_Pos = 0xb
	// Bit mask of SPDP field.
	SSIE0_SSICR_SPDP_Msk = 0x800
	// Bit SPDP.
	SSIE0_SSICR_SPDP = 0x800
	// Padding bits are low.
	SSIE0_SSICR_SPDP_0 = 0x0
	// Padding bits are high.
	SSIE0_SSICR_SPDP_1 = 0x1
	// Position of SDTA field.
	SSIE0_SSICR_SDTA_Pos = 0xa
	// Bit mask of SDTA field.
	SSIE0_SSICR_SDTA_Msk = 0x400
	// Bit SDTA.
	SSIE0_SSICR_SDTA = 0x400
	// Transmitting and receiving in the order of serial data and padding bits
	SSIE0_SSICR_SDTA_0 = 0x0
	// Transmitting and receiving in the order of padding bits and serial data
	SSIE0_SSICR_SDTA_1 = 0x1
	// Position of PDTA field.
	SSIE0_SSICR_PDTA_Pos = 0x9
	// Bit mask of PDTA field.
	SSIE0_SSICR_PDTA_Msk = 0x200
	// Bit PDTA.
	SSIE0_SSICR_PDTA = 0x200
	// The lower bits of parallel data (SSITDR, SSIRDR) are transferred prior to the upper bits.(When data word length is 8 or 16 bits) / Parallel data (SSITDR, SSIRDR) is left-aligned.(When data word length is 18, 20, 22, or 24 bits)
	SSIE0_SSICR_PDTA_0 = 0x0
	// The upper bits of parallel data (SSITDR, SSIRDR) are transferred prior to the lower bits.(When data word length is 8 or 16 bits) / Parallel data (SSITDR, SSIRDR) is right-aligned.(When data word length is 18, 20, 22, or 24 bits)
	SSIE0_SSICR_PDTA_1 = 0x1
	// Position of DEL field.
	SSIE0_SSICR_DEL_Pos = 0x8
	// Bit mask of DEL field.
	SSIE0_SSICR_DEL_Msk = 0x100
	// Bit DEL.
	SSIE0_SSICR_DEL = 0x100
	// 1 clock cycle delay between SSIWS and SSIDATA
	SSIE0_SSICR_DEL_0 = 0x0
	// No delay between SSIWS and SSIDATA
	SSIE0_SSICR_DEL_1 = 0x1
	// Position of CKDV field.
	SSIE0_SSICR_CKDV_Pos = 0x4
	// Bit mask of CKDV field.
	SSIE0_SSICR_CKDV_Msk = 0xf0
	// CLK
	SSIE0_SSICR_CKDV_0x0 = 0x0
	// CLK/2
	SSIE0_SSICR_CKDV_0x1 = 0x1
	// CLK/4
	SSIE0_SSICR_CKDV_0x2 = 0x2
	// CLK/8
	SSIE0_SSICR_CKDV_0x3 = 0x3
	// CLK/16
	SSIE0_SSICR_CKDV_0x4 = 0x4
	// CLK/32
	SSIE0_SSICR_CKDV_0x5 = 0x5
	// CLK/64
	SSIE0_SSICR_CKDV_0x6 = 0x6
	// CLK/128
	SSIE0_SSICR_CKDV_0x7 = 0x7
	// CLK/6
	SSIE0_SSICR_CKDV_0x8 = 0x8
	// CLK/12 (These bits are only settable for channel 0. Setting these bits in the register for channel 1 is prohibited.)
	SSIE0_SSICR_CKDV_0x9 = 0x9
	// CLK/24
	SSIE0_SSICR_CKDV_0xA = 0xa
	// CLK/48(These bits are only settable for channel 0. Setting these bits in the register for channel 1 is prohibited.)
	SSIE0_SSICR_CKDV_0xB = 0xb
	// CLK/96(These bits are only settable for channel 0. Setting these bits in the register for channel 1 is prohibited.)
	SSIE0_SSICR_CKDV_0xC = 0xc
	// Position of MUEN field.
	SSIE0_SSICR_MUEN_Pos = 0x3
	// Bit mask of MUEN field.
	SSIE0_SSICR_MUEN_Msk = 0x8
	// Bit MUEN.
	SSIE0_SSICR_MUEN = 0x8
	// This module is not muted.
	SSIE0_SSICR_MUEN_0 = 0x0
	// This module is muted.
	SSIE0_SSICR_MUEN_1 = 0x1
	// Position of TEN field.
	SSIE0_SSICR_TEN_Pos = 0x1
	// Bit mask of TEN field.
	SSIE0_SSICR_TEN_Msk = 0x2
	// Bit TEN.
	SSIE0_SSICR_TEN = 0x2
	// Disables the transmit operation.
	SSIE0_SSICR_TEN_0 = 0x0
	// Enables the transmit operation.
	SSIE0_SSICR_TEN_1 = 0x1
	// Position of REN field.
	SSIE0_SSICR_REN_Pos = 0x0
	// Bit mask of REN field.
	SSIE0_SSICR_REN_Msk = 0x1
	// Bit REN.
	SSIE0_SSICR_REN = 0x1
	// Disables the receive operation.
	SSIE0_SSICR_REN_0 = 0x0
	// Enables the receive operation.
	SSIE0_SSICR_REN_1 = 0x1

	// SSISR: Status Register
	// Position of TUIRQ field.
	SSIE0_SSISR_TUIRQ_Pos = 0x1d
	// Bit mask of TUIRQ field.
	SSIE0_SSISR_TUIRQ_Msk = 0x20000000
	// Bit TUIRQ.
	SSIE0_SSISR_TUIRQ = 0x20000000
	// No transmit underflow has occurred.
	SSIE0_SSISR_TUIRQ_0 = 0x0
	// A transmit underflow has occurred.
	SSIE0_SSISR_TUIRQ_1 = 0x1
	// Position of TOIRQ field.
	SSIE0_SSISR_TOIRQ_Pos = 0x1c
	// Bit mask of TOIRQ field.
	SSIE0_SSISR_TOIRQ_Msk = 0x10000000
	// Bit TOIRQ.
	SSIE0_SSISR_TOIRQ = 0x10000000
	// No transmit overflow has occurred.
	SSIE0_SSISR_TOIRQ_0 = 0x0
	// A transmit overflow has occurred.
	SSIE0_SSISR_TOIRQ_1 = 0x1
	// Position of RUIRQ field.
	SSIE0_SSISR_RUIRQ_Pos = 0x1b
	// Bit mask of RUIRQ field.
	SSIE0_SSISR_RUIRQ_Msk = 0x8000000
	// Bit RUIRQ.
	SSIE0_SSISR_RUIRQ = 0x8000000
	// No receive underflow has occurred.
	SSIE0_SSISR_RUIRQ_0 = 0x0
	// A receive underflow has occurred.
	SSIE0_SSISR_RUIRQ_1 = 0x1
	// Position of ROIRQ field.
	SSIE0_SSISR_ROIRQ_Pos = 0x1a
	// Bit mask of ROIRQ field.
	SSIE0_SSISR_ROIRQ_Msk = 0x4000000
	// Bit ROIRQ.
	SSIE0_SSISR_ROIRQ = 0x4000000
	// No receive overflow has occurred.
	SSIE0_SSISR_ROIRQ_0 = 0x0
	// A receive overflow has occurred.
	SSIE0_SSISR_ROIRQ_1 = 0x1
	// Position of IIRQ field.
	SSIE0_SSISR_IIRQ_Pos = 0x19
	// Bit mask of IIRQ field.
	SSIE0_SSISR_IIRQ_Msk = 0x2000000
	// Bit IIRQ.
	SSIE0_SSISR_IIRQ = 0x2000000
	// This module is not in idle state.
	SSIE0_SSISR_IIRQ_0 = 0x0
	// This module is in idle state.
	SSIE0_SSISR_IIRQ_1 = 0x1
	// Position of TCHNO field.
	SSIE0_SSISR_TCHNO_Pos = 0x5
	// Bit mask of TCHNO field.
	SSIE0_SSISR_TCHNO_Msk = 0x60
	// Position of TSWNO field.
	SSIE0_SSISR_TSWNO_Pos = 0x4
	// Bit mask of TSWNO field.
	SSIE0_SSISR_TSWNO_Msk = 0x10
	// Bit TSWNO.
	SSIE0_SSISR_TSWNO = 0x10
	// Position of RCHNO field.
	SSIE0_SSISR_RCHNO_Pos = 0x2
	// Bit mask of RCHNO field.
	SSIE0_SSISR_RCHNO_Msk = 0xc
	// Position of RSWNO field.
	SSIE0_SSISR_RSWNO_Pos = 0x1
	// Bit mask of RSWNO field.
	SSIE0_SSISR_RSWNO_Msk = 0x2
	// Bit RSWNO.
	SSIE0_SSISR_RSWNO = 0x2
	// Position of IDST field.
	SSIE0_SSISR_IDST_Pos = 0x0
	// Bit mask of IDST field.
	SSIE0_SSISR_IDST_Msk = 0x1
	// Bit IDST.
	SSIE0_SSISR_IDST = 0x1
	// Serial bus is operating.
	SSIE0_SSISR_IDST_0 = 0x0
	// The current communication is stopped.
	SSIE0_SSISR_IDST_1 = 0x1

	// SSIFCR: FIFO Control Register
	// Position of AUCKE field.
	SSIE0_SSIFCR_AUCKE_Pos = 0x1f
	// Bit mask of AUCKE field.
	SSIE0_SSIFCR_AUCKE_Msk = 0x80000000
	// Bit AUCKE.
	SSIE0_SSIFCR_AUCKE = 0x80000000
	// The oversampling clock is disabled.
	SSIE0_SSIFCR_AUCKE_0 = 0x0
	// The oversampling clock is enabled.
	SSIE0_SSIFCR_AUCKE_1 = 0x1
	// Position of SSIRST field.
	SSIE0_SSIFCR_SSIRST_Pos = 0x10
	// Bit mask of SSIRST field.
	SSIE0_SSIFCR_SSIRST_Msk = 0x10000
	// Bit SSIRST.
	SSIE0_SSIFCR_SSIRST = 0x10000
	// Clears the SSI software reset.
	SSIE0_SSIFCR_SSIRST_0 = 0x0
	// initiates the SSI software reset.
	SSIE0_SSIFCR_SSIRST_1 = 0x1
	// Position of TTRG field.
	SSIE0_SSIFCR_TTRG_Pos = 0x6
	// Bit mask of TTRG field.
	SSIE0_SSIFCR_TTRG_Msk = 0xc0
	// 7 (1)
	SSIE0_SSIFCR_TTRG_00 = 0x0
	// 6 (2)
	SSIE0_SSIFCR_TTRG_01 = 0x1
	// 4 (4)
	SSIE0_SSIFCR_TTRG_10 = 0x2
	// 2 (6)
	SSIE0_SSIFCR_TTRG_11 = 0x3
	// Position of RTRG field.
	SSIE0_SSIFCR_RTRG_Pos = 0x4
	// Bit mask of RTRG field.
	SSIE0_SSIFCR_RTRG_Msk = 0x30
	// 1
	SSIE0_SSIFCR_RTRG_00 = 0x0
	// 2
	SSIE0_SSIFCR_RTRG_01 = 0x1
	// 4
	SSIE0_SSIFCR_RTRG_10 = 0x2
	// 6
	SSIE0_SSIFCR_RTRG_11 = 0x3
	// Position of TIE field.
	SSIE0_SSIFCR_TIE_Pos = 0x3
	// Bit mask of TIE field.
	SSIE0_SSIFCR_TIE_Msk = 0x8
	// Bit TIE.
	SSIE0_SSIFCR_TIE = 0x8
	// Transmit data empty interrupt (TXI) request is disabled
	SSIE0_SSIFCR_TIE_0 = 0x0
	// Transmit data empty interrupt (TXI) request is enabled
	SSIE0_SSIFCR_TIE_1 = 0x1
	// Position of RIE field.
	SSIE0_SSIFCR_RIE_Pos = 0x2
	// Bit mask of RIE field.
	SSIE0_SSIFCR_RIE_Msk = 0x4
	// Bit RIE.
	SSIE0_SSIFCR_RIE = 0x4
	// Receive data full interrupt (RXI) request is disabled
	SSIE0_SSIFCR_RIE_0 = 0x0
	// Receive data full interrupt (RXI) request is enabled
	SSIE0_SSIFCR_RIE_1 = 0x1
	// Position of TFRST field.
	SSIE0_SSIFCR_TFRST_Pos = 0x1
	// Bit mask of TFRST field.
	SSIE0_SSIFCR_TFRST_Msk = 0x2
	// Bit TFRST.
	SSIE0_SSIFCR_TFRST = 0x2
	// Clears the transmit data FIFO reset.
	SSIE0_SSIFCR_TFRST_0 = 0x0
	// Initiates the transmit data FIFO reset.
	SSIE0_SSIFCR_TFRST_1 = 0x1
	// Position of RFRST field.
	SSIE0_SSIFCR_RFRST_Pos = 0x0
	// Bit mask of RFRST field.
	SSIE0_SSIFCR_RFRST_Msk = 0x1
	// Bit RFRST.
	SSIE0_SSIFCR_RFRST = 0x1
	// Clears the receive data FIFO reset.
	SSIE0_SSIFCR_RFRST_0 = 0x0
	// Initiates the receive data FIFO reset.
	SSIE0_SSIFCR_RFRST_1 = 0x1

	// SSIFSR: FIFO Status Register
	// Position of TDC field.
	SSIE0_SSIFSR_TDC_Pos = 0x18
	// Bit mask of TDC field.
	SSIE0_SSIFSR_TDC_Msk = 0xf000000
	// Position of TDE field.
	SSIE0_SSIFSR_TDE_Pos = 0x10
	// Bit mask of TDE field.
	SSIE0_SSIFSR_TDE_Msk = 0x10000
	// Bit TDE.
	SSIE0_SSIFSR_TDE = 0x10000
	// Number of data bytes for transmission in SSIFTDR is greater than the set transmit trigger number.
	SSIE0_SSIFSR_TDE_0 = 0x0
	// Number of data bytes for transmission in SSIFTDR is equal to or less than the set transmit trigger number.
	SSIE0_SSIFSR_TDE_1 = 0x1
	// Position of RDC field.
	SSIE0_SSIFSR_RDC_Pos = 0x8
	// Bit mask of RDC field.
	SSIE0_SSIFSR_RDC_Msk = 0xf00
	// Position of RDF field.
	SSIE0_SSIFSR_RDF_Pos = 0x0
	// Bit mask of RDF field.
	SSIE0_SSIFSR_RDF_Msk = 0x1
	// Bit RDF.
	SSIE0_SSIFSR_RDF = 0x1
	// Number of received data bytes in SSIFRDR is less than the set receive trigger number.
	SSIE0_SSIFSR_RDF_0 = 0x0
	// Number of received data bytes in SSIFRDR is equal to or greater than the set receive trigger number.
	SSIE0_SSIFSR_RDF_1 = 0x1

	// SSIFTDR: Transmit FIFO Data Register
	// Position of SSIFTDR field.
	SSIE0_SSIFTDR_SSIFTDR_Pos = 0x0
	// Bit mask of SSIFTDR field.
	SSIE0_SSIFTDR_SSIFTDR_Msk = 0xffffffff

	// SSIFRDR: Receive FIFO Data Register
	// Position of SSIFRDR field.
	SSIE0_SSIFRDR_SSIFRDR_Pos = 0x0
	// Bit mask of SSIFRDR field.
	SSIE0_SSIFRDR_SSIFRDR_Msk = 0xffffffff

	// SSIOFR: Audio Format Register
	// Position of BCKASTP field.
	SSIE0_SSIOFR_BCKASTP_Pos = 0x9
	// Bit mask of BCKASTP field.
	SSIE0_SSIOFR_BCKASTP_Msk = 0x200
	// Bit BCKASTP.
	SSIE0_SSIOFR_BCKASTP = 0x200
	// Always outputs BCK to the SSIBCK pin.
	SSIE0_SSIOFR_BCKASTP_0 = 0x0
	// Automatically controls output of BCK to the SSIBCK pin.
	SSIE0_SSIOFR_BCKASTP_1 = 0x1
	// Position of LRCONT field.
	SSIE0_SSIOFR_LRCONT_Pos = 0x8
	// Bit mask of LRCONT field.
	SSIE0_SSIOFR_LRCONT_Msk = 0x100
	// Bit LRCONT.
	SSIE0_SSIOFR_LRCONT = 0x100
	// Disables LRCK/FS continuation.
	SSIE0_SSIOFR_LRCONT_0 = 0x0
	// Enables LRCK/FS continuation.
	SSIE0_SSIOFR_LRCONT_1 = 0x1
	// Position of OMOD field.
	SSIE0_SSIOFR_OMOD_Pos = 0x0
	// Bit mask of OMOD field.
	SSIE0_SSIOFR_OMOD_Msk = 0x3
	// I2S format
	SSIE0_SSIOFR_OMOD_00 = 0x0
	// TDM format
	SSIE0_SSIOFR_OMOD_01 = 0x1
	// Monaural format
	SSIE0_SSIOFR_OMOD_10 = 0x2
	// Setting prohibited.
	SSIE0_SSIOFR_OMOD_11 = 0x3

	// SSISCR: Status Control Register
	// Position of TDES field.
	SSIE0_SSISCR_TDES_Pos = 0x8
	// Bit mask of TDES field.
	SSIE0_SSISCR_TDES_Msk = 0x1f00
	// SSIFTDR has one stage or more free space
	SSIE0_SSISCR_TDES_00000 = 0x0
	// SSIFTDR has two stages or more free space (snip)
	SSIE0_SSISCR_TDES_00001 = 0x1
	// SSIFTDR has thirty-one stages or more free space
	SSIE0_SSISCR_TDES_11110 = 0x1e
	// SSIFTDR has thirty-two stages or more free space.
	SSIE0_SSISCR_TDES_11111 = 0x1f
	// Position of RDFS field.
	SSIE0_SSISCR_RDFS_Pos = 0x0
	// Bit mask of RDFS field.
	SSIE0_SSISCR_RDFS_Msk = 0x1f
	// SSIFRDR has one stage or more data size
	SSIE0_SSISCR_RDFS_00000 = 0x0
	// SSIFRDR has two stages or more data size (snip)
	SSIE0_SSISCR_RDFS_00001 = 0x1
	// SSIFRDR has thirty-one stages or more data size
	SSIE0_SSISCR_RDFS_11110 = 0x1e
	// SSIFRDR has thirty-two stages or more data size.
	SSIE0_SSISCR_RDFS_11111 = 0x1f
)

// Constants for USBFS: USB 2.0 FS Module
const (
	// SYSCFG: System Configuration Control Register
	// Position of SCKE field.
	USBFS_SYSCFG_SCKE_Pos = 0xa
	// Bit mask of SCKE field.
	USBFS_SYSCFG_SCKE_Msk = 0x400
	// Bit SCKE.
	USBFS_SYSCFG_SCKE = 0x400
	// Stops supplying the clock signal to the USB.
	USBFS_SYSCFG_SCKE_0 = 0x0
	// Enables supplying the clock signal to the USB.
	USBFS_SYSCFG_SCKE_1 = 0x1
	// Position of DCFM field.
	USBFS_SYSCFG_DCFM_Pos = 0x6
	// Bit mask of DCFM field.
	USBFS_SYSCFG_DCFM_Msk = 0x40
	// Bit DCFM.
	USBFS_SYSCFG_DCFM = 0x40
	// Function controller is selected.
	USBFS_SYSCFG_DCFM_0 = 0x0
	// Host controller is selected.
	USBFS_SYSCFG_DCFM_1 = 0x1
	// Position of DRPD field.
	USBFS_SYSCFG_DRPD_Pos = 0x5
	// Bit mask of DRPD field.
	USBFS_SYSCFG_DRPD_Msk = 0x20
	// Bit DRPD.
	USBFS_SYSCFG_DRPD = 0x20
	// Pulling down the lines is disabled.
	USBFS_SYSCFG_DRPD_0 = 0x0
	// Pulling down the lines is enabled.
	USBFS_SYSCFG_DRPD_1 = 0x1
	// Position of DPRPU field.
	USBFS_SYSCFG_DPRPU_Pos = 0x4
	// Bit mask of DPRPU field.
	USBFS_SYSCFG_DPRPU_Msk = 0x10
	// Bit DPRPU.
	USBFS_SYSCFG_DPRPU = 0x10
	// Pulling up the line is disabled.
	USBFS_SYSCFG_DPRPU_0 = 0x0
	// Pulling up the line is enabled.
	USBFS_SYSCFG_DPRPU_1 = 0x1
	// Position of USBE field.
	USBFS_SYSCFG_USBE_Pos = 0x0
	// Bit mask of USBE field.
	USBFS_SYSCFG_USBE_Msk = 0x1
	// Bit USBE.
	USBFS_SYSCFG_USBE = 0x1
	// USB operation is disabled.
	USBFS_SYSCFG_USBE_0 = 0x0
	// USB operation is enabled.
	USBFS_SYSCFG_USBE_1 = 0x1

	// SYSSTS0: System Configuration Status Register 0
	// Position of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Pos = 0xe
	// Bit mask of OVCMON field.
	USBFS_SYSSTS0_OVCMON_Msk = 0xc000
	// Position of HTACT field.
	USBFS_SYSSTS0_HTACT_Pos = 0x6
	// Bit mask of HTACT field.
	USBFS_SYSSTS0_HTACT_Msk = 0x40
	// Bit HTACT.
	USBFS_SYSSTS0_HTACT = 0x40
	// Host sequencer of the USB is completely stopped.
	USBFS_SYSSTS0_HTACT_0 = 0x0
	// Host sequencer of the USB is not completely stopped.
	USBFS_SYSSTS0_HTACT_1 = 0x1
	// Position of SOFEA field.
	USBFS_SYSSTS0_SOFEA_Pos = 0x5
	// Bit mask of SOFEA field.
	USBFS_SYSSTS0_SOFEA_Msk = 0x20
	// Bit SOFEA.
	USBFS_SYSSTS0_SOFEA = 0x20
	// SOF output is stopped.
	USBFS_SYSSTS0_SOFEA_0 = 0x0
	// SOF output is operating.
	USBFS_SYSSTS0_SOFEA_1 = 0x1
	// Position of IDMON field.
	USBFS_SYSSTS0_IDMON_Pos = 0x2
	// Bit mask of IDMON field.
	USBFS_SYSSTS0_IDMON_Msk = 0x4
	// Bit IDMON.
	USBFS_SYSSTS0_IDMON = 0x4
	// USB0_ID pin is low
	USBFS_SYSSTS0_IDMON_0 = 0x0
	// USB0_ID pin is high
	USBFS_SYSSTS0_IDMON_1 = 0x1
	// Position of LNST field.
	USBFS_SYSSTS0_LNST_Pos = 0x0
	// Bit mask of LNST field.
	USBFS_SYSSTS0_LNST_Msk = 0x3
	// SE0
	USBFS_SYSSTS0_LNST_00 = 0x0
	// J-State
	USBFS_SYSSTS0_LNST_01 = 0x1
	// K-State
	USBFS_SYSSTS0_LNST_10 = 0x2
	// SE1
	USBFS_SYSSTS0_LNST_11 = 0x3

	// DVSTCTR0: Device State Control Register 0
	// Position of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Pos = 0xb
	// Bit mask of HNPBTOA field.
	USBFS_DVSTCTR0_HNPBTOA_Msk = 0x800
	// Bit HNPBTOA.
	USBFS_DVSTCTR0_HNPBTOA = 0x800
	// Normal Operation
	USBFS_DVSTCTR0_HNPBTOA_0 = 0x0
	// Switching from device B to device A is enabled
	USBFS_DVSTCTR0_HNPBTOA_1 = 0x1
	// Position of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Pos = 0xa
	// Bit mask of EXICEN field.
	USBFS_DVSTCTR0_EXICEN_Msk = 0x400
	// Bit EXICEN.
	USBFS_DVSTCTR0_EXICEN = 0x400
	// External USB0_EXICEN pin outputs low
	USBFS_DVSTCTR0_EXICEN_0 = 0x0
	// External USB0_EXICEN pin outputs high
	USBFS_DVSTCTR0_EXICEN_1 = 0x1
	// Position of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Pos = 0x9
	// Bit mask of VBUSEN field.
	USBFS_DVSTCTR0_VBUSEN_Msk = 0x200
	// Bit VBUSEN.
	USBFS_DVSTCTR0_VBUSEN = 0x200
	// External USB0_VBUSEN pin outputs low
	USBFS_DVSTCTR0_VBUSEN_0 = 0x0
	// External USB0_VBUSEN pin outputs high
	USBFS_DVSTCTR0_VBUSEN_1 = 0x1
	// Position of WKUP field.
	USBFS_DVSTCTR0_WKUP_Pos = 0x8
	// Bit mask of WKUP field.
	USBFS_DVSTCTR0_WKUP_Msk = 0x100
	// Bit WKUP.
	USBFS_DVSTCTR0_WKUP = 0x100
	// Remote wakeup signal is not output.
	USBFS_DVSTCTR0_WKUP_0 = 0x0
	// Remote wakeup signal is output.
	USBFS_DVSTCTR0_WKUP_1 = 0x1
	// Position of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Pos = 0x7
	// Bit mask of RWUPE field.
	USBFS_DVSTCTR0_RWUPE_Msk = 0x80
	// Bit RWUPE.
	USBFS_DVSTCTR0_RWUPE = 0x80
	// Downstream port wakeup is disabled.
	USBFS_DVSTCTR0_RWUPE_0 = 0x0
	// Downstream port wakeup is enabled.
	USBFS_DVSTCTR0_RWUPE_1 = 0x1
	// Position of USBRST field.
	USBFS_DVSTCTR0_USBRST_Pos = 0x6
	// Bit mask of USBRST field.
	USBFS_DVSTCTR0_USBRST_Msk = 0x40
	// Bit USBRST.
	USBFS_DVSTCTR0_USBRST = 0x40
	// USB bus reset signal is not output.
	USBFS_DVSTCTR0_USBRST_0 = 0x0
	// USB bus reset signal is output.
	USBFS_DVSTCTR0_USBRST_1 = 0x1
	// Position of RESUME field.
	USBFS_DVSTCTR0_RESUME_Pos = 0x5
	// Bit mask of RESUME field.
	USBFS_DVSTCTR0_RESUME_Msk = 0x20
	// Bit RESUME.
	USBFS_DVSTCTR0_RESUME = 0x20
	// Resume signal is not output.
	USBFS_DVSTCTR0_RESUME_0 = 0x0
	// Resume signal is output.
	USBFS_DVSTCTR0_RESUME_1 = 0x1
	// Position of UACT field.
	USBFS_DVSTCTR0_UACT_Pos = 0x4
	// Bit mask of UACT field.
	USBFS_DVSTCTR0_UACT_Msk = 0x10
	// Bit UACT.
	USBFS_DVSTCTR0_UACT = 0x10
	// Downstream port is disabled (SOF transmission is disabled).
	USBFS_DVSTCTR0_UACT_0 = 0x0
	// Downstream port is enabled (SOF transmission is enabled).
	USBFS_DVSTCTR0_UACT_1 = 0x1
	// Position of RHST field.
	USBFS_DVSTCTR0_RHST_Pos = 0x0
	// Bit mask of RHST field.
	USBFS_DVSTCTR0_RHST_Msk = 0x7
	// Communication speed not determined
	USBFS_DVSTCTR0_RHST_000 = 0x0
	// Low-speed connection(When the host controller is selected) /USB bus reset in progress( When the function controller is selected)
	USBFS_DVSTCTR0_RHST_001 = 0x1
	// Full-speed connection(When the host controller is selected) /USB bus reset in progress or full-speed connection(When the function controller is selected)
	USBFS_DVSTCTR0_RHST_010 = 0x2
	// Setting prohibited
	USBFS_DVSTCTR0_RHST_011 = 0x3

	// CFIFO: CFIFO Port Register
	// Position of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Msk = 0xffff

	// D0FIFO: D0FIFO Port Register
	// Position of FIFOPORT field.
	USBFS_D0FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_D0FIFO_FIFOPORT_Msk = 0xffff

	// D1FIFO: D1FIFO Port Register
	// Position of FIFOPORT field.
	USBFS_D1FIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_D1FIFO_FIFOPORT_Msk = 0xffff

	// CFIFOSEL: CFIFO Port Select Register
	// Position of RCNT field.
	USBFS_CFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_CFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_CFIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the CFIFO.(In double buffer mode, the DTLN[8:0] bit value is cleared when all the data has been read from only a single plane.)
	USBFS_CFIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the CFIFO.
	USBFS_CFIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_CFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_CFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_CFIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_CFIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_CFIFOSEL_REW_1 = 0x1
	// Position of MBW field.
	USBFS_CFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_CFIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_CFIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_CFIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_CFIFOSEL_MBW_1 = 0x1
	// Position of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_CFIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_CFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_CFIFOSEL_BIGEND_1 = 0x1
	// Position of ISEL field.
	USBFS_CFIFOSEL_ISEL_Pos = 0x5
	// Bit mask of ISEL field.
	USBFS_CFIFOSEL_ISEL_Msk = 0x20
	// Bit ISEL.
	USBFS_CFIFOSEL_ISEL = 0x20
	// Reading from the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_0 = 0x0
	// Writing to the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_1 = 0x1
	// Position of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_CFIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_CFIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_CFIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_CFIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_CFIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_CFIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_CFIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_CFIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_CFIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_CFIFOSEL_CURPIPE_1001 = 0x9

	// CFIFOCTR: CFIFO Port Control Register
	// Position of BVAL field.
	USBFS_CFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_CFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_CFIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_CFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_CFIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_CFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_CFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_CFIFOCTR_BCLR = 0x4000
	// Invalid
	USBFS_CFIFOCTR_BCLR_0 = 0x0
	// Clears the buffer memory on the CPU side
	USBFS_CFIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_CFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_CFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_CFIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_CFIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_CFIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBFS_CFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_CFIFOCTR_DTLN_Msk = 0x1ff

	// D0FIFOSEL: D0FIFO Port Select Register
	// Position of RCNT field.
	USBFS_D0FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_D0FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_D0FIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the DnFIFO.(In double buffer mode, the DTLN bit Value is cleared when all the data has been read from only a single plane.)
	USBFS_D0FIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the DnFIFO. (n = 0, 1)
	USBFS_D0FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_D0FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_D0FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_D0FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_D0FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_D0FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBFS_D0FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBFS_D0FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBFS_D0FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled.
	USBFS_D0FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled.
	USBFS_D0FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBFS_D0FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBFS_D0FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBFS_D0FIFOSEL_DREQE = 0x1000
	// DMA/DTC transfer request is disabled.
	USBFS_D0FIFOSEL_DREQE_0 = 0x0
	// DMA/DTC transfer request is enabled.
	USBFS_D0FIFOSEL_DREQE_1 = 0x1
	// Position of MBW field.
	USBFS_D0FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_D0FIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_D0FIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_D0FIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_D0FIFOSEL_MBW_1 = 0x1
	// Position of BIGEND field.
	USBFS_D0FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_D0FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_D0FIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_D0FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_D0FIFOSEL_BIGEND_1 = 0x1
	// Position of CURPIPE field.
	USBFS_D0FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_D0FIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_D0FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_D0FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_D0FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_D0FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_D0FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_D0FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_D0FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_D0FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_D0FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_D0FIFOSEL_CURPIPE_1001 = 0x9

	// D0FIFOCTR: D0FIFO Port Control Register
	// Position of BVAL field.
	USBFS_D0FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_D0FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_D0FIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_D0FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_D0FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_D0FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_D0FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_D0FIFOCTR_BCLR = 0x4000
	// Invalid
	USBFS_D0FIFOCTR_BCLR_0 = 0x0
	// Clears the buffer memory on the CPU side
	USBFS_D0FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_D0FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_D0FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_D0FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_D0FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_D0FIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBFS_D0FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_D0FIFOCTR_DTLN_Msk = 0x1ff

	// D1FIFOSEL: D1FIFO Port Select Register
	// Position of RCNT field.
	USBFS_D1FIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_D1FIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_D1FIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the DnFIFO.(In double buffer mode, the DTLN bit Value is cleared when all the data has been read from only a single plane.)
	USBFS_D1FIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the DnFIFO. (n = 0, 1)
	USBFS_D1FIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_D1FIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_D1FIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_D1FIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_D1FIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_D1FIFOSEL_REW_1 = 0x1
	// Position of DCLRM field.
	USBFS_D1FIFOSEL_DCLRM_Pos = 0xd
	// Bit mask of DCLRM field.
	USBFS_D1FIFOSEL_DCLRM_Msk = 0x2000
	// Bit DCLRM.
	USBFS_D1FIFOSEL_DCLRM = 0x2000
	// Auto buffer clear mode is disabled.
	USBFS_D1FIFOSEL_DCLRM_0 = 0x0
	// Auto buffer clear mode is enabled.
	USBFS_D1FIFOSEL_DCLRM_1 = 0x1
	// Position of DREQE field.
	USBFS_D1FIFOSEL_DREQE_Pos = 0xc
	// Bit mask of DREQE field.
	USBFS_D1FIFOSEL_DREQE_Msk = 0x1000
	// Bit DREQE.
	USBFS_D1FIFOSEL_DREQE = 0x1000
	// DMA/DTC transfer request is disabled.
	USBFS_D1FIFOSEL_DREQE_0 = 0x0
	// DMA/DTC transfer request is enabled.
	USBFS_D1FIFOSEL_DREQE_1 = 0x1
	// Position of MBW field.
	USBFS_D1FIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_D1FIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_D1FIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_D1FIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_D1FIFOSEL_MBW_1 = 0x1
	// Position of BIGEND field.
	USBFS_D1FIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_D1FIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_D1FIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_D1FIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_D1FIFOSEL_BIGEND_1 = 0x1
	// Position of CURPIPE field.
	USBFS_D1FIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_D1FIFOSEL_CURPIPE_Msk = 0xf
	// DCP (Default control pipe)
	USBFS_D1FIFOSEL_CURPIPE_0000 = 0x0
	// Pipe 1
	USBFS_D1FIFOSEL_CURPIPE_0001 = 0x1
	// Pipe 2
	USBFS_D1FIFOSEL_CURPIPE_0010 = 0x2
	// Pipe 3
	USBFS_D1FIFOSEL_CURPIPE_0011 = 0x3
	// Pipe 4
	USBFS_D1FIFOSEL_CURPIPE_0100 = 0x4
	// Pipe 5
	USBFS_D1FIFOSEL_CURPIPE_0101 = 0x5
	// Pipe 6
	USBFS_D1FIFOSEL_CURPIPE_0110 = 0x6
	// Pipe 7
	USBFS_D1FIFOSEL_CURPIPE_0111 = 0x7
	// Pipe 8
	USBFS_D1FIFOSEL_CURPIPE_1000 = 0x8
	// Pipe 9
	USBFS_D1FIFOSEL_CURPIPE_1001 = 0x9

	// D1FIFOCTR: D1FIFO Port Control Register
	// Position of BVAL field.
	USBFS_D1FIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_D1FIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_D1FIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_D1FIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_D1FIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_D1FIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_D1FIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_D1FIFOCTR_BCLR = 0x4000
	// Invalid
	USBFS_D1FIFOCTR_BCLR_0 = 0x0
	// Clears the buffer memory on the CPU side
	USBFS_D1FIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_D1FIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_D1FIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_D1FIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_D1FIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_D1FIFOCTR_FRDY_1 = 0x1
	// Position of DTLN field.
	USBFS_D1FIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_D1FIFOCTR_DTLN_Msk = 0x1ff

	// INTENB0: Interrupt Enable Register 0
	// Position of VBSE field.
	USBFS_INTENB0_VBSE_Pos = 0xf
	// Bit mask of VBSE field.
	USBFS_INTENB0_VBSE_Msk = 0x8000
	// Bit VBSE.
	USBFS_INTENB0_VBSE = 0x8000
	// Interrupt output disabled
	USBFS_INTENB0_VBSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_VBSE_1 = 0x1
	// Position of RSME field.
	USBFS_INTENB0_RSME_Pos = 0xe
	// Bit mask of RSME field.
	USBFS_INTENB0_RSME_Msk = 0x4000
	// Bit RSME.
	USBFS_INTENB0_RSME = 0x4000
	// Interrupt output disabled
	USBFS_INTENB0_RSME_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_RSME_1 = 0x1
	// Position of SOFE field.
	USBFS_INTENB0_SOFE_Pos = 0xd
	// Bit mask of SOFE field.
	USBFS_INTENB0_SOFE_Msk = 0x2000
	// Bit SOFE.
	USBFS_INTENB0_SOFE = 0x2000
	// Interrupt output disabled
	USBFS_INTENB0_SOFE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_SOFE_1 = 0x1
	// Position of DVSE field.
	USBFS_INTENB0_DVSE_Pos = 0xc
	// Bit mask of DVSE field.
	USBFS_INTENB0_DVSE_Msk = 0x1000
	// Bit DVSE.
	USBFS_INTENB0_DVSE = 0x1000
	// Interrupt output disabled
	USBFS_INTENB0_DVSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_DVSE_1 = 0x1
	// Position of CTRE field.
	USBFS_INTENB0_CTRE_Pos = 0xb
	// Bit mask of CTRE field.
	USBFS_INTENB0_CTRE_Msk = 0x800
	// Bit CTRE.
	USBFS_INTENB0_CTRE = 0x800
	// Interrupt output disabled
	USBFS_INTENB0_CTRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_CTRE_1 = 0x1
	// Position of BEMPE field.
	USBFS_INTENB0_BEMPE_Pos = 0xa
	// Bit mask of BEMPE field.
	USBFS_INTENB0_BEMPE_Msk = 0x400
	// Bit BEMPE.
	USBFS_INTENB0_BEMPE = 0x400
	// Interrupt output disabled
	USBFS_INTENB0_BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BEMPE_1 = 0x1
	// Position of NRDYE field.
	USBFS_INTENB0_NRDYE_Pos = 0x9
	// Bit mask of NRDYE field.
	USBFS_INTENB0_NRDYE_Msk = 0x200
	// Bit NRDYE.
	USBFS_INTENB0_NRDYE = 0x200
	// Interrupt output disabled
	USBFS_INTENB0_NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_NRDYE_1 = 0x1
	// Position of BRDYE field.
	USBFS_INTENB0_BRDYE_Pos = 0x8
	// Bit mask of BRDYE field.
	USBFS_INTENB0_BRDYE_Msk = 0x100
	// Bit BRDYE.
	USBFS_INTENB0_BRDYE = 0x100
	// Interrupt output disabled
	USBFS_INTENB0_BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BRDYE_1 = 0x1

	// INTENB1: Interrupt Enable Register 1
	// Position of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Pos = 0xf
	// Bit mask of OVRCRE field.
	USBFS_INTENB1_OVRCRE_Msk = 0x8000
	// Bit OVRCRE.
	USBFS_INTENB1_OVRCRE = 0x8000
	// Interrupt output disabled
	USBFS_INTENB1_OVRCRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_OVRCRE_1 = 0x1
	// Position of BCHGE field.
	USBFS_INTENB1_BCHGE_Pos = 0xe
	// Bit mask of BCHGE field.
	USBFS_INTENB1_BCHGE_Msk = 0x4000
	// Bit BCHGE.
	USBFS_INTENB1_BCHGE = 0x4000
	// Interrupt output disabled
	USBFS_INTENB1_BCHGE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_BCHGE_1 = 0x1
	// Position of DTCHE field.
	USBFS_INTENB1_DTCHE_Pos = 0xc
	// Bit mask of DTCHE field.
	USBFS_INTENB1_DTCHE_Msk = 0x1000
	// Bit DTCHE.
	USBFS_INTENB1_DTCHE = 0x1000
	// Interrupt output disabled
	USBFS_INTENB1_DTCHE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_DTCHE_1 = 0x1
	// Position of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Pos = 0xb
	// Bit mask of ATTCHE field.
	USBFS_INTENB1_ATTCHE_Msk = 0x800
	// Bit ATTCHE.
	USBFS_INTENB1_ATTCHE = 0x800
	// Interrupt output disabled
	USBFS_INTENB1_ATTCHE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_ATTCHE_1 = 0x1
	// Position of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Pos = 0x6
	// Bit mask of EOFERRE field.
	USBFS_INTENB1_EOFERRE_Msk = 0x40
	// Bit EOFERRE.
	USBFS_INTENB1_EOFERRE = 0x40
	// Interrupt output disabled
	USBFS_INTENB1_EOFERRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_EOFERRE_1 = 0x1
	// Position of SIGNE field.
	USBFS_INTENB1_SIGNE_Pos = 0x5
	// Bit mask of SIGNE field.
	USBFS_INTENB1_SIGNE_Msk = 0x20
	// Bit SIGNE.
	USBFS_INTENB1_SIGNE = 0x20
	// Interrupt output disabled
	USBFS_INTENB1_SIGNE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_SIGNE_1 = 0x1
	// Position of SACKE field.
	USBFS_INTENB1_SACKE_Pos = 0x4
	// Bit mask of SACKE field.
	USBFS_INTENB1_SACKE_Msk = 0x10
	// Bit SACKE.
	USBFS_INTENB1_SACKE = 0x10
	// Interrupt output disabled
	USBFS_INTENB1_SACKE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB1_SACKE_1 = 0x1

	// BRDYENB: BRDY Interrupt Enable Register
	// Position of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Pos = 0x9
	// Bit mask of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Msk = 0x200
	// Bit PIPE9BRDYE.
	USBFS_BRDYENB_PIPE9BRDYE = 0x200
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE9BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE9BRDYE_1 = 0x1
	// Position of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Pos = 0x8
	// Bit mask of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Msk = 0x100
	// Bit PIPE8BRDYE.
	USBFS_BRDYENB_PIPE8BRDYE = 0x100
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE8BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE8BRDYE_1 = 0x1
	// Position of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Pos = 0x7
	// Bit mask of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Msk = 0x80
	// Bit PIPE7BRDYE.
	USBFS_BRDYENB_PIPE7BRDYE = 0x80
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE7BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE7BRDYE_1 = 0x1
	// Position of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Pos = 0x6
	// Bit mask of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Msk = 0x40
	// Bit PIPE6BRDYE.
	USBFS_BRDYENB_PIPE6BRDYE = 0x40
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE6BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE6BRDYE_1 = 0x1
	// Position of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Pos = 0x5
	// Bit mask of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Msk = 0x20
	// Bit PIPE5BRDYE.
	USBFS_BRDYENB_PIPE5BRDYE = 0x20
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE5BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE5BRDYE_1 = 0x1
	// Position of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Pos = 0x4
	// Bit mask of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Msk = 0x10
	// Bit PIPE4BRDYE.
	USBFS_BRDYENB_PIPE4BRDYE = 0x10
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE4BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE4BRDYE_1 = 0x1
	// Position of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Pos = 0x3
	// Bit mask of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Msk = 0x8
	// Bit PIPE3BRDYE.
	USBFS_BRDYENB_PIPE3BRDYE = 0x8
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE3BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE3BRDYE_1 = 0x1
	// Position of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Pos = 0x2
	// Bit mask of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Msk = 0x4
	// Bit PIPE2BRDYE.
	USBFS_BRDYENB_PIPE2BRDYE = 0x4
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE2BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE2BRDYE_1 = 0x1
	// Position of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Pos = 0x1
	// Bit mask of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Msk = 0x2
	// Bit PIPE1BRDYE.
	USBFS_BRDYENB_PIPE1BRDYE = 0x2
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE1BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE1BRDYE_1 = 0x1
	// Position of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Pos = 0x0
	// Bit mask of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Msk = 0x1
	// Bit PIPE0BRDYE.
	USBFS_BRDYENB_PIPE0BRDYE = 0x1
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE0BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE0BRDYE_1 = 0x1

	// NRDYENB: NRDY Interrupt Enable Register
	// Position of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Pos = 0x9
	// Bit mask of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Msk = 0x200
	// Bit PIPE9NRDYE.
	USBFS_NRDYENB_PIPE9NRDYE = 0x200
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE9NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE9NRDYE_1 = 0x1
	// Position of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Pos = 0x8
	// Bit mask of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Msk = 0x100
	// Bit PIPE8NRDYE.
	USBFS_NRDYENB_PIPE8NRDYE = 0x100
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE8NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE8NRDYE_1 = 0x1
	// Position of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Pos = 0x7
	// Bit mask of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Msk = 0x80
	// Bit PIPE7NRDYE.
	USBFS_NRDYENB_PIPE7NRDYE = 0x80
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE7NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE7NRDYE_1 = 0x1
	// Position of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Pos = 0x6
	// Bit mask of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Msk = 0x40
	// Bit PIPE6NRDYE.
	USBFS_NRDYENB_PIPE6NRDYE = 0x40
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE6NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE6NRDYE_1 = 0x1
	// Position of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Pos = 0x5
	// Bit mask of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Msk = 0x20
	// Bit PIPE5NRDYE.
	USBFS_NRDYENB_PIPE5NRDYE = 0x20
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE5NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE5NRDYE_1 = 0x1
	// Position of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Pos = 0x4
	// Bit mask of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Msk = 0x10
	// Bit PIPE4NRDYE.
	USBFS_NRDYENB_PIPE4NRDYE = 0x10
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE4NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE4NRDYE_1 = 0x1
	// Position of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Pos = 0x3
	// Bit mask of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Msk = 0x8
	// Bit PIPE3NRDYE.
	USBFS_NRDYENB_PIPE3NRDYE = 0x8
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE3NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE3NRDYE_1 = 0x1
	// Position of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Pos = 0x2
	// Bit mask of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Msk = 0x4
	// Bit PIPE2NRDYE.
	USBFS_NRDYENB_PIPE2NRDYE = 0x4
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE2NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE2NRDYE_1 = 0x1
	// Position of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Pos = 0x1
	// Bit mask of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Msk = 0x2
	// Bit PIPE1NRDYE.
	USBFS_NRDYENB_PIPE1NRDYE = 0x2
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE1NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE1NRDYE_1 = 0x1
	// Position of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Pos = 0x0
	// Bit mask of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Msk = 0x1
	// Bit PIPE0NRDYE.
	USBFS_NRDYENB_PIPE0NRDYE = 0x1
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE0NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE0NRDYE_1 = 0x1

	// BEMPENB: BEMP Interrupt Enable Register
	// Position of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Pos = 0x9
	// Bit mask of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Msk = 0x200
	// Bit PIPE9BEMPE.
	USBFS_BEMPENB_PIPE9BEMPE = 0x200
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE9BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE9BEMPE_1 = 0x1
	// Position of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Pos = 0x8
	// Bit mask of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Msk = 0x100
	// Bit PIPE8BEMPE.
	USBFS_BEMPENB_PIPE8BEMPE = 0x100
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE8BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE8BEMPE_1 = 0x1
	// Position of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Pos = 0x7
	// Bit mask of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Msk = 0x80
	// Bit PIPE7BEMPE.
	USBFS_BEMPENB_PIPE7BEMPE = 0x80
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE7BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE7BEMPE_1 = 0x1
	// Position of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Pos = 0x6
	// Bit mask of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Msk = 0x40
	// Bit PIPE6BEMPE.
	USBFS_BEMPENB_PIPE6BEMPE = 0x40
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE6BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE6BEMPE_1 = 0x1
	// Position of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Pos = 0x5
	// Bit mask of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Msk = 0x20
	// Bit PIPE5BEMPE.
	USBFS_BEMPENB_PIPE5BEMPE = 0x20
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE5BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE5BEMPE_1 = 0x1
	// Position of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Pos = 0x4
	// Bit mask of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Msk = 0x10
	// Bit PIPE4BEMPE.
	USBFS_BEMPENB_PIPE4BEMPE = 0x10
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE4BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE4BEMPE_1 = 0x1
	// Position of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Pos = 0x3
	// Bit mask of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Msk = 0x8
	// Bit PIPE3BEMPE.
	USBFS_BEMPENB_PIPE3BEMPE = 0x8
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE3BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE3BEMPE_1 = 0x1
	// Position of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Pos = 0x2
	// Bit mask of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Msk = 0x4
	// Bit PIPE2BEMPE.
	USBFS_BEMPENB_PIPE2BEMPE = 0x4
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE2BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE2BEMPE_1 = 0x1
	// Position of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Pos = 0x1
	// Bit mask of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Msk = 0x2
	// Bit PIPE1BEMPE.
	USBFS_BEMPENB_PIPE1BEMPE = 0x2
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE1BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE1BEMPE_1 = 0x1
	// Position of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Pos = 0x0
	// Bit mask of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Msk = 0x1
	// Bit PIPE0BEMPE.
	USBFS_BEMPENB_PIPE0BEMPE = 0x1
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE0BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE0BEMPE_1 = 0x1

	// SOFCFG: SOF Output Configuration Register
	// Position of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Pos = 0x8
	// Bit mask of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Msk = 0x100
	// Bit TRNENSEL.
	USBFS_SOFCFG_TRNENSEL = 0x100
	// For non-low-speed communication
	USBFS_SOFCFG_TRNENSEL_0 = 0x0
	// For low-speed communication
	USBFS_SOFCFG_TRNENSEL_1 = 0x1
	// Position of BRDYM field.
	USBFS_SOFCFG_BRDYM_Pos = 0x6
	// Bit mask of BRDYM field.
	USBFS_SOFCFG_BRDYM_Msk = 0x40
	// Bit BRDYM.
	USBFS_SOFCFG_BRDYM = 0x40
	// Software clears the status.
	USBFS_SOFCFG_BRDYM_0 = 0x0
	// The USB clears the status when data has been read from the FIFO buffer or data has been written to the FIFO buffer.
	USBFS_SOFCFG_BRDYM_1 = 0x1
	// Position of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Pos = 0x4
	// Bit mask of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Msk = 0x10
	// Bit EDGESTS.
	USBFS_SOFCFG_EDGESTS = 0x10
	// before stopping the clock supply to the USB module
	USBFS_SOFCFG_EDGESTS_0 = 0x0
	// the edge interrupt output signal is in the middle of the edge processing
	USBFS_SOFCFG_EDGESTS_1 = 0x1

	// INTSTS0: Interrupt Status Register 0
	// Position of VBINT field.
	USBFS_INTSTS0_VBINT_Pos = 0xf
	// Bit mask of VBINT field.
	USBFS_INTSTS0_VBINT_Msk = 0x8000
	// Bit VBINT.
	USBFS_INTSTS0_VBINT = 0x8000
	// VBUS interrupts are not generated.
	USBFS_INTSTS0_VBINT_0 = 0x0
	// VBUS interrupts are generated.
	USBFS_INTSTS0_VBINT_1 = 0x1
	// Position of RESM field.
	USBFS_INTSTS0_RESM_Pos = 0xe
	// Bit mask of RESM field.
	USBFS_INTSTS0_RESM_Msk = 0x4000
	// Bit RESM.
	USBFS_INTSTS0_RESM = 0x4000
	// Resume interrupts are not generated.
	USBFS_INTSTS0_RESM_0 = 0x0
	// Resume interrupts are generated.
	USBFS_INTSTS0_RESM_1 = 0x1
	// Position of SOFR field.
	USBFS_INTSTS0_SOFR_Pos = 0xd
	// Bit mask of SOFR field.
	USBFS_INTSTS0_SOFR_Msk = 0x2000
	// Bit SOFR.
	USBFS_INTSTS0_SOFR = 0x2000
	// SOF interrupts are not generated.
	USBFS_INTSTS0_SOFR_0 = 0x0
	// SOF interrupts are generated.
	USBFS_INTSTS0_SOFR_1 = 0x1
	// Position of DVST field.
	USBFS_INTSTS0_DVST_Pos = 0xc
	// Bit mask of DVST field.
	USBFS_INTSTS0_DVST_Msk = 0x1000
	// Bit DVST.
	USBFS_INTSTS0_DVST = 0x1000
	// Device state transition interrupts are not generated.
	USBFS_INTSTS0_DVST_0 = 0x0
	// Device state transition interrupts are generated.
	USBFS_INTSTS0_DVST_1 = 0x1
	// Position of CTRT field.
	USBFS_INTSTS0_CTRT_Pos = 0xb
	// Bit mask of CTRT field.
	USBFS_INTSTS0_CTRT_Msk = 0x800
	// Bit CTRT.
	USBFS_INTSTS0_CTRT = 0x800
	// Control transfer stage transition interrupts are not generated.
	USBFS_INTSTS0_CTRT_0 = 0x0
	// Control transfer stage transition interrupts are generated.
	USBFS_INTSTS0_CTRT_1 = 0x1
	// Position of BEMP field.
	USBFS_INTSTS0_BEMP_Pos = 0xa
	// Bit mask of BEMP field.
	USBFS_INTSTS0_BEMP_Msk = 0x400
	// Bit BEMP.
	USBFS_INTSTS0_BEMP = 0x400
	// BEMP interrupts are not generated.
	USBFS_INTSTS0_BEMP_0 = 0x0
	// BEMP interrupts are generated.
	USBFS_INTSTS0_BEMP_1 = 0x1
	// Position of NRDY field.
	USBFS_INTSTS0_NRDY_Pos = 0x9
	// Bit mask of NRDY field.
	USBFS_INTSTS0_NRDY_Msk = 0x200
	// Bit NRDY.
	USBFS_INTSTS0_NRDY = 0x200
	// NRDY interrupts are not generated.
	USBFS_INTSTS0_NRDY_0 = 0x0
	// NRDY interrupts are generated.
	USBFS_INTSTS0_NRDY_1 = 0x1
	// Position of BRDY field.
	USBFS_INTSTS0_BRDY_Pos = 0x8
	// Bit mask of BRDY field.
	USBFS_INTSTS0_BRDY_Msk = 0x100
	// Bit BRDY.
	USBFS_INTSTS0_BRDY = 0x100
	// BRDY interrupts are not generated.
	USBFS_INTSTS0_BRDY_0 = 0x0
	// BRDY interrupts are generated.
	USBFS_INTSTS0_BRDY_1 = 0x1
	// Position of VBSTS field.
	USBFS_INTSTS0_VBSTS_Pos = 0x7
	// Bit mask of VBSTS field.
	USBFS_INTSTS0_VBSTS_Msk = 0x80
	// Bit VBSTS.
	USBFS_INTSTS0_VBSTS = 0x80
	// USB0_VBUS pin is low.
	USBFS_INTSTS0_VBSTS_0 = 0x0
	// USB0_VBUS pin is high.
	USBFS_INTSTS0_VBSTS_1 = 0x1
	// Position of DVSQ field.
	USBFS_INTSTS0_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBFS_INTSTS0_DVSQ_Msk = 0x70
	// Powered state
	USBFS_INTSTS0_DVSQ_000 = 0x0
	// Default state
	USBFS_INTSTS0_DVSQ_001 = 0x1
	// Address state
	USBFS_INTSTS0_DVSQ_010 = 0x2
	// Configured state
	USBFS_INTSTS0_DVSQ_011 = 0x3
	// Position of VALID field.
	USBFS_INTSTS0_VALID_Pos = 0x3
	// Bit mask of VALID field.
	USBFS_INTSTS0_VALID_Msk = 0x8
	// Bit VALID.
	USBFS_INTSTS0_VALID = 0x8
	// Setup packet is not received
	USBFS_INTSTS0_VALID_0 = 0x0
	// Setup packet is received
	USBFS_INTSTS0_VALID_1 = 0x1
	// Position of CTSQ field.
	USBFS_INTSTS0_CTSQ_Pos = 0x0
	// Bit mask of CTSQ field.
	USBFS_INTSTS0_CTSQ_Msk = 0x7
	// Idle or setup stage
	USBFS_INTSTS0_CTSQ_000 = 0x0
	// Control read data stage
	USBFS_INTSTS0_CTSQ_001 = 0x1
	// Control read status stage
	USBFS_INTSTS0_CTSQ_010 = 0x2
	// Control write data stage
	USBFS_INTSTS0_CTSQ_011 = 0x3
	// Control write status stage
	USBFS_INTSTS0_CTSQ_100 = 0x4
	// Control write (no data) status stage
	USBFS_INTSTS0_CTSQ_101 = 0x5
	// Control transfer sequence error
	USBFS_INTSTS0_CTSQ_110 = 0x6

	// INTSTS1: Interrupt Status Register 1
	// Position of OVRCR field.
	USBFS_INTSTS1_OVRCR_Pos = 0xf
	// Bit mask of OVRCR field.
	USBFS_INTSTS1_OVRCR_Msk = 0x8000
	// Bit OVRCR.
	USBFS_INTSTS1_OVRCR = 0x8000
	// OVRCR interrupts are not generated.
	USBFS_INTSTS1_OVRCR_0 = 0x0
	// OVRCR interrupts are generated.
	USBFS_INTSTS1_OVRCR_1 = 0x1
	// Position of BCHG field.
	USBFS_INTSTS1_BCHG_Pos = 0xe
	// Bit mask of BCHG field.
	USBFS_INTSTS1_BCHG_Msk = 0x4000
	// Bit BCHG.
	USBFS_INTSTS1_BCHG = 0x4000
	// BCHG interrupts are not generated.
	USBFS_INTSTS1_BCHG_0 = 0x0
	// BCHG interrupts are generated.
	USBFS_INTSTS1_BCHG_1 = 0x1
	// Position of DTCH field.
	USBFS_INTSTS1_DTCH_Pos = 0xc
	// Bit mask of DTCH field.
	USBFS_INTSTS1_DTCH_Msk = 0x1000
	// Bit DTCH.
	USBFS_INTSTS1_DTCH = 0x1000
	// DTCH interrupts are not generated.
	USBFS_INTSTS1_DTCH_0 = 0x0
	// DTCH interrupts are generated.
	USBFS_INTSTS1_DTCH_1 = 0x1
	// Position of ATTCH field.
	USBFS_INTSTS1_ATTCH_Pos = 0xb
	// Bit mask of ATTCH field.
	USBFS_INTSTS1_ATTCH_Msk = 0x800
	// Bit ATTCH.
	USBFS_INTSTS1_ATTCH = 0x800
	// ATTCH interrupts are not generated.
	USBFS_INTSTS1_ATTCH_0 = 0x0
	// ATTCH interrupts are generated.
	USBFS_INTSTS1_ATTCH_1 = 0x1
	// Position of EOFERR field.
	USBFS_INTSTS1_EOFERR_Pos = 0x6
	// Bit mask of EOFERR field.
	USBFS_INTSTS1_EOFERR_Msk = 0x40
	// Bit EOFERR.
	USBFS_INTSTS1_EOFERR = 0x40
	// EOFERR interrupts are not generated.
	USBFS_INTSTS1_EOFERR_0 = 0x0
	// EOFERR interrupts are generated.
	USBFS_INTSTS1_EOFERR_1 = 0x1
	// Position of SIGN field.
	USBFS_INTSTS1_SIGN_Pos = 0x5
	// Bit mask of SIGN field.
	USBFS_INTSTS1_SIGN_Msk = 0x20
	// Bit SIGN.
	USBFS_INTSTS1_SIGN = 0x20
	// SIGN interrupts are not generated.
	USBFS_INTSTS1_SIGN_0 = 0x0
	// SIGN interrupts are generated.
	USBFS_INTSTS1_SIGN_1 = 0x1
	// Position of SACK field.
	USBFS_INTSTS1_SACK_Pos = 0x4
	// Bit mask of SACK field.
	USBFS_INTSTS1_SACK_Msk = 0x10
	// Bit SACK.
	USBFS_INTSTS1_SACK = 0x10
	// SACK interrupts are not generated.
	USBFS_INTSTS1_SACK_0 = 0x0
	// SACK interrupts are generated.
	USBFS_INTSTS1_SACK_1 = 0x1

	// BRDYSTS: BRDY Interrupt Status Register
	// Position of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Pos = 0x9
	// Bit mask of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Msk = 0x200
	// Bit PIPE9BRDY.
	USBFS_BRDYSTS_PIPE9BRDY = 0x200
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE9BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE9BRDY_1 = 0x1
	// Position of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Pos = 0x8
	// Bit mask of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Msk = 0x100
	// Bit PIPE8BRDY.
	USBFS_BRDYSTS_PIPE8BRDY = 0x100
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE8BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE8BRDY_1 = 0x1
	// Position of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Pos = 0x7
	// Bit mask of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Msk = 0x80
	// Bit PIPE7BRDY.
	USBFS_BRDYSTS_PIPE7BRDY = 0x80
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE7BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE7BRDY_1 = 0x1
	// Position of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Pos = 0x6
	// Bit mask of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Msk = 0x40
	// Bit PIPE6BRDY.
	USBFS_BRDYSTS_PIPE6BRDY = 0x40
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE6BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE6BRDY_1 = 0x1
	// Position of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Pos = 0x5
	// Bit mask of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Msk = 0x20
	// Bit PIPE5BRDY.
	USBFS_BRDYSTS_PIPE5BRDY = 0x20
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE5BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE5BRDY_1 = 0x1
	// Position of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Pos = 0x4
	// Bit mask of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Msk = 0x10
	// Bit PIPE4BRDY.
	USBFS_BRDYSTS_PIPE4BRDY = 0x10
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE4BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE4BRDY_1 = 0x1
	// Position of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Pos = 0x3
	// Bit mask of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Msk = 0x8
	// Bit PIPE3BRDY.
	USBFS_BRDYSTS_PIPE3BRDY = 0x8
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE3BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE3BRDY_1 = 0x1
	// Position of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Pos = 0x2
	// Bit mask of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Msk = 0x4
	// Bit PIPE2BRDY.
	USBFS_BRDYSTS_PIPE2BRDY = 0x4
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE2BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE2BRDY_1 = 0x1
	// Position of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Pos = 0x1
	// Bit mask of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Msk = 0x2
	// Bit PIPE1BRDY.
	USBFS_BRDYSTS_PIPE1BRDY = 0x2
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE1BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE1BRDY_1 = 0x1
	// Position of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Pos = 0x0
	// Bit mask of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Msk = 0x1
	// Bit PIPE0BRDY.
	USBFS_BRDYSTS_PIPE0BRDY = 0x1
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE0BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE0BRDY_1 = 0x1

	// NRDYSTS: NRDY Interrupt Status Register
	// Position of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Pos = 0x9
	// Bit mask of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Msk = 0x200
	// Bit PIPE9NRDY.
	USBFS_NRDYSTS_PIPE9NRDY = 0x200
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE9NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE9NRDY_1 = 0x1
	// Position of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Pos = 0x8
	// Bit mask of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Msk = 0x100
	// Bit PIPE8NRDY.
	USBFS_NRDYSTS_PIPE8NRDY = 0x100
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE8NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE8NRDY_1 = 0x1
	// Position of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Pos = 0x7
	// Bit mask of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Msk = 0x80
	// Bit PIPE7NRDY.
	USBFS_NRDYSTS_PIPE7NRDY = 0x80
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE7NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE7NRDY_1 = 0x1
	// Position of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Pos = 0x6
	// Bit mask of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Msk = 0x40
	// Bit PIPE6NRDY.
	USBFS_NRDYSTS_PIPE6NRDY = 0x40
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE6NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE6NRDY_1 = 0x1
	// Position of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Pos = 0x5
	// Bit mask of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Msk = 0x20
	// Bit PIPE5NRDY.
	USBFS_NRDYSTS_PIPE5NRDY = 0x20
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE5NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE5NRDY_1 = 0x1
	// Position of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Pos = 0x4
	// Bit mask of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Msk = 0x10
	// Bit PIPE4NRDY.
	USBFS_NRDYSTS_PIPE4NRDY = 0x10
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE4NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE4NRDY_1 = 0x1
	// Position of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Pos = 0x3
	// Bit mask of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Msk = 0x8
	// Bit PIPE3NRDY.
	USBFS_NRDYSTS_PIPE3NRDY = 0x8
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE3NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE3NRDY_1 = 0x1
	// Position of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Pos = 0x2
	// Bit mask of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Msk = 0x4
	// Bit PIPE2NRDY.
	USBFS_NRDYSTS_PIPE2NRDY = 0x4
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE2NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE2NRDY_1 = 0x1
	// Position of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Pos = 0x1
	// Bit mask of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Msk = 0x2
	// Bit PIPE1NRDY.
	USBFS_NRDYSTS_PIPE1NRDY = 0x2
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE1NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE1NRDY_1 = 0x1
	// Position of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Pos = 0x0
	// Bit mask of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Msk = 0x1
	// Bit PIPE0NRDY.
	USBFS_NRDYSTS_PIPE0NRDY = 0x1
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE0NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE0NRDY_1 = 0x1

	// BEMPSTS: BEMP Interrupt Status Register
	// Position of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Pos = 0x9
	// Bit mask of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Msk = 0x200
	// Bit PIPE9BEMP.
	USBFS_BEMPSTS_PIPE9BEMP = 0x200
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE9BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE9BEMP_1 = 0x1
	// Position of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Pos = 0x8
	// Bit mask of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Msk = 0x100
	// Bit PIPE8BEMP.
	USBFS_BEMPSTS_PIPE8BEMP = 0x100
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE8BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE8BEMP_1 = 0x1
	// Position of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Pos = 0x7
	// Bit mask of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Msk = 0x80
	// Bit PIPE7BEMP.
	USBFS_BEMPSTS_PIPE7BEMP = 0x80
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE7BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE7BEMP_1 = 0x1
	// Position of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Pos = 0x6
	// Bit mask of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Msk = 0x40
	// Bit PIPE6BEMP.
	USBFS_BEMPSTS_PIPE6BEMP = 0x40
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE6BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE6BEMP_1 = 0x1
	// Position of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Pos = 0x5
	// Bit mask of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Msk = 0x20
	// Bit PIPE5BEMP.
	USBFS_BEMPSTS_PIPE5BEMP = 0x20
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE5BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE5BEMP_1 = 0x1
	// Position of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Pos = 0x4
	// Bit mask of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Msk = 0x10
	// Bit PIPE4BEMP.
	USBFS_BEMPSTS_PIPE4BEMP = 0x10
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE4BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE4BEMP_1 = 0x1
	// Position of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Pos = 0x3
	// Bit mask of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Msk = 0x8
	// Bit PIPE3BEMP.
	USBFS_BEMPSTS_PIPE3BEMP = 0x8
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE3BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE3BEMP_1 = 0x1
	// Position of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Pos = 0x2
	// Bit mask of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Msk = 0x4
	// Bit PIPE2BEMP.
	USBFS_BEMPSTS_PIPE2BEMP = 0x4
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE2BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE2BEMP_1 = 0x1
	// Position of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Pos = 0x1
	// Bit mask of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Msk = 0x2
	// Bit PIPE1BEMP.
	USBFS_BEMPSTS_PIPE1BEMP = 0x2
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE1BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE1BEMP_1 = 0x1
	// Position of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Pos = 0x0
	// Bit mask of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Msk = 0x1
	// Bit PIPE0BEMP.
	USBFS_BEMPSTS_PIPE0BEMP = 0x1
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE0BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE0BEMP_1 = 0x1

	// FRMNUM: Frame Number Register
	// Position of OVRN field.
	USBFS_FRMNUM_OVRN_Pos = 0xf
	// Bit mask of OVRN field.
	USBFS_FRMNUM_OVRN_Msk = 0x8000
	// Bit OVRN.
	USBFS_FRMNUM_OVRN = 0x8000
	// No error
	USBFS_FRMNUM_OVRN_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_OVRN_1 = 0x1
	// Position of CRCE field.
	USBFS_FRMNUM_CRCE_Pos = 0xe
	// Bit mask of CRCE field.
	USBFS_FRMNUM_CRCE_Msk = 0x4000
	// Bit CRCE.
	USBFS_FRMNUM_CRCE = 0x4000
	// No error
	USBFS_FRMNUM_CRCE_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_CRCE_1 = 0x1
	// Position of FRNM field.
	USBFS_FRMNUM_FRNM_Pos = 0x0
	// Bit mask of FRNM field.
	USBFS_FRMNUM_FRNM_Msk = 0x7ff

	// DVCHGR: Device State Change Register
	// Position of DVCHG field.
	USBFS_DVCHGR_DVCHG_Pos = 0xf
	// Bit mask of DVCHG field.
	USBFS_DVCHGR_DVCHG_Msk = 0x8000
	// Bit DVCHG.
	USBFS_DVCHGR_DVCHG = 0x8000
	// Disables the writing to the USBADDR.STSRECOV[3:0] bits and USBADDR.USBADDR[6:0].
	USBFS_DVCHGR_DVCHG_0 = 0x0
	// Enables the writing to the USBADDR.STSRECOV[3:0] bits and USBADDR.USBADDR[6:0].
	USBFS_DVCHGR_DVCHG_1 = 0x1

	// USBADDR: USB Address Register
	// Position of STSRECOV field.
	USBFS_USBADDR_STSRECOV_Pos = 0x8
	// Bit mask of STSRECOV field.
	USBFS_USBADDR_STSRECOV_Msk = 0xf00
	// Return to the low-speed state (bits DVSTCTR0.RHST[2:0] = 001b;(Recovery when the host controller is selected))
	USBFS_USBADDR_STSRECOV_0100 = 0x4
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b;(Recovery when the host controller is selected))
	USBFS_USBADDR_STSRECOV_1000 = 0x8
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 001b (Default state);(Recovery when the function controller is selected)
	USBFS_USBADDR_STSRECOV_1001 = 0x9
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 010b (Address state);(Recovery when the function controller is selected)
	USBFS_USBADDR_STSRECOV_1010 = 0xa
	// Return to the full-speed state (bits DVSTCTR0.RHST[2:0] = 010b), bits INTSTS0.DVSQ[2:0] = 011b (Configured state);(Recovery when the function controller is selected)
	USBFS_USBADDR_STSRECOV_1011 = 0xb
	// Position of USBADDR field.
	USBFS_USBADDR_USBADDR_Pos = 0x0
	// Bit mask of USBADDR field.
	USBFS_USBADDR_USBADDR_Msk = 0x7f

	// USBREQ: USB Request Type Register
	// Position of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Pos = 0x8
	// Bit mask of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Msk = 0xff00
	// Position of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Pos = 0x0
	// Bit mask of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Msk = 0xff

	// USBVAL: USB Request Value Register
	// Position of WVALUE field.
	USBFS_USBVAL_WVALUE_Pos = 0x0
	// Bit mask of WVALUE field.
	USBFS_USBVAL_WVALUE_Msk = 0xffff

	// USBINDX: USB Request Index Register
	// Position of WINDEX field.
	USBFS_USBINDX_WINDEX_Pos = 0x0
	// Bit mask of WINDEX field.
	USBFS_USBINDX_WINDEX_Msk = 0xffff

	// USBLENG: USB Request Length Register
	// Position of WLENGTH field.
	USBFS_USBLENG_WLENGTH_Pos = 0x0
	// Bit mask of WLENGTH field.
	USBFS_USBLENG_WLENGTH_Msk = 0xffff

	// DCPCFG: DCP Configuration Register
	// Position of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_DCPCFG_SHTNAK = 0x80
	// Pipe continued at the end of transfer
	USBFS_DCPCFG_SHTNAK_0 = 0x0
	// Pipe disabled at the end of transfer
	USBFS_DCPCFG_SHTNAK_1 = 0x1
	// Position of DIR field.
	USBFS_DCPCFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_DCPCFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_DCPCFG_DIR = 0x10
	// Data receiving direction
	USBFS_DCPCFG_DIR_0 = 0x0
	// Data transmitting direction
	USBFS_DCPCFG_DIR_1 = 0x1

	// DCPMAXP: DCP Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_DCPMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_DCPMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_DCPMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_DCPMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_DCPMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_DCPMAXP_DEVSEL_0101 = 0x5
	// Position of MXPS field.
	USBFS_DCPMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_DCPMAXP_MXPS_Msk = 0x7f

	// DCPCTR: DCP Control Register
	// Position of BSTS field.
	USBFS_DCPCTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_DCPCTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_DCPCTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_DCPCTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_DCPCTR_BSTS_1 = 0x1
	// Position of SUREQ field.
	USBFS_DCPCTR_SUREQ_Pos = 0xe
	// Bit mask of SUREQ field.
	USBFS_DCPCTR_SUREQ_Msk = 0x4000
	// Bit SUREQ.
	USBFS_DCPCTR_SUREQ = 0x4000
	// Invalid
	USBFS_DCPCTR_SUREQ_0 = 0x0
	// Transmits the setup packet.
	USBFS_DCPCTR_SUREQ_1 = 0x1
	// Position of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Pos = 0xb
	// Bit mask of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Msk = 0x800
	// Bit SUREQCLR.
	USBFS_DCPCTR_SUREQCLR = 0x800
	// Invalid
	USBFS_DCPCTR_SUREQCLR_0 = 0x0
	// Clears the SUREQ bit to 0.
	USBFS_DCPCTR_SUREQCLR_1 = 0x1
	// Position of SQCLR field.
	USBFS_DCPCTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_DCPCTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_DCPCTR_SQCLR = 0x100
	// Invalid
	USBFS_DCPCTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_DCPCTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_DCPCTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_DCPCTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_DCPCTR_SQSET = 0x80
	// Invalid
	USBFS_DCPCTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_DCPCTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_DCPCTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_DCPCTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_DCPCTR_SQMON = 0x40
	// DATA0
	USBFS_DCPCTR_SQMON_0 = 0x0
	// DATA1
	USBFS_DCPCTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_DCPCTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_DCPCTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_DCPCTR_PBUSY = 0x20
	// DCP is not used for the transaction.
	USBFS_DCPCTR_PBUSY_0 = 0x0
	// DCP is used for the transaction.
	USBFS_DCPCTR_PBUSY_1 = 0x1
	// Position of CCPL field.
	USBFS_DCPCTR_CCPL_Pos = 0x2
	// Bit mask of CCPL field.
	USBFS_DCPCTR_CCPL_Msk = 0x4
	// Bit CCPL.
	USBFS_DCPCTR_CCPL = 0x4
	// Invalid
	USBFS_DCPCTR_CCPL_0 = 0x0
	// Completion of control transfer is enabled.
	USBFS_DCPCTR_CCPL_1 = 0x1
	// Position of PID field.
	USBFS_DCPCTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_DCPCTR_PID_Msk = 0x3
	// NAK response
	USBFS_DCPCTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_DCPCTR_PID_01 = 0x1
	// STALL response
	USBFS_DCPCTR_PID_10 = 0x2
	// STALL response
	USBFS_DCPCTR_PID_11 = 0x3

	// PIPESEL: Pipe Window Select Register
	// Position of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Pos = 0x0
	// Bit mask of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Msk = 0xf
	// No pipe selected
	USBFS_PIPESEL_PIPESEL_0000 = 0x0
	// PIPE1
	USBFS_PIPESEL_PIPESEL_0001 = 0x1
	// PIPE2
	USBFS_PIPESEL_PIPESEL_0010 = 0x2
	// PIPE3
	USBFS_PIPESEL_PIPESEL_0011 = 0x3
	// PIPE4
	USBFS_PIPESEL_PIPESEL_0100 = 0x4
	// PIPE5
	USBFS_PIPESEL_PIPESEL_0101 = 0x5
	// PIPE6
	USBFS_PIPESEL_PIPESEL_0110 = 0x6
	// PIPE7
	USBFS_PIPESEL_PIPESEL_0111 = 0x7
	// PIPE8
	USBFS_PIPESEL_PIPESEL_1000 = 0x8
	// PIPE9
	USBFS_PIPESEL_PIPESEL_1001 = 0x9

	// PIPECFG: Pipe Configuration Register
	// Position of TYPE field.
	USBFS_PIPECFG_TYPE_Pos = 0xe
	// Bit mask of TYPE field.
	USBFS_PIPECFG_TYPE_Msk = 0xc000
	// Pipe not used
	USBFS_PIPECFG_TYPE_00 = 0x0
	// Bulk transfer(PIPE1 and PIPE5) /Setting prohibited(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_01 = 0x1
	// Setting prohibited(PIPE1 and PIPE5) /Interrupt transfer(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_10 = 0x2
	// Isochronous transfer(PIPE1 and PIPE2) /Setting prohibited(PIPE3 to PIPE9)
	USBFS_PIPECFG_TYPE_11 = 0x3
	// Position of BFRE field.
	USBFS_PIPECFG_BFRE_Pos = 0xa
	// Bit mask of BFRE field.
	USBFS_PIPECFG_BFRE_Msk = 0x400
	// Bit BFRE.
	USBFS_PIPECFG_BFRE = 0x400
	// BRDY interrupt upon transmitting or receiving data
	USBFS_PIPECFG_BFRE_0 = 0x0
	// BRDY interrupt upon completion of reading data
	USBFS_PIPECFG_BFRE_1 = 0x1
	// Position of DBLB field.
	USBFS_PIPECFG_DBLB_Pos = 0x9
	// Bit mask of DBLB field.
	USBFS_PIPECFG_DBLB_Msk = 0x200
	// Bit DBLB.
	USBFS_PIPECFG_DBLB = 0x200
	// Single buffer
	USBFS_PIPECFG_DBLB_0 = 0x0
	// Double buffer
	USBFS_PIPECFG_DBLB_1 = 0x1
	// Position of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_PIPECFG_SHTNAK = 0x80
	// Pipe assignment continued at the end of transfer
	USBFS_PIPECFG_SHTNAK_0 = 0x0
	// Pipe assignment disabled at the end of transfer
	USBFS_PIPECFG_SHTNAK_1 = 0x1
	// Position of DIR field.
	USBFS_PIPECFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_PIPECFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_PIPECFG_DIR = 0x10
	// Receiving direction
	USBFS_PIPECFG_DIR_0 = 0x0
	// Transmitting direction
	USBFS_PIPECFG_DIR_1 = 0x1
	// Position of EPNUM field.
	USBFS_PIPECFG_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USBFS_PIPECFG_EPNUM_Msk = 0xf

	// PIPEMAXP: Pipe Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_PIPEMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_PIPEMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_PIPEMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_PIPEMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_PIPEMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_PIPEMAXP_DEVSEL_0101 = 0x5
	// Position of MXPS field.
	USBFS_PIPEMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_PIPEMAXP_MXPS_Msk = 0x1ff

	// PIPEPERI: Pipe Cycle Control Register
	// Position of IFIS field.
	USBFS_PIPEPERI_IFIS_Pos = 0xc
	// Bit mask of IFIS field.
	USBFS_PIPEPERI_IFIS_Msk = 0x1000
	// Bit IFIS.
	USBFS_PIPEPERI_IFIS = 0x1000
	// The buffer is not flushed.
	USBFS_PIPEPERI_IFIS_0 = 0x0
	// The buffer is flushed.
	USBFS_PIPEPERI_IFIS_1 = 0x1
	// Position of IITV field.
	USBFS_PIPEPERI_IITV_Pos = 0x0
	// Bit mask of IITV field.
	USBFS_PIPEPERI_IITV_Msk = 0x7

	// PIPE1CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access by the CPU is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access by the CPU is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of INBUFM field.
	USBFS_PIPECTR_INBUFM_Pos = 0xe
	// Bit mask of INBUFM field.
	USBFS_PIPECTR_INBUFM_Msk = 0x4000
	// Bit INBUFM.
	USBFS_PIPECTR_INBUFM = 0x4000
	// No data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_0 = 0x0
	// Data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_1 = 0x1
	// Position of ATREPM field.
	USBFS_PIPECTR_ATREPM_Pos = 0xa
	// Bit mask of ATREPM field.
	USBFS_PIPECTR_ATREPM_Msk = 0x400
	// Bit ATREPM.
	USBFS_PIPECTR_ATREPM = 0x400
	// Auto response is disabled.
	USBFS_PIPECTR_ATREPM_0 = 0x0
	// Auto response is enabled.
	USBFS_PIPECTR_ATREPM_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Disabled
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Write disabled
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Write disabled
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// The relevant pipe is not used for the transaction.
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// The relevant pipe is used for the transaction.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE6CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Auto buffer clear mode is disabled.
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Auto buffer clear mode is enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Invalid
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Invalid
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// The relevant pipe is not used at the USB bus.
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// The relevant pipe is used at the USB bus.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE1TRE: Pipe %s Transaction Counter Enable Register
	// Position of TRENB field.
	USBFS_PIPETRE_TRENB_Pos = 0x9
	// Bit mask of TRENB field.
	USBFS_PIPETRE_TRENB_Msk = 0x200
	// Bit TRENB.
	USBFS_PIPETRE_TRENB = 0x200
	// Transaction counter is disabled.
	USBFS_PIPETRE_TRENB_0 = 0x0
	// Transaction counter is enabled.
	USBFS_PIPETRE_TRENB_1 = 0x1
	// Position of TRCLR field.
	USBFS_PIPETRE_TRCLR_Pos = 0x8
	// Bit mask of TRCLR field.
	USBFS_PIPETRE_TRCLR_Msk = 0x100
	// Bit TRCLR.
	USBFS_PIPETRE_TRCLR = 0x100
	// Invalid
	USBFS_PIPETRE_TRCLR_0 = 0x0
	// The current counter value is cleared.
	USBFS_PIPETRE_TRCLR_1 = 0x1

	// PIPE1TRN: Pipe %s Transaction Counter Register
	// Position of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Pos = 0x0
	// Bit mask of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Msk = 0xffff

	// DEVADD0: Device Address %s Configuration Register
	// Position of USBSPD field.
	USBFS_DEVADD_USBSPD_Pos = 0x6
	// Bit mask of USBSPD field.
	USBFS_DEVADD_USBSPD_Msk = 0xc0
	// DEVADDn is not used
	USBFS_DEVADD_USBSPD_00 = 0x0
	// Low speed
	USBFS_DEVADD_USBSPD_01 = 0x1
	// Full speed
	USBFS_DEVADD_USBSPD_10 = 0x2
	// Setting prohibited
	USBFS_DEVADD_USBSPD_11 = 0x3

	// PHYSLEW: PHY Cross Point Adjustment Register
	// Position of SLEWF01 field.
	USBFS_PHYSLEW_SLEWF01_Pos = 0x3
	// Bit mask of SLEWF01 field.
	USBFS_PHYSLEW_SLEWF01_Msk = 0x8
	// Bit SLEWF01.
	USBFS_PHYSLEW_SLEWF01 = 0x8
	// Reserved
	USBFS_PHYSLEW_SLEWF01_0 = 0x0
	// Host or device controller mode.
	USBFS_PHYSLEW_SLEWF01_1 = 0x1
	// Position of SLEWF00 field.
	USBFS_PHYSLEW_SLEWF00_Pos = 0x2
	// Bit mask of SLEWF00 field.
	USBFS_PHYSLEW_SLEWF00_Msk = 0x4
	// Bit SLEWF00.
	USBFS_PHYSLEW_SLEWF00 = 0x4
	// Reserved
	USBFS_PHYSLEW_SLEWF00_0 = 0x0
	// Host or device controller mode.
	USBFS_PHYSLEW_SLEWF00_1 = 0x1
	// Position of SLEWR01 field.
	USBFS_PHYSLEW_SLEWR01_Pos = 0x1
	// Bit mask of SLEWR01 field.
	USBFS_PHYSLEW_SLEWR01_Msk = 0x2
	// Bit SLEWR01.
	USBFS_PHYSLEW_SLEWR01 = 0x2
	// Reserved
	USBFS_PHYSLEW_SLEWR01_0 = 0x0
	// Host or device controller mode.
	USBFS_PHYSLEW_SLEWR01_1 = 0x1
	// Position of SLEWR00 field.
	USBFS_PHYSLEW_SLEWR00_Pos = 0x0
	// Bit mask of SLEWR00 field.
	USBFS_PHYSLEW_SLEWR00_Msk = 0x1
	// Bit SLEWR00.
	USBFS_PHYSLEW_SLEWR00 = 0x1
	// Reserved
	USBFS_PHYSLEW_SLEWR00_0 = 0x0
	// Host or device controller mode.
	USBFS_PHYSLEW_SLEWR00_1 = 0x1

	// DPUSR0R: Deep Software Standby USB Transceiver Control/Pin Monitor Register
	// Position of DVBSTS0 field.
	USBFS_DPUSR0R_DVBSTS0_Pos = 0x17
	// Bit mask of DVBSTS0 field.
	USBFS_DPUSR0R_DVBSTS0_Msk = 0x800000
	// Bit DVBSTS0.
	USBFS_DPUSR0R_DVBSTS0 = 0x800000
	// Position of DOVCB0 field.
	USBFS_DPUSR0R_DOVCB0_Pos = 0x15
	// Bit mask of DOVCB0 field.
	USBFS_DPUSR0R_DOVCB0_Msk = 0x200000
	// Bit DOVCB0.
	USBFS_DPUSR0R_DOVCB0 = 0x200000
	// Position of DOVCA0 field.
	USBFS_DPUSR0R_DOVCA0_Pos = 0x14
	// Bit mask of DOVCA0 field.
	USBFS_DPUSR0R_DOVCA0_Msk = 0x100000
	// Bit DOVCA0.
	USBFS_DPUSR0R_DOVCA0 = 0x100000
	// Position of DM0 field.
	USBFS_DPUSR0R_DM0_Pos = 0x11
	// Bit mask of DM0 field.
	USBFS_DPUSR0R_DM0_Msk = 0x20000
	// Bit DM0.
	USBFS_DPUSR0R_DM0 = 0x20000
	// Position of DP0 field.
	USBFS_DPUSR0R_DP0_Pos = 0x10
	// Bit mask of DP0 field.
	USBFS_DPUSR0R_DP0_Msk = 0x10000
	// Bit DP0.
	USBFS_DPUSR0R_DP0 = 0x10000
	// Position of FIXPHY0 field.
	USBFS_DPUSR0R_FIXPHY0_Pos = 0x4
	// Bit mask of FIXPHY0 field.
	USBFS_DPUSR0R_FIXPHY0_Msk = 0x10
	// Bit FIXPHY0.
	USBFS_DPUSR0R_FIXPHY0 = 0x10
	// The outputs are fixed in normal mode and on return from deep software standby mode.
	USBFS_DPUSR0R_FIXPHY0_0 = 0x0
	// The outputs are fixed on transitions to deep software standby mode.
	USBFS_DPUSR0R_FIXPHY0_1 = 0x1
	// Position of DRPD0 field.
	USBFS_DPUSR0R_DRPD0_Pos = 0x3
	// Bit mask of DRPD0 field.
	USBFS_DPUSR0R_DRPD0_Msk = 0x8
	// Bit DRPD0.
	USBFS_DPUSR0R_DRPD0 = 0x8
	// Disables DP/DM pull-down resistor.
	USBFS_DPUSR0R_DRPD0_0 = 0x0
	// Enables DP/DM pull-down resistor.
	USBFS_DPUSR0R_DRPD0_1 = 0x1
	// Position of RPUE0 field.
	USBFS_DPUSR0R_RPUE0_Pos = 0x1
	// Bit mask of RPUE0 field.
	USBFS_DPUSR0R_RPUE0_Msk = 0x2
	// Bit RPUE0.
	USBFS_DPUSR0R_RPUE0 = 0x2
	// Disables DP pull-up resistor.
	USBFS_DPUSR0R_RPUE0_0 = 0x0
	// Enables DP pull-up resistor.
	USBFS_DPUSR0R_RPUE0_1 = 0x1
	// Position of SRPC0 field.
	USBFS_DPUSR0R_SRPC0_Pos = 0x0
	// Bit mask of SRPC0 field.
	USBFS_DPUSR0R_SRPC0_Msk = 0x1
	// Bit SRPC0.
	USBFS_DPUSR0R_SRPC0 = 0x1
	// Input through the DP and DM inputs is disabled.
	USBFS_DPUSR0R_SRPC0_0 = 0x0
	// Input through the DP and DM inputs is enabled.
	USBFS_DPUSR0R_SRPC0_1 = 0x1

	// DPUSR1R: Deep Software Standby USB Suspend/Resume Interrupt Register
	// Position of DVBINT0 field.
	USBFS_DPUSR1R_DVBINT0_Pos = 0x17
	// Bit mask of DVBINT0 field.
	USBFS_DPUSR1R_DVBINT0_Msk = 0x800000
	// Bit DVBINT0.
	USBFS_DPUSR1R_DVBINT0 = 0x800000
	// The system has not returned from deep software standby mode.
	USBFS_DPUSR1R_DVBINT0_0 = 0x0
	// The system has returned from deep software standby mode.
	USBFS_DPUSR1R_DVBINT0_1 = 0x1
	// Position of DOVRCRB0 field.
	USBFS_DPUSR1R_DOVRCRB0_Pos = 0x15
	// Bit mask of DOVRCRB0 field.
	USBFS_DPUSR1R_DOVRCRB0_Msk = 0x200000
	// Bit DOVRCRB0.
	USBFS_DPUSR1R_DOVRCRB0 = 0x200000
	// The system has not returned from deep software standby mode.
	USBFS_DPUSR1R_DOVRCRB0_0 = 0x0
	// The system has returned from deep software standby mode.
	USBFS_DPUSR1R_DOVRCRB0_1 = 0x1
	// Position of DOVRCRA0 field.
	USBFS_DPUSR1R_DOVRCRA0_Pos = 0x14
	// Bit mask of DOVRCRA0 field.
	USBFS_DPUSR1R_DOVRCRA0_Msk = 0x100000
	// Bit DOVRCRA0.
	USBFS_DPUSR1R_DOVRCRA0 = 0x100000
	// The system has not returned from deep software standby mode.
	USBFS_DPUSR1R_DOVRCRA0_0 = 0x0
	// The system has returned from deep software standby mode.
	USBFS_DPUSR1R_DOVRCRA0_1 = 0x1
	// Position of DMINT0 field.
	USBFS_DPUSR1R_DMINT0_Pos = 0x11
	// Bit mask of DMINT0 field.
	USBFS_DPUSR1R_DMINT0_Msk = 0x20000
	// Bit DMINT0.
	USBFS_DPUSR1R_DMINT0 = 0x20000
	// The system has not returned from deep software standby mode.
	USBFS_DPUSR1R_DMINT0_0 = 0x0
	// The system has returned from deep software standby mode.
	USBFS_DPUSR1R_DMINT0_1 = 0x1
	// Position of DPINT0 field.
	USBFS_DPUSR1R_DPINT0_Pos = 0x10
	// Bit mask of DPINT0 field.
	USBFS_DPUSR1R_DPINT0_Msk = 0x10000
	// Bit DPINT0.
	USBFS_DPUSR1R_DPINT0 = 0x10000
	// The system has not returned from deep software standby mode.
	USBFS_DPUSR1R_DPINT0_0 = 0x0
	// The system has returned from deep software standby mode.
	USBFS_DPUSR1R_DPINT0_1 = 0x1
	// Position of DVBSE0 field.
	USBFS_DPUSR1R_DVBSE0_Pos = 0x7
	// Bit mask of DVBSE0 field.
	USBFS_DPUSR1R_DVBSE0_Msk = 0x80
	// Bit DVBSE0.
	USBFS_DPUSR1R_DVBSE0 = 0x80
	// Recovery from deep software standby mode is disabled.
	USBFS_DPUSR1R_DVBSE0_0 = 0x0
	// Recovery from deep software standby mode is enabled.
	USBFS_DPUSR1R_DVBSE0_1 = 0x1
	// Position of DOVRCRBE0 field.
	USBFS_DPUSR1R_DOVRCRBE0_Pos = 0x5
	// Bit mask of DOVRCRBE0 field.
	USBFS_DPUSR1R_DOVRCRBE0_Msk = 0x20
	// Bit DOVRCRBE0.
	USBFS_DPUSR1R_DOVRCRBE0 = 0x20
	// Recovery from deep software standby mode is disabled.
	USBFS_DPUSR1R_DOVRCRBE0_0 = 0x0
	// Recovery from deep software standby mode is enabled.
	USBFS_DPUSR1R_DOVRCRBE0_1 = 0x1
	// Position of DOVRCRAE0 field.
	USBFS_DPUSR1R_DOVRCRAE0_Pos = 0x4
	// Bit mask of DOVRCRAE0 field.
	USBFS_DPUSR1R_DOVRCRAE0_Msk = 0x10
	// Bit DOVRCRAE0.
	USBFS_DPUSR1R_DOVRCRAE0 = 0x10
	// Recovery from deep software standby mode is disabled.
	USBFS_DPUSR1R_DOVRCRAE0_0 = 0x0
	// Recovery from deep software standby mode is enabled.
	USBFS_DPUSR1R_DOVRCRAE0_1 = 0x1
	// Position of DMINTE0 field.
	USBFS_DPUSR1R_DMINTE0_Pos = 0x1
	// Bit mask of DMINTE0 field.
	USBFS_DPUSR1R_DMINTE0_Msk = 0x2
	// Bit DMINTE0.
	USBFS_DPUSR1R_DMINTE0 = 0x2
	// Recovery from deep software standby mode is disabled.
	USBFS_DPUSR1R_DMINTE0_0 = 0x0
	// Recovery from deep software standby mode is enabled.
	USBFS_DPUSR1R_DMINTE0_1 = 0x1
	// Position of DPINTE0 field.
	USBFS_DPUSR1R_DPINTE0_Pos = 0x0
	// Bit mask of DPINTE0 field.
	USBFS_DPUSR1R_DPINTE0_Msk = 0x1
	// Bit DPINTE0.
	USBFS_DPUSR1R_DPINTE0 = 0x1
	// Recovery from deep software standby mode is disabled.
	USBFS_DPUSR1R_DPINTE0_0 = 0x0
	// Recovery from deep software standby mode is enabled.
	USBFS_DPUSR1R_DPINTE0_1 = 0x1
)

// Constants for SRCRAM: Sampling Rate Converter RAM
const (
	// SRCFCTR: Filter Coefficient Table [%s]
	// Position of SRCFCOE field.
	SRCRAM_SRCFCTR_SRCFCOE_Pos = 0x0
	// Bit mask of SRCFCOE field.
	SRCRAM_SRCFCTR_SRCFCOE_Msk = 0x3fffff
)

// Constants for SRC: Sampling Rate Converter
const (
	// SRCID: Input Data Register
	// Position of SRCID field.
	SRC_SRCID_SRCID_Pos = 0x0
	// Bit mask of SRCID field.
	SRC_SRCID_SRCID_Msk = 0xffffffff

	// SRCOD: Output Data Register
	// Position of SRCOD field.
	SRC_SRCOD_SRCOD_Pos = 0x0
	// Bit mask of SRCOD field.
	SRC_SRCOD_SRCOD_Msk = 0xffffffff

	// SRCIDCTRL: Input Data Control Register
	// Position of IED field.
	SRC_SRCIDCTRL_IED_Pos = 0x9
	// Bit mask of IED field.
	SRC_SRCIDCTRL_IED_Msk = 0x200
	// Bit IED.
	SRC_SRCIDCTRL_IED = 0x200
	// Endian formats 1 are the same between the CPU and input data.
	SRC_SRCIDCTRL_IED_0 = 0x0
	// Endian formats 1 are different between the CPU and input data.
	SRC_SRCIDCTRL_IED_1 = 0x1
	// Position of IEN field.
	SRC_SRCIDCTRL_IEN_Pos = 0x8
	// Bit mask of IEN field.
	SRC_SRCIDCTRL_IEN_Msk = 0x100
	// Bit IEN.
	SRC_SRCIDCTRL_IEN = 0x100
	// Input FIFO empty interrupt is disabled.
	SRC_SRCIDCTRL_IEN_0 = 0x0
	// Input FIFO empty interrupt is enabled.
	SRC_SRCIDCTRL_IEN_1 = 0x1
	// Position of IFTRG field.
	SRC_SRCIDCTRL_IFTRG_Pos = 0x0
	// Bit mask of IFTRG field.
	SRC_SRCIDCTRL_IFTRG_Msk = 0x3
	// 0
	SRC_SRCIDCTRL_IFTRG_00 = 0x0
	// 2
	SRC_SRCIDCTRL_IFTRG_01 = 0x1
	// 4
	SRC_SRCIDCTRL_IFTRG_10 = 0x2
	// 6
	SRC_SRCIDCTRL_IFTRG_11 = 0x3

	// SRCODCTRL: Output Data Control Register
	// Position of OCH field.
	SRC_SRCODCTRL_OCH_Pos = 0xa
	// Bit mask of OCH field.
	SRC_SRCODCTRL_OCH_Msk = 0x400
	// Bit OCH.
	SRC_SRCODCTRL_OCH = 0x400
	// Does not exchange the channels (the same order as data input)
	SRC_SRCODCTRL_OCH_0 = 0x0
	// Exchanges the channels (the opposite order from data input)
	SRC_SRCODCTRL_OCH_1 = 0x1
	// Position of OED field.
	SRC_SRCODCTRL_OED_Pos = 0x9
	// Bit mask of OED field.
	SRC_SRCODCTRL_OED_Msk = 0x200
	// Bit OED.
	SRC_SRCODCTRL_OED = 0x200
	// Endian formats are the same between the chip and input data.
	SRC_SRCODCTRL_OED_0 = 0x0
	// Endian formats are different between the chip and input data.
	SRC_SRCODCTRL_OED_1 = 0x1
	// Position of OEN field.
	SRC_SRCODCTRL_OEN_Pos = 0x8
	// Bit mask of OEN field.
	SRC_SRCODCTRL_OEN_Msk = 0x100
	// Bit OEN.
	SRC_SRCODCTRL_OEN = 0x100
	// Output data FIFO full interrupt is disabled.
	SRC_SRCODCTRL_OEN_0 = 0x0
	// Output data FIFO full interrupt is enabled.
	SRC_SRCODCTRL_OEN_1 = 0x1
	// Position of OFTRG field.
	SRC_SRCODCTRL_OFTRG_Pos = 0x0
	// Bit mask of OFTRG field.
	SRC_SRCODCTRL_OFTRG_Msk = 0x3
	// 1
	SRC_SRCODCTRL_OFTRG_00 = 0x0
	// 4
	SRC_SRCODCTRL_OFTRG_01 = 0x1
	// 8
	SRC_SRCODCTRL_OFTRG_10 = 0x2
	// 12
	SRC_SRCODCTRL_OFTRG_11 = 0x3

	// SRCCTRL: Control Register
	// Position of FICRAE field.
	SRC_SRCCTRL_FICRAE_Pos = 0xf
	// Bit mask of FICRAE field.
	SRC_SRCCTRL_FICRAE_Msk = 0x8000
	// Bit FICRAE.
	SRC_SRCCTRL_FICRAE = 0x8000
	// Reading/writing to filter coefficient table RAM is disabled.
	SRC_SRCCTRL_FICRAE_0 = 0x0
	// Reading/writing to filter coefficient table RAM is enabled.
	SRC_SRCCTRL_FICRAE_1 = 0x1
	// Position of CEEN field.
	SRC_SRCCTRL_CEEN_Pos = 0xd
	// Bit mask of CEEN field.
	SRC_SRCCTRL_CEEN_Msk = 0x2000
	// Bit CEEN.
	SRC_SRCCTRL_CEEN = 0x2000
	// Disables conversion end interrupt requests.
	SRC_SRCCTRL_CEEN_0 = 0x0
	// Enables conversion end interrupt requests.
	SRC_SRCCTRL_CEEN_1 = 0x1
	// Position of SRCEN field.
	SRC_SRCCTRL_SRCEN_Pos = 0xc
	// Bit mask of SRCEN field.
	SRC_SRCCTRL_SRCEN_Msk = 0x1000
	// Bit SRCEN.
	SRC_SRCCTRL_SRCEN = 0x1000
	// Disables this module operation.
	SRC_SRCCTRL_SRCEN_0 = 0x0
	// Enables this module operation.
	SRC_SRCCTRL_SRCEN_1 = 0x1
	// Position of UDEN field.
	SRC_SRCCTRL_UDEN_Pos = 0xb
	// Bit mask of UDEN field.
	SRC_SRCCTRL_UDEN_Msk = 0x800
	// Bit UDEN.
	SRC_SRCCTRL_UDEN = 0x800
	// Disables output data FIFO underflow interrupt requests.
	SRC_SRCCTRL_UDEN_0 = 0x0
	// Enables output data FIFO underflow interrupt requests.
	SRC_SRCCTRL_UDEN_1 = 0x1
	// Position of OVEN field.
	SRC_SRCCTRL_OVEN_Pos = 0xa
	// Bit mask of OVEN field.
	SRC_SRCCTRL_OVEN_Msk = 0x400
	// Bit OVEN.
	SRC_SRCCTRL_OVEN = 0x400
	// Output data FIFO overwrite interrupt is disabled.
	SRC_SRCCTRL_OVEN_0 = 0x0
	// Output data FIFO overwrite interrupt is enabled.
	SRC_SRCCTRL_OVEN_1 = 0x1
	// Position of FL field.
	SRC_SRCCTRL_FL_Pos = 0x9
	// Bit mask of FL field.
	SRC_SRCCTRL_FL_Msk = 0x200
	// Bit FL.
	SRC_SRCCTRL_FL = 0x200
	// no effect
	SRC_SRCCTRL_FL_0 = 0x0
	// starts converting the sampling rate of all the data in the input FIFO, input buffer memory, and intermediate memory(i.e., flush processing).
	SRC_SRCCTRL_FL_1 = 0x1
	// Position of CL field.
	SRC_SRCCTRL_CL_Pos = 0x8
	// Bit mask of CL field.
	SRC_SRCCTRL_CL_Msk = 0x100
	// Bit CL.
	SRC_SRCCTRL_CL = 0x100
	// no effect
	SRC_SRCCTRL_CL_0 = 0x0
	// Clears the input FIFO, output FIFO, input buffer memory, intermediate memory and accumulator.
	SRC_SRCCTRL_CL_1 = 0x1
	// Position of IFS field.
	SRC_SRCCTRL_IFS_Pos = 0x4
	// Bit mask of IFS field.
	SRC_SRCCTRL_IFS_Msk = 0xf0
	// 8.0 kHz
	SRC_SRCCTRL_IFS_0000 = 0x0
	// 11.025 kHz
	SRC_SRCCTRL_IFS_0001 = 0x1
	// 12.0 kHz
	SRC_SRCCTRL_IFS_0010 = 0x2
	// Setting prohibited
	SRC_SRCCTRL_IFS_0011 = 0x3
	// 16.0 kHz
	SRC_SRCCTRL_IFS_0100 = 0x4
	// 22.05 kHz
	SRC_SRCCTRL_IFS_0101 = 0x5
	// 24.0 kHz
	SRC_SRCCTRL_IFS_0110 = 0x6
	// Setting prohibited
	SRC_SRCCTRL_IFS_0111 = 0x7
	// 32.0 kHz
	SRC_SRCCTRL_IFS_1000 = 0x8
	// 44.1 kHz
	SRC_SRCCTRL_IFS_1001 = 0x9
	// 48.0 kHz
	SRC_SRCCTRL_IFS_1010 = 0xa
	// Position of OFS field.
	SRC_SRCCTRL_OFS_Pos = 0x0
	// Bit mask of OFS field.
	SRC_SRCCTRL_OFS_Msk = 0x7
	// 44.1 kHz
	SRC_SRCCTRL_OFS_000 = 0x0
	// 48.0 kHz
	SRC_SRCCTRL_OFS_001 = 0x1
	// 32.0 kHz
	SRC_SRCCTRL_OFS_010 = 0x2
	// Setting prohibited
	SRC_SRCCTRL_OFS_011 = 0x3
	// 8.0 kHz ( Valid only when IFS[3:0] =1001b )
	SRC_SRCCTRL_OFS_100 = 0x4
	// 16.0 kHz ( Valid only when IFS[3:0] =1001b )
	SRC_SRCCTRL_OFS_101 = 0x5

	// SRCSTAT: Status Register
	// Position of OFDN field.
	SRC_SRCSTAT_OFDN_Pos = 0xb
	// Bit mask of OFDN field.
	SRC_SRCSTAT_OFDN_Msk = 0xf800
	// Position of IFDN field.
	SRC_SRCSTAT_IFDN_Pos = 0x7
	// Bit mask of IFDN field.
	SRC_SRCSTAT_IFDN_Msk = 0x780
	// Position of CEF field.
	SRC_SRCSTAT_CEF_Pos = 0x5
	// Bit mask of CEF field.
	SRC_SRCSTAT_CEF_Msk = 0x20
	// Bit CEF.
	SRC_SRCSTAT_CEF = 0x20
	// All of the output data has not been read out.
	SRC_SRCSTAT_CEF_0 = 0x0
	// All of the output data has been read out.
	SRC_SRCSTAT_CEF_1 = 0x1
	// Position of FLF field.
	SRC_SRCSTAT_FLF_Pos = 0x4
	// Bit mask of FLF field.
	SRC_SRCSTAT_FLF_Msk = 0x10
	// Bit FLF.
	SRC_SRCSTAT_FLF = 0x10
	// Flash processing is completed.
	SRC_SRCSTAT_FLF_0 = 0x0
	// Flash processing is in progress.
	SRC_SRCSTAT_FLF_1 = 0x1
	// Position of UDF field.
	SRC_SRCSTAT_UDF_Pos = 0x3
	// Bit mask of UDF field.
	SRC_SRCSTAT_UDF_Msk = 0x8
	// Bit UDF.
	SRC_SRCSTAT_UDF = 0x8
	// Output data FIFO has not been read out.
	SRC_SRCSTAT_UDF_0 = 0x0
	// Output data FIFO has been read out.
	SRC_SRCSTAT_UDF_1 = 0x1
	// Position of OVF field.
	SRC_SRCSTAT_OVF_Pos = 0x2
	// Bit mask of OVF field.
	SRC_SRCSTAT_OVF_Msk = 0x4
	// Bit OVF.
	SRC_SRCSTAT_OVF = 0x4
	// Next data conversion processing is not completed.
	SRC_SRCSTAT_OVF_0 = 0x0
	// Next data conversion processing is completed.
	SRC_SRCSTAT_OVF_1 = 0x1
	// Position of IINT field.
	SRC_SRCSTAT_IINT_Pos = 0x1
	// Bit mask of IINT field.
	SRC_SRCSTAT_IINT_Msk = 0x2
	// Bit IINT.
	SRC_SRCSTAT_IINT = 0x2
	// Number of data units in the input FIFO has not become equal to or smaller than the specified triggering number.
	SRC_SRCSTAT_IINT_0 = 0x0
	// Number of data units in the input FIFO has become equal to or smaller than the specified triggering number.
	SRC_SRCSTAT_IINT_1 = 0x1
	// Position of OINT field.
	SRC_SRCSTAT_OINT_Pos = 0x0
	// Bit mask of OINT field.
	SRC_SRCSTAT_OINT_Msk = 0x1
	// Bit OINT.
	SRC_SRCSTAT_OINT = 0x1
	// Number of data units in the output FIFO has not become equal to or greater than the specified triggering number.
	SRC_SRCSTAT_OINT_0 = 0x0
	// Number of data units in the output FIFO has become equal to or greater than the specified triggering number.
	SRC_SRCSTAT_OINT_1 = 0x1
)

// Constants for ICU: Interrupt Controller
const (
	// IRQCR0: IRQ Control Register %s
	// Position of FLTEN field.
	ICU_IRQCR_FLTEN_Pos = 0x7
	// Bit mask of FLTEN field.
	ICU_IRQCR_FLTEN_Msk = 0x80
	// Bit FLTEN.
	ICU_IRQCR_FLTEN = 0x80
	// Digital filter is disabled.
	ICU_IRQCR_FLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_IRQCR_FLTEN_1 = 0x1
	// Position of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Pos = 0x4
	// Bit mask of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Msk = 0x30
	// PCLKB
	ICU_IRQCR_FCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_IRQCR_FCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_IRQCR_FCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_IRQCR_FCLKSEL_11 = 0x3
	// Position of IRQMD field.
	ICU_IRQCR_IRQMD_Pos = 0x0
	// Bit mask of IRQMD field.
	ICU_IRQCR_IRQMD_Msk = 0x3
	// Falling edge
	ICU_IRQCR_IRQMD_00 = 0x0
	// Rising edge
	ICU_IRQCR_IRQMD_01 = 0x1
	// Rising and falling edges
	ICU_IRQCR_IRQMD_10 = 0x2
	// Low level
	ICU_IRQCR_IRQMD_11 = 0x3

	// NMICR: NMI Pin Interrupt Control Register
	// Position of NFLTEN field.
	ICU_NMICR_NFLTEN_Pos = 0x7
	// Bit mask of NFLTEN field.
	ICU_NMICR_NFLTEN_Msk = 0x80
	// Bit NFLTEN.
	ICU_NMICR_NFLTEN = 0x80
	// Digital filter is disabled.
	ICU_NMICR_NFLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_NMICR_NFLTEN_1 = 0x1
	// Position of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Pos = 0x4
	// Bit mask of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Msk = 0x30
	// PCLKB
	ICU_NMICR_NFCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_NMICR_NFCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_NMICR_NFCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_NMICR_NFCLKSEL_11 = 0x3
	// Position of NMIMD field.
	ICU_NMICR_NMIMD_Pos = 0x0
	// Bit mask of NMIMD field.
	ICU_NMICR_NMIMD_Msk = 0x1
	// Bit NMIMD.
	ICU_NMICR_NMIMD = 0x1
	// Falling edge
	ICU_NMICR_NMIMD_0 = 0x0
	// Rising edge
	ICU_NMICR_NMIMD_1 = 0x1

	// NMIER: Non-Maskable Interrupt Enable Register
	// Position of SPEEN field.
	ICU_NMIER_SPEEN_Pos = 0xc
	// Bit mask of SPEEN field.
	ICU_NMIER_SPEEN_Msk = 0x1000
	// Bit SPEEN.
	ICU_NMIER_SPEEN = 0x1000
	// MPU Stack Error interrupt is disabled.
	ICU_NMIER_SPEEN_0 = 0x0
	// MPU Stack Error interrupt is enabled.
	ICU_NMIER_SPEEN_1 = 0x1
	// Position of BUSMEN field.
	ICU_NMIER_BUSMEN_Pos = 0xb
	// Bit mask of BUSMEN field.
	ICU_NMIER_BUSMEN_Msk = 0x800
	// Bit BUSMEN.
	ICU_NMIER_BUSMEN = 0x800
	// MPU Bus Master Error interrupt is disabled.
	ICU_NMIER_BUSMEN_0 = 0x0
	// MPU Bus Master Error interrupt is enabled.
	ICU_NMIER_BUSMEN_1 = 0x1
	// Position of BUSSEN field.
	ICU_NMIER_BUSSEN_Pos = 0xa
	// Bit mask of BUSSEN field.
	ICU_NMIER_BUSSEN_Msk = 0x400
	// Bit BUSSEN.
	ICU_NMIER_BUSSEN = 0x400
	// MPU Bus Slave Error interrupt is disabled.
	ICU_NMIER_BUSSEN_0 = 0x0
	// MPU Bus Slave Error interrupt is enabled.
	ICU_NMIER_BUSSEN_1 = 0x1
	// Position of RECCEN field.
	ICU_NMIER_RECCEN_Pos = 0x9
	// Bit mask of RECCEN field.
	ICU_NMIER_RECCEN_Msk = 0x200
	// Bit RECCEN.
	ICU_NMIER_RECCEN = 0x200
	// RAM ECC Error interrupt is disabled.
	ICU_NMIER_RECCEN_0 = 0x0
	// RAM ECC Error interrupt is enabled.
	ICU_NMIER_RECCEN_1 = 0x1
	// Position of RPEEN field.
	ICU_NMIER_RPEEN_Pos = 0x8
	// Bit mask of RPEEN field.
	ICU_NMIER_RPEEN_Msk = 0x100
	// Bit RPEEN.
	ICU_NMIER_RPEEN = 0x100
	// RAM Parity Error interrupt is disabled.
	ICU_NMIER_RPEEN_0 = 0x0
	// RAM Parity Error interrupt is enabled.
	ICU_NMIER_RPEEN_1 = 0x1
	// Position of NMIEN field.
	ICU_NMIER_NMIEN_Pos = 0x7
	// Bit mask of NMIEN field.
	ICU_NMIER_NMIEN_Msk = 0x80
	// Bit NMIEN.
	ICU_NMIER_NMIEN = 0x80
	// NMI pin interrupt is disabled.
	ICU_NMIER_NMIEN_0 = 0x0
	// NMI pin interrupt is enabled.
	ICU_NMIER_NMIEN_1 = 0x1
	// Position of OSTEN field.
	ICU_NMIER_OSTEN_Pos = 0x6
	// Bit mask of OSTEN field.
	ICU_NMIER_OSTEN_Msk = 0x40
	// Bit OSTEN.
	ICU_NMIER_OSTEN = 0x40
	// Oscillation stop detection interrupt is disabled.
	ICU_NMIER_OSTEN_0 = 0x0
	// Oscillation stop detection interrupt is enabled.
	ICU_NMIER_OSTEN_1 = 0x1
	// Position of LVD2EN field.
	ICU_NMIER_LVD2EN_Pos = 0x3
	// Bit mask of LVD2EN field.
	ICU_NMIER_LVD2EN_Msk = 0x8
	// Bit LVD2EN.
	ICU_NMIER_LVD2EN = 0x8
	// Voltage-monitoring 2 interrupt is disabled.
	ICU_NMIER_LVD2EN_0 = 0x0
	// Voltage-monitoring 2 interrupt is enabled.
	ICU_NMIER_LVD2EN_1 = 0x1
	// Position of LVD1EN field.
	ICU_NMIER_LVD1EN_Pos = 0x2
	// Bit mask of LVD1EN field.
	ICU_NMIER_LVD1EN_Msk = 0x4
	// Bit LVD1EN.
	ICU_NMIER_LVD1EN = 0x4
	// Voltage-monitoring 1 interrupt is disabled.
	ICU_NMIER_LVD1EN_0 = 0x0
	// Voltage-monitoring 1 interrupt is enabled.
	ICU_NMIER_LVD1EN_1 = 0x1
	// Position of WDTEN field.
	ICU_NMIER_WDTEN_Pos = 0x1
	// Bit mask of WDTEN field.
	ICU_NMIER_WDTEN_Msk = 0x2
	// Bit WDTEN.
	ICU_NMIER_WDTEN = 0x2
	// WDT underflow/refresh error interrupt is disabled.
	ICU_NMIER_WDTEN_0 = 0x0
	// WDT underflow/refresh error interrupt is enabled.
	ICU_NMIER_WDTEN_1 = 0x1
	// Position of IWDTEN field.
	ICU_NMIER_IWDTEN_Pos = 0x0
	// Bit mask of IWDTEN field.
	ICU_NMIER_IWDTEN_Msk = 0x1
	// Bit IWDTEN.
	ICU_NMIER_IWDTEN = 0x1
	// IWDT underflow/refresh error interrupt is disabled.
	ICU_NMIER_IWDTEN_0 = 0x0
	// IWDT underflow/refresh error interrupt is enabled.
	ICU_NMIER_IWDTEN_1 = 0x1

	// NMICLR: Non-Maskable Interrupt Status Clear Register
	// Position of SPECLR field.
	ICU_NMICLR_SPECLR_Pos = 0xc
	// Bit mask of SPECLR field.
	ICU_NMICLR_SPECLR_Msk = 0x1000
	// Bit SPECLR.
	ICU_NMICLR_SPECLR = 0x1000
	// No effect.
	ICU_NMICLR_SPECLR_0 = 0x0
	// Clear the NMISR.SPEST flag.
	ICU_NMICLR_SPECLR_1 = 0x1
	// Position of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Pos = 0xb
	// Bit mask of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Msk = 0x800
	// Bit BUSMCLR.
	ICU_NMICLR_BUSMCLR = 0x800
	// No effect.
	ICU_NMICLR_BUSMCLR_0 = 0x0
	// Clear the NMISR.BUSMST flag.
	ICU_NMICLR_BUSMCLR_1 = 0x1
	// Position of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Pos = 0xa
	// Bit mask of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Msk = 0x400
	// Bit BUSSCLR.
	ICU_NMICLR_BUSSCLR = 0x400
	// No effect.
	ICU_NMICLR_BUSSCLR_0 = 0x0
	// Clear the NMISR.BUSSST flag.
	ICU_NMICLR_BUSSCLR_1 = 0x1
	// Position of RECCCLR field.
	ICU_NMICLR_RECCCLR_Pos = 0x9
	// Bit mask of RECCCLR field.
	ICU_NMICLR_RECCCLR_Msk = 0x200
	// Bit RECCCLR.
	ICU_NMICLR_RECCCLR = 0x200
	// No effect.
	ICU_NMICLR_RECCCLR_0 = 0x0
	// Clear the NMISR.RECCST flag.
	ICU_NMICLR_RECCCLR_1 = 0x1
	// Position of RPECLR field.
	ICU_NMICLR_RPECLR_Pos = 0x8
	// Bit mask of RPECLR field.
	ICU_NMICLR_RPECLR_Msk = 0x100
	// Bit RPECLR.
	ICU_NMICLR_RPECLR = 0x100
	// No effect.
	ICU_NMICLR_RPECLR_0 = 0x0
	// Clear the NMISR.RPEST flag.
	ICU_NMICLR_RPECLR_1 = 0x1
	// Position of NMICLR field.
	ICU_NMICLR_NMICLR_Pos = 0x7
	// Bit mask of NMICLR field.
	ICU_NMICLR_NMICLR_Msk = 0x80
	// Bit NMICLR.
	ICU_NMICLR_NMICLR = 0x80
	// No effect.
	ICU_NMICLR_NMICLR_0 = 0x0
	// Clear the NMISR.NMIST flag.
	ICU_NMICLR_NMICLR_1 = 0x1
	// Position of OSTCLR field.
	ICU_NMICLR_OSTCLR_Pos = 0x6
	// Bit mask of OSTCLR field.
	ICU_NMICLR_OSTCLR_Msk = 0x40
	// Bit OSTCLR.
	ICU_NMICLR_OSTCLR = 0x40
	// No effect.
	ICU_NMICLR_OSTCLR_0 = 0x0
	// Clear the NMISR.OSTST flag.
	ICU_NMICLR_OSTCLR_1 = 0x1
	// Position of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Pos = 0x3
	// Bit mask of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Msk = 0x8
	// Bit LVD2CLR.
	ICU_NMICLR_LVD2CLR = 0x8
	// No effect.
	ICU_NMICLR_LVD2CLR_0 = 0x0
	// Clear the NMISR.LVD2ST flag.
	ICU_NMICLR_LVD2CLR_1 = 0x1
	// Position of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Pos = 0x2
	// Bit mask of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Msk = 0x4
	// Bit LVD1CLR.
	ICU_NMICLR_LVD1CLR = 0x4
	// No effect.
	ICU_NMICLR_LVD1CLR_0 = 0x0
	// Clear the NMISR.LVD1ST flag.
	ICU_NMICLR_LVD1CLR_1 = 0x1
	// Position of WDTCLR field.
	ICU_NMICLR_WDTCLR_Pos = 0x1
	// Bit mask of WDTCLR field.
	ICU_NMICLR_WDTCLR_Msk = 0x2
	// Bit WDTCLR.
	ICU_NMICLR_WDTCLR = 0x2
	// No effect.
	ICU_NMICLR_WDTCLR_0 = 0x0
	// Clear the NMISR.WDTST flag.
	ICU_NMICLR_WDTCLR_1 = 0x1
	// Position of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Pos = 0x0
	// Bit mask of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Msk = 0x1
	// Bit IWDTCLR.
	ICU_NMICLR_IWDTCLR = 0x1
	// No effect.
	ICU_NMICLR_IWDTCLR_0 = 0x0
	// Clear the NMISR.IWDTST flag.
	ICU_NMICLR_IWDTCLR_1 = 0x1

	// NMISR: Non-Maskable Interrupt Status Register
	// Position of SPEST field.
	ICU_NMISR_SPEST_Pos = 0xc
	// Bit mask of SPEST field.
	ICU_NMISR_SPEST_Msk = 0x1000
	// Bit SPEST.
	ICU_NMISR_SPEST = 0x1000
	// MPU Stack Error interrupt is not requested.
	ICU_NMISR_SPEST_0 = 0x0
	// MPU Stack Error interrupt is requested.
	ICU_NMISR_SPEST_1 = 0x1
	// Position of BUSMST field.
	ICU_NMISR_BUSMST_Pos = 0xb
	// Bit mask of BUSMST field.
	ICU_NMISR_BUSMST_Msk = 0x800
	// Bit BUSMST.
	ICU_NMISR_BUSMST = 0x800
	// MPU Bus Master Error interrupt is not requested.
	ICU_NMISR_BUSMST_0 = 0x0
	// MPU Bus Master Error interrupt is requested.
	ICU_NMISR_BUSMST_1 = 0x1
	// Position of BUSSST field.
	ICU_NMISR_BUSSST_Pos = 0xa
	// Bit mask of BUSSST field.
	ICU_NMISR_BUSSST_Msk = 0x400
	// Bit BUSSST.
	ICU_NMISR_BUSSST = 0x400
	// MPU Bus Slave Error interrupt is not requested.
	ICU_NMISR_BUSSST_0 = 0x0
	// MPU Bus Slave Error interrupt is requested.
	ICU_NMISR_BUSSST_1 = 0x1
	// Position of RECCST field.
	ICU_NMISR_RECCST_Pos = 0x9
	// Bit mask of RECCST field.
	ICU_NMISR_RECCST_Msk = 0x200
	// Bit RECCST.
	ICU_NMISR_RECCST = 0x200
	// RAM ECC Error interrupt is not requested.
	ICU_NMISR_RECCST_0 = 0x0
	// RAM ECC Error interrupt is requested.
	ICU_NMISR_RECCST_1 = 0x1
	// Position of RPEST field.
	ICU_NMISR_RPEST_Pos = 0x8
	// Bit mask of RPEST field.
	ICU_NMISR_RPEST_Msk = 0x100
	// Bit RPEST.
	ICU_NMISR_RPEST = 0x100
	// RAM Parity Error interrupt is not requested.
	ICU_NMISR_RPEST_0 = 0x0
	// RAM Parity Error interrupt is requested.
	ICU_NMISR_RPEST_1 = 0x1
	// Position of NMIST field.
	ICU_NMISR_NMIST_Pos = 0x7
	// Bit mask of NMIST field.
	ICU_NMISR_NMIST_Msk = 0x80
	// Bit NMIST.
	ICU_NMISR_NMIST = 0x80
	// NMI pin interrupt is not requested.
	ICU_NMISR_NMIST_0 = 0x0
	// NMI pin interrupt is requested.
	ICU_NMISR_NMIST_1 = 0x1
	// Position of OSTST field.
	ICU_NMISR_OSTST_Pos = 0x6
	// Bit mask of OSTST field.
	ICU_NMISR_OSTST_Msk = 0x40
	// Bit OSTST.
	ICU_NMISR_OSTST = 0x40
	// Oscillation stop detection interrupt is not requested.
	ICU_NMISR_OSTST_0 = 0x0
	// Oscillation stop detection interrupt is requested.
	ICU_NMISR_OSTST_1 = 0x1
	// Position of LVD2ST field.
	ICU_NMISR_LVD2ST_Pos = 0x3
	// Bit mask of LVD2ST field.
	ICU_NMISR_LVD2ST_Msk = 0x8
	// Bit LVD2ST.
	ICU_NMISR_LVD2ST = 0x8
	// Voltage-monitoring 2 interrupt is not requested.
	ICU_NMISR_LVD2ST_0 = 0x0
	// Voltage-monitoring 2 interrupt is requested.
	ICU_NMISR_LVD2ST_1 = 0x1
	// Position of LVD1ST field.
	ICU_NMISR_LVD1ST_Pos = 0x2
	// Bit mask of LVD1ST field.
	ICU_NMISR_LVD1ST_Msk = 0x4
	// Bit LVD1ST.
	ICU_NMISR_LVD1ST = 0x4
	// Voltage-monitoring 1 interrupt is not requested.
	ICU_NMISR_LVD1ST_0 = 0x0
	// Voltage-monitoring 1 interrupt is requested.
	ICU_NMISR_LVD1ST_1 = 0x1
	// Position of WDTST field.
	ICU_NMISR_WDTST_Pos = 0x1
	// Bit mask of WDTST field.
	ICU_NMISR_WDTST_Msk = 0x2
	// Bit WDTST.
	ICU_NMISR_WDTST = 0x2
	// WDT underflow/refresh error interrupt is not requested.
	ICU_NMISR_WDTST_0 = 0x0
	// WDT underflow/refresh error interrupt is requested.
	ICU_NMISR_WDTST_1 = 0x1
	// Position of IWDTST field.
	ICU_NMISR_IWDTST_Pos = 0x0
	// Bit mask of IWDTST field.
	ICU_NMISR_IWDTST_Msk = 0x1
	// Bit IWDTST.
	ICU_NMISR_IWDTST = 0x1
	// IWDT underflow/refresh error interrupt is not requested.
	ICU_NMISR_IWDTST_0 = 0x0
	// IWDT underflow/refresh error interrupt is requested.
	ICU_NMISR_IWDTST_1 = 0x1

	// WUPEN: Wake Up interrupt enable register
	// Position of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Pos = 0x1f
	// Bit mask of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Msk = 0x80000000
	// Bit IIC0WUPEN.
	ICU_WUPEN_IIC0WUPEN = 0x80000000
	// S/W standby returns by IIC0 address match interrupt is disabled
	ICU_WUPEN_IIC0WUPEN_0 = 0x0
	// S/W standby returns by IIC0 address match interrupt is enabled
	ICU_WUPEN_IIC0WUPEN_1 = 0x1
	// Position of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Pos = 0x1e
	// Bit mask of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Msk = 0x40000000
	// Bit AGT1CBWUPEN.
	ICU_WUPEN_AGT1CBWUPEN = 0x40000000
	// S/W standby returns by AGT1 compare match B interrupt is disabled
	ICU_WUPEN_AGT1CBWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match B interrupt is enabled
	ICU_WUPEN_AGT1CBWUPEN_1 = 0x1
	// Position of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Pos = 0x1d
	// Bit mask of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Msk = 0x20000000
	// Bit AGT1CAWUPEN.
	ICU_WUPEN_AGT1CAWUPEN = 0x20000000
	// S/W standby returns by AGT1 compare match A interrupt is disabled
	ICU_WUPEN_AGT1CAWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match A interrupt is enabled
	ICU_WUPEN_AGT1CAWUPEN_1 = 0x1
	// Position of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Pos = 0x1c
	// Bit mask of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Msk = 0x10000000
	// Bit AGT1UDWUPEN.
	ICU_WUPEN_AGT1UDWUPEN = 0x10000000
	// S/W standby returns by AGT1 underflow interrupt is disabled
	ICU_WUPEN_AGT1UDWUPEN_0 = 0x0
	// S/W standby returns by AGT1 underflow interrupt is enabled
	ICU_WUPEN_AGT1UDWUPEN_1 = 0x1
	// Position of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Pos = 0x1b
	// Bit mask of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Msk = 0x8000000
	// Bit USBFSWUPEN.
	ICU_WUPEN_USBFSWUPEN = 0x8000000
	// S/W standby returns by USBFS interrupt is disabled
	ICU_WUPEN_USBFSWUPEN_0 = 0x0
	// S/W standby returns by USBFS interrupt is enabled
	ICU_WUPEN_USBFSWUPEN_1 = 0x1
	// Position of USBHSWUPEN field.
	ICU_WUPEN_USBHSWUPEN_Pos = 0x1a
	// Bit mask of USBHSWUPEN field.
	ICU_WUPEN_USBHSWUPEN_Msk = 0x4000000
	// Bit USBHSWUPEN.
	ICU_WUPEN_USBHSWUPEN = 0x4000000
	// S/W standby returns by USBHS interrupt is disabled
	ICU_WUPEN_USBHSWUPEN_0 = 0x0
	// S/W standby returns by USBHS interrupt is enabled
	ICU_WUPEN_USBHSWUPEN_1 = 0x1
	// Position of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Pos = 0x19
	// Bit mask of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Msk = 0x2000000
	// Bit RTCPRDWUPEN.
	ICU_WUPEN_RTCPRDWUPEN = 0x2000000
	// S/W standby returns by RTC period interrupt is disabled
	ICU_WUPEN_RTCPRDWUPEN_0 = 0x0
	// S/W standby returns by RTC period interrupt is enabled
	ICU_WUPEN_RTCPRDWUPEN_1 = 0x1
	// Position of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Pos = 0x18
	// Bit mask of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Msk = 0x1000000
	// Bit RTCALMWUPEN.
	ICU_WUPEN_RTCALMWUPEN = 0x1000000
	// S/W standby returns by RTC alarm interrupt is disabled
	ICU_WUPEN_RTCALMWUPEN_0 = 0x0
	// S/W standby returns by RTC alarm interrupt is enabled
	ICU_WUPEN_RTCALMWUPEN_1 = 0x1
	// Position of ACMPHS0WUPEN field.
	ICU_WUPEN_ACMPHS0WUPEN_Pos = 0x16
	// Bit mask of ACMPHS0WUPEN field.
	ICU_WUPEN_ACMPHS0WUPEN_Msk = 0x400000
	// Bit ACMPHS0WUPEN.
	ICU_WUPEN_ACMPHS0WUPEN = 0x400000
	// S/W standby returns by ACMPHS0 interrupt is disabled
	ICU_WUPEN_ACMPHS0WUPEN_0 = 0x0
	// S/W standby returns by ACMPHS0 interrupt is enabled
	ICU_WUPEN_ACMPHS0WUPEN_1 = 0x1
	// Position of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Pos = 0x13
	// Bit mask of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Msk = 0x80000
	// Bit LVD2WUPEN.
	ICU_WUPEN_LVD2WUPEN = 0x80000
	// S/W standby returns by LVD2 interrupt is disabled
	ICU_WUPEN_LVD2WUPEN_0 = 0x0
	// S/W standby returns by LVD2 interrupt is enabled
	ICU_WUPEN_LVD2WUPEN_1 = 0x1
	// Position of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Pos = 0x12
	// Bit mask of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Msk = 0x40000
	// Bit LVD1WUPEN.
	ICU_WUPEN_LVD1WUPEN = 0x40000
	// S/W standby returns by LVD1 interrupt is disabled
	ICU_WUPEN_LVD1WUPEN_0 = 0x0
	// S/W standby returns by LVD1 interrupt is enabled
	ICU_WUPEN_LVD1WUPEN_1 = 0x1
	// Position of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Pos = 0x11
	// Bit mask of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Msk = 0x20000
	// Bit KEYWUPEN.
	ICU_WUPEN_KEYWUPEN = 0x20000
	// S/W standby returns by KEY interrupt is disabled
	ICU_WUPEN_KEYWUPEN_0 = 0x0
	// S/W standby returns by KEY interrupt is enabled
	ICU_WUPEN_KEYWUPEN_1 = 0x1
	// Position of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Pos = 0x10
	// Bit mask of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Msk = 0x10000
	// Bit IWDTWUPEN.
	ICU_WUPEN_IWDTWUPEN = 0x10000
	// S/W standby returns by IWDT interrupt is disabled
	ICU_WUPEN_IWDTWUPEN_0 = 0x0
	// S/W standby returns by IWDT interrupt is enabled
	ICU_WUPEN_IWDTWUPEN_1 = 0x1
	// Position of IRQWUPEN15 field.
	ICU_WUPEN_IRQWUPEN15_Pos = 0xf
	// Bit mask of IRQWUPEN15 field.
	ICU_WUPEN_IRQWUPEN15_Msk = 0x8000
	// Bit IRQWUPEN15.
	ICU_WUPEN_IRQWUPEN15 = 0x8000
	// S/W standby returns by IRQ15 interrupt is disabled
	ICU_WUPEN_IRQWUPEN15_0 = 0x0
	// S/W standby returns by IRQ15 interrupt is enabled
	ICU_WUPEN_IRQWUPEN15_1 = 0x1
	// Position of IRQWUPEN14 field.
	ICU_WUPEN_IRQWUPEN14_Pos = 0xe
	// Bit mask of IRQWUPEN14 field.
	ICU_WUPEN_IRQWUPEN14_Msk = 0x4000
	// Bit IRQWUPEN14.
	ICU_WUPEN_IRQWUPEN14 = 0x4000
	// S/W standby returns by IRQ14 interrupt is disabled
	ICU_WUPEN_IRQWUPEN14_0 = 0x0
	// S/W standby returns by IRQ14 interrupt is enabled
	ICU_WUPEN_IRQWUPEN14_1 = 0x1
	// Position of IRQWUPEN13 field.
	ICU_WUPEN_IRQWUPEN13_Pos = 0xd
	// Bit mask of IRQWUPEN13 field.
	ICU_WUPEN_IRQWUPEN13_Msk = 0x2000
	// Bit IRQWUPEN13.
	ICU_WUPEN_IRQWUPEN13 = 0x2000
	// S/W standby returns by IRQ13 interrupt is disabled
	ICU_WUPEN_IRQWUPEN13_0 = 0x0
	// S/W standby returns by IRQ13 interrupt is enabled
	ICU_WUPEN_IRQWUPEN13_1 = 0x1
	// Position of IRQWUPEN12 field.
	ICU_WUPEN_IRQWUPEN12_Pos = 0xc
	// Bit mask of IRQWUPEN12 field.
	ICU_WUPEN_IRQWUPEN12_Msk = 0x1000
	// Bit IRQWUPEN12.
	ICU_WUPEN_IRQWUPEN12 = 0x1000
	// S/W standby returns by IRQ12 interrupt is disabled
	ICU_WUPEN_IRQWUPEN12_0 = 0x0
	// S/W standby returns by IRQ12 interrupt is enabled
	ICU_WUPEN_IRQWUPEN12_1 = 0x1
	// Position of IRQWUPEN11 field.
	ICU_WUPEN_IRQWUPEN11_Pos = 0xb
	// Bit mask of IRQWUPEN11 field.
	ICU_WUPEN_IRQWUPEN11_Msk = 0x800
	// Bit IRQWUPEN11.
	ICU_WUPEN_IRQWUPEN11 = 0x800
	// S/W standby returns by IRQ11 interrupt is disabled
	ICU_WUPEN_IRQWUPEN11_0 = 0x0
	// S/W standby returns by IRQ11 interrupt is enabled
	ICU_WUPEN_IRQWUPEN11_1 = 0x1
	// Position of IRQWUPEN10 field.
	ICU_WUPEN_IRQWUPEN10_Pos = 0xa
	// Bit mask of IRQWUPEN10 field.
	ICU_WUPEN_IRQWUPEN10_Msk = 0x400
	// Bit IRQWUPEN10.
	ICU_WUPEN_IRQWUPEN10 = 0x400
	// S/W standby returns by IRQ10 interrupt is disabled
	ICU_WUPEN_IRQWUPEN10_0 = 0x0
	// S/W standby returns by IRQ10 interrupt is enabled
	ICU_WUPEN_IRQWUPEN10_1 = 0x1
	// Position of IRQWUPEN9 field.
	ICU_WUPEN_IRQWUPEN9_Pos = 0x9
	// Bit mask of IRQWUPEN9 field.
	ICU_WUPEN_IRQWUPEN9_Msk = 0x200
	// Bit IRQWUPEN9.
	ICU_WUPEN_IRQWUPEN9 = 0x200
	// S/W standby returns by IRQ9 interrupt is disabled
	ICU_WUPEN_IRQWUPEN9_0 = 0x0
	// S/W standby returns by IRQ9 interrupt is enabled
	ICU_WUPEN_IRQWUPEN9_1 = 0x1
	// Position of IRQWUPEN8 field.
	ICU_WUPEN_IRQWUPEN8_Pos = 0x8
	// Bit mask of IRQWUPEN8 field.
	ICU_WUPEN_IRQWUPEN8_Msk = 0x100
	// Bit IRQWUPEN8.
	ICU_WUPEN_IRQWUPEN8 = 0x100
	// S/W standby returns by IRQ8 interrupt is disabled
	ICU_WUPEN_IRQWUPEN8_0 = 0x0
	// S/W standby returns by IRQ8 interrupt is enabled
	ICU_WUPEN_IRQWUPEN8_1 = 0x1
	// Position of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Pos = 0x7
	// Bit mask of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Msk = 0x80
	// Bit IRQWUPEN7.
	ICU_WUPEN_IRQWUPEN7 = 0x80
	// S/W standby returns by IRQ7 interrupt is disabled
	ICU_WUPEN_IRQWUPEN7_0 = 0x0
	// S/W standby returns by IRQ7 interrupt is enabled
	ICU_WUPEN_IRQWUPEN7_1 = 0x1
	// Position of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Pos = 0x6
	// Bit mask of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Msk = 0x40
	// Bit IRQWUPEN6.
	ICU_WUPEN_IRQWUPEN6 = 0x40
	// S/W standby returns by IRQ6 interrupt is disabled
	ICU_WUPEN_IRQWUPEN6_0 = 0x0
	// S/W standby returns by IRQ6 interrupt is enabled
	ICU_WUPEN_IRQWUPEN6_1 = 0x1
	// Position of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Pos = 0x5
	// Bit mask of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Msk = 0x20
	// Bit IRQWUPEN5.
	ICU_WUPEN_IRQWUPEN5 = 0x20
	// S/W standby returns by IRQ5 interrupt is disabled
	ICU_WUPEN_IRQWUPEN5_0 = 0x0
	// S/W standby returns by IRQ5 interrupt is enabled
	ICU_WUPEN_IRQWUPEN5_1 = 0x1
	// Position of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Pos = 0x4
	// Bit mask of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Msk = 0x10
	// Bit IRQWUPEN4.
	ICU_WUPEN_IRQWUPEN4 = 0x10
	// S/W standby returns by IRQ4 interrupt is disabled
	ICU_WUPEN_IRQWUPEN4_0 = 0x0
	// S/W standby returns by IRQ4 interrupt is enabled
	ICU_WUPEN_IRQWUPEN4_1 = 0x1
	// Position of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Pos = 0x3
	// Bit mask of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Msk = 0x8
	// Bit IRQWUPEN3.
	ICU_WUPEN_IRQWUPEN3 = 0x8
	// S/W standby returns by IRQ3 interrupt is disabled
	ICU_WUPEN_IRQWUPEN3_0 = 0x0
	// S/W standby returns by IRQ3 interrupt is enabled
	ICU_WUPEN_IRQWUPEN3_1 = 0x1
	// Position of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Pos = 0x2
	// Bit mask of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Msk = 0x4
	// Bit IRQWUPEN2.
	ICU_WUPEN_IRQWUPEN2 = 0x4
	// S/W standby returns by IRQ2 interrupt is disabled
	ICU_WUPEN_IRQWUPEN2_0 = 0x0
	// S/W standby returns by IRQ2 interrupt is enabled
	ICU_WUPEN_IRQWUPEN2_1 = 0x1
	// Position of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Pos = 0x1
	// Bit mask of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Msk = 0x2
	// Bit IRQWUPEN1.
	ICU_WUPEN_IRQWUPEN1 = 0x2
	// S/W standby returns by IRQ1 interrupt is disabled
	ICU_WUPEN_IRQWUPEN1_0 = 0x0
	// S/W standby returns by IRQ1 interrupt is enabled
	ICU_WUPEN_IRQWUPEN1_1 = 0x1
	// Position of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Pos = 0x0
	// Bit mask of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Msk = 0x1
	// Bit IRQWUPEN0.
	ICU_WUPEN_IRQWUPEN0 = 0x1
	// S/W standby returns by IRQ0 interrupt is disabled
	ICU_WUPEN_IRQWUPEN0_0 = 0x0
	// S/W standby returns by IRQ0 interrupt is enabled
	ICU_WUPEN_IRQWUPEN0_1 = 0x1

	// SELSR0: SYS Event Link Setting Register
	// Position of SELS field.
	ICU_SELSR0_SELS_Pos = 0x0
	// Bit mask of SELS field.
	ICU_SELSR0_SELS_Msk = 0x1ff
	// Disable event output to the associated low-power mode module
	ICU_SELSR0_SELS_000000000 = 0x0

	// DELSR0: DMAC Event Link Setting Register %s
	// Position of IR field.
	ICU_DELSR_IR_Pos = 0x10
	// Bit mask of IR field.
	ICU_DELSR_IR_Msk = 0x10000
	// Bit IR.
	ICU_DELSR_IR = 0x10000
	// No interrupt request is generated
	ICU_DELSR_IR_0 = 0x0
	// An interrupt request is generated ( "1" write to the IR bit is prohibited. )
	ICU_DELSR_IR_1 = 0x1
	// Position of DELS field.
	ICU_DELSR_DELS_Pos = 0x0
	// Bit mask of DELS field.
	ICU_DELSR_DELS_Msk = 0x1ff
	// Nothing is selected.
	ICU_DELSR_DELS_0x000 = 0x0

	// IELSR0: INT Event Link Setting Register %s
	// Position of DTCE field.
	ICU_IELSR_DTCE_Pos = 0x18
	// Bit mask of DTCE field.
	ICU_IELSR_DTCE_Msk = 0x1000000
	// Bit DTCE.
	ICU_IELSR_DTCE = 0x1000000
	// DTC activation is disabled
	ICU_IELSR_DTCE_0 = 0x0
	// DTC activation is enabled
	ICU_IELSR_DTCE_1 = 0x1
	// Position of IR field.
	ICU_IELSR_IR_Pos = 0x10
	// Bit mask of IR field.
	ICU_IELSR_IR_Msk = 0x10000
	// Bit IR.
	ICU_IELSR_IR = 0x10000
	// No interrupt request is generated
	ICU_IELSR_IR_0 = 0x0
	// An interrupt request is generated ( "1" write to the IR bit is prohibited. )
	ICU_IELSR_IR_1 = 0x1
	// Position of IELS field.
	ICU_IELSR_IELS_Pos = 0x0
	// Bit mask of IELS field.
	ICU_IELSR_IELS_Msk = 0x1ff
	// Nothing is selected
	ICU_IELSR_IELS_0x000 = 0x0
)

// Constants for SRAM: SRAM Control
const (
	// PARIOAD: SRAM Parity Error Operation After Detection Register
	// Position of OAD field.
	SRAM_PARIOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_PARIOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_PARIOAD_OAD = 0x1
	// Non-maskable interrupt
	SRAM_PARIOAD_OAD_0 = 0x0
	// Reset
	SRAM_PARIOAD_OAD_1 = 0x1

	// SRAMPRCR: SRAM Protection Register
	// Position of KW field.
	SRAM_SRAMPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR_KW_Msk = 0xfe
	// Writing to the RAMPRCR bit is valid, when the KEY bits are written 1111000b.
	SRAM_SRAMPRCR_KW_1111000 = 0x78
	// Position of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Pos = 0x0
	// Bit mask of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Msk = 0x1
	// Bit SRAMPRCR.
	SRAM_SRAMPRCR_SRAMPRCR = 0x1
	// Disable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_0 = 0x0
	// Enable writes to protected registers
	SRAM_SRAMPRCR_SRAMPRCR_1 = 0x1

	// SRAMWTSC: RAM Wait State Control Register
	// Position of SRAM1WTEN field.
	SRAM_SRAMWTSC_SRAM1WTEN_Pos = 0x3
	// Bit mask of SRAM1WTEN field.
	SRAM_SRAMWTSC_SRAM1WTEN_Msk = 0x8
	// Bit SRAM1WTEN.
	SRAM_SRAMWTSC_SRAM1WTEN = 0x8
	// Not add wait state in read access cycle to SRAM1
	SRAM_SRAMWTSC_SRAM1WTEN_0 = 0x0
	// Add wait state in read access cycle to SRAM1
	SRAM_SRAMWTSC_SRAM1WTEN_1 = 0x1
	// Position of SRAM0WTEN field.
	SRAM_SRAMWTSC_SRAM0WTEN_Pos = 0x2
	// Bit mask of SRAM0WTEN field.
	SRAM_SRAMWTSC_SRAM0WTEN_Msk = 0x4
	// Bit SRAM0WTEN.
	SRAM_SRAMWTSC_SRAM0WTEN = 0x4
	// Not add wait state in read access cycle to SRAM0
	SRAM_SRAMWTSC_SRAM0WTEN_0 = 0x0
	// Add wait state in read access cycle to SRAM0
	SRAM_SRAMWTSC_SRAM0WTEN_1 = 0x1
	// Position of ECCRAMRDWTEN field.
	SRAM_SRAMWTSC_ECCRAMRDWTEN_Pos = 0x1
	// Bit mask of ECCRAMRDWTEN field.
	SRAM_SRAMWTSC_ECCRAMRDWTEN_Msk = 0x2
	// Bit ECCRAMRDWTEN.
	SRAM_SRAMWTSC_ECCRAMRDWTEN = 0x2
	// Not add wait state in read access cycle to SRAM0 (ECC area)
	SRAM_SRAMWTSC_ECCRAMRDWTEN_0 = 0x0
	// Add wait state in read access cycle to SRAM0 (ECC area)
	SRAM_SRAMWTSC_ECCRAMRDWTEN_1 = 0x1

	// ECCMODE: ECCRAM Operating Mode Control Register
	// Position of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Pos = 0x0
	// Bit mask of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Msk = 0x3
	// Disable ECC function
	SRAM_ECCMODE_ECCMOD_00 = 0x0
	// Setting prohibited
	SRAM_ECCMODE_ECCMOD_01 = 0x1
	// Enable ECC function without error checking
	SRAM_ECCMODE_ECCMOD_10 = 0x2
	// Enable ECC function with error checking.
	SRAM_ECCMODE_ECCMOD_11 = 0x3

	// ECC2STS: ECCRAM 2-Bit Error Status Register
	// Position of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Pos = 0x0
	// Bit mask of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Msk = 0x1
	// Bit ECC2ERR.
	SRAM_ECC2STS_ECC2ERR = 0x1
	// No 2-bit ECC error occurred
	SRAM_ECC2STS_ECC2ERR_0 = 0x0
	// 2-bit ECC error occurred
	SRAM_ECC2STS_ECC2ERR_1 = 0x1

	// ECC1STSEN: ECCRAM 1-Bit Error Information Update Enable Register
	// Position of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Pos = 0x0
	// Bit mask of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Msk = 0x1
	// Bit E1STSEN.
	SRAM_ECC1STSEN_E1STSEN = 0x1
	// Disables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_0 = 0x0
	// Enables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_1 = 0x1

	// ECC1STS: ECCRAM 1-Bit Error Status Register
	// Position of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Pos = 0x0
	// Bit mask of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Msk = 0x1
	// Bit ECC1ERR.
	SRAM_ECC1STS_ECC1ERR = 0x1
	// No 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_0 = 0x0
	// 1-bit ECC error occurred
	SRAM_ECC1STS_ECC1ERR_1 = 0x1

	// ECCPRCR: ECCRAM Protection Register
	// Position of KW field.
	SRAM_ECCPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_ECCPRCR_KW_Msk = 0xfe
	// Writing to the ECCRAMPRCR bit is valid, when the KEY bits are written 1111000b.
	SRAM_ECCPRCR_KW_1111000 = 0x78
	// Position of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Pos = 0x0
	// Bit mask of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Msk = 0x1
	// Bit ECCPRCR.
	SRAM_ECCPRCR_ECCPRCR = 0x1
	// Disable writes to protected registers
	SRAM_ECCPRCR_ECCPRCR_0 = 0x0
	// Enable writes to protected registers
	SRAM_ECCPRCR_ECCPRCR_1 = 0x1

	// ECCETST: ECC Test Control Register
	// Position of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Pos = 0x0
	// Bit mask of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Msk = 0x1
	// Bit TSTBYP.
	SRAM_ECCETST_TSTBYP = 0x1
	// ECC bypass disabled
	SRAM_ECCETST_TSTBYP_0 = 0x0
	// ECC bypass enabled.
	SRAM_ECCETST_TSTBYP_1 = 0x1

	// ECCOAD: RAM ECC Error Operation After Detection Register
	// Position of OAD field.
	SRAM_ECCOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_ECCOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_ECCOAD_OAD = 0x1
	// Non maskable interrupt.
	SRAM_ECCOAD_OAD_0 = 0x0
	// Internal reset.
	SRAM_ECCOAD_OAD_1 = 0x1
)

// Constants for GPT_ODC: PWM Delay Generation Circuit
const (
	// GTDLYCR: PWM Output Delay Control Register
	// Position of DLYRST field.
	GPT_ODC_GTDLYCR_DLYRST_Pos = 0x1
	// Bit mask of DLYRST field.
	GPT_ODC_GTDLYCR_DLYRST_Msk = 0x2
	// Bit DLYRST.
	GPT_ODC_GTDLYCR_DLYRST = 0x2
	// Normal operation
	GPT_ODC_GTDLYCR_DLYRST_0 = 0x0
	// Reset
	GPT_ODC_GTDLYCR_DLYRST_1 = 0x1
	// Position of DLLEN field.
	GPT_ODC_GTDLYCR_DLLEN_Pos = 0x0
	// Bit mask of DLLEN field.
	GPT_ODC_GTDLYCR_DLLEN_Msk = 0x1
	// Bit DLLEN.
	GPT_ODC_GTDLYCR_DLLEN = 0x1
	// Disable DLL operation
	GPT_ODC_GTDLYCR_DLLEN_0 = 0x0
	// Enable DLL operation
	GPT_ODC_GTDLYCR_DLLEN_1 = 0x1

	// GTDLYCR2: PWM Output Delay Control Register2
	// Position of DLYEN3 field.
	GPT_ODC_GTDLYCR2_DLYEN3_Pos = 0xb
	// Bit mask of DLYEN3 field.
	GPT_ODC_GTDLYCR2_DLYEN3_Msk = 0x800
	// Bit DLYEN3.
	GPT_ODC_GTDLYCR2_DLYEN3 = 0x800
	// Enable delay generation circuit of channel 3
	GPT_ODC_GTDLYCR2_DLYEN3_0 = 0x0
	// Disable delay generation circuit of channel 3
	GPT_ODC_GTDLYCR2_DLYEN3_1 = 0x1
	// Position of DLYEN2 field.
	GPT_ODC_GTDLYCR2_DLYEN2_Pos = 0xa
	// Bit mask of DLYEN2 field.
	GPT_ODC_GTDLYCR2_DLYEN2_Msk = 0x400
	// Bit DLYEN2.
	GPT_ODC_GTDLYCR2_DLYEN2 = 0x400
	// Enable delay generation circuit of channel 2
	GPT_ODC_GTDLYCR2_DLYEN2_0 = 0x0
	// Disable delay generation circuit of channel 2.
	GPT_ODC_GTDLYCR2_DLYEN2_1 = 0x1
	// Position of DLYEN1 field.
	GPT_ODC_GTDLYCR2_DLYEN1_Pos = 0x9
	// Bit mask of DLYEN1 field.
	GPT_ODC_GTDLYCR2_DLYEN1_Msk = 0x200
	// Bit DLYEN1.
	GPT_ODC_GTDLYCR2_DLYEN1 = 0x200
	// Enable delay generation circuit of channel 1
	GPT_ODC_GTDLYCR2_DLYEN1_0 = 0x0
	// Disable delay generation circuit of channel 1.
	GPT_ODC_GTDLYCR2_DLYEN1_1 = 0x1
	// Position of DLYEN0 field.
	GPT_ODC_GTDLYCR2_DLYEN0_Pos = 0x8
	// Bit mask of DLYEN0 field.
	GPT_ODC_GTDLYCR2_DLYEN0_Msk = 0x100
	// Bit DLYEN0.
	GPT_ODC_GTDLYCR2_DLYEN0 = 0x100
	// Enable delay generation circuit of channel 0
	GPT_ODC_GTDLYCR2_DLYEN0_0 = 0x0
	// Disable delay generation circuit of channel 0.
	GPT_ODC_GTDLYCR2_DLYEN0_1 = 0x1
	// Position of DLYBS3 field.
	GPT_ODC_GTDLYCR2_DLYBS3_Pos = 0x3
	// Bit mask of DLYBS3 field.
	GPT_ODC_GTDLYCR2_DLYBS3_Msk = 0x8
	// Bit DLYBS3.
	GPT_ODC_GTDLYCR2_DLYBS3 = 0x8
	// Bypass delay generation circuit of channel 3
	GPT_ODC_GTDLYCR2_DLYBS3_0 = 0x0
	// Do not bypass delay generation circuit of channel 3.
	GPT_ODC_GTDLYCR2_DLYBS3_1 = 0x1
	// Position of DLYBS2 field.
	GPT_ODC_GTDLYCR2_DLYBS2_Pos = 0x2
	// Bit mask of DLYBS2 field.
	GPT_ODC_GTDLYCR2_DLYBS2_Msk = 0x4
	// Bit DLYBS2.
	GPT_ODC_GTDLYCR2_DLYBS2 = 0x4
	// Bypass delay generation circuit of channel 2
	GPT_ODC_GTDLYCR2_DLYBS2_0 = 0x0
	// Do not bypass delay generation circuit of channel 2.
	GPT_ODC_GTDLYCR2_DLYBS2_1 = 0x1
	// Position of DLYBS1 field.
	GPT_ODC_GTDLYCR2_DLYBS1_Pos = 0x1
	// Bit mask of DLYBS1 field.
	GPT_ODC_GTDLYCR2_DLYBS1_Msk = 0x2
	// Bit DLYBS1.
	GPT_ODC_GTDLYCR2_DLYBS1 = 0x2
	// Bypass delay generation circuit of channel 1
	GPT_ODC_GTDLYCR2_DLYBS1_0 = 0x0
	// Do not bypass delay generation circuit of channel 1.
	GPT_ODC_GTDLYCR2_DLYBS1_1 = 0x1
	// Position of DLYBS0 field.
	GPT_ODC_GTDLYCR2_DLYBS0_Pos = 0x0
	// Bit mask of DLYBS0 field.
	GPT_ODC_GTDLYCR2_DLYBS0_Msk = 0x1
	// Bit DLYBS0.
	GPT_ODC_GTDLYCR2_DLYBS0 = 0x1
	// Bypass delay generation circuit of channel 0
	GPT_ODC_GTDLYCR2_DLYBS0_0 = 0x0
	// Do not bypass delay generation circuit of channel 0.
	GPT_ODC_GTDLYCR2_DLYBS0_1 = 0x1

	// GTDLYR0A: GTIOC%sA Rising Output Delay Register
	// Position of DLY field.
	GPT_ODC_GTDLYRA_DLY_Pos = 0x0
	// Bit mask of DLY field.
	GPT_ODC_GTDLYRA_DLY_Msk = 0x1f
	// No delay on rising edges
	GPT_ODC_GTDLYRA_DLY_00000 = 0x0

	// GTDLYR0B: GTIOC%sB Rising Output Delay Register
	// Position of DLY field.
	GPT_ODC_GTDLYRB_DLY_Pos = 0x0
	// Bit mask of DLY field.
	GPT_ODC_GTDLYRB_DLY_Msk = 0x1f
	// No delay on rising edges
	GPT_ODC_GTDLYRB_DLY_00000 = 0x0

	// GTDLYF0A: GTIOC%sA Falling Output Delay Register
	// Position of DLY field.
	GPT_ODC_GTDLYFA_DLY_Pos = 0x0
	// Bit mask of DLY field.
	GPT_ODC_GTDLYFA_DLY_Msk = 0x1f
	// No delay on rising edges
	GPT_ODC_GTDLYFA_DLY_00000 = 0x0

	// GTDLYF0B: GTIOC%sB Falling Output Delay Register
	// Position of DLY field.
	GPT_ODC_GTDLYFB_DLY_Pos = 0x0
	// Bit mask of DLY field.
	GPT_ODC_GTDLYFB_DLY_Msk = 0x1f
	// No delay on rising edges
	GPT_ODC_GTDLYFB_DLY_00000 = 0x0
)

// Constants for AGT0: Asynchronous General purpose Timer 0
const (
	// AGT: AGT Counter Register
	// Position of AGT field.
	AGT0_AGT_AGT_Pos = 0x0
	// Bit mask of AGT field.
	AGT0_AGT_AGT_Msk = 0xffff

	// AGTCMA: AGT Compare Match A Register
	// Position of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Pos = 0x0
	// Bit mask of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Msk = 0xffff

	// AGTCMB: AGT Compare Match B Register
	// Position of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Pos = 0x0
	// Bit mask of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Msk = 0xffff

	// AGTCR: AGT Control Register
	// Position of TCMBF field.
	AGT0_AGTCR_TCMBF_Pos = 0x7
	// Bit mask of TCMBF field.
	AGT0_AGTCR_TCMBF_Msk = 0x80
	// Bit TCMBF.
	AGT0_AGTCR_TCMBF = 0x80
	// No Match
	AGT0_AGTCR_TCMBF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMBF_1 = 0x1
	// Position of TCMAF field.
	AGT0_AGTCR_TCMAF_Pos = 0x6
	// Bit mask of TCMAF field.
	AGT0_AGTCR_TCMAF_Msk = 0x40
	// Bit TCMAF.
	AGT0_AGTCR_TCMAF = 0x40
	// No Match
	AGT0_AGTCR_TCMAF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMAF_1 = 0x1
	// Position of TUNDF field.
	AGT0_AGTCR_TUNDF_Pos = 0x5
	// Bit mask of TUNDF field.
	AGT0_AGTCR_TUNDF_Msk = 0x20
	// Bit TUNDF.
	AGT0_AGTCR_TUNDF = 0x20
	// No underflow
	AGT0_AGTCR_TUNDF_0 = 0x0
	// Underflow
	AGT0_AGTCR_TUNDF_1 = 0x1
	// Position of TEDGF field.
	AGT0_AGTCR_TEDGF_Pos = 0x4
	// Bit mask of TEDGF field.
	AGT0_AGTCR_TEDGF_Msk = 0x10
	// Bit TEDGF.
	AGT0_AGTCR_TEDGF = 0x10
	// No active edge received
	AGT0_AGTCR_TEDGF_0 = 0x0
	// Active edge received
	AGT0_AGTCR_TEDGF_1 = 0x1
	// Position of TSTOP field.
	AGT0_AGTCR_TSTOP_Pos = 0x2
	// Bit mask of TSTOP field.
	AGT0_AGTCR_TSTOP_Msk = 0x4
	// Bit TSTOP.
	AGT0_AGTCR_TSTOP = 0x4
	// no effect
	AGT0_AGTCR_TSTOP_0 = 0x0
	// The count is forcibly stopped.
	AGT0_AGTCR_TSTOP_1 = 0x1
	// Position of TCSTF field.
	AGT0_AGTCR_TCSTF_Pos = 0x1
	// Bit mask of TCSTF field.
	AGT0_AGTCR_TCSTF_Msk = 0x2
	// Bit TCSTF.
	AGT0_AGTCR_TCSTF = 0x2
	// Count stops
	AGT0_AGTCR_TCSTF_0 = 0x0
	// Count starts
	AGT0_AGTCR_TCSTF_1 = 0x1
	// Position of TSTART field.
	AGT0_AGTCR_TSTART_Pos = 0x0
	// Bit mask of TSTART field.
	AGT0_AGTCR_TSTART_Msk = 0x1
	// Bit TSTART.
	AGT0_AGTCR_TSTART = 0x1
	// Count stops
	AGT0_AGTCR_TSTART_0 = 0x0
	// Count starts
	AGT0_AGTCR_TSTART_1 = 0x1

	// AGTMR1: AGT Mode Register 1
	// Position of TCK field.
	AGT0_AGTMR1_TCK_Pos = 0x4
	// Bit mask of TCK field.
	AGT0_AGTMR1_TCK_Msk = 0x70
	// PCLKB
	AGT0_AGTMR1_TCK_000 = 0x0
	// PCLKB/8
	AGT0_AGTMR1_TCK_001 = 0x1
	// PCLKB/2
	AGT0_AGTMR1_TCK_011 = 0x3
	// Divided clock LOCO specified by AGTMR2.CKS bit.
	AGT0_AGTMR1_TCK_100 = 0x4
	// Underflow event signal from AGT
	AGT0_AGTMR1_TCK_101 = 0x5
	// Divided clock fSUB specified by AGTMR2.CKS bit.
	AGT0_AGTMR1_TCK_110 = 0x6
	// Position of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Pos = 0x3
	// Bit mask of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Msk = 0x8
	// Bit TEDGPL.
	AGT0_AGTMR1_TEDGPL = 0x8
	// One edge
	AGT0_AGTMR1_TEDGPL_0 = 0x0
	// Both edges
	AGT0_AGTMR1_TEDGPL_1 = 0x1
	// Position of TMOD field.
	AGT0_AGTMR1_TMOD_Pos = 0x0
	// Bit mask of TMOD field.
	AGT0_AGTMR1_TMOD_Msk = 0x7
	// Timer mode
	AGT0_AGTMR1_TMOD_000 = 0x0
	// Pulse output mode
	AGT0_AGTMR1_TMOD_001 = 0x1
	// Event counter mode
	AGT0_AGTMR1_TMOD_010 = 0x2
	// Pulse width measurement mode
	AGT0_AGTMR1_TMOD_011 = 0x3
	// Pulse period measurement mode
	AGT0_AGTMR1_TMOD_100 = 0x4

	// AGTMR2: AGT Mode Register 2
	// Position of LPM field.
	AGT0_AGTMR2_LPM_Pos = 0x7
	// Bit mask of LPM field.
	AGT0_AGTMR2_LPM_Msk = 0x80
	// Bit LPM.
	AGT0_AGTMR2_LPM = 0x80
	// Normal mode
	AGT0_AGTMR2_LPM_0 = 0x0
	// Low Power mode
	AGT0_AGTMR2_LPM_1 = 0x1
	// Position of CKS field.
	AGT0_AGTMR2_CKS_Pos = 0x0
	// Bit mask of CKS field.
	AGT0_AGTMR2_CKS_Msk = 0x7
	// 1/1
	AGT0_AGTMR2_CKS_000 = 0x0
	// 1/2
	AGT0_AGTMR2_CKS_001 = 0x1
	// 1/4
	AGT0_AGTMR2_CKS_010 = 0x2
	// 1/8
	AGT0_AGTMR2_CKS_011 = 0x3
	// 1/16
	AGT0_AGTMR2_CKS_100 = 0x4
	// 1/32
	AGT0_AGTMR2_CKS_101 = 0x5
	// 1/64
	AGT0_AGTMR2_CKS_110 = 0x6
	// 1/128
	AGT0_AGTMR2_CKS_111 = 0x7

	// AGTIOC: AGT I/O Control Register
	// Position of TIOGT field.
	AGT0_AGTIOC_TIOGT_Pos = 0x6
	// Bit mask of TIOGT field.
	AGT0_AGTIOC_TIOGT_Msk = 0xc0
	// Event is always counted
	AGT0_AGTIOC_TIOGT_00 = 0x0
	// Event is counted during polarity period specified for AGTEE
	AGT0_AGTIOC_TIOGT_01 = 0x1
	// Position of TIPF field.
	AGT0_AGTIOC_TIPF_Pos = 0x4
	// Bit mask of TIPF field.
	AGT0_AGTIOC_TIPF_Msk = 0x30
	// No filter
	AGT0_AGTIOC_TIPF_00 = 0x0
	// Filter sampled at PCLKB
	AGT0_AGTIOC_TIPF_01 = 0x1
	// Filter sampled at PCLKB/8
	AGT0_AGTIOC_TIPF_10 = 0x2
	// Filter sampled at PCLKB/32
	AGT0_AGTIOC_TIPF_11 = 0x3
	// Position of TOE field.
	AGT0_AGTIOC_TOE_Pos = 0x2
	// Bit mask of TOE field.
	AGT0_AGTIOC_TOE_Msk = 0x4
	// Bit TOE.
	AGT0_AGTIOC_TOE = 0x4
	// AGTO output disabled (port)
	AGT0_AGTIOC_TOE_0 = 0x0
	// AGTO output enabled
	AGT0_AGTIOC_TOE_1 = 0x1
	// Position of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Pos = 0x0
	// Bit mask of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Msk = 0x1
	// Bit TEDGSEL.
	AGT0_AGTIOC_TEDGSEL = 0x1

	// AGTISR: AGT Event Pin Select Register
	// Position of EEPS field.
	AGT0_AGTISR_EEPS_Pos = 0x2
	// Bit mask of EEPS field.
	AGT0_AGTISR_EEPS_Msk = 0x4
	// Bit EEPS.
	AGT0_AGTISR_EEPS = 0x4
	// An event is counted during the low-level period
	AGT0_AGTISR_EEPS_0 = 0x0
	// An event is counted during the high-level period
	AGT0_AGTISR_EEPS_1 = 0x1

	// AGTCMSR: AGT Compare Match Function Select Register
	// Position of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Pos = 0x6
	// Bit mask of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Msk = 0x40
	// Bit TOPOLB.
	AGT0_AGTCMSR_TOPOLB = 0x40
	// AGTOB Output is started at low
	AGT0_AGTCMSR_TOPOLB_0 = 0x0
	// AGTOB Output is started at high
	AGT0_AGTCMSR_TOPOLB_1 = 0x1
	// Position of TOEB field.
	AGT0_AGTCMSR_TOEB_Pos = 0x5
	// Bit mask of TOEB field.
	AGT0_AGTCMSR_TOEB_Msk = 0x20
	// Bit TOEB.
	AGT0_AGTCMSR_TOEB = 0x20
	// AGTOB output disabled (port)
	AGT0_AGTCMSR_TOEB_0 = 0x0
	// AGTOB output enabled
	AGT0_AGTCMSR_TOEB_1 = 0x1
	// Position of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Pos = 0x4
	// Bit mask of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Msk = 0x10
	// Bit TCMEB.
	AGT0_AGTCMSR_TCMEB = 0x10
	// Disable compare match B register
	AGT0_AGTCMSR_TCMEB_0 = 0x0
	// Enable compare match B register
	AGT0_AGTCMSR_TCMEB_1 = 0x1
	// Position of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Pos = 0x2
	// Bit mask of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Msk = 0x4
	// Bit TOPOLA.
	AGT0_AGTCMSR_TOPOLA = 0x4
	// AGTOA Output is started at low
	AGT0_AGTCMSR_TOPOLA_0 = 0x0
	// AGTOA Output is started at high
	AGT0_AGTCMSR_TOPOLA_1 = 0x1
	// Position of TOEA field.
	AGT0_AGTCMSR_TOEA_Pos = 0x1
	// Bit mask of TOEA field.
	AGT0_AGTCMSR_TOEA_Msk = 0x2
	// Bit TOEA.
	AGT0_AGTCMSR_TOEA = 0x2
	// AGTOA output disabled (port)
	AGT0_AGTCMSR_TOEA_0 = 0x0
	// AGTOA output enabled
	AGT0_AGTCMSR_TOEA_1 = 0x1
	// Position of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Pos = 0x0
	// Bit mask of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Msk = 0x1
	// Bit TCMEA.
	AGT0_AGTCMSR_TCMEA = 0x1
	// Disable compare match A register
	AGT0_AGTCMSR_TCMEA_0 = 0x0
	// Enable compare match A register
	AGT0_AGTCMSR_TCMEA_1 = 0x1

	// AGTIOSEL: AGT Pin Select Register
	// Position of TIES field.
	AGT0_AGTIOSEL_TIES_Pos = 0x4
	// Bit mask of TIES field.
	AGT0_AGTIOSEL_TIES_Msk = 0x10
	// Bit TIES.
	AGT0_AGTIOSEL_TIES = 0x10
	// external event input disable during software standby mode
	AGT0_AGTIOSEL_TIES_0 = 0x0
	// external event input enable during software standby mode
	AGT0_AGTIOSEL_TIES_1 = 0x1
	// Position of SEL field.
	AGT0_AGTIOSEL_SEL_Pos = 0x0
	// Bit mask of SEL field.
	AGT0_AGTIOSEL_SEL_Msk = 0x3
	// AGTIO_A can not be used as AGTIO input pin in deep software standby mode
	AGT0_AGTIOSEL_SEL_00 = 0x0
	// Setting prohibited
	AGT0_AGTIOSEL_SEL_01 = 0x1
	// AGTIO_B can be used as AGTIO input pin in deep software standby mode. AGTIO_B is input only. It is not possible to output.
	AGT0_AGTIOSEL_SEL_10 = 0x2
	// AGTIO_C can be used as AGTIO input pin in deep software standby mode. AGTIO_C is input only. It is not possible to output.
	AGT0_AGTIOSEL_SEL_11 = 0x3
)

// Constants for FCACHE: Flash Cache
const (
	// FCACHEE: Flash Cache Enable Register
	// Position of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Pos = 0x0
	// Bit mask of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Msk = 0x1
	// Bit FCACHEEN.
	FCACHE_FCACHEE_FCACHEEN = 0x1
	// FCACHE is disabled
	FCACHE_FCACHEE_FCACHEEN_0 = 0x0
	// FCACHE is enabled
	FCACHE_FCACHEE_FCACHEEN_1 = 0x1

	// FCACHEIV: Flash Cache Invalidate Register
	// Position of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Pos = 0x0
	// Bit mask of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Msk = 0x1
	// Bit FCACHEIV.
	FCACHE_FCACHEIV_FCACHEIV = 0x1
	// (Read)not in progress / (Write) no effect.
	FCACHE_FCACHEIV_FCACHEIV_0 = 0x0
	// (Read)in progress /(Write) Starting Cache Invalidation
	FCACHE_FCACHEIV_FCACHEIV_1 = 0x1

	// FLWT: Flash Wait Cycle Register
	// Position of FLWT field.
	FCACHE_FLWT_FLWT_Pos = 0x0
	// Bit mask of FLWT field.
	FCACHE_FLWT_FLWT_Msk = 0x7
	// 0 wait (ICLK<=80MHz)
	FCACHE_FLWT_FLWT_000 = 0x0
	// 1 wait (80MHz < ICLK <=160MHz)
	FCACHE_FLWT_FLWT_001 = 0x1
	// 2 waits (160MHz < ICLK <=240MHz)
	FCACHE_FLWT_FLWT_010 = 0x2
)

// Constants for BUS: BUS Control
const (
	// CS0MOD: CS%s Mode Register
	// Position of PRMOD field.
	BUS_CSMOD_PRMOD_Pos = 0xf
	// Bit mask of PRMOD field.
	BUS_CSMOD_PRMOD_Msk = 0x8000
	// Bit PRMOD.
	BUS_CSMOD_PRMOD = 0x8000
	// Normal access compatible mode
	BUS_CSMOD_PRMOD_0 = 0x0
	// External data read continuous assertion mode
	BUS_CSMOD_PRMOD_1 = 0x1
	// Position of PWENB field.
	BUS_CSMOD_PWENB_Pos = 0x9
	// Bit mask of PWENB field.
	BUS_CSMOD_PWENB_Msk = 0x200
	// Bit PWENB.
	BUS_CSMOD_PWENB = 0x200
	// Disable
	BUS_CSMOD_PWENB_0 = 0x0
	// Enable
	BUS_CSMOD_PWENB_1 = 0x1
	// Position of PRENB field.
	BUS_CSMOD_PRENB_Pos = 0x8
	// Bit mask of PRENB field.
	BUS_CSMOD_PRENB_Msk = 0x100
	// Bit PRENB.
	BUS_CSMOD_PRENB = 0x100
	// Disable
	BUS_CSMOD_PRENB_0 = 0x0
	// Enable
	BUS_CSMOD_PRENB_1 = 0x1
	// Position of EWENB field.
	BUS_CSMOD_EWENB_Pos = 0x3
	// Bit mask of EWENB field.
	BUS_CSMOD_EWENB_Msk = 0x8
	// Bit EWENB.
	BUS_CSMOD_EWENB = 0x8
	// Disable
	BUS_CSMOD_EWENB_0 = 0x0
	// Enable
	BUS_CSMOD_EWENB_1 = 0x1
	// Position of WRMOD field.
	BUS_CSMOD_WRMOD_Pos = 0x0
	// Bit mask of WRMOD field.
	BUS_CSMOD_WRMOD_Msk = 0x1
	// Bit WRMOD.
	BUS_CSMOD_WRMOD = 0x1
	// Byte strobe mode
	BUS_CSMOD_WRMOD_0 = 0x0
	// Single write strobe mode
	BUS_CSMOD_WRMOD_1 = 0x1

	// CS0WCR1: CS%s Wait Control Register 1
	// Position of CSRWAIT field.
	BUS_CSWCR1_CSRWAIT_Pos = 0x18
	// Bit mask of CSRWAIT field.
	BUS_CSWCR1_CSRWAIT_Msk = 0x1f000000
	// No wait is inserted.
	BUS_CSWCR1_CSRWAIT_0x00 = 0x0
	// Position of CSWWAIT field.
	BUS_CSWCR1_CSWWAIT_Pos = 0x10
	// Bit mask of CSWWAIT field.
	BUS_CSWCR1_CSWWAIT_Msk = 0x1f0000
	// No wait is inserted.
	BUS_CSWCR1_CSWWAIT_0x00 = 0x0
	// Position of CSPRWAIT field.
	BUS_CSWCR1_CSPRWAIT_Pos = 0x8
	// Bit mask of CSPRWAIT field.
	BUS_CSWCR1_CSPRWAIT_Msk = 0x700
	// No wait is inserted.
	BUS_CSWCR1_CSPRWAIT_0x0 = 0x0
	// Position of CSPWWAIT field.
	BUS_CSWCR1_CSPWWAIT_Pos = 0x0
	// Bit mask of CSPWWAIT field.
	BUS_CSWCR1_CSPWWAIT_Msk = 0x7
	// No wait is inserted.
	BUS_CSWCR1_CSPWWAIT_0x0 = 0x0

	// CS0WCR2: CS%s Wait Control Register 2
	// Position of CSON field.
	BUS_CSWCR2_CSON_Pos = 0x1c
	// Bit mask of CSON field.
	BUS_CSWCR2_CSON_Msk = 0x70000000
	// No wait is inserted.
	BUS_CSWCR2_CSON_0x0 = 0x0
	// Position of WDON field.
	BUS_CSWCR2_WDON_Pos = 0x18
	// Bit mask of WDON field.
	BUS_CSWCR2_WDON_Msk = 0x7000000
	// No wait is inserted.
	BUS_CSWCR2_WDON_0x0 = 0x0
	// Position of WRON field.
	BUS_CSWCR2_WRON_Pos = 0x14
	// Bit mask of WRON field.
	BUS_CSWCR2_WRON_Msk = 0x700000
	// No wait is inserted.
	BUS_CSWCR2_WRON_0x0 = 0x0
	// Position of RDON field.
	BUS_CSWCR2_RDON_Pos = 0x10
	// Bit mask of RDON field.
	BUS_CSWCR2_RDON_Msk = 0x70000
	// No wait is inserted.
	BUS_CSWCR2_RDON_0x0 = 0x0
	// Position of AWAIT field.
	BUS_CSWCR2_AWAIT_Pos = 0xc
	// Bit mask of AWAIT field.
	BUS_CSWCR2_AWAIT_Msk = 0x3000
	// No wait is inserted.
	BUS_CSWCR2_AWAIT_0x0 = 0x0
	// Position of WDOFF field.
	BUS_CSWCR2_WDOFF_Pos = 0x8
	// Bit mask of WDOFF field.
	BUS_CSWCR2_WDOFF_Msk = 0x700
	// No wait is inserted.
	BUS_CSWCR2_WDOFF_0x0 = 0x0
	// Position of CSWOFF field.
	BUS_CSWCR2_CSWOFF_Pos = 0x4
	// Bit mask of CSWOFF field.
	BUS_CSWCR2_CSWOFF_Msk = 0x70
	// No wait is inserted.
	BUS_CSWCR2_CSWOFF_0x0 = 0x0
	// Position of CSROFF field.
	BUS_CSWCR2_CSROFF_Pos = 0x0
	// Bit mask of CSROFF field.
	BUS_CSWCR2_CSROFF_Msk = 0x7
	// No wait is inserted.
	BUS_CSWCR2_CSROFF_0x0 = 0x0

	// CS0CR: CS0 Control Register
	// Position of MPXEN field.
	BUS_CS0CR_MPXEN_Pos = 0xc
	// Bit mask of MPXEN field.
	BUS_CS0CR_MPXEN_Msk = 0x1000
	// Bit MPXEN.
	BUS_CS0CR_MPXEN = 0x1000
	// Separate bus interface is selected for area n
	BUS_CS0CR_MPXEN_0 = 0x0
	// Address/data multiplexed I/O interface is selected for area n. (n = 0 to 7)
	BUS_CS0CR_MPXEN_1 = 0x1
	// Position of EMODE field.
	BUS_CS0CR_EMODE_Pos = 0x8
	// Bit mask of EMODE field.
	BUS_CS0CR_EMODE_Msk = 0x100
	// Bit EMODE.
	BUS_CS0CR_EMODE = 0x100
	// Little Endian
	BUS_CS0CR_EMODE_0 = 0x0
	// Big Endian
	BUS_CS0CR_EMODE_1 = 0x1
	// Position of BSIZE field.
	BUS_CS0CR_BSIZE_Pos = 0x4
	// Bit mask of BSIZE field.
	BUS_CS0CR_BSIZE_Msk = 0x30
	// A 16-bit bus space
	BUS_CS0CR_BSIZE_00 = 0x0
	// Setting prohibited
	BUS_CS0CR_BSIZE_01 = 0x1
	// An 8-bit bus space
	BUS_CS0CR_BSIZE_10 = 0x2
	// Setting prohibited
	BUS_CS0CR_BSIZE_11 = 0x3
	// Position of EXENB field.
	BUS_CS0CR_EXENB_Pos = 0x0
	// Bit mask of EXENB field.
	BUS_CS0CR_EXENB_Msk = 0x1
	// Bit EXENB.
	BUS_CS0CR_EXENB = 0x1
	// Disable operation
	BUS_CS0CR_EXENB_0 = 0x0
	// Enable operation
	BUS_CS0CR_EXENB_1 = 0x1

	// CS0REC: CS%s Recovery Cycle Register
	// Position of WRCV field.
	BUS_CSREC_WRCV_Pos = 0x8
	// Bit mask of WRCV field.
	BUS_CSREC_WRCV_Msk = 0xf00
	// No recovery cycle is inserted.
	BUS_CSREC_WRCV_0x0 = 0x0
	// Position of RRCV field.
	BUS_CSREC_RRCV_Pos = 0x0
	// Bit mask of RRCV field.
	BUS_CSREC_RRCV_Msk = 0xf
	// No recovery cycle is inserted.
	BUS_CSREC_RRCV_0x0 = 0x0

	// CS1CR: CS%s Control Register
	// Position of MPXEN field.
	BUS_CSCR_MPXEN_Pos = 0xc
	// Bit mask of MPXEN field.
	BUS_CSCR_MPXEN_Msk = 0x1000
	// Bit MPXEN.
	BUS_CSCR_MPXEN = 0x1000
	// Separate bus interface is selected for area n
	BUS_CSCR_MPXEN_0 = 0x0
	// Address/data multiplexed I/O interface is selected for area n. (n = 0 to 7)
	BUS_CSCR_MPXEN_1 = 0x1
	// Position of EMODE field.
	BUS_CSCR_EMODE_Pos = 0x8
	// Bit mask of EMODE field.
	BUS_CSCR_EMODE_Msk = 0x100
	// Bit EMODE.
	BUS_CSCR_EMODE = 0x100
	// Little Endian
	BUS_CSCR_EMODE_0 = 0x0
	// Big Endian
	BUS_CSCR_EMODE_1 = 0x1
	// Position of BSIZE field.
	BUS_CSCR_BSIZE_Pos = 0x4
	// Bit mask of BSIZE field.
	BUS_CSCR_BSIZE_Msk = 0x30
	// A 16-bit bus space
	BUS_CSCR_BSIZE_00 = 0x0
	// Setting prohibited
	BUS_CSCR_BSIZE_01 = 0x1
	// An 8-bit bus space
	BUS_CSCR_BSIZE_10 = 0x2
	// Setting prohibited
	BUS_CSCR_BSIZE_11 = 0x3
	// Position of EXENB field.
	BUS_CSCR_EXENB_Pos = 0x0
	// Bit mask of EXENB field.
	BUS_CSCR_EXENB_Msk = 0x1
	// Bit EXENB.
	BUS_CSCR_EXENB = 0x1
	// Disable operation
	BUS_CSCR_EXENB_0 = 0x0
	// Enable operation
	BUS_CSCR_EXENB_1 = 0x1

	// CSRECEN: CS Recovery Cycle Insertion Enable Register
	// Position of RCVENM7 field.
	BUS_CSRECEN_RCVENM7_Pos = 0xf
	// Bit mask of RCVENM7 field.
	BUS_CSRECEN_RCVENM7_Msk = 0x8000
	// Bit RCVENM7.
	BUS_CSRECEN_RCVENM7 = 0x8000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM7_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM7_1 = 0x1
	// Position of RCVENM6 field.
	BUS_CSRECEN_RCVENM6_Pos = 0xe
	// Bit mask of RCVENM6 field.
	BUS_CSRECEN_RCVENM6_Msk = 0x4000
	// Bit RCVENM6.
	BUS_CSRECEN_RCVENM6 = 0x4000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM6_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM6_1 = 0x1
	// Position of RCVENM5 field.
	BUS_CSRECEN_RCVENM5_Pos = 0xd
	// Bit mask of RCVENM5 field.
	BUS_CSRECEN_RCVENM5_Msk = 0x2000
	// Bit RCVENM5.
	BUS_CSRECEN_RCVENM5 = 0x2000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM5_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM5_1 = 0x1
	// Position of RCVENM4 field.
	BUS_CSRECEN_RCVENM4_Pos = 0xc
	// Bit mask of RCVENM4 field.
	BUS_CSRECEN_RCVENM4_Msk = 0x1000
	// Bit RCVENM4.
	BUS_CSRECEN_RCVENM4 = 0x1000
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM4_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM4_1 = 0x1
	// Position of RCVENM3 field.
	BUS_CSRECEN_RCVENM3_Pos = 0xb
	// Bit mask of RCVENM3 field.
	BUS_CSRECEN_RCVENM3_Msk = 0x800
	// Bit RCVENM3.
	BUS_CSRECEN_RCVENM3 = 0x800
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM3_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM3_1 = 0x1
	// Position of RCVENM2 field.
	BUS_CSRECEN_RCVENM2_Pos = 0xa
	// Bit mask of RCVENM2 field.
	BUS_CSRECEN_RCVENM2_Msk = 0x400
	// Bit RCVENM2.
	BUS_CSRECEN_RCVENM2 = 0x400
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM2_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM2_1 = 0x1
	// Position of RCVENM1 field.
	BUS_CSRECEN_RCVENM1_Pos = 0x9
	// Bit mask of RCVENM1 field.
	BUS_CSRECEN_RCVENM1_Msk = 0x200
	// Bit RCVENM1.
	BUS_CSRECEN_RCVENM1 = 0x200
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM1_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM1_1 = 0x1
	// Position of RCVENM0 field.
	BUS_CSRECEN_RCVENM0_Pos = 0x8
	// Bit mask of RCVENM0 field.
	BUS_CSRECEN_RCVENM0_Msk = 0x100
	// Bit RCVENM0.
	BUS_CSRECEN_RCVENM0 = 0x100
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVENM0_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVENM0_1 = 0x1
	// Position of RCVEN7 field.
	BUS_CSRECEN_RCVEN7_Pos = 0x7
	// Bit mask of RCVEN7 field.
	BUS_CSRECEN_RCVEN7_Msk = 0x80
	// Bit RCVEN7.
	BUS_CSRECEN_RCVEN7 = 0x80
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN7_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN7_1 = 0x1
	// Position of RCVEN6 field.
	BUS_CSRECEN_RCVEN6_Pos = 0x6
	// Bit mask of RCVEN6 field.
	BUS_CSRECEN_RCVEN6_Msk = 0x40
	// Bit RCVEN6.
	BUS_CSRECEN_RCVEN6 = 0x40
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN6_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN6_1 = 0x1
	// Position of RCVEN5 field.
	BUS_CSRECEN_RCVEN5_Pos = 0x5
	// Bit mask of RCVEN5 field.
	BUS_CSRECEN_RCVEN5_Msk = 0x20
	// Bit RCVEN5.
	BUS_CSRECEN_RCVEN5 = 0x20
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN5_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN5_1 = 0x1
	// Position of RCVEN4 field.
	BUS_CSRECEN_RCVEN4_Pos = 0x4
	// Bit mask of RCVEN4 field.
	BUS_CSRECEN_RCVEN4_Msk = 0x10
	// Bit RCVEN4.
	BUS_CSRECEN_RCVEN4 = 0x10
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN4_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN4_1 = 0x1
	// Position of RCVEN3 field.
	BUS_CSRECEN_RCVEN3_Pos = 0x3
	// Bit mask of RCVEN3 field.
	BUS_CSRECEN_RCVEN3_Msk = 0x8
	// Bit RCVEN3.
	BUS_CSRECEN_RCVEN3 = 0x8
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN3_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN3_1 = 0x1
	// Position of RCVEN2 field.
	BUS_CSRECEN_RCVEN2_Pos = 0x2
	// Bit mask of RCVEN2 field.
	BUS_CSRECEN_RCVEN2_Msk = 0x4
	// Bit RCVEN2.
	BUS_CSRECEN_RCVEN2 = 0x4
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN2_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN2_1 = 0x1
	// Position of RCVEN1 field.
	BUS_CSRECEN_RCVEN1_Pos = 0x1
	// Bit mask of RCVEN1 field.
	BUS_CSRECEN_RCVEN1_Msk = 0x2
	// Bit RCVEN1.
	BUS_CSRECEN_RCVEN1 = 0x2
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN1_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN1_1 = 0x1
	// Position of RCVEN0 field.
	BUS_CSRECEN_RCVEN0_Pos = 0x0
	// Bit mask of RCVEN0 field.
	BUS_CSRECEN_RCVEN0_Msk = 0x1
	// Bit RCVEN0.
	BUS_CSRECEN_RCVEN0 = 0x1
	// Recovery cycle insertion is disabled.
	BUS_CSRECEN_RCVEN0_0 = 0x0
	// Recovery cycle insertion is enabled.
	BUS_CSRECEN_RCVEN0_1 = 0x1

	// SDCCR: SDC Control Register
	// Position of BSIZE field.
	BUS_SDCCR_BSIZE_Pos = 0x4
	// Bit mask of BSIZE field.
	BUS_SDCCR_BSIZE_Msk = 0x30
	// A 16-bit bus space
	BUS_SDCCR_BSIZE_00 = 0x0
	// Setting prohibited
	BUS_SDCCR_BSIZE_01 = 0x1
	// An 8-bit bus space
	BUS_SDCCR_BSIZE_10 = 0x2
	// Setting prohibited
	BUS_SDCCR_BSIZE_11 = 0x3
	// Position of EXENB field.
	BUS_SDCCR_EXENB_Pos = 0x0
	// Bit mask of EXENB field.
	BUS_SDCCR_EXENB_Msk = 0x1
	// Bit EXENB.
	BUS_SDCCR_EXENB = 0x1
	// Disable
	BUS_SDCCR_EXENB_0 = 0x0
	// Enable
	BUS_SDCCR_EXENB_1 = 0x1

	// SDCMOD: SDC Mode Register
	// Position of EMODE field.
	BUS_SDCMOD_EMODE_Pos = 0x0
	// Bit mask of EMODE field.
	BUS_SDCMOD_EMODE_Msk = 0x1
	// Bit EMODE.
	BUS_SDCMOD_EMODE = 0x1
	// Endian order of SDRAM address space is the same as the endian order of the operating mode
	BUS_SDCMOD_EMODE_0 = 0x0
	// Endian order of SDRAM address space is not the endian order of the operating mode.
	BUS_SDCMOD_EMODE_1 = 0x1

	// SDAMOD: SDRAM Access Mode Register
	// Position of BE field.
	BUS_SDAMOD_BE_Pos = 0x0
	// Bit mask of BE field.
	BUS_SDAMOD_BE_Msk = 0x1
	// Bit BE.
	BUS_SDAMOD_BE = 0x1
	// Disable
	BUS_SDAMOD_BE_0 = 0x0
	// Enable.
	BUS_SDAMOD_BE_1 = 0x1

	// SDSELF: SDRAM Self-Refresh Control Register
	// Position of SFEN field.
	BUS_SDSELF_SFEN_Pos = 0x0
	// Bit mask of SFEN field.
	BUS_SDSELF_SFEN_Msk = 0x1
	// Bit SFEN.
	BUS_SDSELF_SFEN = 0x1
	// Disable
	BUS_SDSELF_SFEN_0 = 0x0
	// Enable
	BUS_SDSELF_SFEN_1 = 0x1

	// SDRFCR: SDRAM Refresh Control Register
	// Position of REFW field.
	BUS_SDRFCR_REFW_Pos = 0xc
	// Bit mask of REFW field.
	BUS_SDRFCR_REFW_Msk = 0xf000
	// Position of RFC field.
	BUS_SDRFCR_RFC_Pos = 0x0
	// Bit mask of RFC field.
	BUS_SDRFCR_RFC_Msk = 0xfff
	// Setting prohibited
	BUS_SDRFCR_RFC_0x0 = 0x0

	// SDRFEN: SDRAM Auto-Refresh Control Register
	// Position of RFEN field.
	BUS_SDRFEN_RFEN_Pos = 0x0
	// Bit mask of RFEN field.
	BUS_SDRFEN_RFEN_Msk = 0x1
	// Bit RFEN.
	BUS_SDRFEN_RFEN = 0x1
	// Disable
	BUS_SDRFEN_RFEN_0 = 0x0
	// Enable
	BUS_SDRFEN_RFEN_1 = 0x1

	// SDICR: SDRAM Initialization Sequence Control Register
	// Position of INIRQ field.
	BUS_SDICR_INIRQ_Pos = 0x0
	// Bit mask of INIRQ field.
	BUS_SDICR_INIRQ_Msk = 0x1
	// Bit INIRQ.
	BUS_SDICR_INIRQ = 0x1
	// Invalid
	BUS_SDICR_INIRQ_0 = 0x0
	// Initialization sequence starts
	BUS_SDICR_INIRQ_1 = 0x1

	// SDIR: SDRAM Initialization Register
	// Position of PRC field.
	BUS_SDIR_PRC_Pos = 0x8
	// Bit mask of PRC field.
	BUS_SDIR_PRC_Msk = 0x700
	// Position of ARFC field.
	BUS_SDIR_ARFC_Pos = 0x4
	// Bit mask of ARFC field.
	BUS_SDIR_ARFC_Msk = 0xf0
	// Setting prohibited
	BUS_SDIR_ARFC_0x0 = 0x0
	// Position of ARFI field.
	BUS_SDIR_ARFI_Pos = 0x0
	// Bit mask of ARFI field.
	BUS_SDIR_ARFI_Msk = 0xf

	// SDADR: SDRAM Address Register
	// Position of MXC field.
	BUS_SDADR_MXC_Pos = 0x0
	// Bit mask of MXC field.
	BUS_SDADR_MXC_Msk = 0x3
	// 8-bit shift
	BUS_SDADR_MXC_00 = 0x0
	// 9-bit shift
	BUS_SDADR_MXC_01 = 0x1
	// 10-bit shift
	BUS_SDADR_MXC_10 = 0x2
	// 11-bit shift
	BUS_SDADR_MXC_11 = 0x3

	// SDTR: SDRAM Timing Register
	// Position of RAS field.
	BUS_SDTR_RAS_Pos = 0x10
	// Bit mask of RAS field.
	BUS_SDTR_RAS_Msk = 0x70000
	// 1 cycle
	BUS_SDTR_RAS_000 = 0x0
	// 2 cycles
	BUS_SDTR_RAS_001 = 0x1
	// 3 cycles
	BUS_SDTR_RAS_010 = 0x2
	// 4 cycles
	BUS_SDTR_RAS_011 = 0x3
	// 5 cycles
	BUS_SDTR_RAS_100 = 0x4
	// 6 cycles
	BUS_SDTR_RAS_101 = 0x5
	// 7 cycles
	BUS_SDTR_RAS_110 = 0x6
	// Setting prohibited
	BUS_SDTR_RAS_111 = 0x7
	// Position of RCD field.
	BUS_SDTR_RCD_Pos = 0xc
	// Bit mask of RCD field.
	BUS_SDTR_RCD_Msk = 0x3000
	// Position of RP field.
	BUS_SDTR_RP_Pos = 0x9
	// Bit mask of RP field.
	BUS_SDTR_RP_Msk = 0xe00
	// Position of WR field.
	BUS_SDTR_WR_Pos = 0x8
	// Bit mask of WR field.
	BUS_SDTR_WR_Msk = 0x100
	// Bit WR.
	BUS_SDTR_WR = 0x100
	// 1 cycle
	BUS_SDTR_WR_0 = 0x0
	// 2 cycles
	BUS_SDTR_WR_1 = 0x1
	// Position of CL field.
	BUS_SDTR_CL_Pos = 0x0
	// Bit mask of CL field.
	BUS_SDTR_CL_Msk = 0x7
	// 1 cycle
	BUS_SDTR_CL_001 = 0x1
	// 2 cycles
	BUS_SDTR_CL_010 = 0x2
	// 3 cycles
	BUS_SDTR_CL_011 = 0x3

	// SDMOD: SDRAM Mode Register
	// Position of MR field.
	BUS_SDMOD_MR_Pos = 0x0
	// Bit mask of MR field.
	BUS_SDMOD_MR_Msk = 0x7fff

	// SDSR: SDRAM Status Register
	// Position of SRFST field.
	BUS_SDSR_SRFST_Pos = 0x4
	// Bit mask of SRFST field.
	BUS_SDSR_SRFST_Msk = 0x10
	// Bit SRFST.
	BUS_SDSR_SRFST = 0x10
	// Transition/recovery not in progress
	BUS_SDSR_SRFST_0 = 0x0
	// Transition/recovery in progress
	BUS_SDSR_SRFST_1 = 0x1
	// Position of INIST field.
	BUS_SDSR_INIST_Pos = 0x3
	// Bit mask of INIST field.
	BUS_SDSR_INIST_Msk = 0x8
	// Bit INIST.
	BUS_SDSR_INIST = 0x8
	// Initialization sequence not in progress
	BUS_SDSR_INIST_0 = 0x0
	// Initialization sequence in progress
	BUS_SDSR_INIST_1 = 0x1
	// Position of MRSST field.
	BUS_SDSR_MRSST_Pos = 0x0
	// Bit mask of MRSST field.
	BUS_SDSR_MRSST_Msk = 0x1
	// Bit MRSST.
	BUS_SDSR_MRSST = 0x1
	// Mode register setting not in progress
	BUS_SDSR_MRSST_0 = 0x0
	// Mode register setting in progress
	BUS_SDSR_MRSST_1 = 0x1

	// BUSMCNTM4I: Master Bus Control Register %s
	// Position of IERES field.
	BUS_BUSMCNT_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNT_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNT_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNT_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNT_IERES_1 = 0x1

	// BUSMCNTSYS: Master Bus Control Register SYS
	// Position of IERES field.
	BUS_BUSMCNTSYS_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTSYS_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTSYS_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNTSYS_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNTSYS_IERES_1 = 0x1

	// BUSMCNTDMA: Master Bus Control Register DMA
	// Position of IERES field.
	BUS_BUSMCNTDMA_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTDMA_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTDMA_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNTDMA_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNTDMA_IERES_1 = 0x1

	// BUSMCNTEDM: Master Bus Control Register %s
	// Position of IERES field.
	BUS_BUSMCNT_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNT_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNT_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNT_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNT_IERES_1 = 0x1

	// BUSSCNTFLI: Slave Bus Control Register %s
	// Position of EWRES field.
	BUS_BUSSCNT_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNT_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNT_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNT_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNT_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1

	// BUSSCNTMBIU: Slave Bus Control Register MBIU
	// Position of EWRES field.
	BUS_BUSSCNTMBIU_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNTMBIU_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNTMBIU_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNTMBIU_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNTMBIU_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNTMBIU_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTMBIU_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTMBIU_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTMBIU_ARBMET_01 = 0x1

	// BUSSCNTRAM0: Slave Bus Control Register %s
	// Position of EWRES field.
	BUS_BUSSCNT_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNT_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNT_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNT_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNT_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1

	// BUSSCNTP0B: Slave Bus Control Register %s
	// Position of EWRES field.
	BUS_BUSSCNT_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNT_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNT_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNT_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNT_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1

	// BUSSCNTP6B: Slave Bus Control Register %s
	// Position of EWRES field.
	BUS_BUSSCNT_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNT_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNT_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNT_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNT_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1

	// BUSSCNTFBU: Slave Bus Control Register %s
	// Position of EWRES field.
	BUS_BUSSCNT_EWRES_Pos = 0x8
	// Bit mask of EWRES field.
	BUS_BUSSCNT_EWRES_Msk = 0x100
	// Bit EWRES.
	BUS_BUSSCNT_EWRES = 0x100
	// Not accepted.
	BUS_BUSSCNT_EWRES_0 = 0x0
	// Accepted but error response is ignored.
	BUS_BUSSCNT_EWRES_1 = 0x1
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1

	// BUS1ERRADD: Bus Error Address Register %s
	// Position of BERAD field.
	BUS_BUSERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUSERRADD_BERAD_Msk = 0xffffffff

	// BUS1ERRSTAT: Bus Error Status Register %s
	// Position of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Pos = 0x7
	// Bit mask of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Msk = 0x80
	// Bit ERRSTAT.
	BUS_BUSERRSTAT_ERRSTAT = 0x80
	// No bus error occurred
	BUS_BUSERRSTAT_ERRSTAT_0 = 0x0
	// Bus error occurred
	BUS_BUSERRSTAT_ERRSTAT_1 = 0x1
	// Position of ACCSTAT field.
	BUS_BUSERRSTAT_ACCSTAT_Pos = 0x0
	// Bit mask of ACCSTAT field.
	BUS_BUSERRSTAT_ACCSTAT_Msk = 0x1
	// Bit ACCSTAT.
	BUS_BUSERRSTAT_ACCSTAT = 0x1
	// Read access
	BUS_BUSERRSTAT_ACCSTAT_0 = 0x0
	// Write Access
	BUS_BUSERRSTAT_ACCSTAT_1 = 0x1
)

// Constants for DAC12: 12-bit D/A converter
const (
	// DADR0: D/A Data Register %s
	// Position of DADR field.
	DAC12_DADR_DADR_Pos = 0x0
	// Bit mask of DADR field.
	DAC12_DADR_DADR_Msk = 0xffff

	// DACR: D/A Control Register
	// Position of DAOE1 field.
	DAC12_DACR_DAOE1_Pos = 0x7
	// Bit mask of DAOE1 field.
	DAC12_DACR_DAOE1_Msk = 0x80
	// Bit DAOE1.
	DAC12_DACR_DAOE1 = 0x80
	// Analog output of channel 1 (DA1) is disabled.
	DAC12_DACR_DAOE1_0 = 0x0
	// D/A conversion of channel 1 is enabled. Analog output of channel 1 (DA1) is enabled.
	DAC12_DACR_DAOE1_1 = 0x1
	// Position of DAOE0 field.
	DAC12_DACR_DAOE0_Pos = 0x6
	// Bit mask of DAOE0 field.
	DAC12_DACR_DAOE0_Msk = 0x40
	// Bit DAOE0.
	DAC12_DACR_DAOE0 = 0x40
	// Analog output of channel 0 (DA0) is disabled.
	DAC12_DACR_DAOE0_0 = 0x0
	// D/A conversion of channel 0 is enabled. Analog output of channel 0 (DA0) is enabled.
	DAC12_DACR_DAOE0_1 = 0x1
	// Position of DAE field.
	DAC12_DACR_DAE_Pos = 0x5
	// Bit mask of DAE field.
	DAC12_DACR_DAE_Msk = 0x20
	// Bit DAE.
	DAC12_DACR_DAE = 0x20
	// D/A conversion is independently controlled on channels 0 and 1.
	DAC12_DACR_DAE_0 = 0x0
	// D/A conversion on channels 0 and 1 is controlled as a single whole.
	DAC12_DACR_DAE_1 = 0x1

	// DADPR: DADRm Format Select Register
	// Position of DPSEL field.
	DAC12_DADPR_DPSEL_Pos = 0x7
	// Bit mask of DPSEL field.
	DAC12_DADPR_DPSEL_Msk = 0x80
	// Bit DPSEL.
	DAC12_DADPR_DPSEL = 0x80
	// Right justified format.
	DAC12_DADPR_DPSEL_0 = 0x0
	// Left justified format.
	DAC12_DADPR_DPSEL_1 = 0x1

	// DAADSCR: D/A-A/D Synchronous Start Control Register
	// Position of DAADST field.
	DAC12_DAADSCR_DAADST_Pos = 0x7
	// Bit mask of DAADST field.
	DAC12_DAADSCR_DAADST_Msk = 0x80
	// Bit DAADST.
	DAC12_DAADSCR_DAADST = 0x80
	// D/A converter operation does not synchronize with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is disabled).
	DAC12_DAADSCR_DAADST_0 = 0x0
	// D/A converter operation synchronizes with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is enabled).
	DAC12_DAADSCR_DAADST_1 = 0x1

	// DAAMPCR: D/A Output Amplifier Control Register
	// Position of DAAMP1 field.
	DAC12_DAAMPCR_DAAMP1_Pos = 0x7
	// Bit mask of DAAMP1 field.
	DAC12_DAAMPCR_DAAMP1_Msk = 0x80
	// Bit DAAMP1.
	DAC12_DAAMPCR_DAAMP1 = 0x80
	// Output amplifier of channel 1 is not used.
	DAC12_DAAMPCR_DAAMP1_0 = 0x0
	// Output amplifier of channel 1 is used.
	DAC12_DAAMPCR_DAAMP1_1 = 0x1
	// Position of DAAMP0 field.
	DAC12_DAAMPCR_DAAMP0_Pos = 0x6
	// Bit mask of DAAMP0 field.
	DAC12_DAAMPCR_DAAMP0_Msk = 0x40
	// Bit DAAMP0.
	DAC12_DAAMPCR_DAAMP0 = 0x40
	// Output amplifier of channel 0 is not used.
	DAC12_DAAMPCR_DAAMP0_0 = 0x0
	// Output amplifier of channel 0 is used.
	DAC12_DAAMPCR_DAAMP0_1 = 0x1

	// DAASWCR: D/A Amplifier Stabilization Wait Control Register
	// Position of DAASW1 field.
	DAC12_DAASWCR_DAASW1_Pos = 0x7
	// Bit mask of DAASW1 field.
	DAC12_DAASWCR_DAASW1_Msk = 0x80
	// Bit DAASW1.
	DAC12_DAASWCR_DAASW1 = 0x80
	// Amplifier stabilization wait off (output) for channel 1
	DAC12_DAASWCR_DAASW1_0 = 0x0
	// Amplifier stabilization wait on (high-Z) for channel 1.
	DAC12_DAASWCR_DAASW1_1 = 0x1
	// Position of DAASW0 field.
	DAC12_DAASWCR_DAASW0_Pos = 0x6
	// Bit mask of DAASW0 field.
	DAC12_DAASWCR_DAASW0_Msk = 0x40
	// Bit DAASW0.
	DAC12_DAASWCR_DAASW0 = 0x40
	// Amplifier stabilization wait off (output) for channel 0
	DAC12_DAASWCR_DAASW0_0 = 0x0
	// Amplifier stabilization wait on (high-Z) for channel 0.
	DAC12_DAASWCR_DAASW0_1 = 0x1
)

// Constants for AMI: ADC-DAC Interface
const (
	// DAADUSR: D/A A/D Synchronous Unit Select Register
	// Position of AMADSEL1 field.
	AMI_DAADUSR_AMADSEL1_Pos = 0x1
	// Bit mask of AMADSEL1 field.
	AMI_DAADUSR_AMADSEL1_Msk = 0x2
	// Bit AMADSEL1.
	AMI_DAADUSR_AMADSEL1 = 0x2
	// Unit 1 is not selected.
	AMI_DAADUSR_AMADSEL1_0 = 0x0
	// Unit 1 is selected.
	AMI_DAADUSR_AMADSEL1_1 = 0x1
)

// Constants for POEG: Port Output Enable Module for GPT
const (
	// POEGGA: POEG Group %s Setting Register
	// Position of NFCS field.
	POEG_POEGG_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGG_NFCS_Msk = 0xc0000000
	// Sampling GTETRG pin input level for three times in every PCLKB.
	POEG_POEGG_NFCS_00 = 0x0
	// Sampling GTETRG pin input level for three times in every PCLKB /8.
	POEG_POEGG_NFCS_01 = 0x1
	// Sampling GTETRG pin input level for three times in every PCLKB /32.
	POEG_POEGG_NFCS_10 = 0x2
	// Sampling GTETRG pin input level for three times in every PCLKB /128.
	POEG_POEGG_NFCS_11 = 0x3
	// Position of NFEN field.
	POEG_POEGG_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGG_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGG_NFEN = 0x20000000
	// Filtering noise disabled
	POEG_POEGG_NFEN_0 = 0x0
	// Filtering noise enabled
	POEG_POEGG_NFEN_1 = 0x1
	// Position of INV field.
	POEG_POEGG_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGG_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGG_INV = 0x10000000
	// GTETRG Input
	POEG_POEGG_INV_0 = 0x0
	// GTETRG Input Reversed.
	POEG_POEGG_INV_1 = 0x1
	// Position of ST field.
	POEG_POEGG_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGG_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGG_ST = 0x10000
	// GTETRG input after filtering is 0.
	POEG_POEGG_ST_0 = 0x0
	// GTETRG input after filtering is 1.
	POEG_POEGG_ST_1 = 0x1
	// Position of CDRE5 field.
	POEG_POEGG_CDRE5_Pos = 0xd
	// Bit mask of CDRE5 field.
	POEG_POEGG_CDRE5_Msk = 0x2000
	// Bit CDRE5.
	POEG_POEGG_CDRE5 = 0x2000
	// A disable request of comparator 5 disabled.
	POEG_POEGG_CDRE5_0 = 0x0
	// A disable request of comparator 5 enabled.
	POEG_POEGG_CDRE5_1 = 0x1
	// Position of CDRE4 field.
	POEG_POEGG_CDRE4_Pos = 0xc
	// Bit mask of CDRE4 field.
	POEG_POEGG_CDRE4_Msk = 0x1000
	// Bit CDRE4.
	POEG_POEGG_CDRE4 = 0x1000
	// A disable request of comparator 4 disabled.
	POEG_POEGG_CDRE4_0 = 0x0
	// A disable request of comparator 4 enabled.
	POEG_POEGG_CDRE4_1 = 0x1
	// Position of CDRE3 field.
	POEG_POEGG_CDRE3_Pos = 0xb
	// Bit mask of CDRE3 field.
	POEG_POEGG_CDRE3_Msk = 0x800
	// Bit CDRE3.
	POEG_POEGG_CDRE3 = 0x800
	// A disable request of comparator 3 disabled.
	POEG_POEGG_CDRE3_0 = 0x0
	// A disable request of comparator 3 enabled.
	POEG_POEGG_CDRE3_1 = 0x1
	// Position of CDRE2 field.
	POEG_POEGG_CDRE2_Pos = 0xa
	// Bit mask of CDRE2 field.
	POEG_POEGG_CDRE2_Msk = 0x400
	// Bit CDRE2.
	POEG_POEGG_CDRE2 = 0x400
	// A disable request of comparator 2 disabled.
	POEG_POEGG_CDRE2_0 = 0x0
	// A disable request of comparator 2 enabled.
	POEG_POEGG_CDRE2_1 = 0x1
	// Position of CDRE1 field.
	POEG_POEGG_CDRE1_Pos = 0x9
	// Bit mask of CDRE1 field.
	POEG_POEGG_CDRE1_Msk = 0x200
	// Bit CDRE1.
	POEG_POEGG_CDRE1 = 0x200
	// A disable request of comparator 1 disabled.
	POEG_POEGG_CDRE1_0 = 0x0
	// A disable request of comparator 1 enabled.
	POEG_POEGG_CDRE1_1 = 0x1
	// Position of CDRE0 field.
	POEG_POEGG_CDRE0_Pos = 0x8
	// Bit mask of CDRE0 field.
	POEG_POEGG_CDRE0_Msk = 0x100
	// Bit CDRE0.
	POEG_POEGG_CDRE0 = 0x100
	// A disable request of comparator 0 disabled.
	POEG_POEGG_CDRE0_0 = 0x0
	// A disable request of comparator 0 enabled.
	POEG_POEGG_CDRE0_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGG_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGG_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGG_OSTPE = 0x40
	// A output-disable request from the oscillation stop detection disabled.
	POEG_POEGG_OSTPE_0 = 0x0
	// A output-disable request from the oscillation stop detection enabled.
	POEG_POEGG_OSTPE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGG_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGG_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGG_IOCE = 0x20
	// Disable output-disable requests from GPT disable request
	POEG_POEGG_IOCE_0 = 0x0
	// Enable output-disable requests from GPT disable request
	POEG_POEGG_IOCE_1 = 0x1
	// Position of PIDE field.
	POEG_POEGG_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGG_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGG_PIDE = 0x10
	// A output-disable request from the GTETRG pins disabled.
	POEG_POEGG_PIDE_0 = 0x0
	// A output-disable request from the GTETRG pins enabled.
	POEG_POEGG_PIDE_1 = 0x1
	// Position of SSF field.
	POEG_POEGG_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGG_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGG_SSF = 0x8
	// A output-disable request from software has not been generated.
	POEG_POEGG_SSF_0 = 0x0
	// A output-disable request from software has been generated.
	POEG_POEGG_SSF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGG_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGG_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGG_OSTPF = 0x4
	// A output-disable request from the oscillation stop detection has not been generated.
	POEG_POEGG_OSTPF_0 = 0x0
	// A output-disable request from the oscillation stop detection has been generated.
	POEG_POEGG_OSTPF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGG_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGG_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGG_IOCF = 0x2
	// A output-disable request from GPT disable request or comparator interrupt has not been generated.
	POEG_POEGG_IOCF_0 = 0x0
	// A output-disable request from GPT disable request or comparator interrupt has been generated.
	POEG_POEGG_IOCF_1 = 0x1
	// Position of PIDF field.
	POEG_POEGG_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGG_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGG_PIDF = 0x1
	// A output-disable request from the GTETRG pin has not been generated.
	POEG_POEGG_PIDF_0 = 0x0
	// A output-disable request from the GTETRG pin has been generated.
	POEG_POEGG_PIDF_1 = 0x1
)

// Constants for IRDA: Infrared Data Association
const (
	// IRCR: IrDA Control Register
	// Position of IRE field.
	IRDA_IRCR_IRE_Pos = 0x7
	// Bit mask of IRE field.
	IRDA_IRCR_IRE_Msk = 0x80
	// Bit IRE.
	IRDA_IRCR_IRE = 0x80
	// Serial I/O pins are used for normal serial communication.
	IRDA_IRCR_IRE_0 = 0x0
	// Serial I/O pins are used for IrDA data communication.
	IRDA_IRCR_IRE_1 = 0x1
	// Position of IRTXINV field.
	IRDA_IRCR_IRTXINV_Pos = 0x3
	// Bit mask of IRTXINV field.
	IRDA_IRCR_IRTXINV_Msk = 0x8
	// Bit IRTXINV.
	IRDA_IRCR_IRTXINV = 0x8
	// Data to be transmitted is output to IRTXD as is.
	IRDA_IRCR_IRTXINV_0 = 0x0
	// Data to be transmitted is output to IRTXD after the polarity is inverted.
	IRDA_IRCR_IRTXINV_1 = 0x1
	// Position of IRRXINV field.
	IRDA_IRCR_IRRXINV_Pos = 0x2
	// Bit mask of IRRXINV field.
	IRDA_IRCR_IRRXINV_Msk = 0x4
	// Bit IRRXINV.
	IRDA_IRCR_IRRXINV = 0x4
	// IRRXD input is used as received data as is.
	IRDA_IRCR_IRRXINV_0 = 0x0
	// IRRXD input is used as received data after the polarity is inverted.
	IRDA_IRCR_IRRXINV_1 = 0x1
)

// Constants for CAN0: CAN0 Module
const (
	// MB0_ID: Mailbox Register
	// Position of IDE field.
	CAN0_MB_ID_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_MB_ID_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_MB_ID_IDE = 0x80000000
	// Standard ID
	CAN0_MB_ID_IDE_0 = 0x0
	// Extended ID
	CAN0_MB_ID_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_MB_ID_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_MB_ID_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_MB_ID_RTR = 0x40000000
	// Data frame
	CAN0_MB_ID_RTR_0 = 0x0
	// Remote frame
	CAN0_MB_ID_RTR_1 = 0x1
	// Position of SID field.
	CAN0_MB_ID_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MB_ID_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_MB_ID_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MB_ID_EID_Msk = 0x3ffff

	// MB0_DL: Mailbox Register
	// Position of DLC field.
	CAN0_MB_DL_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN0_MB_DL_DLC_Msk = 0xf
	// Data length = 0 byte
	CAN0_MB_DL_DLC_0000 = 0x0
	// Data length = 1 byte
	CAN0_MB_DL_DLC_0001 = 0x1
	// Data length = 2 bytes
	CAN0_MB_DL_DLC_0010 = 0x2
	// Data length = 3 bytes
	CAN0_MB_DL_DLC_0011 = 0x3
	// Data length = 4 bytes
	CAN0_MB_DL_DLC_0100 = 0x4
	// Data length = 5 bytes
	CAN0_MB_DL_DLC_0101 = 0x5
	// Data length = 6 bytes
	CAN0_MB_DL_DLC_0110 = 0x6
	// Data length = 7 bytes
	CAN0_MB_DL_DLC_0111 = 0x7

	// MB0_D0: Mailbox Register
	// Position of DATA0 field.
	CAN0_MB_D0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN0_MB_D0_DATA0_Msk = 0xff

	// MB0_D1: Mailbox Register
	// Position of DATA1 field.
	CAN0_MB_D1_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN0_MB_D1_DATA1_Msk = 0xff

	// MB0_D2: Mailbox Register
	// Position of DATA2 field.
	CAN0_MB_D2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	CAN0_MB_D2_DATA2_Msk = 0xff

	// MB0_D3: Mailbox Register
	// Position of DATA3 field.
	CAN0_MB_D3_DATA3_Pos = 0x0
	// Bit mask of DATA3 field.
	CAN0_MB_D3_DATA3_Msk = 0xff

	// MB0_D4: Mailbox Register
	// Position of DATA4 field.
	CAN0_MB_D4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN0_MB_D4_DATA4_Msk = 0xff

	// MB0_D5: Mailbox Register
	// Position of DATA5 field.
	CAN0_MB_D5_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN0_MB_D5_DATA5_Msk = 0xff

	// MB0_D6: Mailbox Register
	// Position of DATA6 field.
	CAN0_MB_D6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	CAN0_MB_D6_DATA6_Msk = 0xff

	// MB0_D7: Mailbox Register
	// Position of DATA7 field.
	CAN0_MB_D7_DATA7_Pos = 0x0
	// Bit mask of DATA7 field.
	CAN0_MB_D7_DATA7_Msk = 0xff

	// MB0_TS: Mailbox Register
	// Position of TSH field.
	CAN0_MB_TS_TSH_Pos = 0x8
	// Bit mask of TSH field.
	CAN0_MB_TS_TSH_Msk = 0xff00
	// Position of TSL field.
	CAN0_MB_TS_TSL_Pos = 0x0
	// Bit mask of TSL field.
	CAN0_MB_TS_TSL_Msk = 0xff

	// MKR: Mask Register
	// Position of SID field.
	CAN0_MKR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MKR_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_MKR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MKR_EID_Msk = 0x3ffff

	// FIDCR0: FIFO Received ID Compare Registers
	// Position of IDE field.
	CAN0_FIDCR_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_FIDCR_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_FIDCR_IDE = 0x80000000
	// Standard ID
	CAN0_FIDCR_IDE_0 = 0x0
	// Extended ID
	CAN0_FIDCR_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_FIDCR_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_FIDCR_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_FIDCR_RTR = 0x40000000
	// Data frame
	CAN0_FIDCR_RTR_0 = 0x0
	// Remote frame
	CAN0_FIDCR_RTR_1 = 0x1
	// Position of SID field.
	CAN0_FIDCR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_FIDCR_SID_Msk = 0x1ffc0000
	// Position of EID field.
	CAN0_FIDCR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_FIDCR_EID_Msk = 0x3ffff

	// MKIVLR: Mask Invalid Register
	// Position of MB31 field.
	CAN0_MKIVLR_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MKIVLR_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MKIVLR_MB31 = 0x80000000
	// Mask valid
	CAN0_MKIVLR_MB31_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MKIVLR_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MKIVLR_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MKIVLR_MB30 = 0x40000000
	// Mask valid
	CAN0_MKIVLR_MB30_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MKIVLR_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MKIVLR_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MKIVLR_MB29 = 0x20000000
	// Mask valid
	CAN0_MKIVLR_MB29_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MKIVLR_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MKIVLR_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MKIVLR_MB28 = 0x10000000
	// Mask valid
	CAN0_MKIVLR_MB28_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MKIVLR_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MKIVLR_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MKIVLR_MB27 = 0x8000000
	// Mask valid
	CAN0_MKIVLR_MB27_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MKIVLR_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MKIVLR_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MKIVLR_MB26 = 0x4000000
	// Mask valid
	CAN0_MKIVLR_MB26_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MKIVLR_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MKIVLR_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MKIVLR_MB25 = 0x2000000
	// Mask valid
	CAN0_MKIVLR_MB25_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MKIVLR_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MKIVLR_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MKIVLR_MB24 = 0x1000000
	// Mask valid
	CAN0_MKIVLR_MB24_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MKIVLR_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MKIVLR_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MKIVLR_MB23 = 0x800000
	// Mask valid
	CAN0_MKIVLR_MB23_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MKIVLR_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MKIVLR_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MKIVLR_MB22 = 0x400000
	// Mask valid
	CAN0_MKIVLR_MB22_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MKIVLR_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MKIVLR_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MKIVLR_MB21 = 0x200000
	// Mask valid
	CAN0_MKIVLR_MB21_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MKIVLR_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MKIVLR_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MKIVLR_MB20 = 0x100000
	// Mask valid
	CAN0_MKIVLR_MB20_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MKIVLR_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MKIVLR_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MKIVLR_MB19 = 0x80000
	// Mask valid
	CAN0_MKIVLR_MB19_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MKIVLR_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MKIVLR_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MKIVLR_MB18 = 0x40000
	// Mask valid
	CAN0_MKIVLR_MB18_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MKIVLR_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MKIVLR_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MKIVLR_MB17 = 0x20000
	// Mask valid
	CAN0_MKIVLR_MB17_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MKIVLR_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MKIVLR_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MKIVLR_MB16 = 0x10000
	// Mask valid
	CAN0_MKIVLR_MB16_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MKIVLR_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MKIVLR_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MKIVLR_MB15 = 0x8000
	// Mask valid
	CAN0_MKIVLR_MB15_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MKIVLR_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MKIVLR_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MKIVLR_MB14 = 0x4000
	// Mask valid
	CAN0_MKIVLR_MB14_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MKIVLR_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MKIVLR_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MKIVLR_MB13 = 0x2000
	// Mask valid
	CAN0_MKIVLR_MB13_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MKIVLR_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MKIVLR_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MKIVLR_MB12 = 0x1000
	// Mask valid
	CAN0_MKIVLR_MB12_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MKIVLR_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MKIVLR_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MKIVLR_MB11 = 0x800
	// Mask valid
	CAN0_MKIVLR_MB11_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MKIVLR_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MKIVLR_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MKIVLR_MB10 = 0x400
	// Mask valid
	CAN0_MKIVLR_MB10_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MKIVLR_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MKIVLR_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MKIVLR_MB9 = 0x200
	// Mask valid
	CAN0_MKIVLR_MB9_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MKIVLR_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MKIVLR_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MKIVLR_MB8 = 0x100
	// Mask valid
	CAN0_MKIVLR_MB8_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MKIVLR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MKIVLR_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MKIVLR_MB7 = 0x80
	// Mask valid
	CAN0_MKIVLR_MB7_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MKIVLR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MKIVLR_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MKIVLR_MB6 = 0x40
	// Mask valid
	CAN0_MKIVLR_MB6_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MKIVLR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MKIVLR_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MKIVLR_MB5 = 0x20
	// Mask valid
	CAN0_MKIVLR_MB5_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MKIVLR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MKIVLR_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MKIVLR_MB4 = 0x10
	// Mask valid
	CAN0_MKIVLR_MB4_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MKIVLR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MKIVLR_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MKIVLR_MB3 = 0x8
	// Mask valid
	CAN0_MKIVLR_MB3_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MKIVLR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MKIVLR_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MKIVLR_MB2 = 0x4
	// Mask valid
	CAN0_MKIVLR_MB2_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MKIVLR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MKIVLR_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MKIVLR_MB1 = 0x2
	// Mask valid
	CAN0_MKIVLR_MB1_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MKIVLR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MKIVLR_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MKIVLR_MB0 = 0x1
	// Mask valid
	CAN0_MKIVLR_MB0_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB0_1 = 0x1

	// MIER: Mailbox Interrupt Enable Register
	// Position of MB31 field.
	CAN0_MIER_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MIER_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MIER_MB31 = 0x80000000
	// Interrupt disabled
	CAN0_MIER_MB31_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MIER_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MIER_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MIER_MB30 = 0x40000000
	// Interrupt disabled
	CAN0_MIER_MB30_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_MB29 = 0x20000000
	// Interrupt disabled
	CAN0_MIER_MB29_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MIER_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MIER_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MIER_MB27 = 0x8000000
	// Interrupt disabled
	CAN0_MIER_MB27_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MIER_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MIER_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MIER_MB26 = 0x4000000
	// Interrupt disabled
	CAN0_MIER_MB26_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_MB25 = 0x2000000
	// Interrupt disabled
	CAN0_MIER_MB25_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB0_1 = 0x1

	// MIER_FIFO: Mailbox Interrupt Enable Register for FIFO Mailbox Mode
	// Position of MB29 field.
	CAN0_MIER_FIFO_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_FIFO_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_FIFO_MB29 = 0x20000000
	// Every time reception is completed
	CAN0_MIER_FIFO_MB29_0 = 0x0
	// When the receive FIFO becomes buffer warning by completion of reception
	CAN0_MIER_FIFO_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_FIFO_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_FIFO_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_FIFO_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB28_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_FIFO_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_FIFO_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_FIFO_MB25 = 0x2000000
	// Every time transmission is completed
	CAN0_MIER_FIFO_MB25_0 = 0x0
	// When the transmit FIFO becomes empty due to completion of transmission
	CAN0_MIER_FIFO_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_FIFO_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_FIFO_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_FIFO_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_FIFO_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_FIFO_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_FIFO_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_FIFO_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_FIFO_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_FIFO_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_FIFO_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_FIFO_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_FIFO_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_FIFO_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_FIFO_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_FIFO_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_FIFO_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_FIFO_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_FIFO_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_FIFO_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_FIFO_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_FIFO_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_FIFO_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_FIFO_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_FIFO_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_FIFO_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_FIFO_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_FIFO_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_FIFO_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_FIFO_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_FIFO_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_FIFO_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_FIFO_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_FIFO_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_FIFO_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_FIFO_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_FIFO_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_FIFO_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_FIFO_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_FIFO_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_FIFO_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_FIFO_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_FIFO_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_FIFO_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_FIFO_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_FIFO_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_FIFO_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_FIFO_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_FIFO_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_FIFO_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_FIFO_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_FIFO_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_FIFO_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_FIFO_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_FIFO_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_FIFO_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_FIFO_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_FIFO_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_FIFO_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_FIFO_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_FIFO_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_FIFO_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_FIFO_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_FIFO_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_FIFO_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_FIFO_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_FIFO_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_FIFO_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_FIFO_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_FIFO_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_FIFO_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_FIFO_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_FIFO_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_FIFO_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_FIFO_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_FIFO_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_FIFO_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_FIFO_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_FIFO_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_FIFO_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_FIFO_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_FIFO_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_FIFO_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_FIFO_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_FIFO_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_FIFO_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_FIFO_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_FIFO_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB0_1 = 0x1

	// MCTL_TX: Message Control Register for Transmit
	// Position of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_TX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_TX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_TX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_TX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_TX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_TX_RECREQ_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_TX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_TX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_TX_ONESHOT_1 = 0x1
	// Position of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Pos = 0x2
	// Bit mask of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Msk = 0x4
	// Bit TRMABT.
	CAN0_MCTL_TX_TRMABT = 0x4
	// Transmission has started, transmission abort failed because transmission is completed, or transmission abort is not requested
	CAN0_MCTL_TX_TRMABT_0 = 0x0
	// Transmission abort is completed
	CAN0_MCTL_TX_TRMABT_1 = 0x1
	// Position of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Pos = 0x1
	// Bit mask of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Msk = 0x2
	// Bit TRMACTIVE.
	CAN0_MCTL_TX_TRMACTIVE = 0x2
	// Transmission is pending or transmission is not requested
	CAN0_MCTL_TX_TRMACTIVE_0 = 0x0
	// From acceptance of transmission request to completion of transmission, or error/arbitration-lost
	CAN0_MCTL_TX_TRMACTIVE_1 = 0x1
	// Position of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Pos = 0x0
	// Bit mask of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Msk = 0x1
	// Bit SENTDATA.
	CAN0_MCTL_TX_SENTDATA = 0x1
	// Transmission is not completed
	CAN0_MCTL_TX_SENTDATA_0 = 0x0
	// Transmission is completed
	CAN0_MCTL_TX_SENTDATA_1 = 0x1

	// MCTL_RX: Message Control Register for Receive
	// Position of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_RX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_RX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_RX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_RX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_RX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_RX_RECREQ_1 = 0x1
	// Position of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_RX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_RX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_RX_ONESHOT_1 = 0x1
	// Position of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Pos = 0x2
	// Bit mask of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Msk = 0x4
	// Bit MSGLOST.
	CAN0_MCTL_RX_MSGLOST = 0x4
	// Message is not overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_0 = 0x0
	// Message is overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_1 = 0x1
	// Position of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Pos = 0x1
	// Bit mask of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Msk = 0x2
	// Bit INVALDATA.
	CAN0_MCTL_RX_INVALDATA = 0x2
	// Message valid
	CAN0_MCTL_RX_INVALDATA_0 = 0x0
	// Message being updated
	CAN0_MCTL_RX_INVALDATA_1 = 0x1
	// Position of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Pos = 0x0
	// Bit mask of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Msk = 0x1
	// Bit NEWDATA.
	CAN0_MCTL_RX_NEWDATA = 0x1
	// No data has been received or 0 is written to the NEWDATA bit
	CAN0_MCTL_RX_NEWDATA_0 = 0x0
	// A new message is being stored or has been stored to the mailbox
	CAN0_MCTL_RX_NEWDATA_1 = 0x1

	// CTLR: Control Register
	// Position of RBOC field.
	CAN0_CTLR_RBOC_Pos = 0xd
	// Bit mask of RBOC field.
	CAN0_CTLR_RBOC_Msk = 0x2000
	// Bit RBOC.
	CAN0_CTLR_RBOC = 0x2000
	// Nothing occurred
	CAN0_CTLR_RBOC_0 = 0x0
	// Forcible return from bus-off
	CAN0_CTLR_RBOC_1 = 0x1
	// Position of BOM field.
	CAN0_CTLR_BOM_Pos = 0xb
	// Bit mask of BOM field.
	CAN0_CTLR_BOM_Msk = 0x1800
	// Normal mode (ISO11898-1 compliant)
	CAN0_CTLR_BOM_00 = 0x0
	// Entry to CAN halt mode automatically at bus-off entry
	CAN0_CTLR_BOM_01 = 0x1
	// Entry to CAN halt mode automatically at bus-off end
	CAN0_CTLR_BOM_10 = 0x2
	// Entry to CAN halt mode (during bus-off recovery period)
	CAN0_CTLR_BOM_11 = 0x3
	// Position of SLPM field.
	CAN0_CTLR_SLPM_Pos = 0xa
	// Bit mask of SLPM field.
	CAN0_CTLR_SLPM_Msk = 0x400
	// Bit SLPM.
	CAN0_CTLR_SLPM = 0x400
	// Other than CAN sleep mode
	CAN0_CTLR_SLPM_0 = 0x0
	// CAN sleep mode
	CAN0_CTLR_SLPM_1 = 0x1
	// Position of CANM field.
	CAN0_CTLR_CANM_Pos = 0x8
	// Bit mask of CANM field.
	CAN0_CTLR_CANM_Msk = 0x300
	// CAN operation mode
	CAN0_CTLR_CANM_00 = 0x0
	// CAN reset mode
	CAN0_CTLR_CANM_01 = 0x1
	// CAN halt mode
	CAN0_CTLR_CANM_10 = 0x2
	// CAN reset mode (forcible transition)
	CAN0_CTLR_CANM_11 = 0x3
	// Position of TSPS field.
	CAN0_CTLR_TSPS_Pos = 0x6
	// Bit mask of TSPS field.
	CAN0_CTLR_TSPS_Msk = 0xc0
	// Every bit time
	CAN0_CTLR_TSPS_00 = 0x0
	// Every 2-bit time
	CAN0_CTLR_TSPS_01 = 0x1
	// Every 4-bit time
	CAN0_CTLR_TSPS_10 = 0x2
	// Every 8-bit time
	CAN0_CTLR_TSPS_11 = 0x3
	// Position of TSRC field.
	CAN0_CTLR_TSRC_Pos = 0x5
	// Bit mask of TSRC field.
	CAN0_CTLR_TSRC_Msk = 0x20
	// Bit TSRC.
	CAN0_CTLR_TSRC = 0x20
	// Nothing occurred
	CAN0_CTLR_TSRC_0 = 0x0
	// Reset
	CAN0_CTLR_TSRC_1 = 0x1
	// Position of TPM field.
	CAN0_CTLR_TPM_Pos = 0x4
	// Bit mask of TPM field.
	CAN0_CTLR_TPM_Msk = 0x10
	// Bit TPM.
	CAN0_CTLR_TPM = 0x10
	// ID priority transmit mode
	CAN0_CTLR_TPM_0 = 0x0
	// Mailbox number priority transmit mode
	CAN0_CTLR_TPM_1 = 0x1
	// Position of MLM field.
	CAN0_CTLR_MLM_Pos = 0x3
	// Bit mask of MLM field.
	CAN0_CTLR_MLM_Msk = 0x8
	// Bit MLM.
	CAN0_CTLR_MLM = 0x8
	// Overwrite mode
	CAN0_CTLR_MLM_0 = 0x0
	// Overrun mode
	CAN0_CTLR_MLM_1 = 0x1
	// Position of IDFM field.
	CAN0_CTLR_IDFM_Pos = 0x1
	// Bit mask of IDFM field.
	CAN0_CTLR_IDFM_Msk = 0x6
	// Standard ID mode.All mailboxes (including FIFO mailboxes) handle only standard Ids.
	CAN0_CTLR_IDFM_00 = 0x0
	// Extended ID mode.All mailboxes (including FIFO mailboxes) handle only extended IDs.
	CAN0_CTLR_IDFM_01 = 0x1
	// Mixed ID mode.All mailboxes (including FIFO mailboxes) handle both standard IDs and extended IDs. Standard IDs or extended IDs are specified by using the IDE bit in the corresponding mailbox in normal mailbox mode. In FIFO mailbox mode, the IDE bit in the corresponding mailbox is used for mailboxes [0] to [23], the IDE bits in FIDCR0 and FIDCR1 are used for the receive FIFO, and the IDE bit in mailbox [24] is used for the transmit FIFO.
	CAN0_CTLR_IDFM_10 = 0x2
	// Do not use this combination
	CAN0_CTLR_IDFM_11 = 0x3
	// Position of MBM field.
	CAN0_CTLR_MBM_Pos = 0x0
	// Bit mask of MBM field.
	CAN0_CTLR_MBM_Msk = 0x1
	// Bit MBM.
	CAN0_CTLR_MBM = 0x1
	// Normal mailbox mode
	CAN0_CTLR_MBM_0 = 0x0
	// FIFO mailbox mode
	CAN0_CTLR_MBM_1 = 0x1

	// STR: Status Register
	// Position of RECST field.
	CAN0_STR_RECST_Pos = 0xe
	// Bit mask of RECST field.
	CAN0_STR_RECST_Msk = 0x4000
	// Bit RECST.
	CAN0_STR_RECST = 0x4000
	// Bus idle or transmission in progress
	CAN0_STR_RECST_0 = 0x0
	// Reception in progress
	CAN0_STR_RECST_1 = 0x1
	// Position of TRMST field.
	CAN0_STR_TRMST_Pos = 0xd
	// Bit mask of TRMST field.
	CAN0_STR_TRMST_Msk = 0x2000
	// Bit TRMST.
	CAN0_STR_TRMST = 0x2000
	// Bus idle or reception in progress
	CAN0_STR_TRMST_0 = 0x0
	// Transmission in progress or in bus-off state
	CAN0_STR_TRMST_1 = 0x1
	// Position of BOST field.
	CAN0_STR_BOST_Pos = 0xc
	// Bit mask of BOST field.
	CAN0_STR_BOST_Msk = 0x1000
	// Bit BOST.
	CAN0_STR_BOST = 0x1000
	// Not in bus-off state
	CAN0_STR_BOST_0 = 0x0
	// In bus-off state
	CAN0_STR_BOST_1 = 0x1
	// Position of EPST field.
	CAN0_STR_EPST_Pos = 0xb
	// Bit mask of EPST field.
	CAN0_STR_EPST_Msk = 0x800
	// Bit EPST.
	CAN0_STR_EPST = 0x800
	// Not in error-passive state
	CAN0_STR_EPST_0 = 0x0
	// In error-passive state
	CAN0_STR_EPST_1 = 0x1
	// Position of SLPST field.
	CAN0_STR_SLPST_Pos = 0xa
	// Bit mask of SLPST field.
	CAN0_STR_SLPST_Msk = 0x400
	// Bit SLPST.
	CAN0_STR_SLPST = 0x400
	// Not in CAN sleep mode
	CAN0_STR_SLPST_0 = 0x0
	// In CAN sleep mode
	CAN0_STR_SLPST_1 = 0x1
	// Position of HLTST field.
	CAN0_STR_HLTST_Pos = 0x9
	// Bit mask of HLTST field.
	CAN0_STR_HLTST_Msk = 0x200
	// Bit HLTST.
	CAN0_STR_HLTST = 0x200
	// Not in CAN halt mode
	CAN0_STR_HLTST_0 = 0x0
	// In CAN halt mode
	CAN0_STR_HLTST_1 = 0x1
	// Position of RSTST field.
	CAN0_STR_RSTST_Pos = 0x8
	// Bit mask of RSTST field.
	CAN0_STR_RSTST_Msk = 0x100
	// Bit RSTST.
	CAN0_STR_RSTST = 0x100
	// Not in CAN reset mode
	CAN0_STR_RSTST_0 = 0x0
	// In CAN reset mode
	CAN0_STR_RSTST_1 = 0x1
	// Position of EST field.
	CAN0_STR_EST_Pos = 0x7
	// Bit mask of EST field.
	CAN0_STR_EST_Msk = 0x80
	// Bit EST.
	CAN0_STR_EST = 0x80
	// No error occurred
	CAN0_STR_EST_0 = 0x0
	// Error occurred
	CAN0_STR_EST_1 = 0x1
	// Position of TABST field.
	CAN0_STR_TABST_Pos = 0x6
	// Bit mask of TABST field.
	CAN0_STR_TABST_Msk = 0x40
	// Bit TABST.
	CAN0_STR_TABST = 0x40
	// No mailbox with TRMABT bit = 1
	CAN0_STR_TABST_0 = 0x0
	// Mailbox(es) with TRMABT bit = 1
	CAN0_STR_TABST_1 = 0x1
	// Position of FMLST field.
	CAN0_STR_FMLST_Pos = 0x5
	// Bit mask of FMLST field.
	CAN0_STR_FMLST_Msk = 0x20
	// Bit FMLST.
	CAN0_STR_FMLST = 0x20
	// RFMLF bit = 0
	CAN0_STR_FMLST_0 = 0x0
	// RFMLF bit = 1
	CAN0_STR_FMLST_1 = 0x1
	// Position of NMLST field.
	CAN0_STR_NMLST_Pos = 0x4
	// Bit mask of NMLST field.
	CAN0_STR_NMLST_Msk = 0x10
	// Bit NMLST.
	CAN0_STR_NMLST = 0x10
	// No mailbox with MSGLOST bit = 1
	CAN0_STR_NMLST_0 = 0x0
	// Mailbox(es) with MSGLOST bit = 1
	CAN0_STR_NMLST_1 = 0x1
	// Position of TFST field.
	CAN0_STR_TFST_Pos = 0x3
	// Bit mask of TFST field.
	CAN0_STR_TFST_Msk = 0x8
	// Bit TFST.
	CAN0_STR_TFST = 0x8
	// Transmit FIFO is full
	CAN0_STR_TFST_0 = 0x0
	// Transmit FIFO is not full
	CAN0_STR_TFST_1 = 0x1
	// Position of RFST field.
	CAN0_STR_RFST_Pos = 0x2
	// Bit mask of RFST field.
	CAN0_STR_RFST_Msk = 0x4
	// Bit RFST.
	CAN0_STR_RFST = 0x4
	// No message in receive FIFO (empty)
	CAN0_STR_RFST_0 = 0x0
	// Message in receive FIFO
	CAN0_STR_RFST_1 = 0x1
	// Position of SDST field.
	CAN0_STR_SDST_Pos = 0x1
	// Bit mask of SDST field.
	CAN0_STR_SDST_Msk = 0x2
	// Bit SDST.
	CAN0_STR_SDST = 0x2
	// No mailbox with SENTDATA bit = 1
	CAN0_STR_SDST_0 = 0x0
	// Mailbox(es) with SENTDATA bit = 1
	CAN0_STR_SDST_1 = 0x1
	// Position of NDST field.
	CAN0_STR_NDST_Pos = 0x0
	// Bit mask of NDST field.
	CAN0_STR_NDST_Msk = 0x1
	// Bit NDST.
	CAN0_STR_NDST = 0x1
	// No mailbox with NEWDATA bit = 1
	CAN0_STR_NDST_0 = 0x0
	// Mailbox(es) with NEWDATA bit = 1
	CAN0_STR_NDST_1 = 0x1

	// BCR: Bit Configuration Register
	// Position of TSEG1 field.
	CAN0_BCR_TSEG1_Pos = 0x1c
	// Bit mask of TSEG1 field.
	CAN0_BCR_TSEG1_Msk = 0xf0000000
	// Setting prohibited
	CAN0_BCR_TSEG1_0000 = 0x0
	// Setting prohibited
	CAN0_BCR_TSEG1_0001 = 0x1
	// Setting prohibited
	CAN0_BCR_TSEG1_0010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG1_0011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG1_0100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG1_0101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG1_0110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG1_0111 = 0x7
	// 9 Tq
	CAN0_BCR_TSEG1_1000 = 0x8
	// 10 Tq
	CAN0_BCR_TSEG1_1001 = 0x9
	// 11 Tq
	CAN0_BCR_TSEG1_1010 = 0xa
	// 12 Tq
	CAN0_BCR_TSEG1_1011 = 0xb
	// 13 Tq
	CAN0_BCR_TSEG1_1100 = 0xc
	// 14 Tq
	CAN0_BCR_TSEG1_1101 = 0xd
	// 15 Tq
	CAN0_BCR_TSEG1_1110 = 0xe
	// 16 Tq
	CAN0_BCR_TSEG1_1111 = 0xf
	// Position of BRP field.
	CAN0_BCR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN0_BCR_BRP_Msk = 0x3ff0000
	// Position of SJW field.
	CAN0_BCR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN0_BCR_SJW_Msk = 0x3000
	// 1 Tq
	CAN0_BCR_SJW_00 = 0x0
	// 2 Tq
	CAN0_BCR_SJW_01 = 0x1
	// 3 Tq
	CAN0_BCR_SJW_10 = 0x2
	// 4 Tq
	CAN0_BCR_SJW_11 = 0x3
	// Position of TSEG2 field.
	CAN0_BCR_TSEG2_Pos = 0x8
	// Bit mask of TSEG2 field.
	CAN0_BCR_TSEG2_Msk = 0x700
	// Setting prohibited
	CAN0_BCR_TSEG2_000 = 0x0
	// 2 Tq
	CAN0_BCR_TSEG2_001 = 0x1
	// 3 Tq
	CAN0_BCR_TSEG2_010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG2_011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG2_100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG2_101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG2_110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG2_111 = 0x7
	// Position of CCLKS field.
	CAN0_BCR_CCLKS_Pos = 0x0
	// Bit mask of CCLKS field.
	CAN0_BCR_CCLKS_Msk = 0x1
	// Bit CCLKS.
	CAN0_BCR_CCLKS = 0x1
	// PCLK (generated by the PLL clock)
	CAN0_BCR_CCLKS_0 = 0x0
	// CANMCLK (generated by the main clock)
	CAN0_BCR_CCLKS_1 = 0x1

	// RFCR: Receive FIFO Control Register
	// Position of RFEST field.
	CAN0_RFCR_RFEST_Pos = 0x7
	// Bit mask of RFEST field.
	CAN0_RFCR_RFEST_Msk = 0x80
	// Bit RFEST.
	CAN0_RFCR_RFEST = 0x80
	// Unread message in receive FIFO
	CAN0_RFCR_RFEST_0 = 0x0
	// No unread message in receive FIFO
	CAN0_RFCR_RFEST_1 = 0x1
	// Position of RFWST field.
	CAN0_RFCR_RFWST_Pos = 0x6
	// Bit mask of RFWST field.
	CAN0_RFCR_RFWST_Msk = 0x40
	// Bit RFWST.
	CAN0_RFCR_RFWST = 0x40
	// Receive FIFO is not buffer warning
	CAN0_RFCR_RFWST_0 = 0x0
	// Receive FIFO is buffer warning (3 unread messages)
	CAN0_RFCR_RFWST_1 = 0x1
	// Position of RFFST field.
	CAN0_RFCR_RFFST_Pos = 0x5
	// Bit mask of RFFST field.
	CAN0_RFCR_RFFST_Msk = 0x20
	// Bit RFFST.
	CAN0_RFCR_RFFST = 0x20
	// Receive FIFO is not full
	CAN0_RFCR_RFFST_0 = 0x0
	// Receive FIFO is full (4 unread messages)
	CAN0_RFCR_RFFST_1 = 0x1
	// Position of RFMLF field.
	CAN0_RFCR_RFMLF_Pos = 0x4
	// Bit mask of RFMLF field.
	CAN0_RFCR_RFMLF_Msk = 0x10
	// Bit RFMLF.
	CAN0_RFCR_RFMLF = 0x10
	// No receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_0 = 0x0
	// Receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_1 = 0x1
	// Position of RFUST field.
	CAN0_RFCR_RFUST_Pos = 0x1
	// Bit mask of RFUST field.
	CAN0_RFCR_RFUST_Msk = 0xe
	// No unread message
	CAN0_RFCR_RFUST_000 = 0x0
	// 1 unread message
	CAN0_RFCR_RFUST_001 = 0x1
	// 2 unread messages
	CAN0_RFCR_RFUST_010 = 0x2
	// 3 unread messages
	CAN0_RFCR_RFUST_011 = 0x3
	// 4 unread messages
	CAN0_RFCR_RFUST_100 = 0x4
	// Position of RFE field.
	CAN0_RFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	CAN0_RFCR_RFE_Msk = 0x1
	// Bit RFE.
	CAN0_RFCR_RFE = 0x1
	// Receive FIFO disabled
	CAN0_RFCR_RFE_0 = 0x0
	// Receive FIFO enabled
	CAN0_RFCR_RFE_1 = 0x1

	// RFPCR: Receive FIFO Pointer Control Register
	// Position of RFPCR field.
	CAN0_RFPCR_RFPCR_Pos = 0x0
	// Bit mask of RFPCR field.
	CAN0_RFPCR_RFPCR_Msk = 0xff

	// TFCR: Transmit FIFO Control Register
	// Position of TFEST field.
	CAN0_TFCR_TFEST_Pos = 0x7
	// Bit mask of TFEST field.
	CAN0_TFCR_TFEST_Msk = 0x80
	// Bit TFEST.
	CAN0_TFCR_TFEST = 0x80
	// Unsent message in transmit FIFO
	CAN0_TFCR_TFEST_0 = 0x0
	// No unsent message in transmit FIFO
	CAN0_TFCR_TFEST_1 = 0x1
	// Position of TFFST field.
	CAN0_TFCR_TFFST_Pos = 0x6
	// Bit mask of TFFST field.
	CAN0_TFCR_TFFST_Msk = 0x40
	// Bit TFFST.
	CAN0_TFCR_TFFST = 0x40
	// Transmit FIFO is not full
	CAN0_TFCR_TFFST_0 = 0x0
	// Transmit FIFO is full (4 unsent messages)
	CAN0_TFCR_TFFST_1 = 0x1
	// Position of TFUST field.
	CAN0_TFCR_TFUST_Pos = 0x1
	// Bit mask of TFUST field.
	CAN0_TFCR_TFUST_Msk = 0xe
	// No unsent message
	CAN0_TFCR_TFUST_000 = 0x0
	// 1 unsent message
	CAN0_TFCR_TFUST_001 = 0x1
	// 2 unsent messages
	CAN0_TFCR_TFUST_010 = 0x2
	// 3 unsent messages
	CAN0_TFCR_TFUST_011 = 0x3
	// 4 unsent messages
	CAN0_TFCR_TFUST_100 = 0x4
	// Position of TFE field.
	CAN0_TFCR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	CAN0_TFCR_TFE_Msk = 0x1
	// Bit TFE.
	CAN0_TFCR_TFE = 0x1
	// Transmit FIFO disabled
	CAN0_TFCR_TFE_0 = 0x0
	// Transmit FIFO enabled
	CAN0_TFCR_TFE_1 = 0x1

	// TFPCR: Transmit FIFO Pointer Control Register
	// Position of TFPCR field.
	CAN0_TFPCR_TFPCR_Pos = 0x0
	// Bit mask of TFPCR field.
	CAN0_TFPCR_TFPCR_Msk = 0xff

	// EIER: Error Interrupt Enable Register
	// Position of BLIE field.
	CAN0_EIER_BLIE_Pos = 0x7
	// Bit mask of BLIE field.
	CAN0_EIER_BLIE_Msk = 0x80
	// Bit BLIE.
	CAN0_EIER_BLIE = 0x80
	// Bus lock interrupt disabled
	CAN0_EIER_BLIE_0 = 0x0
	// Bus lock interrupt enabled
	CAN0_EIER_BLIE_1 = 0x1
	// Position of OLIE field.
	CAN0_EIER_OLIE_Pos = 0x6
	// Bit mask of OLIE field.
	CAN0_EIER_OLIE_Msk = 0x40
	// Bit OLIE.
	CAN0_EIER_OLIE = 0x40
	// Overload frame transmit interrupt disabled
	CAN0_EIER_OLIE_0 = 0x0
	// Overload frame transmit interrupt enabled
	CAN0_EIER_OLIE_1 = 0x1
	// Position of ORIE field.
	CAN0_EIER_ORIE_Pos = 0x5
	// Bit mask of ORIE field.
	CAN0_EIER_ORIE_Msk = 0x20
	// Bit ORIE.
	CAN0_EIER_ORIE = 0x20
	// Receive overrun interrupt disabled
	CAN0_EIER_ORIE_0 = 0x0
	// Receive overrun interrupt enabled
	CAN0_EIER_ORIE_1 = 0x1
	// Position of BORIE field.
	CAN0_EIER_BORIE_Pos = 0x4
	// Bit mask of BORIE field.
	CAN0_EIER_BORIE_Msk = 0x10
	// Bit BORIE.
	CAN0_EIER_BORIE = 0x10
	// Bus-off recovery interrupt disabled
	CAN0_EIER_BORIE_0 = 0x0
	// Bus-off recovery interrupt enabled
	CAN0_EIER_BORIE_1 = 0x1
	// Position of BOEIE field.
	CAN0_EIER_BOEIE_Pos = 0x3
	// Bit mask of BOEIE field.
	CAN0_EIER_BOEIE_Msk = 0x8
	// Bit BOEIE.
	CAN0_EIER_BOEIE = 0x8
	// Bus-off entry interrupt disabled
	CAN0_EIER_BOEIE_0 = 0x0
	// Bus-off entry interrupt enabled
	CAN0_EIER_BOEIE_1 = 0x1
	// Position of EPIE field.
	CAN0_EIER_EPIE_Pos = 0x2
	// Bit mask of EPIE field.
	CAN0_EIER_EPIE_Msk = 0x4
	// Bit EPIE.
	CAN0_EIER_EPIE = 0x4
	// Error-passive interrupt disabled
	CAN0_EIER_EPIE_0 = 0x0
	// Error-passive interrupt enabled
	CAN0_EIER_EPIE_1 = 0x1
	// Position of EWIE field.
	CAN0_EIER_EWIE_Pos = 0x1
	// Bit mask of EWIE field.
	CAN0_EIER_EWIE_Msk = 0x2
	// Bit EWIE.
	CAN0_EIER_EWIE = 0x2
	// Error-warning interrupt disabled
	CAN0_EIER_EWIE_0 = 0x0
	// Error-warning interrupt enabled
	CAN0_EIER_EWIE_1 = 0x1
	// Position of BEIE field.
	CAN0_EIER_BEIE_Pos = 0x0
	// Bit mask of BEIE field.
	CAN0_EIER_BEIE_Msk = 0x1
	// Bit BEIE.
	CAN0_EIER_BEIE = 0x1
	// Bus error interrupt disabled
	CAN0_EIER_BEIE_0 = 0x0
	// Bus error interrupt enabled
	CAN0_EIER_BEIE_1 = 0x1

	// EIFR: Error Interrupt Factor Judge Register
	// Position of BLIF field.
	CAN0_EIFR_BLIF_Pos = 0x7
	// Bit mask of BLIF field.
	CAN0_EIFR_BLIF_Msk = 0x80
	// Bit BLIF.
	CAN0_EIFR_BLIF = 0x80
	// No bus lock detected
	CAN0_EIFR_BLIF_0 = 0x0
	// Bus lock detected
	CAN0_EIFR_BLIF_1 = 0x1
	// Position of OLIF field.
	CAN0_EIFR_OLIF_Pos = 0x6
	// Bit mask of OLIF field.
	CAN0_EIFR_OLIF_Msk = 0x40
	// Bit OLIF.
	CAN0_EIFR_OLIF = 0x40
	// No overload frame transmission detected
	CAN0_EIFR_OLIF_0 = 0x0
	// Overload frame transmission detected
	CAN0_EIFR_OLIF_1 = 0x1
	// Position of ORIF field.
	CAN0_EIFR_ORIF_Pos = 0x5
	// Bit mask of ORIF field.
	CAN0_EIFR_ORIF_Msk = 0x20
	// Bit ORIF.
	CAN0_EIFR_ORIF = 0x20
	// No receive overrun detected
	CAN0_EIFR_ORIF_0 = 0x0
	// Receive overrun detected
	CAN0_EIFR_ORIF_1 = 0x1
	// Position of BORIF field.
	CAN0_EIFR_BORIF_Pos = 0x4
	// Bit mask of BORIF field.
	CAN0_EIFR_BORIF_Msk = 0x10
	// Bit BORIF.
	CAN0_EIFR_BORIF = 0x10
	// No bus-off recovery detected
	CAN0_EIFR_BORIF_0 = 0x0
	// Bus-off recovery detected
	CAN0_EIFR_BORIF_1 = 0x1
	// Position of BOEIF field.
	CAN0_EIFR_BOEIF_Pos = 0x3
	// Bit mask of BOEIF field.
	CAN0_EIFR_BOEIF_Msk = 0x8
	// Bit BOEIF.
	CAN0_EIFR_BOEIF = 0x8
	// No bus-off entry detected
	CAN0_EIFR_BOEIF_0 = 0x0
	// Bus-off entry detected
	CAN0_EIFR_BOEIF_1 = 0x1
	// Position of EPIF field.
	CAN0_EIFR_EPIF_Pos = 0x2
	// Bit mask of EPIF field.
	CAN0_EIFR_EPIF_Msk = 0x4
	// Bit EPIF.
	CAN0_EIFR_EPIF = 0x4
	// No error-passive detected
	CAN0_EIFR_EPIF_0 = 0x0
	// Error-passive detected
	CAN0_EIFR_EPIF_1 = 0x1
	// Position of EWIF field.
	CAN0_EIFR_EWIF_Pos = 0x1
	// Bit mask of EWIF field.
	CAN0_EIFR_EWIF_Msk = 0x2
	// Bit EWIF.
	CAN0_EIFR_EWIF = 0x2
	// No error-warning detected
	CAN0_EIFR_EWIF_0 = 0x0
	// Error-warning detected
	CAN0_EIFR_EWIF_1 = 0x1
	// Position of BEIF field.
	CAN0_EIFR_BEIF_Pos = 0x0
	// Bit mask of BEIF field.
	CAN0_EIFR_BEIF_Msk = 0x1
	// Bit BEIF.
	CAN0_EIFR_BEIF = 0x1
	// No bus error detected
	CAN0_EIFR_BEIF_0 = 0x0
	// Bus error detected
	CAN0_EIFR_BEIF_1 = 0x1

	// RECR: Receive Error Count Register
	// Position of RECR field.
	CAN0_RECR_RECR_Pos = 0x0
	// Bit mask of RECR field.
	CAN0_RECR_RECR_Msk = 0xff

	// TECR: Transmit Error Count Register
	// Position of TECR field.
	CAN0_TECR_TECR_Pos = 0x0
	// Bit mask of TECR field.
	CAN0_TECR_TECR_Msk = 0xff

	// ECSR: Error Code Store Register
	// Position of EDPM field.
	CAN0_ECSR_EDPM_Pos = 0x7
	// Bit mask of EDPM field.
	CAN0_ECSR_EDPM_Msk = 0x80
	// Bit EDPM.
	CAN0_ECSR_EDPM = 0x80
	// Output of first detected error code
	CAN0_ECSR_EDPM_0 = 0x0
	// Output of accumulated error code
	CAN0_ECSR_EDPM_1 = 0x1
	// Position of ADEF field.
	CAN0_ECSR_ADEF_Pos = 0x6
	// Bit mask of ADEF field.
	CAN0_ECSR_ADEF_Msk = 0x40
	// Bit ADEF.
	CAN0_ECSR_ADEF = 0x40
	// No ACK delimiter error detected
	CAN0_ECSR_ADEF_0 = 0x0
	// ACK delimiter error detected
	CAN0_ECSR_ADEF_1 = 0x1
	// Position of BE0F field.
	CAN0_ECSR_BE0F_Pos = 0x5
	// Bit mask of BE0F field.
	CAN0_ECSR_BE0F_Msk = 0x20
	// Bit BE0F.
	CAN0_ECSR_BE0F = 0x20
	// No bit error (dominant) detected
	CAN0_ECSR_BE0F_0 = 0x0
	// Bit error (dominant) detected
	CAN0_ECSR_BE0F_1 = 0x1
	// Position of BE1F field.
	CAN0_ECSR_BE1F_Pos = 0x4
	// Bit mask of BE1F field.
	CAN0_ECSR_BE1F_Msk = 0x10
	// Bit BE1F.
	CAN0_ECSR_BE1F = 0x10
	// No bit error (recessive) detected
	CAN0_ECSR_BE1F_0 = 0x0
	// Bit error (recessive) detected
	CAN0_ECSR_BE1F_1 = 0x1
	// Position of CEF field.
	CAN0_ECSR_CEF_Pos = 0x3
	// Bit mask of CEF field.
	CAN0_ECSR_CEF_Msk = 0x8
	// Bit CEF.
	CAN0_ECSR_CEF = 0x8
	// No CRC error detected
	CAN0_ECSR_CEF_0 = 0x0
	// CRC error detected
	CAN0_ECSR_CEF_1 = 0x1
	// Position of AEF field.
	CAN0_ECSR_AEF_Pos = 0x2
	// Bit mask of AEF field.
	CAN0_ECSR_AEF_Msk = 0x4
	// Bit AEF.
	CAN0_ECSR_AEF = 0x4
	// No ACK error detected
	CAN0_ECSR_AEF_0 = 0x0
	// ACK error detected
	CAN0_ECSR_AEF_1 = 0x1
	// Position of FEF field.
	CAN0_ECSR_FEF_Pos = 0x1
	// Bit mask of FEF field.
	CAN0_ECSR_FEF_Msk = 0x2
	// Bit FEF.
	CAN0_ECSR_FEF = 0x2
	// No form error detected
	CAN0_ECSR_FEF_0 = 0x0
	// Form error detected
	CAN0_ECSR_FEF_1 = 0x1
	// Position of SEF field.
	CAN0_ECSR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	CAN0_ECSR_SEF_Msk = 0x1
	// Bit SEF.
	CAN0_ECSR_SEF = 0x1
	// No stuff error detected
	CAN0_ECSR_SEF_0 = 0x0
	// Stuff error detected
	CAN0_ECSR_SEF_1 = 0x1

	// CSSR: Channel Search Support Register
	// Position of CSSR field.
	CAN0_CSSR_CSSR_Pos = 0x0
	// Bit mask of CSSR field.
	CAN0_CSSR_CSSR_Msk = 0xff

	// MSSR: Mailbox Search Status Register
	// Position of SEST field.
	CAN0_MSSR_SEST_Pos = 0x7
	// Bit mask of SEST field.
	CAN0_MSSR_SEST_Msk = 0x80
	// Bit SEST.
	CAN0_MSSR_SEST = 0x80
	// Search result found
	CAN0_MSSR_SEST_0 = 0x0
	// No search result
	CAN0_MSSR_SEST_1 = 0x1
	// Position of MBNST field.
	CAN0_MSSR_MBNST_Pos = 0x0
	// Bit mask of MBNST field.
	CAN0_MSSR_MBNST_Msk = 0x1f

	// MSMR: Mailbox Search Mode Register
	// Position of MBSM field.
	CAN0_MSMR_MBSM_Pos = 0x0
	// Bit mask of MBSM field.
	CAN0_MSMR_MBSM_Msk = 0x3
	// Receive mailbox search mode
	CAN0_MSMR_MBSM_00 = 0x0
	// Transmit mailbox search mode
	CAN0_MSMR_MBSM_01 = 0x1
	// Message lost search mode
	CAN0_MSMR_MBSM_10 = 0x2
	// Channel search mode
	CAN0_MSMR_MBSM_11 = 0x3

	// TSR: Time Stamp Register
	// Position of TSR field.
	CAN0_TSR_TSR_Pos = 0x0
	// Bit mask of TSR field.
	CAN0_TSR_TSR_Msk = 0xffff

	// AFSR: Acceptance Filter Support Register
	// Position of AFSR field.
	CAN0_AFSR_AFSR_Pos = 0x0
	// Bit mask of AFSR field.
	CAN0_AFSR_AFSR_Msk = 0xffff

	// TCR: Test Control Register
	// Position of TSTM field.
	CAN0_TCR_TSTM_Pos = 0x1
	// Bit mask of TSTM field.
	CAN0_TCR_TSTM_Msk = 0x6
	// Other than CAN test mode
	CAN0_TCR_TSTM_00 = 0x0
	// Listen-only mode
	CAN0_TCR_TSTM_01 = 0x1
	// Self-test mode 0 (external loopback)
	CAN0_TCR_TSTM_10 = 0x2
	// Self-test mode 1 (internal loopback)
	CAN0_TCR_TSTM_11 = 0x3
	// Position of TSTE field.
	CAN0_TCR_TSTE_Pos = 0x0
	// Bit mask of TSTE field.
	CAN0_TCR_TSTE_Msk = 0x1
	// Bit TSTE.
	CAN0_TCR_TSTE = 0x1
	// CAN test mode disabled
	CAN0_TCR_TSTE_0 = 0x0
	// CAN test mode enabled
	CAN0_TCR_TSTE_1 = 0x1
)

// Constants for PDC: Parallel Data Capture Unit
const (
	// PCCR0: PDC Control Register 0
	// Position of EDS field.
	PDC_PCCR0_EDS_Pos = 0xe
	// Bit mask of EDS field.
	PDC_PCCR0_EDS_Msk = 0x4000
	// Bit EDS.
	PDC_PCCR0_EDS = 0x4000
	// Little endian
	PDC_PCCR0_EDS_0 = 0x0
	// Big endian
	PDC_PCCR0_EDS_1 = 0x1
	// Position of PCKDIV field.
	PDC_PCCR0_PCKDIV_Pos = 0xb
	// Bit mask of PCKDIV field.
	PDC_PCCR0_PCKDIV_Msk = 0x3800
	// PCKO/2
	PDC_PCCR0_PCKDIV_000 = 0x0
	// PCKO/4
	PDC_PCCR0_PCKDIV_001 = 0x1
	// PCKO/6
	PDC_PCCR0_PCKDIV_010 = 0x2
	// PCKO/8
	PDC_PCCR0_PCKDIV_011 = 0x3
	// PCKO/10
	PDC_PCCR0_PCKDIV_100 = 0x4
	// PCKO/12
	PDC_PCCR0_PCKDIV_101 = 0x5
	// PCKO/14
	PDC_PCCR0_PCKDIV_110 = 0x6
	// PCKO/16
	PDC_PCCR0_PCKDIV_111 = 0x7
	// Position of PCKOE field.
	PDC_PCCR0_PCKOE_Pos = 0xa
	// Bit mask of PCKOE field.
	PDC_PCCR0_PCKOE_Msk = 0x400
	// Bit PCKOE.
	PDC_PCCR0_PCKOE = 0x400
	// PCKO output is disabled (fixed to the high level)
	PDC_PCCR0_PCKOE_0 = 0x0
	// PCKO output is enabled.
	PDC_PCCR0_PCKOE_1 = 0x1
	// Position of HERIE field.
	PDC_PCCR0_HERIE_Pos = 0x9
	// Bit mask of HERIE field.
	PDC_PCCR0_HERIE_Msk = 0x200
	// Bit HERIE.
	PDC_PCCR0_HERIE = 0x200
	// Generation of horizontal byte number setting error interrupt requests is disabled.
	PDC_PCCR0_HERIE_0 = 0x0
	// Generation of horizontal byte number setting error interrupt requests is enabled.
	PDC_PCCR0_HERIE_1 = 0x1
	// Position of VERIE field.
	PDC_PCCR0_VERIE_Pos = 0x8
	// Bit mask of VERIE field.
	PDC_PCCR0_VERIE_Msk = 0x100
	// Bit VERIE.
	PDC_PCCR0_VERIE = 0x100
	// Generation of vertical line number setting error interrupt requests is disabled.
	PDC_PCCR0_VERIE_0 = 0x0
	// Generation of vertical line number setting error interrupt requests is enabled.
	PDC_PCCR0_VERIE_1 = 0x1
	// Position of UDRIE field.
	PDC_PCCR0_UDRIE_Pos = 0x7
	// Bit mask of UDRIE field.
	PDC_PCCR0_UDRIE_Msk = 0x80
	// Bit UDRIE.
	PDC_PCCR0_UDRIE = 0x80
	// Generation of underrun interrupt requests is disabled.
	PDC_PCCR0_UDRIE_0 = 0x0
	// Generation of underrun interrupt requests is enabled.
	PDC_PCCR0_UDRIE_1 = 0x1
	// Position of OVIE field.
	PDC_PCCR0_OVIE_Pos = 0x6
	// Bit mask of OVIE field.
	PDC_PCCR0_OVIE_Msk = 0x40
	// Bit OVIE.
	PDC_PCCR0_OVIE = 0x40
	// Generation of overrun interrupt requests is disabled.
	PDC_PCCR0_OVIE_0 = 0x0
	// Generation of overrun interrupt requests is enabled.
	PDC_PCCR0_OVIE_1 = 0x1
	// Position of FEIE field.
	PDC_PCCR0_FEIE_Pos = 0x5
	// Bit mask of FEIE field.
	PDC_PCCR0_FEIE_Msk = 0x20
	// Bit FEIE.
	PDC_PCCR0_FEIE = 0x20
	// Generation of frame end interrupt requests is disabled.
	PDC_PCCR0_FEIE_0 = 0x0
	// Generation of frame end interrupt requests is enabled.
	PDC_PCCR0_FEIE_1 = 0x1
	// Position of DFIE field.
	PDC_PCCR0_DFIE_Pos = 0x4
	// Bit mask of DFIE field.
	PDC_PCCR0_DFIE_Msk = 0x10
	// Bit DFIE.
	PDC_PCCR0_DFIE = 0x10
	// Generation of receive data ready interrupt requests is disabled.
	PDC_PCCR0_DFIE_0 = 0x0
	// Generation of receive data ready interrupt requests is enabled.
	PDC_PCCR0_DFIE_1 = 0x1
	// Position of PRST field.
	PDC_PCCR0_PRST_Pos = 0x3
	// Bit mask of PRST field.
	PDC_PCCR0_PRST_Msk = 0x8
	// Bit PRST.
	PDC_PCCR0_PRST = 0x8
	// PDC reset is not applied.
	PDC_PCCR0_PRST_0 = 0x0
	// PDC is reset.
	PDC_PCCR0_PRST_1 = 0x1
	// Position of HPS field.
	PDC_PCCR0_HPS_Pos = 0x2
	// Bit mask of HPS field.
	PDC_PCCR0_HPS_Msk = 0x4
	// Bit HPS.
	PDC_PCCR0_HPS = 0x4
	// HSYNC signal is active high.
	PDC_PCCR0_HPS_0 = 0x0
	// HSYNC signal is active low.
	PDC_PCCR0_HPS_1 = 0x1
	// Position of VPS field.
	PDC_PCCR0_VPS_Pos = 0x1
	// Bit mask of VPS field.
	PDC_PCCR0_VPS_Msk = 0x2
	// Bit VPS.
	PDC_PCCR0_VPS = 0x2
	// VSYNC signal is active high.
	PDC_PCCR0_VPS_0 = 0x0
	// VSYNC signal is active low.
	PDC_PCCR0_VPS_1 = 0x1
	// Position of PCKE field.
	PDC_PCCR0_PCKE_Pos = 0x0
	// Bit mask of PCKE field.
	PDC_PCCR0_PCKE_Msk = 0x1
	// Bit PCKE.
	PDC_PCCR0_PCKE = 0x1
	// Operations for reception are stopped.
	PDC_PCCR0_PCKE_0 = 0x0
	// Operations for reception are ongoing.
	PDC_PCCR0_PCKE_1 = 0x1

	// PCCR1: PDC Control Register 1
	// Position of PCE field.
	PDC_PCCR1_PCE_Pos = 0x0
	// Bit mask of PCE field.
	PDC_PCCR1_PCE_Msk = 0x1
	// Bit PCE.
	PDC_PCCR1_PCE = 0x1
	// Operations for reception are disabled.
	PDC_PCCR1_PCE_0 = 0x0
	// Operations for reception are enabled.
	PDC_PCCR1_PCE_1 = 0x1

	// PCSR: PDC Status Register
	// Position of HERF field.
	PDC_PCSR_HERF_Pos = 0x6
	// Bit mask of HERF field.
	PDC_PCSR_HERF_Msk = 0x40
	// Bit HERF.
	PDC_PCSR_HERF = 0x40
	// Horizontal byte number setting error has not been generated.
	PDC_PCSR_HERF_0 = 0x0
	// Horizontal byte number setting error has been generated.
	PDC_PCSR_HERF_1 = 0x1
	// Position of VERF field.
	PDC_PCSR_VERF_Pos = 0x5
	// Bit mask of VERF field.
	PDC_PCSR_VERF_Msk = 0x20
	// Bit VERF.
	PDC_PCSR_VERF = 0x20
	// Vertical line number setting error has not been generated.
	PDC_PCSR_VERF_0 = 0x0
	// Vertical line number setting error has been generated.
	PDC_PCSR_VERF_1 = 0x1
	// Position of UDRF field.
	PDC_PCSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	PDC_PCSR_UDRF_Msk = 0x10
	// Bit UDRF.
	PDC_PCSR_UDRF = 0x10
	// Underrun has not been generated.
	PDC_PCSR_UDRF_0 = 0x0
	// Underrun has been generated.
	PDC_PCSR_UDRF_1 = 0x1
	// Position of OVRF field.
	PDC_PCSR_OVRF_Pos = 0x3
	// Bit mask of OVRF field.
	PDC_PCSR_OVRF_Msk = 0x8
	// Bit OVRF.
	PDC_PCSR_OVRF = 0x8
	// FIFO overrun has not been generated.
	PDC_PCSR_OVRF_0 = 0x0
	// FIFO overrun has been generated.
	PDC_PCSR_OVRF_1 = 0x1
	// Position of FEF field.
	PDC_PCSR_FEF_Pos = 0x2
	// Bit mask of FEF field.
	PDC_PCSR_FEF_Msk = 0x4
	// Bit FEF.
	PDC_PCSR_FEF = 0x4
	// Frame end has not been generated.
	PDC_PCSR_FEF_0 = 0x0
	// Frame end has been generated.
	PDC_PCSR_FEF_1 = 0x1
	// Position of FEMPF field.
	PDC_PCSR_FEMPF_Pos = 0x1
	// Bit mask of FEMPF field.
	PDC_PCSR_FEMPF_Msk = 0x2
	// Bit FEMPF.
	PDC_PCSR_FEMPF = 0x2
	// FIFO is not empty.
	PDC_PCSR_FEMPF_0 = 0x0
	// FIFO is empty.
	PDC_PCSR_FEMPF_1 = 0x1
	// Position of FBSY field.
	PDC_PCSR_FBSY_Pos = 0x0
	// Bit mask of FBSY field.
	PDC_PCSR_FBSY_Msk = 0x1
	// Bit FBSY.
	PDC_PCSR_FBSY = 0x1
	// Operations for reception are stopped.
	PDC_PCSR_FBSY_0 = 0x0
	// Operations for reception are ongoing.
	PDC_PCSR_FBSY_1 = 0x1

	// PCMONR: PDC Pin Monitor Register
	// Position of HSYNC field.
	PDC_PCMONR_HSYNC_Pos = 0x1
	// Bit mask of HSYNC field.
	PDC_PCMONR_HSYNC_Msk = 0x2
	// Bit HSYNC.
	PDC_PCMONR_HSYNC = 0x2
	// HSYNC signal is at the low level.
	PDC_PCMONR_HSYNC_0 = 0x0
	// HSYNC signal is at the high level.
	PDC_PCMONR_HSYNC_1 = 0x1
	// Position of VSYNC field.
	PDC_PCMONR_VSYNC_Pos = 0x0
	// Bit mask of VSYNC field.
	PDC_PCMONR_VSYNC_Msk = 0x1
	// Bit VSYNC.
	PDC_PCMONR_VSYNC = 0x1
	// VSYNC signal is at the low level.
	PDC_PCMONR_VSYNC_0 = 0x0
	// VSYNC signal is at the high level.
	PDC_PCMONR_VSYNC_1 = 0x1

	// PCDR: PDC Receive Data Register
	// Position of PCDR field.
	PDC_PCDR_PCDR_Pos = 0x0
	// Bit mask of PCDR field.
	PDC_PCDR_PCDR_Msk = 0xffffffff

	// VCR: Vertical Capture Register
	// Position of VSZ field.
	PDC_VCR_VSZ_Pos = 0x10
	// Bit mask of VSZ field.
	PDC_VCR_VSZ_Msk = 0xfff0000
	// Position of VST field.
	PDC_VCR_VST_Pos = 0x0
	// Bit mask of VST field.
	PDC_VCR_VST_Msk = 0xfff

	// HCR: Horizontal Capture Register
	// Position of HSZ field.
	PDC_HCR_HSZ_Pos = 0x10
	// Bit mask of HSZ field.
	PDC_HCR_HSZ_Msk = 0xfff0000
	// Position of HST field.
	PDC_HCR_HST_Pos = 0x0
	// Bit mask of HST field.
	PDC_HCR_HST_Msk = 0xfff
)

// Constants for QSPI: Quad-SPI
const (
	// SFMSMD: Transfer Mode Control Register
	// Position of SFMCCE field.
	QSPI_SFMSMD_SFMCCE_Pos = 0xf
	// Bit mask of SFMCCE field.
	QSPI_SFMSMD_SFMCCE_Msk = 0x8000
	// Bit SFMCCE.
	QSPI_SFMSMD_SFMCCE = 0x8000
	// Default instruction code set for each instruction
	QSPI_SFMSMD_SFMCCE_0 = 0x0
	// Instruction code written in the SFMSIC register
	QSPI_SFMSMD_SFMCCE_1 = 0x1
	// Position of SFMOSW field.
	QSPI_SFMSMD_SFMOSW_Pos = 0xb
	// Bit mask of SFMOSW field.
	QSPI_SFMSMD_SFMOSW_Msk = 0x800
	// Bit SFMOSW.
	QSPI_SFMSMD_SFMOSW = 0x800
	// Does not extend the low-level width of SCK at transmission time
	QSPI_SFMSMD_SFMOSW_0 = 0x0
	// Extends the low-level width of SCK by 1*PCLKA at transmission time
	QSPI_SFMSMD_SFMOSW_1 = 0x1
	// Position of SFMOHW field.
	QSPI_SFMSMD_SFMOHW_Pos = 0xa
	// Bit mask of SFMOHW field.
	QSPI_SFMSMD_SFMOHW_Msk = 0x400
	// Bit SFMOHW.
	QSPI_SFMSMD_SFMOHW = 0x400
	// Does not extend the high-level width of SCK at transmission time
	QSPI_SFMSMD_SFMOHW_0 = 0x0
	// Extends the high-level width of SCK by 1*PCLKA at transmission time
	QSPI_SFMSMD_SFMOHW_1 = 0x1
	// Position of SFMOEX field.
	QSPI_SFMSMD_SFMOEX_Pos = 0x9
	// Bit mask of SFMOEX field.
	QSPI_SFMSMD_SFMOEX_Msk = 0x200
	// Bit SFMOEX.
	QSPI_SFMSMD_SFMOEX = 0x200
	// Does not extend the output enable signal
	QSPI_SFMSMD_SFMOEX_0 = 0x0
	// Extends the output enable signal by 1*QSPCLK
	QSPI_SFMSMD_SFMOEX_1 = 0x1
	// Position of SFMMD3 field.
	QSPI_SFMSMD_SFMMD3_Pos = 0x8
	// Bit mask of SFMMD3 field.
	QSPI_SFMSMD_SFMMD3_Msk = 0x100
	// Bit SFMMD3.
	QSPI_SFMSMD_SFMMD3 = 0x100
	// SPI mode 0
	QSPI_SFMSMD_SFMMD3_0 = 0x0
	// SPI mode 3
	QSPI_SFMSMD_SFMMD3_1 = 0x1
	// Position of SFMPAE field.
	QSPI_SFMSMD_SFMPAE_Pos = 0x7
	// Bit mask of SFMPAE field.
	QSPI_SFMSMD_SFMPAE_Msk = 0x80
	// Bit SFMPAE.
	QSPI_SFMSMD_SFMPAE = 0x80
	// Disables prefetch stopping at locations other than on byte boundaries
	QSPI_SFMSMD_SFMPAE_0 = 0x0
	// Enables prefetch stopping at locations other than on byte boundaries
	QSPI_SFMSMD_SFMPAE_1 = 0x1
	// Position of SFMPFE field.
	QSPI_SFMSMD_SFMPFE_Pos = 0x6
	// Bit mask of SFMPFE field.
	QSPI_SFMSMD_SFMPFE_Msk = 0x40
	// Bit SFMPFE.
	QSPI_SFMSMD_SFMPFE = 0x40
	// Disables prefetch
	QSPI_SFMSMD_SFMPFE_0 = 0x0
	// Enables prefetch
	QSPI_SFMSMD_SFMPFE_1 = 0x1
	// Position of SFMSE field.
	QSPI_SFMSMD_SFMSE_Pos = 0x4
	// Bit mask of SFMSE field.
	QSPI_SFMSMD_SFMSE_Msk = 0x30
	// Does not extend QSSL
	QSPI_SFMSMD_SFMSE_00 = 0x0
	// Extends QSSL by 33*QSPCLK
	QSPI_SFMSMD_SFMSE_01 = 0x1
	// Extends QSSL by 129*QSPCLK
	QSPI_SFMSMD_SFMSE_10 = 0x2
	// Extends QSSL infinitely
	QSPI_SFMSMD_SFMSE_11 = 0x3
	// Position of SFMRM field.
	QSPI_SFMSMD_SFMRM_Pos = 0x0
	// Bit mask of SFMRM field.
	QSPI_SFMSMD_SFMRM_Msk = 0x7
	// Standard Read
	QSPI_SFMSMD_SFMRM_000 = 0x0
	// Fast Read
	QSPI_SFMSMD_SFMRM_001 = 0x1
	// Fast Read Dual Output
	QSPI_SFMSMD_SFMRM_010 = 0x2
	// Fast Read Dual I/O
	QSPI_SFMSMD_SFMRM_011 = 0x3
	// Fast Read Quad Output
	QSPI_SFMSMD_SFMRM_100 = 0x4
	// Fast Read Quad I/O
	QSPI_SFMSMD_SFMRM_101 = 0x5
	// Setting prohibited
	QSPI_SFMSMD_SFMRM_110 = 0x6
	// Setting prohibited
	QSPI_SFMSMD_SFMRM_111 = 0x7

	// SFMSSC: Chip Selection Control Register
	// Position of SFMSLD field.
	QSPI_SFMSSC_SFMSLD_Pos = 0x5
	// Bit mask of SFMSLD field.
	QSPI_SFMSSC_SFMSLD_Msk = 0x20
	// Bit SFMSLD.
	QSPI_SFMSSC_SFMSLD = 0x20
	// Outputs QSSL 0.5*SCK before the first rising edge of QSPCLK
	QSPI_SFMSSC_SFMSLD_0 = 0x0
	// Outputs QSSL 1.5*SCK before the first rising edge of QSPCLK
	QSPI_SFMSSC_SFMSLD_1 = 0x1
	// Position of SFMSHD field.
	QSPI_SFMSSC_SFMSHD_Pos = 0x4
	// Bit mask of SFMSHD field.
	QSPI_SFMSSC_SFMSHD_Msk = 0x10
	// Bit SFMSHD.
	QSPI_SFMSSC_SFMSHD = 0x10
	// Releases QSSL 0.5*SCK after the last rising edge of QSPCLK
	QSPI_SFMSSC_SFMSHD_0 = 0x0
	// Releases QSSL 1.5*SCK after the last rising edge of QSPCLK
	QSPI_SFMSSC_SFMSHD_1 = 0x1
	// Position of SFMSW field.
	QSPI_SFMSSC_SFMSW_Pos = 0x0
	// Bit mask of SFMSW field.
	QSPI_SFMSSC_SFMSW_Msk = 0xf
	// 1 x QSPCLK
	QSPI_SFMSSC_SFMSW_0000 = 0x0
	// 2 x QSPCLK
	QSPI_SFMSSC_SFMSW_0001 = 0x1
	// 3 x QSPCLK
	QSPI_SFMSSC_SFMSW_0010 = 0x2
	// 4 x QSPCLK
	QSPI_SFMSSC_SFMSW_0011 = 0x3
	// 5 x QSPCLK
	QSPI_SFMSSC_SFMSW_0100 = 0x4
	// 6 x QSPCLK
	QSPI_SFMSSC_SFMSW_0101 = 0x5
	// 7 x QSPCLK
	QSPI_SFMSSC_SFMSW_0110 = 0x6
	// 8 x QSPCLK
	QSPI_SFMSSC_SFMSW_0111 = 0x7
	// 9 x QSPCLK
	QSPI_SFMSSC_SFMSW_1000 = 0x8
	// 10 x QSPCLK
	QSPI_SFMSSC_SFMSW_1001 = 0x9
	// 11 x QSPCLK
	QSPI_SFMSSC_SFMSW_1010 = 0xa
	// 12 x QSPCLK
	QSPI_SFMSSC_SFMSW_1011 = 0xb
	// 13 x QSPCLK
	QSPI_SFMSSC_SFMSW_1100 = 0xc
	// 14 x QSPCLK
	QSPI_SFMSSC_SFMSW_1101 = 0xd
	// 15 x QSPCLK
	QSPI_SFMSSC_SFMSW_1110 = 0xe
	// 16 x QSPCLK
	QSPI_SFMSSC_SFMSW_1111 = 0xf

	// SFMSKC: Clock Control Register
	// Position of SFMDTY field.
	QSPI_SFMSKC_SFMDTY_Pos = 0x5
	// Bit mask of SFMDTY field.
	QSPI_SFMSKC_SFMDTY_Msk = 0x20
	// Bit SFMDTY.
	QSPI_SFMSKC_SFMDTY = 0x20
	// Serial interface reference cycle selection (* Pay attention to the irregularity.)
	QSPI_SFMSKC_SFMDTY_0 = 0x0
	// Delays the rising of the SCK signal by 0.5*PCLKA.(* Valid with PCLKA multiplied by an odd number)
	QSPI_SFMSKC_SFMDTY_1 = 0x1
	// Position of SFMDV field.
	QSPI_SFMSKC_SFMDV_Pos = 0x0
	// Bit mask of SFMDV field.
	QSPI_SFMSKC_SFMDV_Msk = 0x1f
	// 18 x PCLKA
	QSPI_SFMSKC_SFMDV_10000 = 0x10
	// 20 x PCLKA
	QSPI_SFMSKC_SFMDV_10001 = 0x11
	// 22 x PCLKA
	QSPI_SFMSKC_SFMDV_10010 = 0x12
	// 24 x PCLKA
	QSPI_SFMSKC_SFMDV_10011 = 0x13
	// 26 x PCLKA
	QSPI_SFMSKC_SFMDV_10100 = 0x14
	// 28 x PCLKA
	QSPI_SFMSKC_SFMDV_10101 = 0x15
	// 30 x PCLKA
	QSPI_SFMSKC_SFMDV_10110 = 0x16
	// 32 x PCLKA
	QSPI_SFMSKC_SFMDV_10111 = 0x17
	// 34 x PCLKA
	QSPI_SFMSKC_SFMDV_11000 = 0x18
	// 36 x PCLKA
	QSPI_SFMSKC_SFMDV_11001 = 0x19
	// 38 x PCLKA
	QSPI_SFMSKC_SFMDV_11010 = 0x1a
	// 40 x PCLKA
	QSPI_SFMSKC_SFMDV_11011 = 0x1b
	// 42 x PCLKA
	QSPI_SFMSKC_SFMDV_11100 = 0x1c
	// 44 x PCLKA
	QSPI_SFMSKC_SFMDV_11101 = 0x1d
	// 46 x PCLKA
	QSPI_SFMSKC_SFMDV_11110 = 0x1e
	// 48 x PCLKA
	QSPI_SFMSKC_SFMDV_11111 = 0x1f

	// SFMSST: Status Register
	// Position of PFOFF field.
	QSPI_SFMSST_PFOFF_Pos = 0x7
	// Bit mask of PFOFF field.
	QSPI_SFMSST_PFOFF_Msk = 0x80
	// Bit PFOFF.
	QSPI_SFMSST_PFOFF = 0x80
	// The prefetch function is operating.
	QSPI_SFMSST_PFOFF_0 = 0x0
	// The prefetch function is not enabled or is not operating.
	QSPI_SFMSST_PFOFF_1 = 0x1
	// Position of PFFUL field.
	QSPI_SFMSST_PFFUL_Pos = 0x6
	// Bit mask of PFFUL field.
	QSPI_SFMSST_PFFUL_Msk = 0x40
	// Bit PFFUL.
	QSPI_SFMSST_PFFUL = 0x40
	// The prefetch buffer has a free space.
	QSPI_SFMSST_PFFUL_0 = 0x0
	// The prefetch buffer is full.
	QSPI_SFMSST_PFFUL_1 = 0x1
	// Position of PFCNT field.
	QSPI_SFMSST_PFCNT_Pos = 0x0
	// Bit mask of PFCNT field.
	QSPI_SFMSST_PFCNT_Msk = 0x1f
	// Nodata has been prefetched.
	QSPI_SFMSST_PFCNT_00000 = 0x0

	// SFMCOM: Communication Port Register
	// Position of SFMD field.
	QSPI_SFMCOM_SFMD_Pos = 0x0
	// Bit mask of SFMD field.
	QSPI_SFMCOM_SFMD_Msk = 0xff

	// SFMCMD: Communication Mode Control Register
	// Position of DCOM field.
	QSPI_SFMCMD_DCOM_Pos = 0x0
	// Bit mask of DCOM field.
	QSPI_SFMCMD_DCOM_Msk = 0x1
	// Bit DCOM.
	QSPI_SFMCMD_DCOM = 0x1
	// ROM access mode
	QSPI_SFMCMD_DCOM_0 = 0x0
	// Direct communication mode
	QSPI_SFMCMD_DCOM_1 = 0x1

	// SFMCST: Communication Status Register
	// Position of EROMR field.
	QSPI_SFMCST_EROMR_Pos = 0x7
	// Bit mask of EROMR field.
	QSPI_SFMCST_EROMR_Msk = 0x80
	// Bit EROMR.
	QSPI_SFMCST_EROMR = 0x80
	// ROM access is not detected in direct communication mode
	QSPI_SFMCST_EROMR_0 = 0x0
	// ROM access is detected in direct communication mode
	QSPI_SFMCST_EROMR_1 = 0x1
	// Position of COMBSY field.
	QSPI_SFMCST_COMBSY_Pos = 0x0
	// Bit mask of COMBSY field.
	QSPI_SFMCST_COMBSY_Msk = 0x1
	// Bit COMBSY.
	QSPI_SFMCST_COMBSY = 0x1
	// There is no serial transfer being processed.
	QSPI_SFMCST_COMBSY_0 = 0x0
	// There is a serial transfer being processed.
	QSPI_SFMCST_COMBSY_1 = 0x1

	// SFMSIC: Instruction Code Register
	// Position of SFMCIC field.
	QSPI_SFMSIC_SFMCIC_Pos = 0x0
	// Bit mask of SFMCIC field.
	QSPI_SFMSIC_SFMCIC_Msk = 0xff

	// SFMSAC: Address Mode Control Register
	// Position of SFM4BC field.
	QSPI_SFMSAC_SFM4BC_Pos = 0x4
	// Bit mask of SFM4BC field.
	QSPI_SFMSAC_SFM4BC_Msk = 0x10
	// Bit SFM4BC.
	QSPI_SFMSAC_SFM4BC = 0x10
	// Does not use 4 Byte address read Instruction code
	QSPI_SFMSAC_SFM4BC_0 = 0x0
	// Use 4 Byte address read Instruction code
	QSPI_SFMSAC_SFM4BC_1 = 0x1
	// Position of SFMAS field.
	QSPI_SFMSAC_SFMAS_Pos = 0x0
	// Bit mask of SFMAS field.
	QSPI_SFMSAC_SFMAS_Msk = 0x3
	// 1byte
	QSPI_SFMSAC_SFMAS_00 = 0x0
	// 2bytes
	QSPI_SFMSAC_SFMAS_01 = 0x1
	// 3bytes
	QSPI_SFMSAC_SFMAS_10 = 0x2
	// 4 bytes
	QSPI_SFMSAC_SFMAS_11 = 0x3

	// SFMSDC: Dummy Cycle Control Register
	// Position of SFMXD field.
	QSPI_SFMSDC_SFMXD_Pos = 0x8
	// Bit mask of SFMXD field.
	QSPI_SFMSDC_SFMXD_Msk = 0xff00
	// XIP mode is prohibited
	QSPI_SFMSDC_SFMXD_0 = 0x0
	// XIP mode is permitted
	QSPI_SFMSDC_SFMXD_1 = 0x1
	// Position of SFMXEN field.
	QSPI_SFMSDC_SFMXEN_Pos = 0x7
	// Bit mask of SFMXEN field.
	QSPI_SFMSDC_SFMXEN_Msk = 0x80
	// Bit SFMXEN.
	QSPI_SFMSDC_SFMXEN = 0x80
	// XIP mode is prohibited
	QSPI_SFMSDC_SFMXEN_0 = 0x0
	// XIP mode is permitted
	QSPI_SFMSDC_SFMXEN_1 = 0x1
	// Position of SFMXST field.
	QSPI_SFMSDC_SFMXST_Pos = 0x6
	// Bit mask of SFMXST field.
	QSPI_SFMSDC_SFMXST_Msk = 0x40
	// Bit SFMXST.
	QSPI_SFMSDC_SFMXST = 0x40
	// Normal (non-XIP) mode is operating
	QSPI_SFMSDC_SFMXST_0 = 0x0
	// XIP mode is operating
	QSPI_SFMSDC_SFMXST_1 = 0x1
	// Position of SFMDN field.
	QSPI_SFMSDC_SFMDN_Pos = 0x0
	// Bit mask of SFMDN field.
	QSPI_SFMSDC_SFMDN_Msk = 0xf
	// Default dummy cycles of each instruction.
	QSPI_SFMSDC_SFMDN_0000 = 0x0

	// SFMSPC: SPI Protocol Control Register
	// Position of SFMSDE field.
	QSPI_SFMSPC_SFMSDE_Pos = 0x4
	// Bit mask of SFMSDE field.
	QSPI_SFMSPC_SFMSDE_Msk = 0x10
	// Bit SFMSDE.
	QSPI_SFMSPC_SFMSDE = 0x10
	// Does not allocate minimum switch time
	QSPI_SFMSPC_SFMSDE_0 = 0x0
	// Allocate the minimum switch time equivalent to 1*QSPXLK
	QSPI_SFMSPC_SFMSDE_1 = 0x1
	// Position of SFMSPI field.
	QSPI_SFMSPC_SFMSPI_Pos = 0x0
	// Bit mask of SFMSPI field.
	QSPI_SFMSPC_SFMSPI_Msk = 0x3
	// Extended SPI protocol
	QSPI_SFMSPC_SFMSPI_00 = 0x0
	// Dual SPI protocol
	QSPI_SFMSPC_SFMSPI_01 = 0x1
	// Quad SPI protocol
	QSPI_SFMSPC_SFMSPI_10 = 0x2
	// Setting prohibited.
	QSPI_SFMSPC_SFMSPI_11 = 0x3

	// SFMPMD: Port Control Register
	// Position of SFMWPL field.
	QSPI_SFMPMD_SFMWPL_Pos = 0x2
	// Bit mask of SFMWPL field.
	QSPI_SFMPMD_SFMWPL_Msk = 0x4
	// Bit SFMWPL.
	QSPI_SFMPMD_SFMWPL = 0x4
	// Low level
	QSPI_SFMPMD_SFMWPL_0 = 0x0
	// High level
	QSPI_SFMPMD_SFMWPL_1 = 0x1

	// SFMCNT1: External QSPI Address Register 1
	// Position of QSPI_EXT field.
	QSPI_SFMCNT1_QSPI_EXT_Pos = 0x1a
	// Bit mask of QSPI_EXT field.
	QSPI_SFMCNT1_QSPI_EXT_Msk = 0xfc000000
)

// Constants for MMF: Memory Mirror Function
const (
	// MMSFR: MemMirror Special Function Register
	// Position of KEY field.
	MMF_MMSFR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMSFR_KEY_Msk = 0xff000000
	// Writing to the MEMMIRADDR bits are valid, when the KEY bits are written 0xDB.
	MMF_MMSFR_KEY_0xDB = 0xdb
	// Position of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Pos = 0x7
	// Bit mask of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Msk = 0x7fff80

	// MMEN: MemMirror Enable Register
	// Position of KEY field.
	MMF_MMEN_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMEN_KEY_Msk = 0xff000000
	// Writing to the EN bit is valid, when the KEY bits are written 0xDB.
	MMF_MMEN_KEY_0xDB = 0xdb
	// Position of EN field.
	MMF_MMEN_EN_Pos = 0x0
	// Bit mask of EN field.
	MMF_MMEN_EN_Msk = 0x1
	// Bit EN.
	MMF_MMEN_EN = 0x1
	// Memory Mirror Function is enabled.
	MMF_MMEN_EN_1 = 0x1
	// Memory Mirror Function is disabled.
	MMF_MMEN_EN_0 = 0x0
)

// Constants for DMAC0: Direct memory access controller 0
const (
	// DMSAR: DMA Source Address Register
	// Position of DMSAR field.
	DMAC0_DMSAR_DMSAR_Pos = 0x0
	// Bit mask of DMSAR field.
	DMAC0_DMSAR_DMSAR_Msk = 0xffffffff

	// DMDAR: DMA Destination Address Register
	// Position of DMDAR field.
	DMAC0_DMDAR_DMDAR_Pos = 0x0
	// Bit mask of DMDAR field.
	DMAC0_DMDAR_DMDAR_Msk = 0xffffffff

	// DMCRA: DMA Transfer Count Register
	// Position of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Pos = 0x10
	// Bit mask of DMCRAH field.
	DMAC0_DMCRA_DMCRAH_Msk = 0x3ff0000
	// Position of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Pos = 0x0
	// Bit mask of DMCRAL field.
	DMAC0_DMCRA_DMCRAL_Msk = 0xffff

	// DMCRB: DMA Block Transfer Count Register
	// Position of DMCRB field.
	DMAC0_DMCRB_DMCRB_Pos = 0x0
	// Bit mask of DMCRB field.
	DMAC0_DMCRB_DMCRB_Msk = 0xffff
	// 65,536 blocks
	DMAC0_DMCRB_DMCRB_0000 = 0x0

	// DMTMD: DMA Transfer Mode Register
	// Position of MD field.
	DMAC0_DMTMD_MD_Pos = 0xe
	// Bit mask of MD field.
	DMAC0_DMTMD_MD_Msk = 0xc000
	// Normal transfer
	DMAC0_DMTMD_MD_00 = 0x0
	// Repeat transfer
	DMAC0_DMTMD_MD_01 = 0x1
	// Block transfer
	DMAC0_DMTMD_MD_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_MD_11 = 0x3
	// Position of DTS field.
	DMAC0_DMTMD_DTS_Pos = 0xc
	// Bit mask of DTS field.
	DMAC0_DMTMD_DTS_Msk = 0x3000
	// Specify destination as the repeat area or block area
	DMAC0_DMTMD_DTS_00 = 0x0
	// Specify source as the repeat area or block area
	DMAC0_DMTMD_DTS_01 = 0x1
	// Do not specify repeat area or block area
	DMAC0_DMTMD_DTS_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_DTS_11 = 0x3
	// Position of SZ field.
	DMAC0_DMTMD_SZ_Pos = 0x8
	// Bit mask of SZ field.
	DMAC0_DMTMD_SZ_Msk = 0x300
	// 8 bits
	DMAC0_DMTMD_SZ_00 = 0x0
	// 16 bits
	DMAC0_DMTMD_SZ_01 = 0x1
	// 32 bits
	DMAC0_DMTMD_SZ_10 = 0x2
	// Setting prohibited
	DMAC0_DMTMD_SZ_11 = 0x3
	// Position of DCTG field.
	DMAC0_DMTMD_DCTG_Pos = 0x0
	// Bit mask of DCTG field.
	DMAC0_DMTMD_DCTG_Msk = 0x3
	// Software
	DMAC0_DMTMD_DCTG_00 = 0x0
	// Interrupts from peripheral modules or external interrupt input pins
	DMAC0_DMTMD_DCTG_01 = 0x1

	// DMINT: DMA Interrupt Setting Register
	// Position of DTIE field.
	DMAC0_DMINT_DTIE_Pos = 0x4
	// Bit mask of DTIE field.
	DMAC0_DMINT_DTIE_Msk = 0x10
	// Bit DTIE.
	DMAC0_DMINT_DTIE = 0x10
	// Disable
	DMAC0_DMINT_DTIE_0 = 0x0
	// Enable.
	DMAC0_DMINT_DTIE_1 = 0x1
	// Position of ESIE field.
	DMAC0_DMINT_ESIE_Pos = 0x3
	// Bit mask of ESIE field.
	DMAC0_DMINT_ESIE_Msk = 0x8
	// Bit ESIE.
	DMAC0_DMINT_ESIE = 0x8
	// Disable
	DMAC0_DMINT_ESIE_0 = 0x0
	// Enable.
	DMAC0_DMINT_ESIE_1 = 0x1
	// Position of RPTIE field.
	DMAC0_DMINT_RPTIE_Pos = 0x2
	// Bit mask of RPTIE field.
	DMAC0_DMINT_RPTIE_Msk = 0x4
	// Bit RPTIE.
	DMAC0_DMINT_RPTIE = 0x4
	// Disable
	DMAC0_DMINT_RPTIE_0 = 0x0
	// Enable.
	DMAC0_DMINT_RPTIE_1 = 0x1
	// Position of SARIE field.
	DMAC0_DMINT_SARIE_Pos = 0x1
	// Bit mask of SARIE field.
	DMAC0_DMINT_SARIE_Msk = 0x2
	// Bit SARIE.
	DMAC0_DMINT_SARIE = 0x2
	// Disable
	DMAC0_DMINT_SARIE_0 = 0x0
	// Enable.
	DMAC0_DMINT_SARIE_1 = 0x1
	// Position of DARIE field.
	DMAC0_DMINT_DARIE_Pos = 0x0
	// Bit mask of DARIE field.
	DMAC0_DMINT_DARIE_Msk = 0x1
	// Bit DARIE.
	DMAC0_DMINT_DARIE = 0x1
	// Disable
	DMAC0_DMINT_DARIE_0 = 0x0
	// Enable.
	DMAC0_DMINT_DARIE_1 = 0x1

	// DMAMD: DMA Address Mode Register
	// Position of SM field.
	DMAC0_DMAMD_SM_Pos = 0xe
	// Bit mask of SM field.
	DMAC0_DMAMD_SM_Msk = 0xc000
	// Fixed address
	DMAC0_DMAMD_SM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_SM_01 = 0x1
	// Incremented address
	DMAC0_DMAMD_SM_10 = 0x2
	// Decremented address.
	DMAC0_DMAMD_SM_11 = 0x3
	// Position of SARA field.
	DMAC0_DMAMD_SARA_Pos = 0x8
	// Bit mask of SARA field.
	DMAC0_DMAMD_SARA_Msk = 0x1f00
	// Position of DM field.
	DMAC0_DMAMD_DM_Pos = 0x6
	// Bit mask of DM field.
	DMAC0_DMAMD_DM_Msk = 0xc0
	// Fixed address
	DMAC0_DMAMD_DM_00 = 0x0
	// Offset addition
	DMAC0_DMAMD_DM_01 = 0x1
	// Incremented address
	DMAC0_DMAMD_DM_10 = 0x2
	// Decremented address.
	DMAC0_DMAMD_DM_11 = 0x3
	// Position of DARA field.
	DMAC0_DMAMD_DARA_Pos = 0x0
	// Bit mask of DARA field.
	DMAC0_DMAMD_DARA_Msk = 0x1f

	// DMOFR: DMA Offset Register
	// Position of DMOFR field.
	DMAC0_DMOFR_DMOFR_Pos = 0x0
	// Bit mask of DMOFR field.
	DMAC0_DMOFR_DMOFR_Msk = 0xffffffff

	// DMCNT: DMA Transfer Enable Register
	// Position of DTE field.
	DMAC0_DMCNT_DTE_Pos = 0x0
	// Bit mask of DTE field.
	DMAC0_DMCNT_DTE_Msk = 0x1
	// Bit DTE.
	DMAC0_DMCNT_DTE = 0x1
	// Disable
	DMAC0_DMCNT_DTE_0 = 0x0
	// Enable
	DMAC0_DMCNT_DTE_1 = 0x1

	// DMREQ: DMA Software Start Register
	// Position of CLRS field.
	DMAC0_DMREQ_CLRS_Pos = 0x4
	// Bit mask of CLRS field.
	DMAC0_DMREQ_CLRS_Msk = 0x10
	// Bit CLRS.
	DMAC0_DMREQ_CLRS = 0x10
	// Clear SWREQ bit after DMA transfer is started by software
	DMAC0_DMREQ_CLRS_0 = 0x0
	// Do not clear SWREQ bit after DMA transfer is started by software
	DMAC0_DMREQ_CLRS_1 = 0x1
	// Position of SWREQ field.
	DMAC0_DMREQ_SWREQ_Pos = 0x0
	// Bit mask of SWREQ field.
	DMAC0_DMREQ_SWREQ_Msk = 0x1
	// Bit SWREQ.
	DMAC0_DMREQ_SWREQ = 0x1
	// Do not request DMA transfer
	DMAC0_DMREQ_SWREQ_0 = 0x0
	// Request DMA transfer.
	DMAC0_DMREQ_SWREQ_1 = 0x1

	// DMSTS: DMAC Module Activation Register
	// Position of ACT field.
	DMAC0_DMSTS_ACT_Pos = 0x7
	// Bit mask of ACT field.
	DMAC0_DMSTS_ACT_Msk = 0x80
	// Bit ACT.
	DMAC0_DMSTS_ACT = 0x80
	// DMAC operation is suspended.
	DMAC0_DMSTS_ACT_0 = 0x0
	// DMAC is operating.
	DMAC0_DMSTS_ACT_1 = 0x1
	// Position of DTIF field.
	DMAC0_DMSTS_DTIF_Pos = 0x4
	// Bit mask of DTIF field.
	DMAC0_DMSTS_DTIF_Msk = 0x10
	// Bit DTIF.
	DMAC0_DMSTS_DTIF = 0x10
	// No interrupt occurred
	DMAC0_DMSTS_DTIF_0 = 0x0
	// Interrupt occurred.
	DMAC0_DMSTS_DTIF_1 = 0x1
	// Position of ESIF field.
	DMAC0_DMSTS_ESIF_Pos = 0x0
	// Bit mask of ESIF field.
	DMAC0_DMSTS_ESIF_Msk = 0x1
	// Bit ESIF.
	DMAC0_DMSTS_ESIF = 0x1
	// A transfer escape end interrupt has not been generated.
	DMAC0_DMSTS_ESIF_0 = 0x0
	// A transfer escape end interrupt has been generated.
	DMAC0_DMSTS_ESIF_1 = 0x1
)

// Constants for DMA: DMAC Module Activation
const (
	// DMAST: DMA Module Activation Register
	// Position of DMST field.
	DMA_DMAST_DMST_Pos = 0x0
	// Bit mask of DMST field.
	DMA_DMAST_DMST_Msk = 0x1
	// Bit DMST.
	DMA_DMAST_DMST = 0x1
	// DMAC activation is disabled.
	DMA_DMAST_DMST_0 = 0x0
	// DMAC activation is enabled.
	DMA_DMAST_DMST_1 = 0x1
)

// Constants for DTC: Data Transfer Controller
const (
	// DTCCR: DTC Control Register
	// Position of RRS field.
	DTC_DTCCR_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_RRS = 0x10
	// Do not skip transfer information read
	DTC_DTCCR_RRS_0 = 0x0
	// Skip transfer information read when vector numbers match
	DTC_DTCCR_RRS_1 = 0x1

	// DTCVBR: DTC Vector Base Register
	// Position of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Pos = 0x0
	// Bit mask of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Msk = 0xffffffff

	// DTCST: DTC Module Start Register
	// Position of DTCST field.
	DTC_DTCST_DTCST_Pos = 0x0
	// Bit mask of DTCST field.
	DTC_DTCST_DTCST_Msk = 0x1
	// Bit DTCST.
	DTC_DTCST_DTCST = 0x1
	// DTC module stop
	DTC_DTCST_DTCST_0 = 0x0
	// DTC module start
	DTC_DTCST_DTCST_1 = 0x1

	// DTCSTS: DTC Status Register
	// Position of ACT field.
	DTC_DTCSTS_ACT_Pos = 0xf
	// Bit mask of ACT field.
	DTC_DTCSTS_ACT_Msk = 0x8000
	// Bit ACT.
	DTC_DTCSTS_ACT = 0x8000
	// DTC transfer operation is not in progress.
	DTC_DTCSTS_ACT_0 = 0x0
	// DTC transfer operation is in progress.
	DTC_DTCSTS_ACT_1 = 0x1
	// Position of VECN field.
	DTC_DTCSTS_VECN_Pos = 0x0
	// Bit mask of VECN field.
	DTC_DTCSTS_VECN_Msk = 0xff
)

// Constants for DBG: Debug Function
const (
	// DBGSTR: Debug Status Register
	// Position of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Pos = 0x1d
	// Bit mask of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Msk = 0x20000000
	// Bit CDBGPWRUPACK.
	DBG_DBGSTR_CDBGPWRUPACK = 0x20000000
	// Debug power-up request is not acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_0 = 0x0
	// Debug power-up request is acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_1 = 0x1
	// Position of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Pos = 0x1c
	// Bit mask of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Msk = 0x10000000
	// Bit CDBGPWRUPREQ.
	DBG_DBGSTR_CDBGPWRUPREQ = 0x10000000
	// OCD is not requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_0 = 0x0
	// OCD is requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_1 = 0x1

	// DBGSTOPCR: Debug Stop Control Register
	// Position of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Pos = 0x19
	// Bit mask of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Msk = 0x2000000
	// Bit DBGSTOP_RECCR.
	DBG_DBGSTOPCR_DBGSTOP_RECCR = 0x2000000
	// Enable RAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_0 = 0x0
	// Mask RAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_1 = 0x1
	// Position of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Pos = 0x18
	// Bit mask of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Msk = 0x1000000
	// Bit DBGSTOP_RPER.
	DBG_DBGSTOPCR_DBGSTOP_RPER = 0x1000000
	// Enable RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_0 = 0x0
	// Mask RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_1 = 0x1
	// Position of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Pos = 0x10
	// Bit mask of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Msk = 0x70000
	// Position of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Pos = 0x1
	// Bit mask of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Msk = 0x2
	// Bit DBGSTOP_WDT.
	DBG_DBGSTOPCR_DBGSTOP_WDT = 0x2
	// Mask WDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_WDT_0 = 0x0
	// Enable WDT reset
	DBG_DBGSTOPCR_DBGSTOP_WDT_1 = 0x1
	// Position of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Pos = 0x0
	// Bit mask of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Msk = 0x1
	// Bit DBGSTOP_IWDT.
	DBG_DBGSTOPCR_DBGSTOP_IWDT = 0x1
	// Mask IWDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_IWDT_0 = 0x0
	// Enable IWDT reset
	DBG_DBGSTOPCR_DBGSTOP_IWDT_1 = 0x1

	// TRACECTR: Trace Control Register
	// Position of ENETBFULL field.
	DBG_TRACECTR_ENETBFULL_Pos = 0x1f
	// Bit mask of ENETBFULL field.
	DBG_TRACECTR_ENETBFULL_Msk = 0x80000000
	// Bit ENETBFULL.
	DBG_TRACECTR_ENETBFULL = 0x80000000
	// ETB full does not cause CPU halt
	DBG_TRACECTR_ENETBFULL_0 = 0x0
	// ETB full cause CPU halt
	DBG_TRACECTR_ENETBFULL_1 = 0x1
)

// Constants for TSN: Temperature Sensor
const (
	// TSCR: Temperature Sensor Control Register
	// Position of TSEN field.
	TSN_TSCR_TSEN_Pos = 0x7
	// Bit mask of TSEN field.
	TSN_TSCR_TSEN_Msk = 0x80
	// Bit TSEN.
	TSN_TSCR_TSEN = 0x80
	// Stops the temperature sensor.
	TSN_TSCR_TSEN_0 = 0x0
	// Starts the temperature sensor.
	TSN_TSCR_TSEN_1 = 0x1
	// Position of TSOE field.
	TSN_TSCR_TSOE_Pos = 0x4
	// Bit mask of TSOE field.
	TSN_TSCR_TSOE_Msk = 0x10
	// Bit TSOE.
	TSN_TSCR_TSOE = 0x10
	// Disables output from the temperature sensor to the 12-bit A/D converter.
	TSN_TSCR_TSOE_0 = 0x0
	// Enables output from the temperature sensor to the 12-bit A/D converter.
	TSN_TSCR_TSOE_1 = 0x1
)

// Constants for ACMPHS0: High-Speed Analog Comparator 0
const (
	// CMPCTL: Comparator Control Register
	// Position of HCMPON field.
	ACMPHS0_CMPCTL_HCMPON_Pos = 0x7
	// Bit mask of HCMPON field.
	ACMPHS0_CMPCTL_HCMPON_Msk = 0x80
	// Bit HCMPON.
	ACMPHS0_CMPCTL_HCMPON = 0x80
	// Operation stopped (the comparator outputs a low-level signal)
	ACMPHS0_CMPCTL_HCMPON_0 = 0x0
	// Operation enabled (input to the comparator pins is enabled
	ACMPHS0_CMPCTL_HCMPON_1 = 0x1
	// Position of CDFS field.
	ACMPHS0_CMPCTL_CDFS_Pos = 0x5
	// Bit mask of CDFS field.
	ACMPHS0_CMPCTL_CDFS_Msk = 0x60
	// Noise filter not used.
	ACMPHS0_CMPCTL_CDFS_00 = 0x0
	// Noise filter sampling frequency is 2^3/PCLKB.
	ACMPHS0_CMPCTL_CDFS_01 = 0x1
	// Noise filter sampling frequency is 2^4/PCLKB.
	ACMPHS0_CMPCTL_CDFS_10 = 0x2
	// Noise filter sampling frequency is 2^5/PCLKB.
	ACMPHS0_CMPCTL_CDFS_11 = 0x3
	// Position of CEG field.
	ACMPHS0_CMPCTL_CEG_Pos = 0x3
	// Bit mask of CEG field.
	ACMPHS0_CMPCTL_CEG_Msk = 0x18
	// No edge selection.
	ACMPHS0_CMPCTL_CEG_00 = 0x0
	// Rising edge selection.
	ACMPHS0_CMPCTL_CEG_01 = 0x1
	// Falling edge selection
	ACMPHS0_CMPCTL_CEG_10 = 0x2
	// Both-edge selection
	ACMPHS0_CMPCTL_CEG_11 = 0x3
	// Position of CSTEN field.
	ACMPHS0_CMPCTL_CSTEN_Pos = 0x2
	// Bit mask of CSTEN field.
	ACMPHS0_CMPCTL_CSTEN_Msk = 0x4
	// Bit CSTEN.
	ACMPHS0_CMPCTL_CSTEN = 0x4
	// Output via the Edge selector
	ACMPHS0_CMPCTL_CSTEN_0 = 0x0
	// Direct output
	ACMPHS0_CMPCTL_CSTEN_1 = 0x1
	// Position of COE field.
	ACMPHS0_CMPCTL_COE_Pos = 0x1
	// Bit mask of COE field.
	ACMPHS0_CMPCTL_COE_Msk = 0x2
	// Bit COE.
	ACMPHS0_CMPCTL_COE = 0x2
	// Comparator output disabled (the output signal is low level).
	ACMPHS0_CMPCTL_COE_0 = 0x0
	// Comparator output enabled
	ACMPHS0_CMPCTL_COE_1 = 0x1
	// Position of CINV field.
	ACMPHS0_CMPCTL_CINV_Pos = 0x0
	// Bit mask of CINV field.
	ACMPHS0_CMPCTL_CINV_Msk = 0x1
	// Bit CINV.
	ACMPHS0_CMPCTL_CINV = 0x1
	// Comparator output not inverted
	ACMPHS0_CMPCTL_CINV_0 = 0x0
	// Comparator output inverted
	ACMPHS0_CMPCTL_CINV_1 = 0x1

	// CMPSEL0: Comparator Input Select Register
	// Position of CMPSEL field.
	ACMPHS0_CMPSEL0_CMPSEL_Pos = 0x0
	// Bit mask of CMPSEL field.
	ACMPHS0_CMPSEL0_CMPSEL_Msk = 0xf
	// No input
	ACMPHS0_CMPSEL0_CMPSEL_0000 = 0x0
	// IVCMP0 selected
	ACMPHS0_CMPSEL0_CMPSEL_0001 = 0x1
	// IVCMP1 selected
	ACMPHS0_CMPSEL0_CMPSEL_0010 = 0x2
	// IVCMP2 selected
	ACMPHS0_CMPSEL0_CMPSEL_0100 = 0x4
	// IVCMP3 selected
	ACMPHS0_CMPSEL0_CMPSEL_1000 = 0x8

	// CMPSEL1: Comparator Reference Voltage Select Register
	// Position of CRVS field.
	ACMPHS0_CMPSEL1_CRVS_Pos = 0x0
	// Bit mask of CRVS field.
	ACMPHS0_CMPSEL1_CRVS_Msk = 0xf
	// No reference voltage
	ACMPHS0_CMPSEL1_CRVS_0000 = 0x0
	// IVREF0 selected
	ACMPHS0_CMPSEL1_CRVS_0001 = 0x1
	// IVREF1 selected
	ACMPHS0_CMPSEL1_CRVS_0010 = 0x2
	// IVREF2 selected
	ACMPHS0_CMPSEL1_CRVS_0100 = 0x4
	// IVREF3 selected
	ACMPHS0_CMPSEL1_CRVS_1000 = 0x8

	// CMPMON: Comparator Output Monitor Register
	// Position of CMPMON field.
	ACMPHS0_CMPMON_CMPMON_Pos = 0x0
	// Bit mask of CMPMON field.
	ACMPHS0_CMPMON_CMPMON_Msk = 0x1
	// Bit CMPMON.
	ACMPHS0_CMPMON_CMPMON = 0x1
	// Comparator output Low
	ACMPHS0_CMPMON_CMPMON_0 = 0x0
	// Comparator output High
	ACMPHS0_CMPMON_CMPMON_1 = 0x1

	// CPIOC: Comparator Output Control Register
	// Position of VREFEN field.
	ACMPHS0_CPIOC_VREFEN_Pos = 0x7
	// Bit mask of VREFEN field.
	ACMPHS0_CPIOC_VREFEN_Msk = 0x80
	// Bit VREFEN.
	ACMPHS0_CPIOC_VREFEN = 0x80
	// Internal Vref disable
	ACMPHS0_CPIOC_VREFEN_0 = 0x0
	// Internal Vref enable
	ACMPHS0_CPIOC_VREFEN_1 = 0x1
	// Position of CPOE field.
	ACMPHS0_CPIOC_CPOE_Pos = 0x0
	// Bit mask of CPOE field.
	ACMPHS0_CPIOC_CPOE_Msk = 0x1
	// Bit CPOE.
	ACMPHS0_CPIOC_CPOE = 0x1
	// VCOUT pin output of the comparator is disabled (the output signal is low level).
	ACMPHS0_CPIOC_CPOE_0 = 0x0
	// VCOUT pin output of the comparator is enabled
	ACMPHS0_CPIOC_CPOE_1 = 0x1
)

// Constants for ACMPHS1: High-Speed Analog Comparator 1
const (
	// CMPCTL: Comparator Control Register
	// Position of HCMPON field.
	ACMPHS1_CMPCTL_HCMPON_Pos = 0x7
	// Bit mask of HCMPON field.
	ACMPHS1_CMPCTL_HCMPON_Msk = 0x80
	// Bit HCMPON.
	ACMPHS1_CMPCTL_HCMPON = 0x80
	// Operation stopped (the comparator outputs a low-level signal)
	ACMPHS1_CMPCTL_HCMPON_0 = 0x0
	// Operation enabled (input to the comparator pins is enabled
	ACMPHS1_CMPCTL_HCMPON_1 = 0x1
	// Position of CDFS field.
	ACMPHS1_CMPCTL_CDFS_Pos = 0x5
	// Bit mask of CDFS field.
	ACMPHS1_CMPCTL_CDFS_Msk = 0x60
	// Noise filter not used.
	ACMPHS1_CMPCTL_CDFS_00 = 0x0
	// Noise filter sampling frequency is 2^3/PCLKB.
	ACMPHS1_CMPCTL_CDFS_01 = 0x1
	// Noise filter sampling frequency is 2^4/PCLKB.
	ACMPHS1_CMPCTL_CDFS_10 = 0x2
	// Noise filter sampling frequency is 2^5/PCLKB.
	ACMPHS1_CMPCTL_CDFS_11 = 0x3
	// Position of CEG field.
	ACMPHS1_CMPCTL_CEG_Pos = 0x3
	// Bit mask of CEG field.
	ACMPHS1_CMPCTL_CEG_Msk = 0x18
	// No edge selection.
	ACMPHS1_CMPCTL_CEG_00 = 0x0
	// Rising edge selection.
	ACMPHS1_CMPCTL_CEG_01 = 0x1
	// Falling edge selection
	ACMPHS1_CMPCTL_CEG_10 = 0x2
	// Both-edge selection
	ACMPHS1_CMPCTL_CEG_11 = 0x3
	// Position of CSTEN field.
	ACMPHS1_CMPCTL_CSTEN_Pos = 0x2
	// Bit mask of CSTEN field.
	ACMPHS1_CMPCTL_CSTEN_Msk = 0x4
	// Bit CSTEN.
	ACMPHS1_CMPCTL_CSTEN = 0x4
	// Output via the Edge selector
	ACMPHS1_CMPCTL_CSTEN_0 = 0x0
	// Direct output
	ACMPHS1_CMPCTL_CSTEN_1 = 0x1
	// Position of COE field.
	ACMPHS1_CMPCTL_COE_Pos = 0x1
	// Bit mask of COE field.
	ACMPHS1_CMPCTL_COE_Msk = 0x2
	// Bit COE.
	ACMPHS1_CMPCTL_COE = 0x2
	// Comparator output disabled (the output signal is low level).
	ACMPHS1_CMPCTL_COE_0 = 0x0
	// Comparator output enabled
	ACMPHS1_CMPCTL_COE_1 = 0x1
	// Position of CINV field.
	ACMPHS1_CMPCTL_CINV_Pos = 0x0
	// Bit mask of CINV field.
	ACMPHS1_CMPCTL_CINV_Msk = 0x1
	// Bit CINV.
	ACMPHS1_CMPCTL_CINV = 0x1
	// Comparator output not inverted
	ACMPHS1_CMPCTL_CINV_0 = 0x0
	// Comparator output inverted
	ACMPHS1_CMPCTL_CINV_1 = 0x1

	// CMPSEL0: Comparator Input Select Register
	// Position of CMPSEL field.
	ACMPHS1_CMPSEL0_CMPSEL_Pos = 0x0
	// Bit mask of CMPSEL field.
	ACMPHS1_CMPSEL0_CMPSEL_Msk = 0xf
	// No input
	ACMPHS1_CMPSEL0_CMPSEL_0000 = 0x0
	// IVCMP0 selected
	ACMPHS1_CMPSEL0_CMPSEL_0001 = 0x1
	// IVCMP1 selected
	ACMPHS1_CMPSEL0_CMPSEL_0010 = 0x2
	// IVCMP2 selected
	ACMPHS1_CMPSEL0_CMPSEL_0100 = 0x4
	// IVCMP3 selected
	ACMPHS1_CMPSEL0_CMPSEL_1000 = 0x8

	// CMPSEL1: Comparator Reference Voltage Select Register
	// Position of CRVS field.
	ACMPHS1_CMPSEL1_CRVS_Pos = 0x0
	// Bit mask of CRVS field.
	ACMPHS1_CMPSEL1_CRVS_Msk = 0xf
	// No reference voltage
	ACMPHS1_CMPSEL1_CRVS_0000 = 0x0
	// IVREF0 selected
	ACMPHS1_CMPSEL1_CRVS_0001 = 0x1
	// IVREF1 selected
	ACMPHS1_CMPSEL1_CRVS_0010 = 0x2
	// IVREF2 selected
	ACMPHS1_CMPSEL1_CRVS_0100 = 0x4
	// IVREF3 selected
	ACMPHS1_CMPSEL1_CRVS_1000 = 0x8

	// CMPMON: Comparator Output Monitor Register
	// Position of CMPMON field.
	ACMPHS1_CMPMON_CMPMON_Pos = 0x0
	// Bit mask of CMPMON field.
	ACMPHS1_CMPMON_CMPMON_Msk = 0x1
	// Bit CMPMON.
	ACMPHS1_CMPMON_CMPMON = 0x1
	// Comparator output Low
	ACMPHS1_CMPMON_CMPMON_0 = 0x0
	// Comparator output High
	ACMPHS1_CMPMON_CMPMON_1 = 0x1

	// CPIOC: Comparator Output Control Register
	// Position of VREFEN field.
	ACMPHS1_CPIOC_VREFEN_Pos = 0x7
	// Bit mask of VREFEN field.
	ACMPHS1_CPIOC_VREFEN_Msk = 0x80
	// Bit VREFEN.
	ACMPHS1_CPIOC_VREFEN = 0x80
	// Internal Vref disable
	ACMPHS1_CPIOC_VREFEN_0 = 0x0
	// Internal Vref enable
	ACMPHS1_CPIOC_VREFEN_1 = 0x1
	// Position of CPOE field.
	ACMPHS1_CPIOC_CPOE_Pos = 0x0
	// Bit mask of CPOE field.
	ACMPHS1_CPIOC_CPOE_Msk = 0x1
	// Bit CPOE.
	ACMPHS1_CPIOC_CPOE = 0x1
	// VCOUT pin output of the comparator is disabled (the output signal is low level).
	ACMPHS1_CPIOC_CPOE_0 = 0x0
	// VCOUT pin output of the comparator is enabled
	ACMPHS1_CPIOC_CPOE_1 = 0x1
)

// Constants for ELC: Event Link Controller
const (
	// ELCR: Event Link Controller Register
	// Position of ELCON field.
	ELC_ELCR_ELCON_Pos = 0x7
	// Bit mask of ELCON field.
	ELC_ELCR_ELCON_Msk = 0x80
	// Bit ELCON.
	ELC_ELCR_ELCON = 0x80
	// Disable ELC function
	ELC_ELCR_ELCON_0 = 0x0
	// Enable ELC function.
	ELC_ELCR_ELCON_1 = 0x1

	// ELSEGR0: Event Link Software Event Generation Register %s
	// Position of WI field.
	ELC_ELSEGR_WI_Pos = 0x7
	// Bit mask of WI field.
	ELC_ELSEGR_WI_Msk = 0x80
	// Bit WI.
	ELC_ELSEGR_WI = 0x80
	// Enable writes to ELSEGR register
	ELC_ELSEGR_WI_0 = 0x0
	// Disable writes to ELSEGR register.
	ELC_ELSEGR_WI_1 = 0x1
	// Position of WE field.
	ELC_ELSEGR_WE_Pos = 0x6
	// Bit mask of WE field.
	ELC_ELSEGR_WE_Msk = 0x40
	// Bit WE.
	ELC_ELSEGR_WE = 0x40
	// Disable writes to SEG bit
	ELC_ELSEGR_WE_0 = 0x0
	// Enable writes to SEG bit
	ELC_ELSEGR_WE_1 = 0x1
	// Position of SEG field.
	ELC_ELSEGR_SEG_Pos = 0x0
	// Bit mask of SEG field.
	ELC_ELSEGR_SEG_Msk = 0x1
	// Bit SEG.
	ELC_ELSEGR_SEG = 0x1
	// Normal operation
	ELC_ELSEGR_SEG_0 = 0x0
	// Generate a software event
	ELC_ELSEGR_SEG_1 = 0x1

	// ELSR0: Event Link Setting Register %s
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0x1ff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x000 = 0x0
)

// Constants for WDT: Watchdog Timer
const (
	// WDTRR: WDT Refresh Register
	// Position of WDTRR field.
	WDT_WDTRR_WDTRR_Pos = 0x0
	// Bit mask of WDTRR field.
	WDT_WDTRR_WDTRR_Msk = 0xff

	// WDTCR: WDT Control Register
	// Position of RPSS field.
	WDT_WDTCR_RPSS_Pos = 0xc
	// Bit mask of RPSS field.
	WDT_WDTCR_RPSS_Msk = 0x3000
	// 25 percent
	WDT_WDTCR_RPSS_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPSS_01 = 0x1
	// 75 percent
	WDT_WDTCR_RPSS_10 = 0x2
	// 100 percent (window start position is not specified)
	WDT_WDTCR_RPSS_11 = 0x3
	// Position of RPES field.
	WDT_WDTCR_RPES_Pos = 0x8
	// Bit mask of RPES field.
	WDT_WDTCR_RPES_Msk = 0x300
	// 75 percent
	WDT_WDTCR_RPES_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPES_01 = 0x1
	// 25 percent
	WDT_WDTCR_RPES_10 = 0x2
	// 0 percent (window end position is not specified)
	WDT_WDTCR_RPES_11 = 0x3
	// Position of CKS field.
	WDT_WDTCR_CKS_Pos = 0x4
	// Bit mask of CKS field.
	WDT_WDTCR_CKS_Msk = 0xf0
	// PCLK/4
	WDT_WDTCR_CKS_0001 = 0x1
	// PCLK/64
	WDT_WDTCR_CKS_0100 = 0x4
	// PCLK/128
	WDT_WDTCR_CKS_1111 = 0xf
	// PCLK/512
	WDT_WDTCR_CKS_0110 = 0x6
	// PCLK/2048
	WDT_WDTCR_CKS_0111 = 0x7
	// PCLK/8192
	WDT_WDTCR_CKS_1000 = 0x8
	// Position of TOPS field.
	WDT_WDTCR_TOPS_Pos = 0x0
	// Bit mask of TOPS field.
	WDT_WDTCR_TOPS_Msk = 0x3
	// 1,024 cycles (03FFh)
	WDT_WDTCR_TOPS_00 = 0x0
	// 4,096 cycles (0FFFh)
	WDT_WDTCR_TOPS_01 = 0x1
	// 8,192 cycles (1FFFh)
	WDT_WDTCR_TOPS_10 = 0x2
	// 16,384 cycles (3FFFh)
	WDT_WDTCR_TOPS_11 = 0x3

	// WDTSR: WDT Status Register
	// Position of REFEF field.
	WDT_WDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	WDT_WDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	WDT_WDTSR_REFEF = 0x8000
	// No refresh error occurred
	WDT_WDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	WDT_WDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	WDT_WDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	WDT_WDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	WDT_WDTSR_UNDFF = 0x4000
	// No underflow occurred
	WDT_WDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	WDT_WDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	WDT_WDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	WDT_WDTSR_CNTVAL_Msk = 0x3fff

	// WDTRCR: WDT Reset Control Register
	// Position of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Pos = 0x7
	// Bit mask of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Msk = 0x80
	// Bit RSTIRQS.
	WDT_WDTRCR_RSTIRQS = 0x80
	// Non-maskable interrupt request or interrupt request output is enabled
	WDT_WDTRCR_RSTIRQS_0 = 0x0
	// Reset output is enabled.
	WDT_WDTRCR_RSTIRQS_1 = 0x1

	// WDTCSTPR: WDT Count Stop Control Register
	// Position of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Pos = 0x7
	// Bit mask of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Msk = 0x80
	// Bit SLCSTP.
	WDT_WDTCSTPR_SLCSTP = 0x80
	// Count stop is disabled.
	WDT_WDTCSTPR_SLCSTP_0 = 0x0
	// Count is stopped at a transition to sleep mode.
	WDT_WDTCSTPR_SLCSTP_1 = 0x1
)

// Constants for IWDT: Independent Watchdog Timer
const (
	// IWDTRR: IWDT Refresh Register
	// Position of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Pos = 0x0
	// Bit mask of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Msk = 0xff

	// IWDTSR: IWDT Status Register
	// Position of REFEF field.
	IWDT_IWDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	IWDT_IWDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	IWDT_IWDTSR_REFEF = 0x8000
	// Refresh error not occurred
	IWDT_IWDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	IWDT_IWDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	IWDT_IWDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	IWDT_IWDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	IWDT_IWDTSR_UNDFF = 0x4000
	// Underflow not occurred
	IWDT_IWDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	IWDT_IWDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Msk = 0x3fff
)

// Constants for KINT: Key Interrupt Function
const (
	// KRCTL: KEY Return Control Register
	// Position of KRMD field.
	KINT_KRCTL_KRMD_Pos = 0x7
	// Bit mask of KRMD field.
	KINT_KRCTL_KRMD_Msk = 0x80
	// Bit KRMD.
	KINT_KRCTL_KRMD = 0x80
	// Do not use key interrupt flags
	KINT_KRCTL_KRMD_0 = 0x0
	// Use key interrupt flags.
	KINT_KRCTL_KRMD_1 = 0x1
	// Position of KREG field.
	KINT_KRCTL_KREG_Pos = 0x0
	// Bit mask of KREG field.
	KINT_KRCTL_KREG_Msk = 0x1
	// Bit KREG.
	KINT_KRCTL_KREG = 0x1
	// Falling edge
	KINT_KRCTL_KREG_0 = 0x0
	// Rising edge
	KINT_KRCTL_KREG_1 = 0x1

	// KRF: KEY Return Flag Register
	// Position of KRF7 field.
	KINT_KRF_KRF7_Pos = 0x7
	// Bit mask of KRF7 field.
	KINT_KRF_KRF7_Msk = 0x80
	// Bit KRF7.
	KINT_KRF_KRF7 = 0x80
	// No interrupt detected
	KINT_KRF_KRF7_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF7_1 = 0x1
	// Position of KRF6 field.
	KINT_KRF_KRF6_Pos = 0x6
	// Bit mask of KRF6 field.
	KINT_KRF_KRF6_Msk = 0x40
	// Bit KRF6.
	KINT_KRF_KRF6 = 0x40
	// No interrupt detected
	KINT_KRF_KRF6_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF6_1 = 0x1
	// Position of KRF5 field.
	KINT_KRF_KRF5_Pos = 0x5
	// Bit mask of KRF5 field.
	KINT_KRF_KRF5_Msk = 0x20
	// Bit KRF5.
	KINT_KRF_KRF5 = 0x20
	// No interrupt detected
	KINT_KRF_KRF5_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF5_1 = 0x1
	// Position of KRF4 field.
	KINT_KRF_KRF4_Pos = 0x4
	// Bit mask of KRF4 field.
	KINT_KRF_KRF4_Msk = 0x10
	// Bit KRF4.
	KINT_KRF_KRF4 = 0x10
	// No interrupt detected
	KINT_KRF_KRF4_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF4_1 = 0x1
	// Position of KRF3 field.
	KINT_KRF_KRF3_Pos = 0x3
	// Bit mask of KRF3 field.
	KINT_KRF_KRF3_Msk = 0x8
	// Bit KRF3.
	KINT_KRF_KRF3 = 0x8
	// No interrupt detected
	KINT_KRF_KRF3_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF3_1 = 0x1
	// Position of KRF2 field.
	KINT_KRF_KRF2_Pos = 0x2
	// Bit mask of KRF2 field.
	KINT_KRF_KRF2_Msk = 0x4
	// Bit KRF2.
	KINT_KRF_KRF2 = 0x4
	// No interrupt detected
	KINT_KRF_KRF2_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF2_1 = 0x1
	// Position of KRF1 field.
	KINT_KRF_KRF1_Pos = 0x1
	// Bit mask of KRF1 field.
	KINT_KRF_KRF1_Msk = 0x2
	// Bit KRF1.
	KINT_KRF_KRF1 = 0x2
	// No interrupt detected
	KINT_KRF_KRF1_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF1_1 = 0x1
	// Position of KRF0 field.
	KINT_KRF_KRF0_Pos = 0x0
	// Bit mask of KRF0 field.
	KINT_KRF_KRF0_Msk = 0x1
	// Bit KRF0.
	KINT_KRF_KRF0 = 0x1
	// No interrupt detected
	KINT_KRF_KRF0_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF0_1 = 0x1

	// KRM: KEY Return Mode Register
	// Position of KRM7 field.
	KINT_KRM_KRM7_Pos = 0x7
	// Bit mask of KRM7 field.
	KINT_KRM_KRM7_Msk = 0x80
	// Bit KRM7.
	KINT_KRM_KRM7 = 0x80
	// Does not detect key interrupt signal
	KINT_KRM_KRM7_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM7_1 = 0x1
	// Position of KRM6 field.
	KINT_KRM_KRM6_Pos = 0x6
	// Bit mask of KRM6 field.
	KINT_KRM_KRM6_Msk = 0x40
	// Bit KRM6.
	KINT_KRM_KRM6 = 0x40
	// Does not detect key interrupt signal
	KINT_KRM_KRM6_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM6_1 = 0x1
	// Position of KRM5 field.
	KINT_KRM_KRM5_Pos = 0x5
	// Bit mask of KRM5 field.
	KINT_KRM_KRM5_Msk = 0x20
	// Bit KRM5.
	KINT_KRM_KRM5 = 0x20
	// Does not detect key interrupt signal
	KINT_KRM_KRM5_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM5_1 = 0x1
	// Position of KRM4 field.
	KINT_KRM_KRM4_Pos = 0x4
	// Bit mask of KRM4 field.
	KINT_KRM_KRM4_Msk = 0x10
	// Bit KRM4.
	KINT_KRM_KRM4 = 0x10
	// Does not detect key interrupt signal
	KINT_KRM_KRM4_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM4_1 = 0x1
	// Position of KRM3 field.
	KINT_KRM_KRM3_Pos = 0x3
	// Bit mask of KRM3 field.
	KINT_KRM_KRM3_Msk = 0x8
	// Bit KRM3.
	KINT_KRM_KRM3 = 0x8
	// Does not detect key interrupt signal
	KINT_KRM_KRM3_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM3_1 = 0x1
	// Position of KRM2 field.
	KINT_KRM_KRM2_Pos = 0x2
	// Bit mask of KRM2 field.
	KINT_KRM_KRM2_Msk = 0x4
	// Bit KRM2.
	KINT_KRM_KRM2 = 0x4
	// Does not detect key interrupt signal
	KINT_KRM_KRM2_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM2_1 = 0x1
	// Position of KRM1 field.
	KINT_KRM_KRM1_Pos = 0x1
	// Bit mask of KRM1 field.
	KINT_KRM_KRM1_Msk = 0x2
	// Bit KRM1.
	KINT_KRM_KRM1 = 0x2
	// Does not detect key interrupt signal
	KINT_KRM_KRM1_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM1_1 = 0x1
	// Position of KRM0 field.
	KINT_KRM_KRM0_Pos = 0x0
	// Bit mask of KRM0 field.
	KINT_KRM_KRM0_Msk = 0x1
	// Bit KRM0.
	KINT_KRM_KRM0 = 0x1
	// Does not detect key interrupt signal
	KINT_KRM_KRM0_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM0_1 = 0x1
)

// Constants for DOC: Data Operation Circuit
const (
	// DOCR: DOC Control Register
	// Position of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Pos = 0x6
	// Bit mask of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Msk = 0x40
	// Bit DOPCFCL.
	DOC_DOCR_DOPCFCL = 0x40
	// Maintains the DOPCF flag state.
	DOC_DOCR_DOPCFCL_0 = 0x0
	// Clears the DOPCF flag.
	DOC_DOCR_DOPCFCL_1 = 0x1
	// Position of DOPCF field.
	DOC_DOCR_DOPCF_Pos = 0x5
	// Bit mask of DOPCF field.
	DOC_DOCR_DOPCF_Msk = 0x20
	// Bit DOPCF.
	DOC_DOCR_DOPCF = 0x20
	// Position of DCSEL field.
	DOC_DOCR_DCSEL_Pos = 0x2
	// Bit mask of DCSEL field.
	DOC_DOCR_DCSEL_Msk = 0x4
	// Bit DCSEL.
	DOC_DOCR_DCSEL = 0x4
	// DOPCF is set when data mismatch is detected.
	DOC_DOCR_DCSEL_0 = 0x0
	// DOPCF is set when data match is detected.
	DOC_DOCR_DCSEL_1 = 0x1
	// Position of OMS field.
	DOC_DOCR_OMS_Pos = 0x0
	// Bit mask of OMS field.
	DOC_DOCR_OMS_Msk = 0x3
	// Data comparison mode
	DOC_DOCR_OMS_00 = 0x0
	// Data addition mode
	DOC_DOCR_OMS_01 = 0x1
	// Data subtraction mode
	DOC_DOCR_OMS_10 = 0x2
	// Setting prohibited
	DOC_DOCR_OMS_11 = 0x3

	// DODIR: DOC Data Input Register
	// Position of DODIR field.
	DOC_DODIR_DODIR_Pos = 0x0
	// Bit mask of DODIR field.
	DOC_DODIR_DODIR_Msk = 0xffff

	// DODSR: DOC Data Setting Register
	// Position of DODSR field.
	DOC_DODSR_DODSR_Pos = 0x0
	// Bit mask of DODSR field.
	DOC_DODSR_DODSR_Msk = 0xffff
)

// Constants for CAC: Clock Frequency Accuracy Measurement Circuit
const (
	// CACR0: CAC Control Register 0
	// Position of CFME field.
	CAC_CACR0_CFME_Pos = 0x0
	// Bit mask of CFME field.
	CAC_CACR0_CFME_Msk = 0x1
	// Bit CFME.
	CAC_CACR0_CFME = 0x1
	// Disable
	CAC_CACR0_CFME_0 = 0x0
	// Enable
	CAC_CACR0_CFME_1 = 0x1

	// CACR1: CAC Control Register 1
	// Position of EDGES field.
	CAC_CACR1_EDGES_Pos = 0x6
	// Bit mask of EDGES field.
	CAC_CACR1_EDGES_Msk = 0xc0
	// Rising edge
	CAC_CACR1_EDGES_00 = 0x0
	// Falling edge
	CAC_CACR1_EDGES_01 = 0x1
	// Both rising and falling edges
	CAC_CACR1_EDGES_10 = 0x2
	// Setting prohibited
	CAC_CACR1_EDGES_11 = 0x3
	// Position of TCSS field.
	CAC_CACR1_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	CAC_CACR1_TCSS_Msk = 0x30
	// No division
	CAC_CACR1_TCSS_00 = 0x0
	// x 1/4 clock
	CAC_CACR1_TCSS_01 = 0x1
	// x 1/8 clock
	CAC_CACR1_TCSS_10 = 0x2
	// x 1/32 clock
	CAC_CACR1_TCSS_11 = 0x3
	// Position of FMCS field.
	CAC_CACR1_FMCS_Pos = 0x1
	// Bit mask of FMCS field.
	CAC_CACR1_FMCS_Msk = 0xe
	// Main clock
	CAC_CACR1_FMCS_000 = 0x0
	// Sub-clock
	CAC_CACR1_FMCS_001 = 0x1
	// HOCO clock
	CAC_CACR1_FMCS_010 = 0x2
	// MOCO clock
	CAC_CACR1_FMCS_011 = 0x3
	// LOCO clock
	CAC_CACR1_FMCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR1_FMCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR1_FMCS_110 = 0x6
	// Setting prohibited
	CAC_CACR1_FMCS_111 = 0x7
	// Position of CACREFE field.
	CAC_CACR1_CACREFE_Pos = 0x0
	// Bit mask of CACREFE field.
	CAC_CACR1_CACREFE_Msk = 0x1
	// Bit CACREFE.
	CAC_CACR1_CACREFE = 0x1
	// Disable
	CAC_CACR1_CACREFE_0 = 0x0
	// Enable
	CAC_CACR1_CACREFE_1 = 0x1

	// CACR2: CAC Control Register 2
	// Position of DFS field.
	CAC_CACR2_DFS_Pos = 0x6
	// Bit mask of DFS field.
	CAC_CACR2_DFS_Msk = 0xc0
	// Digital filtering is disabled.
	CAC_CACR2_DFS_00 = 0x0
	// The sampling clock for the digital filter is the frequency measuring clock.
	CAC_CACR2_DFS_01 = 0x1
	// The sampling clock for the digital filter is the frequency measuring clock divided by 4.
	CAC_CACR2_DFS_10 = 0x2
	// The sampling clock for the digital filter is the frequency measuring clock divided by 16.
	CAC_CACR2_DFS_11 = 0x3
	// Position of RCDS field.
	CAC_CACR2_RCDS_Pos = 0x4
	// Bit mask of RCDS field.
	CAC_CACR2_RCDS_Msk = 0x30
	// 1/32 clock
	CAC_CACR2_RCDS_00 = 0x0
	// 1/128 clock
	CAC_CACR2_RCDS_01 = 0x1
	// 1/1024 clock
	CAC_CACR2_RCDS_10 = 0x2
	// 1/8192 clock
	CAC_CACR2_RCDS_11 = 0x3
	// Position of RSCS field.
	CAC_CACR2_RSCS_Pos = 0x1
	// Bit mask of RSCS field.
	CAC_CACR2_RSCS_Msk = 0xe
	// Main clock
	CAC_CACR2_RSCS_000 = 0x0
	// Sub-clock
	CAC_CACR2_RSCS_001 = 0x1
	// HOCO clock
	CAC_CACR2_RSCS_010 = 0x2
	// MOCO clock
	CAC_CACR2_RSCS_011 = 0x3
	// LOCO clock
	CAC_CACR2_RSCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR2_RSCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR2_RSCS_110 = 0x6
	// Setting prohibited
	CAC_CACR2_RSCS_111 = 0x7
	// Position of RPS field.
	CAC_CACR2_RPS_Pos = 0x0
	// Bit mask of RPS field.
	CAC_CACR2_RPS_Msk = 0x1
	// Bit RPS.
	CAC_CACR2_RPS = 0x1
	// CACREF pin input
	CAC_CACR2_RPS_0 = 0x0
	// Internal clock (internally generated signal)
	CAC_CACR2_RPS_1 = 0x1

	// CAICR: CAC Interrupt Control Register
	// Position of OVFFCL field.
	CAC_CAICR_OVFFCL_Pos = 0x6
	// Bit mask of OVFFCL field.
	CAC_CAICR_OVFFCL_Msk = 0x40
	// Bit OVFFCL.
	CAC_CAICR_OVFFCL = 0x40
	// No effect on operations
	CAC_CAICR_OVFFCL_0 = 0x0
	// Clears the OVFF flag
	CAC_CAICR_OVFFCL_1 = 0x1
	// Position of MENDFCL field.
	CAC_CAICR_MENDFCL_Pos = 0x5
	// Bit mask of MENDFCL field.
	CAC_CAICR_MENDFCL_Msk = 0x20
	// Bit MENDFCL.
	CAC_CAICR_MENDFCL = 0x20
	// No effect on operations
	CAC_CAICR_MENDFCL_0 = 0x0
	// Clears the MENDF flag
	CAC_CAICR_MENDFCL_1 = 0x1
	// Position of FERRFCL field.
	CAC_CAICR_FERRFCL_Pos = 0x4
	// Bit mask of FERRFCL field.
	CAC_CAICR_FERRFCL_Msk = 0x10
	// Bit FERRFCL.
	CAC_CAICR_FERRFCL = 0x10
	// No effect on operations
	CAC_CAICR_FERRFCL_0 = 0x0
	// Clears the FERRF flag
	CAC_CAICR_FERRFCL_1 = 0x1
	// Position of OVFIE field.
	CAC_CAICR_OVFIE_Pos = 0x2
	// Bit mask of OVFIE field.
	CAC_CAICR_OVFIE_Msk = 0x4
	// Bit OVFIE.
	CAC_CAICR_OVFIE = 0x4
	// Disable
	CAC_CAICR_OVFIE_0 = 0x0
	// Enable
	CAC_CAICR_OVFIE_1 = 0x1
	// Position of MENDIE field.
	CAC_CAICR_MENDIE_Pos = 0x1
	// Bit mask of MENDIE field.
	CAC_CAICR_MENDIE_Msk = 0x2
	// Bit MENDIE.
	CAC_CAICR_MENDIE = 0x2
	// Disable
	CAC_CAICR_MENDIE_0 = 0x0
	// Enable
	CAC_CAICR_MENDIE_1 = 0x1
	// Position of FERRIE field.
	CAC_CAICR_FERRIE_Pos = 0x0
	// Bit mask of FERRIE field.
	CAC_CAICR_FERRIE_Msk = 0x1
	// Bit FERRIE.
	CAC_CAICR_FERRIE = 0x1
	// Disable
	CAC_CAICR_FERRIE_0 = 0x0
	// Enable
	CAC_CAICR_FERRIE_1 = 0x1

	// CASTR: CAC Status Register
	// Position of OVFF field.
	CAC_CASTR_OVFF_Pos = 0x2
	// Bit mask of OVFF field.
	CAC_CASTR_OVFF_Msk = 0x4
	// Bit OVFF.
	CAC_CASTR_OVFF = 0x4
	// The counter has not overflowed.
	CAC_CASTR_OVFF_0 = 0x0
	// The counter has overflowed.
	CAC_CASTR_OVFF_1 = 0x1
	// Position of MENDF field.
	CAC_CASTR_MENDF_Pos = 0x1
	// Bit mask of MENDF field.
	CAC_CASTR_MENDF_Msk = 0x2
	// Bit MENDF.
	CAC_CASTR_MENDF = 0x2
	// Measurement is in progress.
	CAC_CASTR_MENDF_0 = 0x0
	// Measurement has ended.
	CAC_CASTR_MENDF_1 = 0x1
	// Position of FERRF field.
	CAC_CASTR_FERRF_Pos = 0x0
	// Bit mask of FERRF field.
	CAC_CASTR_FERRF_Msk = 0x1
	// Bit FERRF.
	CAC_CASTR_FERRF = 0x1
	// The clock frequency is within the range corresponding to the settings.
	CAC_CASTR_FERRF_0 = 0x0
	// The clock frequency has deviated beyond the range corresponding to the settings (frequency error).
	CAC_CASTR_FERRF_1 = 0x1

	// CAULVR: CAC Upper-Limit Value Setting Register
	// Position of CAULVR field.
	CAC_CAULVR_CAULVR_Pos = 0x0
	// Bit mask of CAULVR field.
	CAC_CAULVR_CAULVR_Msk = 0xffff

	// CALLVR: CAC Lower-Limit Value Setting Register
	// Position of CALLVR field.
	CAC_CALLVR_CALLVR_Pos = 0x0
	// Bit mask of CALLVR field.
	CAC_CALLVR_CALLVR_Msk = 0xffff

	// CACNTBR: CAC Counter Buffer Register
	// Position of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Pos = 0x0
	// Bit mask of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Msk = 0xffff
)
