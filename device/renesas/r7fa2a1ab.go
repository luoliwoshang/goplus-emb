// Automatically generated file. DO NOT EDIT.
// Generated by gen-device-svd.go from R7FA2A1AB.svd, see https://github.com/cmsis-svd/cmsis-svd-data/tree/master/data/Renesas

//go:build renesas && r7fa2a1ab

/*
// ARM 32-bit Cortex-M23 Microcontroller based device, CPU clock up to 48MHz, etc.
*/

package renesas

import (
	"runtime/volatile"
	"unsafe"
)

// Some information about this device.
const (
	Device       = "R7FA2A1AB"
	CPU          = "CM23"
	FPUPresent   = false
	NVICPrioBits = 2
)

// Interrupt numbers.
const (
	// Interrupt Controller
	IRQ_IEL0 = 0

	// Interrupt Controller
	IRQ_IEL1 = 1

	// Interrupt Controller
	IRQ_IEL2 = 2

	// Interrupt Controller
	IRQ_IEL3 = 3

	// Interrupt Controller
	IRQ_IEL4 = 4

	// Interrupt Controller
	IRQ_IEL5 = 5

	// Interrupt Controller
	IRQ_IEL6 = 6

	// Interrupt Controller
	IRQ_IEL7 = 7

	// Interrupt Controller
	IRQ_IEL8 = 8

	// Interrupt Controller
	IRQ_IEL9 = 9

	// Interrupt Controller
	IRQ_IEL10 = 10

	// Interrupt Controller
	IRQ_IEL11 = 11

	// Interrupt Controller
	IRQ_IEL12 = 12

	// Interrupt Controller
	IRQ_IEL13 = 13

	// Interrupt Controller
	IRQ_IEL14 = 14

	// Interrupt Controller
	IRQ_IEL15 = 15

	// Interrupt Controller
	IRQ_IEL16 = 16

	// Interrupt Controller
	IRQ_IEL17 = 17

	// Interrupt Controller
	IRQ_IEL18 = 18

	// Interrupt Controller
	IRQ_IEL19 = 19

	// Interrupt Controller
	IRQ_IEL20 = 20

	// Interrupt Controller
	IRQ_IEL21 = 21

	// Interrupt Controller
	IRQ_IEL22 = 22

	// Interrupt Controller
	IRQ_IEL23 = 23

	// Interrupt Controller
	IRQ_IEL24 = 24

	// Interrupt Controller
	IRQ_IEL25 = 25

	// Interrupt Controller
	IRQ_IEL26 = 26

	// Interrupt Controller
	IRQ_IEL27 = 27

	// Interrupt Controller
	IRQ_IEL28 = 28

	// Interrupt Controller
	IRQ_IEL29 = 29

	// Interrupt Controller
	IRQ_IEL30 = 30

	// Interrupt Controller
	IRQ_IEL31 = 31

	// Highest interrupt number on this device.
	IRQ_max = 31
)

// Pseudo function call that is replaced by the compiler with the actual
// functions registered through interrupt.New.
//
//go:linkname callHandlers runtime/interrupt.callHandlers
func callHandlers(num int)

//export IEL0_IRQHandler
func interruptIEL0() {
	callHandlers(IRQ_IEL0)
}

//export IEL1_IRQHandler
func interruptIEL1() {
	callHandlers(IRQ_IEL1)
}

//export IEL2_IRQHandler
func interruptIEL2() {
	callHandlers(IRQ_IEL2)
}

//export IEL3_IRQHandler
func interruptIEL3() {
	callHandlers(IRQ_IEL3)
}

//export IEL4_IRQHandler
func interruptIEL4() {
	callHandlers(IRQ_IEL4)
}

//export IEL5_IRQHandler
func interruptIEL5() {
	callHandlers(IRQ_IEL5)
}

//export IEL6_IRQHandler
func interruptIEL6() {
	callHandlers(IRQ_IEL6)
}

//export IEL7_IRQHandler
func interruptIEL7() {
	callHandlers(IRQ_IEL7)
}

//export IEL8_IRQHandler
func interruptIEL8() {
	callHandlers(IRQ_IEL8)
}

//export IEL9_IRQHandler
func interruptIEL9() {
	callHandlers(IRQ_IEL9)
}

//export IEL10_IRQHandler
func interruptIEL10() {
	callHandlers(IRQ_IEL10)
}

//export IEL11_IRQHandler
func interruptIEL11() {
	callHandlers(IRQ_IEL11)
}

//export IEL12_IRQHandler
func interruptIEL12() {
	callHandlers(IRQ_IEL12)
}

//export IEL13_IRQHandler
func interruptIEL13() {
	callHandlers(IRQ_IEL13)
}

//export IEL14_IRQHandler
func interruptIEL14() {
	callHandlers(IRQ_IEL14)
}

//export IEL15_IRQHandler
func interruptIEL15() {
	callHandlers(IRQ_IEL15)
}

//export IEL16_IRQHandler
func interruptIEL16() {
	callHandlers(IRQ_IEL16)
}

//export IEL17_IRQHandler
func interruptIEL17() {
	callHandlers(IRQ_IEL17)
}

//export IEL18_IRQHandler
func interruptIEL18() {
	callHandlers(IRQ_IEL18)
}

//export IEL19_IRQHandler
func interruptIEL19() {
	callHandlers(IRQ_IEL19)
}

//export IEL20_IRQHandler
func interruptIEL20() {
	callHandlers(IRQ_IEL20)
}

//export IEL21_IRQHandler
func interruptIEL21() {
	callHandlers(IRQ_IEL21)
}

//export IEL22_IRQHandler
func interruptIEL22() {
	callHandlers(IRQ_IEL22)
}

//export IEL23_IRQHandler
func interruptIEL23() {
	callHandlers(IRQ_IEL23)
}

//export IEL24_IRQHandler
func interruptIEL24() {
	callHandlers(IRQ_IEL24)
}

//export IEL25_IRQHandler
func interruptIEL25() {
	callHandlers(IRQ_IEL25)
}

//export IEL26_IRQHandler
func interruptIEL26() {
	callHandlers(IRQ_IEL26)
}

//export IEL27_IRQHandler
func interruptIEL27() {
	callHandlers(IRQ_IEL27)
}

//export IEL28_IRQHandler
func interruptIEL28() {
	callHandlers(IRQ_IEL28)
}

//export IEL29_IRQHandler
func interruptIEL29() {
	callHandlers(IRQ_IEL29)
}

//export IEL30_IRQHandler
func interruptIEL30() {
	callHandlers(IRQ_IEL30)
}

//export IEL31_IRQHandler
func interruptIEL31() {
	callHandlers(IRQ_IEL31)
}

// Peripherals.
var (
	// High-Speed Analog Comparator 0
	ACMPHS0 = (*ACMPHS0_Type)(unsafe.Pointer(uintptr(0x40085000)))

	// Low-Power Analog Comparator
	ACMPLP = (*ACMPLP_Type)(unsafe.Pointer(uintptr(0x40085e00)))

	// 16-bit A/D Converter
	ADC160 = (*ADC160_Type)(unsafe.Pointer(uintptr(0x4005c000)))

	// Capacitive Touch Sensing Unit
	CTSU = (*CTSU_Type)(unsafe.Pointer(uintptr(0x40081000)))

	// OperationalAmplifier
	OPAMP = (*OPAMP_Type)(unsafe.Pointer(uintptr(0x40086800)))

	// 24-Bit Sigma-Delta A/D Converter
	SDADC24 = (*SDADC24_Type)(unsafe.Pointer(uintptr(0x4009c000)))

	// Temperature Sensor
	TSN = (*TSN_Type)(unsafe.Pointer(uintptr(0x407ec000)))

	// 12-bit D/A converter
	DAC12 = (*DAC12_Type)(unsafe.Pointer(uintptr(0x4005e000)))

	// 8-bit D/A converter
	DAC8 = (*DAC8_Type)(unsafe.Pointer(uintptr(0x4009e000)))

	// Event Link Controller
	ELC = (*ELC_Type)(unsafe.Pointer(uintptr(0x40041000)))

	// Independent Watchdog Timer
	IWDT = (*IWDT_Type)(unsafe.Pointer(uintptr(0x40044400)))

	// Key Interrupt Function
	KINT = (*KINT_Type)(unsafe.Pointer(uintptr(0x40080000)))

	// USB 2.0 FS Module
	USBFS = (*USBFS_Type)(unsafe.Pointer(uintptr(0x40090000)))

	// Watchdog Timer
	WDT = (*WDT_Type)(unsafe.Pointer(uintptr(0x40044200)))

	// Clock Frequency Accuracy Measurement Circuit
	CAC = (*CAC_Type)(unsafe.Pointer(uintptr(0x40044600)))

	// CRC Calculator
	CRC = (*CRC_Type)(unsafe.Pointer(uintptr(0x40074000)))

	// Data Operation Circuit
	DOC = (*DOC_Type)(unsafe.Pointer(uintptr(0x40054100)))

	// Serial Communication Interface 0
	SCI0 = (*SCI0_Type)(unsafe.Pointer(uintptr(0x40070000)))

	// Serial Communication Interface 1
	SCI1 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070020)))

	// Serial Communication Interface 9
	SCI9 = (*SCI1_Type)(unsafe.Pointer(uintptr(0x40070120)))

	// Serial Peripheral Interface 0
	SPI0 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072000)))

	// Serial Peripheral Interface 1
	SPI1 = (*SPI0_Type)(unsafe.Pointer(uintptr(0x40072100)))

	// CAN0 Module
	CAN0 = (*CAN0_Type)(unsafe.Pointer(uintptr(0x40050000)))

	// Inter-Integrated Circuit 0
	IIC0 = (*IIC0_Type)(unsafe.Pointer(uintptr(0x40053000)))

	// Inter-Integrated Circuit 1
	IIC1 = (*IIC1_Type)(unsafe.Pointer(uintptr(0x40053100)))

	// Memory Mirror Function
	MMF = (*MMF_Type)(unsafe.Pointer(uintptr(0x40001000)))

	// Bus Master MPU
	MMPU = (*MMPU_Type)(unsafe.Pointer(uintptr(0x40000000)))

	// Bus Slave MPU
	SMPU = (*SMPU_Type)(unsafe.Pointer(uintptr(0x40000c00)))

	// CPU Stack Pointer Monitor
	SPMON = (*SPMON_Type)(unsafe.Pointer(uintptr(0x40000d00)))

	// SRAM Control
	SRAM = (*SRAM_Type)(unsafe.Pointer(uintptr(0x40002000)))

	// BUS Control
	BUS = (*BUS_Type)(unsafe.Pointer(uintptr(0x40003000)))

	// Debug Function
	DBG = (*DBG_Type)(unsafe.Pointer(uintptr(0x4001b000)))

	// Data Transfer Controller
	DTC = (*DTC_Type)(unsafe.Pointer(uintptr(0x40005400)))

	// Interrupt Controller
	ICU = (*ICU_Type)(unsafe.Pointer(uintptr(0x40006000)))

	// System Control
	SYSTEM = (*SYSTEM_Type)(unsafe.Pointer(uintptr(0x4001e000)))

	// Module Stop Control B,C,D
	MSTP = (*MSTP_Type)(unsafe.Pointer(uintptr(0x40047000)))

	// Asynchronous General purpose Timer 0
	AGT0 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084000)))

	// Asynchronous General purpose Timer 1
	AGT1 = (*AGT0_Type)(unsafe.Pointer(uintptr(0x40084100)))

	// General PWM Timer 0 (32-bit)
	GPT320 = (*GPT320_Type)(unsafe.Pointer(uintptr(0x40078000)))

	// Output Phase Switching Controller
	GPT_OPS = (*GPT_OPS_Type)(unsafe.Pointer(uintptr(0x40078ff0)))

	// General PWM Timer 1 (16-bit)
	GPT161 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078100)))

	// General PWM Timer 2 (16-bit)
	GPT162 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078200)))

	// General PWM Timer 3 (16-bit)
	GPT163 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078300)))

	// General PWM Timer 4 (16-bit)
	GPT164 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078400)))

	// General PWM Timer 5 (16-bit)
	GPT165 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078500)))

	// General PWM Timer 6 (16-bit)
	GPT166 = (*GPT161_Type)(unsafe.Pointer(uintptr(0x40078600)))

	// Port Output Enable Module for GPT
	POEG = (*POEG_Type)(unsafe.Pointer(uintptr(0x40042000)))

	// Realtime Clock
	RTC = (*RTC_Type)(unsafe.Pointer(uintptr(0x40044000)))

	// Flash Cache
	FCACHE = (*FCACHE_Type)(unsafe.Pointer(uintptr(0x4001c000)))

	// Port 0 Control Registers
	PORT0 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040000)))

	// Port 1 Control Registers
	PORT1 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040020)))

	// Port 2 Control Registers
	PORT2 = (*PORT1_Type)(unsafe.Pointer(uintptr(0x40040040)))

	// Port 3 Control Registers
	PORT3 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040060)))

	// Port 4 Control Registers
	PORT4 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040080)))

	// Port 5 Control Registers
	PORT5 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x400400a0)))

	// Port 9 Control Registers
	PORT9 = (*PORT0_Type)(unsafe.Pointer(uintptr(0x40040120)))

	// Pmn Pin Function Control Register
	PFS = (*PFS_Type)(unsafe.Pointer(uintptr(0x40040800)))

	// Miscellaneous Port Control Register
	PMISC = (*PMISC_Type)(unsafe.Pointer(uintptr(0x40040d00)))
)

// High-Speed Analog Comparator 0
type ACMPHS0_Type struct {
	CMPCTL  volatile.Register8 // 0x0
	_       [3]byte
	CMPSEL0 volatile.Register8 // 0x4
	_       [3]byte
	CMPSEL1 volatile.Register8 // 0x8
	_       [3]byte
	CMPMON  volatile.Register8 // 0xC
	_       [3]byte
	CPIOC   volatile.Register8 // 0x10
}

// ACMPHS0.CMPCTL: Comparator Control Register
func (o *ACMPHS0_Type) SetCMPCTL_HCMPON(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS0_Type) GetCMPCTL_HCMPON() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x80) >> 7
}
func (o *ACMPHS0_Type) SetCMPCTL_CDFS(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x60)|value<<5)
}
func (o *ACMPHS0_Type) GetCMPCTL_CDFS() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x60) >> 5
}
func (o *ACMPHS0_Type) SetCMPCTL_CEG(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x18)|value<<3)
}
func (o *ACMPHS0_Type) GetCMPCTL_CEG() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x18) >> 3
}
func (o *ACMPHS0_Type) SetCMPCTL_Reserved(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x4)|value<<2)
}
func (o *ACMPHS0_Type) GetCMPCTL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x4) >> 2
}
func (o *ACMPHS0_Type) SetCMPCTL_COE(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x2)|value<<1)
}
func (o *ACMPHS0_Type) GetCMPCTL_COE() uint8 {
	return (volatile.LoadUint8(&o.CMPCTL.Reg) & 0x2) >> 1
}
func (o *ACMPHS0_Type) SetCMPCTL_CINV(value uint8) {
	volatile.StoreUint8(&o.CMPCTL.Reg, volatile.LoadUint8(&o.CMPCTL.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCMPCTL_CINV() uint8 {
	return volatile.LoadUint8(&o.CMPCTL.Reg) & 0x1
}

// ACMPHS0.CMPSEL0: Comparator Input Select Register
func (o *ACMPHS0_Type) SetCMPSEL0_CMPSEL(value uint8) {
	volatile.StoreUint8(&o.CMPSEL0.Reg, volatile.LoadUint8(&o.CMPSEL0.Reg)&^(0x7)|value)
}
func (o *ACMPHS0_Type) GetCMPSEL0_CMPSEL() uint8 {
	return volatile.LoadUint8(&o.CMPSEL0.Reg) & 0x7
}

// ACMPHS0.CMPSEL1: Comparator Reference Voltage Select Register
func (o *ACMPHS0_Type) SetCMPSEL1_CRVS(value uint8) {
	volatile.StoreUint8(&o.CMPSEL1.Reg, volatile.LoadUint8(&o.CMPSEL1.Reg)&^(0x3f)|value)
}
func (o *ACMPHS0_Type) GetCMPSEL1_CRVS() uint8 {
	return volatile.LoadUint8(&o.CMPSEL1.Reg) & 0x3f
}

// ACMPHS0.CMPMON: Comparator Output Monitor Register
func (o *ACMPHS0_Type) SetCMPMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.CMPMON.Reg, volatile.LoadUint8(&o.CMPMON.Reg)&^(0xfe)|value<<1)
}
func (o *ACMPHS0_Type) GetCMPMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CMPMON.Reg) & 0xfe) >> 1
}
func (o *ACMPHS0_Type) SetCMPMON(value uint8) {
	volatile.StoreUint8(&o.CMPMON.Reg, volatile.LoadUint8(&o.CMPMON.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCMPMON() uint8 {
	return volatile.LoadUint8(&o.CMPMON.Reg) & 0x1
}

// ACMPHS0.CPIOC: Comparator Output Control Register
func (o *ACMPHS0_Type) SetCPIOC_VREFEN(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x80)|value<<7)
}
func (o *ACMPHS0_Type) GetCPIOC_VREFEN() uint8 {
	return (volatile.LoadUint8(&o.CPIOC.Reg) & 0x80) >> 7
}
func (o *ACMPHS0_Type) SetCPIOC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x7e)|value<<1)
}
func (o *ACMPHS0_Type) GetCPIOC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CPIOC.Reg) & 0x7e) >> 1
}
func (o *ACMPHS0_Type) SetCPIOC_CPOE(value uint8) {
	volatile.StoreUint8(&o.CPIOC.Reg, volatile.LoadUint8(&o.CPIOC.Reg)&^(0x1)|value)
}
func (o *ACMPHS0_Type) GetCPIOC_CPOE() uint8 {
	return volatile.LoadUint8(&o.CPIOC.Reg) & 0x1
}

// Low-Power Analog Comparator
type ACMPLP_Type struct {
	COMPMDR  volatile.Register8 // 0x0
	COMPFIR  volatile.Register8 // 0x1
	COMPOCR  volatile.Register8 // 0x2
	_        byte
	COMPSEL0 volatile.Register8 // 0x4
	COMPSEL1 volatile.Register8 // 0x5
}

// ACMPLP.COMPMDR: ACMPLP Mode Setting Register
func (o *ACMPLP_Type) SetCOMPMDR_C1MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPMDR_C1VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPMDR_C1WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPMDR_C1ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x10)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPMDR_C1ENB() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x10) >> 4
}
func (o *ACMPLP_Type) SetCOMPMDR_C0MON(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0MON() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPMDR_C0VRF(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0VRF() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPMDR_C0WDE(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0WDE() uint8 {
	return (volatile.LoadUint8(&o.COMPMDR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPMDR_C0ENB(value uint8) {
	volatile.StoreUint8(&o.COMPMDR.Reg, volatile.LoadUint8(&o.COMPMDR.Reg)&^(0x1)|value)
}
func (o *ACMPLP_Type) GetCOMPMDR_C0ENB() uint8 {
	return volatile.LoadUint8(&o.COMPMDR.Reg) & 0x1
}

// ACMPLP.COMPFIR: ACMPLP Filter Control Register
func (o *ACMPLP_Type) SetCOMPFIR_C1EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPFIR_C1EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPFIR_C1FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x30)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPFIR_C1FCK() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x30) >> 4
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EDG(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x8)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EDG() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x8) >> 3
}
func (o *ACMPLP_Type) SetCOMPFIR_C0EPO(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0EPO() uint8 {
	return (volatile.LoadUint8(&o.COMPFIR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPFIR_C0FCK(value uint8) {
	volatile.StoreUint8(&o.COMPFIR.Reg, volatile.LoadUint8(&o.COMPFIR.Reg)&^(0x3)|value)
}
func (o *ACMPLP_Type) GetCOMPFIR_C0FCK() uint8 {
	return volatile.LoadUint8(&o.COMPFIR.Reg) & 0x3
}

// ACMPLP.COMPOCR: ACMPLP Output Control Register
func (o *ACMPLP_Type) SetCOMPOCR_SPDMD(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPOCR_SPDMD() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPOCR_C1OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x20)|value<<5)
}
func (o *ACMPLP_Type) GetCOMPOCR_C1OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x20) >> 5
}
func (o *ACMPLP_Type) SetCOMPOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x18)|value<<3)
}
func (o *ACMPLP_Type) GetCOMPOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x18) >> 3
}
func (o *ACMPLP_Type) SetCOMPOCR_C0OP(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x4)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OP() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x4) >> 2
}
func (o *ACMPLP_Type) SetCOMPOCR_C0OE(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x2)|value<<1)
}
func (o *ACMPLP_Type) GetCOMPOCR_C0OE() uint8 {
	return (volatile.LoadUint8(&o.COMPOCR.Reg) & 0x2) >> 1
}
func (o *ACMPLP_Type) SetCOMPOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPOCR.Reg, volatile.LoadUint8(&o.COMPOCR.Reg)&^(0x1)|value)
}
func (o *ACMPLP_Type) GetCOMPOCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.COMPOCR.Reg) & 0x1
}

// ACMPLP.COMPSEL0: Comparator Input Select Register
func (o *ACMPLP_Type) SetCOMPSEL0_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0xc0)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPSEL0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0xc0) >> 6
}
func (o *ACMPLP_Type) SetCOMPSEL0_CMPSEL54(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x30)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPSEL0_CMPSEL54() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x30) >> 4
}
func (o *ACMPLP_Type) SetCOMPSEL0_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0xc)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPSEL0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL0.Reg) & 0xc) >> 2
}
func (o *ACMPLP_Type) SetCOMPSEL0_CMPSEL10(value uint8) {
	volatile.StoreUint8(&o.COMPSEL0.Reg, volatile.LoadUint8(&o.COMPSEL0.Reg)&^(0x3)|value)
}
func (o *ACMPLP_Type) GetCOMPSEL0_CMPSEL10() uint8 {
	return volatile.LoadUint8(&o.COMPSEL0.Reg) & 0x3
}

// ACMPLP.COMPSEL1: Comparator Reference voltage Select Register
func (o *ACMPLP_Type) SetCOMPSEL1_C1VRF2(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x80)|value<<7)
}
func (o *ACMPLP_Type) GetCOMPSEL1_C1VRF2() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x80) >> 7
}
func (o *ACMPLP_Type) SetCOMPSEL1_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x40)|value<<6)
}
func (o *ACMPLP_Type) GetCOMPSEL1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x40) >> 6
}
func (o *ACMPLP_Type) SetCOMPSEL1_CRVS54(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x30)|value<<4)
}
func (o *ACMPLP_Type) GetCOMPSEL1_CRVS54() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x30) >> 4
}
func (o *ACMPLP_Type) SetCOMPSEL1_Reserved(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0xc)|value<<2)
}
func (o *ACMPLP_Type) GetCOMPSEL1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.COMPSEL1.Reg) & 0xc) >> 2
}
func (o *ACMPLP_Type) SetCOMPSEL1_CRVS10(value uint8) {
	volatile.StoreUint8(&o.COMPSEL1.Reg, volatile.LoadUint8(&o.COMPSEL1.Reg)&^(0x3)|value)
}
func (o *ACMPLP_Type) GetCOMPSEL1_CRVS10() uint8 {
	return volatile.LoadUint8(&o.COMPSEL1.Reg) & 0x3
}

// 16-bit A/D Converter
type ADC160_Type struct {
	ADCSR      volatile.Register16 // 0x0
	_          [2]byte
	ADANSA0    volatile.Register16 // 0x4
	ADANSA1    volatile.Register16 // 0x6
	ADADS0     volatile.Register16 // 0x8
	ADADS1     volatile.Register16 // 0xA
	ADADC      volatile.Register8  // 0xC
	_          byte
	ADCER      volatile.Register16 // 0xE
	ADSTRGR    volatile.Register16 // 0x10
	ADEXICR    volatile.Register16 // 0x12
	ADANSB0    volatile.Register16 // 0x14
	ADANSB1    volatile.Register16 // 0x16
	ADDBLDR    volatile.Register16 // 0x18
	ADTSDR     volatile.Register16 // 0x1A
	ADOCDR     volatile.Register16 // 0x1C
	_          [2]byte
	ADDR0      volatile.Register16 // 0x20
	ADDR1      volatile.Register16 // 0x22
	ADDR2      volatile.Register16 // 0x24
	ADDR3      volatile.Register16 // 0x26
	ADDR4      volatile.Register16 // 0x28
	ADDR5      volatile.Register16 // 0x2A
	ADDR6      volatile.Register16 // 0x2C
	ADDR7      volatile.Register16 // 0x2E
	ADDR8      volatile.Register16 // 0x30
	_          [14]byte
	ADDR16     volatile.Register16 // 0x40
	ADDR17     volatile.Register16 // 0x42
	ADDR18     volatile.Register16 // 0x44
	ADDR19     volatile.Register16 // 0x46
	ADDR20     volatile.Register16 // 0x48
	ADDR21     volatile.Register16 // 0x4A
	ADDR22     volatile.Register16 // 0x4C
	ADDR23     volatile.Register16 // 0x4E
	ADDR24     volatile.Register16 // 0x50
	_          [40]byte
	ADDISCR    volatile.Register8 // 0x7A
	_          [2]byte
	ADICR      volatile.Register8 // 0x7D
	_          [2]byte
	ADGSPCR    volatile.Register16 // 0x80
	_          [2]byte
	ADDBLDRA   volatile.Register16 // 0x84
	ADDBLDRB   volatile.Register16 // 0x86
	_          [4]byte
	ADWINMON   volatile.Register8 // 0x8C
	_          [3]byte
	ADCMPCR    volatile.Register16 // 0x90
	ADCMPANSER volatile.Register8  // 0x92
	ADCMPLER   volatile.Register8  // 0x93
	ADCMPANSR0 volatile.Register16 // 0x94
	ADCMPANSR1 volatile.Register16 // 0x96
	ADCMPLR0   volatile.Register16 // 0x98
	ADCMPLR1   volatile.Register16 // 0x9A
	ADCMPDR0   volatile.Register16 // 0x9C
	ADCMPDR1   volatile.Register16 // 0x9E
	ADCMPSR0   volatile.Register16 // 0xA0
	ADCMPSR1   volatile.Register16 // 0xA2
	ADCMPSER   volatile.Register8  // 0xA4
	_          byte
	ADCMPBNSR  volatile.Register8 // 0xA6
	_          byte
	ADWINLLB   volatile.Register16 // 0xA8
	ADWINULB   volatile.Register16 // 0xAA
	ADCMPBSR   volatile.Register8  // 0xAC
	_          [48]byte
	ADSSTRL    volatile.Register8 // 0xDD
	ADSSTRT    volatile.Register8 // 0xDE
	ADSSTRO    volatile.Register8 // 0xDF
	ADSSTR00   volatile.Register8 // 0xE0
	ADSSTR01   volatile.Register8 // 0xE1
	ADSSTR02   volatile.Register8 // 0xE2
	ADSSTR03   volatile.Register8 // 0xE3
	ADSSTR04   volatile.Register8 // 0xE4
	ADSSTR05   volatile.Register8 // 0xE5
	ADSSTR06   volatile.Register8 // 0xE6
	ADSSTR07   volatile.Register8 // 0xE7
	ADSSTR08   volatile.Register8 // 0xE8
	_          [7]byte
	ADANIM     volatile.Register16 // 0xF0
	ADCALEXE   volatile.Register8  // 0xF2
	_          byte
	VREFAMPCNT volatile.Register8 // 0xF4
	_          [3]byte
	ADRD       volatile.Register16 // 0xF8
	ADRST      volatile.Register8  // 0xFA
}

// ADC160.ADCSR: A/D Control Register
func (o *ADC160_Type) SetADCSR_ADST(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC160_Type) GetADCSR_ADST() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x8000) >> 15
}
func (o *ADC160_Type) SetADCSR_ADCS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x6000)|value<<13)
}
func (o *ADC160_Type) GetADCSR_ADCS() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x6000) >> 13
}
func (o *ADC160_Type) SetADCSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1800)|value<<11)
}
func (o *ADC160_Type) GetADCSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x1800) >> 11
}
func (o *ADC160_Type) SetADCSR_ADHSC(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x400)|value<<10)
}
func (o *ADC160_Type) GetADCSR_ADHSC() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x400) >> 10
}
func (o *ADC160_Type) SetADCSR_TRGE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x200)|value<<9)
}
func (o *ADC160_Type) GetADCSR_TRGE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x200) >> 9
}
func (o *ADC160_Type) SetADCSR_EXTRG(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCSR_EXTRG() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCSR_DBLE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCSR_DBLE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCSR_GBADIE(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCSR_GBADIE() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCSR.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCSR_DBLANS(value uint16) {
	volatile.StoreUint16(&o.ADCSR.Reg, volatile.LoadUint16(&o.ADCSR.Reg)&^(0x1f)|value)
}
func (o *ADC160_Type) GetADCSR_DBLANS() uint16 {
	return volatile.LoadUint16(&o.ADCSR.Reg) & 0x1f
}

// ADC160.ADANSA0: A/D Channel Select Register A0
func (o *ADC160_Type) SetADANSA0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADANSA0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADANSA0_ANSA08(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADANSA0_ANSA08() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADANSA0_ANSA07(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADANSA0_ANSA07() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADANSA0_ANSA06(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADANSA0_ANSA06() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADANSA0_ANSA05(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADANSA0_ANSA05() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADANSA0_ANSA04(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADANSA0_ANSA04() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADANSA0_ANSA03(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADANSA0_ANSA03() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADANSA0_ANSA02(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADANSA0_ANSA02() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADANSA0_ANSA01(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADANSA0_ANSA01() uint16 {
	return (volatile.LoadUint16(&o.ADANSA0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADANSA0_ANSA00(value uint16) {
	volatile.StoreUint16(&o.ADANSA0.Reg, volatile.LoadUint16(&o.ADANSA0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADANSA0_ANSA00() uint16 {
	return volatile.LoadUint16(&o.ADANSA0.Reg) & 0x1
}

// ADC160.ADANSA1: A/D Channel Select Register A1
func (o *ADC160_Type) SetADANSA1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADANSA1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADANSA1_ANSA24(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADANSA1_ANSA24() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADANSA1_ANSA23(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADANSA1_ANSA23() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADANSA1_ANSA22(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADANSA1_ANSA22() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADANSA1_ANSA21(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADANSA1_ANSA21() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADANSA1_ANSA20(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADANSA1_ANSA20() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADANSA1_ANSA19(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADANSA1_ANSA19() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADANSA1_ANSA18(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADANSA1_ANSA18() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADANSA1_ANSA17(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADANSA1_ANSA17() uint16 {
	return (volatile.LoadUint16(&o.ADANSA1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADANSA1_ANSA16(value uint16) {
	volatile.StoreUint16(&o.ADANSA1.Reg, volatile.LoadUint16(&o.ADANSA1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADANSA1_ANSA16() uint16 {
	return volatile.LoadUint16(&o.ADANSA1.Reg) & 0x1
}

// ADC160.ADADS0: A/D-Converted Value Average Channel Select Register 0
func (o *ADC160_Type) SetADADS0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADADS0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADADS0_ADS08(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADADS0_ADS08() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADADS0_ADS07(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADADS0_ADS07() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADADS0_ADS06(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADADS0_ADS06() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADADS0_ADS05(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADADS0_ADS05() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADADS0_ADS04(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADADS0_ADS04() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADADS0_ADS03(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADADS0_ADS03() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADADS0_ADS02(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADADS0_ADS02() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADADS0_ADS01(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADADS0_ADS01() uint16 {
	return (volatile.LoadUint16(&o.ADADS0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADADS0_ADS00(value uint16) {
	volatile.StoreUint16(&o.ADADS0.Reg, volatile.LoadUint16(&o.ADADS0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADADS0_ADS00() uint16 {
	return volatile.LoadUint16(&o.ADADS0.Reg) & 0x1
}

// ADC160.ADADS1: A/D-Converted Value Average Channel Select Register 1
func (o *ADC160_Type) SetADADS1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADADS1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADADS1_ADS24(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADADS1_ADS24() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADADS1_ADS23(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADADS1_ADS23() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADADS1_ADS22(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADADS1_ADS22() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADADS1_ADS21(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADADS1_ADS21() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADADS1_ADS20(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADADS1_ADS20() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADADS1_ADS19(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADADS1_ADS19() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADADS1_ADS18(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADADS1_ADS18() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADADS1_ADS17(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADADS1_ADS17() uint16 {
	return (volatile.LoadUint16(&o.ADADS1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADADS1_ADS16(value uint16) {
	volatile.StoreUint16(&o.ADADS1.Reg, volatile.LoadUint16(&o.ADADS1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADADS1_ADS16() uint16 {
	return volatile.LoadUint16(&o.ADADS1.Reg) & 0x1
}

// ADC160.ADADC: A/D-Converted Value Average Count Select Register
func (o *ADC160_Type) SetADADC_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0xf8)|value<<3)
}
func (o *ADC160_Type) GetADADC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADADC.Reg) & 0xf8) >> 3
}
func (o *ADC160_Type) SetADADC_ADC(value uint8) {
	volatile.StoreUint8(&o.ADADC.Reg, volatile.LoadUint8(&o.ADADC.Reg)&^(0x7)|value)
}
func (o *ADC160_Type) GetADADC_ADC() uint8 {
	return volatile.LoadUint8(&o.ADADC.Reg) & 0x7
}

// ADC160.ADCER: A/D Control Extended Register
func (o *ADC160_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x8000)|value<<15)
}
func (o *ADC160_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x8000) >> 15
}
func (o *ADC160_Type) SetADCER_ADINV(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x4000)|value<<14)
}
func (o *ADC160_Type) GetADCER_ADINV() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x4000) >> 14
}
func (o *ADC160_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x3000)|value<<12)
}
func (o *ADC160_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x3000) >> 12
}
func (o *ADC160_Type) SetADCER_DIAGM(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x800)|value<<11)
}
func (o *ADC160_Type) GetADCER_DIAGM() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x800) >> 11
}
func (o *ADC160_Type) SetADCER_DIAGLD(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x400)|value<<10)
}
func (o *ADC160_Type) GetADCER_DIAGLD() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x400) >> 10
}
func (o *ADC160_Type) SetADCER_DIAGVAL(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x300)|value<<8)
}
func (o *ADC160_Type) GetADCER_DIAGVAL() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x300) >> 8
}
func (o *ADC160_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0xc0)|value<<6)
}
func (o *ADC160_Type) GetADCER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0xc0) >> 6
}
func (o *ADC160_Type) SetADCER_ACE(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCER_ACE() uint16 {
	return (volatile.LoadUint16(&o.ADCER.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCER_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCER.Reg, volatile.LoadUint16(&o.ADCER.Reg)&^(0x1f)|value)
}
func (o *ADC160_Type) GetADCER_Reserved() uint16 {
	return volatile.LoadUint16(&o.ADCER.Reg) & 0x1f
}

// ADC160.ADSTRGR: A/D Conversion Start Trigger Select Register
func (o *ADC160_Type) SetADSTRGR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0xc000)|value<<14)
}
func (o *ADC160_Type) GetADSTRGR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0xc000) >> 14
}
func (o *ADC160_Type) SetADSTRGR_TRSA(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f00)|value<<8)
}
func (o *ADC160_Type) GetADSTRGR_TRSA() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f00) >> 8
}
func (o *ADC160_Type) SetADSTRGR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC160_Type) GetADSTRGR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADSTRGR.Reg) & 0xc0) >> 6
}
func (o *ADC160_Type) SetADSTRGR_TRSB(value uint16) {
	volatile.StoreUint16(&o.ADSTRGR.Reg, volatile.LoadUint16(&o.ADSTRGR.Reg)&^(0x3f)|value)
}
func (o *ADC160_Type) GetADSTRGR_TRSB() uint16 {
	return volatile.LoadUint16(&o.ADSTRGR.Reg) & 0x3f
}

// ADC160.ADEXICR: A/D Conversion Extended Input Control Register
func (o *ADC160_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0xfc00)|value<<10)
}
func (o *ADC160_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0xfc00) >> 10
}
func (o *ADC160_Type) SetADEXICR_OCSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x200)|value<<9)
}
func (o *ADC160_Type) GetADEXICR_OCSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x200) >> 9
}
func (o *ADC160_Type) SetADEXICR_TSSA(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADEXICR_TSSA() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADEXICR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADEXICR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADEXICR_OCSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADEXICR_OCSAD() uint16 {
	return (volatile.LoadUint16(&o.ADEXICR.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADEXICR_TSSAD(value uint16) {
	volatile.StoreUint16(&o.ADEXICR.Reg, volatile.LoadUint16(&o.ADEXICR.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADEXICR_TSSAD() uint16 {
	return volatile.LoadUint16(&o.ADEXICR.Reg) & 0x1
}

// ADC160.ADANSB0: A/D Channel Select Register B0
func (o *ADC160_Type) SetADANSB0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADANSB0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADANSB0_ANSB08(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADANSB0_ANSB08() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADANSB0_ANSB07(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADANSB0_ANSB07() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADANSB0_ANSB06(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADANSB0_ANSB06() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADANSB0_ANSB05(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADANSB0_ANSB05() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADANSB0_ANSB04(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADANSB0_ANSB04() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADANSB0_ANSB03(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADANSB0_ANSB03() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADANSB0_ANSB02(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADANSB0_ANSB02() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADANSB0_ANSB01(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADANSB0_ANSB01() uint16 {
	return (volatile.LoadUint16(&o.ADANSB0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADANSB0_ANSB00(value uint16) {
	volatile.StoreUint16(&o.ADANSB0.Reg, volatile.LoadUint16(&o.ADANSB0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADANSB0_ANSB00() uint16 {
	return volatile.LoadUint16(&o.ADANSB0.Reg) & 0x1
}

// ADC160.ADANSB1: A/D Channel Select Register B1
func (o *ADC160_Type) SetADANSB1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADANSB1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADANSB1_ANSB24(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADANSB1_ANSB24() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADANSB1_ANSB23(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADANSB1_ANSB23() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADANSB1_ANSB22(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADANSB1_ANSB22() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADANSB1_ANSB21(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADANSB1_ANSB21() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADANSB1_ANSB20(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADANSB1_ANSB20() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADANSB1_ANSB19(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADANSB1_ANSB19() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADANSB1_ANSB18(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADANSB1_ANSB18() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADANSB1_ANSB17(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADANSB1_ANSB17() uint16 {
	return (volatile.LoadUint16(&o.ADANSB1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADANSB1_ANSB16(value uint16) {
	volatile.StoreUint16(&o.ADANSB1.Reg, volatile.LoadUint16(&o.ADANSB1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADANSB1_ANSB16() uint16 {
	return volatile.LoadUint16(&o.ADANSB1.Reg) & 0x1
}

// ADC160.ADDBLDR: A/D Data Duplexing Register
func (o *ADC160_Type) SetADDBLDR(value uint16) {
	volatile.StoreUint16(&o.ADDBLDR.Reg, value)
}
func (o *ADC160_Type) GetADDBLDR() uint16 {
	return volatile.LoadUint16(&o.ADDBLDR.Reg)
}

// ADC160.ADTSDR: A/D Temperature Sensor Data Register
func (o *ADC160_Type) SetADTSDR(value uint16) {
	volatile.StoreUint16(&o.ADTSDR.Reg, value)
}
func (o *ADC160_Type) GetADTSDR() uint16 {
	return volatile.LoadUint16(&o.ADTSDR.Reg)
}

// ADC160.ADOCDR: A/D Internal Reference Voltage Data Register
func (o *ADC160_Type) SetADOCDR(value uint16) {
	volatile.StoreUint16(&o.ADOCDR.Reg, value)
}
func (o *ADC160_Type) GetADOCDR() uint16 {
	return volatile.LoadUint16(&o.ADOCDR.Reg)
}

// ADC160.ADDR0: A/D Data Register %s
func (o *ADC160_Type) SetADDR0(value uint16) {
	volatile.StoreUint16(&o.ADDR0.Reg, value)
}
func (o *ADC160_Type) GetADDR0() uint16 {
	return volatile.LoadUint16(&o.ADDR0.Reg)
}

// ADC160.ADDR1: A/D Data Register %s
func (o *ADC160_Type) SetADDR1(value uint16) {
	volatile.StoreUint16(&o.ADDR1.Reg, value)
}
func (o *ADC160_Type) GetADDR1() uint16 {
	return volatile.LoadUint16(&o.ADDR1.Reg)
}

// ADC160.ADDR2: A/D Data Register %s
func (o *ADC160_Type) SetADDR2(value uint16) {
	volatile.StoreUint16(&o.ADDR2.Reg, value)
}
func (o *ADC160_Type) GetADDR2() uint16 {
	return volatile.LoadUint16(&o.ADDR2.Reg)
}

// ADC160.ADDR3: A/D Data Register %s
func (o *ADC160_Type) SetADDR3(value uint16) {
	volatile.StoreUint16(&o.ADDR3.Reg, value)
}
func (o *ADC160_Type) GetADDR3() uint16 {
	return volatile.LoadUint16(&o.ADDR3.Reg)
}

// ADC160.ADDR4: A/D Data Register %s
func (o *ADC160_Type) SetADDR4(value uint16) {
	volatile.StoreUint16(&o.ADDR4.Reg, value)
}
func (o *ADC160_Type) GetADDR4() uint16 {
	return volatile.LoadUint16(&o.ADDR4.Reg)
}

// ADC160.ADDR5: A/D Data Register %s
func (o *ADC160_Type) SetADDR5(value uint16) {
	volatile.StoreUint16(&o.ADDR5.Reg, value)
}
func (o *ADC160_Type) GetADDR5() uint16 {
	return volatile.LoadUint16(&o.ADDR5.Reg)
}

// ADC160.ADDR6: A/D Data Register %s
func (o *ADC160_Type) SetADDR6(value uint16) {
	volatile.StoreUint16(&o.ADDR6.Reg, value)
}
func (o *ADC160_Type) GetADDR6() uint16 {
	return volatile.LoadUint16(&o.ADDR6.Reg)
}

// ADC160.ADDR7: A/D Data Register %s
func (o *ADC160_Type) SetADDR7(value uint16) {
	volatile.StoreUint16(&o.ADDR7.Reg, value)
}
func (o *ADC160_Type) GetADDR7() uint16 {
	return volatile.LoadUint16(&o.ADDR7.Reg)
}

// ADC160.ADDR8: A/D Data Register %s
func (o *ADC160_Type) SetADDR8(value uint16) {
	volatile.StoreUint16(&o.ADDR8.Reg, value)
}
func (o *ADC160_Type) GetADDR8() uint16 {
	return volatile.LoadUint16(&o.ADDR8.Reg)
}

// ADC160.ADDR16: A/D Data Register %s
func (o *ADC160_Type) SetADDR16(value uint16) {
	volatile.StoreUint16(&o.ADDR16.Reg, value)
}
func (o *ADC160_Type) GetADDR16() uint16 {
	return volatile.LoadUint16(&o.ADDR16.Reg)
}

// ADC160.ADDR17: A/D Data Register %s
func (o *ADC160_Type) SetADDR17(value uint16) {
	volatile.StoreUint16(&o.ADDR17.Reg, value)
}
func (o *ADC160_Type) GetADDR17() uint16 {
	return volatile.LoadUint16(&o.ADDR17.Reg)
}

// ADC160.ADDR18: A/D Data Register %s
func (o *ADC160_Type) SetADDR18(value uint16) {
	volatile.StoreUint16(&o.ADDR18.Reg, value)
}
func (o *ADC160_Type) GetADDR18() uint16 {
	return volatile.LoadUint16(&o.ADDR18.Reg)
}

// ADC160.ADDR19: A/D Data Register %s
func (o *ADC160_Type) SetADDR19(value uint16) {
	volatile.StoreUint16(&o.ADDR19.Reg, value)
}
func (o *ADC160_Type) GetADDR19() uint16 {
	return volatile.LoadUint16(&o.ADDR19.Reg)
}

// ADC160.ADDR20: A/D Data Register %s
func (o *ADC160_Type) SetADDR20(value uint16) {
	volatile.StoreUint16(&o.ADDR20.Reg, value)
}
func (o *ADC160_Type) GetADDR20() uint16 {
	return volatile.LoadUint16(&o.ADDR20.Reg)
}

// ADC160.ADDR21: A/D Data Register %s
func (o *ADC160_Type) SetADDR21(value uint16) {
	volatile.StoreUint16(&o.ADDR21.Reg, value)
}
func (o *ADC160_Type) GetADDR21() uint16 {
	return volatile.LoadUint16(&o.ADDR21.Reg)
}

// ADC160.ADDR22: A/D Data Register %s
func (o *ADC160_Type) SetADDR22(value uint16) {
	volatile.StoreUint16(&o.ADDR22.Reg, value)
}
func (o *ADC160_Type) GetADDR22() uint16 {
	return volatile.LoadUint16(&o.ADDR22.Reg)
}

// ADC160.ADDR23: A/D Data Register %s
func (o *ADC160_Type) SetADDR23(value uint16) {
	volatile.StoreUint16(&o.ADDR23.Reg, value)
}
func (o *ADC160_Type) GetADDR23() uint16 {
	return volatile.LoadUint16(&o.ADDR23.Reg)
}

// ADC160.ADDR24: A/D Data Register %s
func (o *ADC160_Type) SetADDR24(value uint16) {
	volatile.StoreUint16(&o.ADDR24.Reg, value)
}
func (o *ADC160_Type) GetADDR24() uint16 {
	return volatile.LoadUint16(&o.ADDR24.Reg)
}

// ADC160.ADDISCR: A/D Disconnection Detection Control Register
func (o *ADC160_Type) SetADDISCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xc0)|value<<6)
}
func (o *ADC160_Type) GetADDISCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0xc0) >> 6
}
func (o *ADC160_Type) SetADDISCR_PCHG1(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADDISCR_PCHG1() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADDISCR_PCHG2(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADDISCR_PCHG2() uint8 {
	return (volatile.LoadUint8(&o.ADDISCR.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADDISCR_ADNDIS(value uint8) {
	volatile.StoreUint8(&o.ADDISCR.Reg, volatile.LoadUint8(&o.ADDISCR.Reg)&^(0xf)|value)
}
func (o *ADC160_Type) GetADDISCR_ADNDIS() uint8 {
	return volatile.LoadUint8(&o.ADDISCR.Reg) & 0xf
}

// ADC160.ADICR: A/D Interrupt Control Register
func (o *ADC160_Type) SetADICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADICR.Reg, volatile.LoadUint8(&o.ADICR.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADICR.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADICR_ADIC(value uint8) {
	volatile.StoreUint8(&o.ADICR.Reg, volatile.LoadUint8(&o.ADICR.Reg)&^(0x3)|value)
}
func (o *ADC160_Type) GetADICR_ADIC() uint8 {
	return volatile.LoadUint8(&o.ADICR.Reg) & 0x3
}

// ADC160.ADGSPCR: A/D Group Scan Priority Control Register
func (o *ADC160_Type) SetADGSPCR_GBRP(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC160_Type) GetADGSPCR_GBRP() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x8000) >> 15
}
func (o *ADC160_Type) SetADGSPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x7ffc)|value<<2)
}
func (o *ADC160_Type) GetADGSPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x7ffc) >> 2
}
func (o *ADC160_Type) SetADGSPCR_GBRSCN(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADGSPCR_GBRSCN() uint16 {
	return (volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADGSPCR_PGS(value uint16) {
	volatile.StoreUint16(&o.ADGSPCR.Reg, volatile.LoadUint16(&o.ADGSPCR.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADGSPCR_PGS() uint16 {
	return volatile.LoadUint16(&o.ADGSPCR.Reg) & 0x1
}

// ADC160.ADDBLDRA: A/D Data Duplexing Register A
func (o *ADC160_Type) SetADDBLDRA(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRA.Reg, value)
}
func (o *ADC160_Type) GetADDBLDRA() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRA.Reg)
}

// ADC160.ADDBLDRB: A/D Data Duplexing Register B
func (o *ADC160_Type) SetADDBLDRB(value uint16) {
	volatile.StoreUint16(&o.ADDBLDRB.Reg, value)
}
func (o *ADC160_Type) GetADDBLDRB() uint16 {
	return volatile.LoadUint16(&o.ADDBLDRB.Reg)
}

// ADC160.ADWINMON: A/D Compare Function Window A/B Status Monitor Register
func (o *ADC160_Type) SetADWINMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0xc0)|value<<6)
}
func (o *ADC160_Type) GetADWINMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0xc0) >> 6
}
func (o *ADC160_Type) SetADWINMON_MONCMPB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADWINMON_MONCMPB() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADWINMON_MONCMPA(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADWINMON_MONCMPA() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADWINMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0xe)|value<<1)
}
func (o *ADC160_Type) GetADWINMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADWINMON.Reg) & 0xe) >> 1
}
func (o *ADC160_Type) SetADWINMON_MONCOMB(value uint8) {
	volatile.StoreUint8(&o.ADWINMON.Reg, volatile.LoadUint8(&o.ADWINMON.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADWINMON_MONCOMB() uint8 {
	return volatile.LoadUint8(&o.ADWINMON.Reg) & 0x1
}

// ADC160.ADCMPCR: A/D Compare Function Control Register
func (o *ADC160_Type) SetADCMPCR_CMPAIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x8000)|value<<15)
}
func (o *ADC160_Type) GetADCMPCR_CMPAIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x8000) >> 15
}
func (o *ADC160_Type) SetADCMPCR_WCMPE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x4000)|value<<14)
}
func (o *ADC160_Type) GetADCMPCR_WCMPE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x4000) >> 14
}
func (o *ADC160_Type) SetADCMPCR_CMPBIE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x2000)|value<<13)
}
func (o *ADC160_Type) GetADCMPCR_CMPBIE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x2000) >> 13
}
func (o *ADC160_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x1000)|value<<12)
}
func (o *ADC160_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x1000) >> 12
}
func (o *ADC160_Type) SetADCMPCR_CMPAE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x800)|value<<11)
}
func (o *ADC160_Type) GetADCMPCR_CMPAE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x800) >> 11
}
func (o *ADC160_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x400)|value<<10)
}
func (o *ADC160_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x400) >> 10
}
func (o *ADC160_Type) SetADCMPCR_CMPBE(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x200)|value<<9)
}
func (o *ADC160_Type) GetADCMPCR_CMPBE() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x200) >> 9
}
func (o *ADC160_Type) SetADCMPCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x1fc)|value<<2)
}
func (o *ADC160_Type) GetADCMPCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x1fc) >> 2
}
func (o *ADC160_Type) SetADCMPCR_CMPAB(value uint16) {
	volatile.StoreUint16(&o.ADCMPCR.Reg, volatile.LoadUint16(&o.ADCMPCR.Reg)&^(0x3)|value)
}
func (o *ADC160_Type) GetADCMPCR_CMPAB() uint16 {
	return volatile.LoadUint16(&o.ADCMPCR.Reg) & 0x3
}

// ADC160.ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
func (o *ADC160_Type) SetADCMPANSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADCMPANSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADCMPANSER_CMPOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPANSER_CMPOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPANSER_CMPTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPANSER.Reg, volatile.LoadUint8(&o.ADCMPANSER.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPANSER_CMPTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPANSER.Reg) & 0x1
}

// ADC160.ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
func (o *ADC160_Type) SetADCMPLER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADCMPLER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADCMPLER_CMPLOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPLER_CMPLOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPLER_CMPLTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPLER.Reg, volatile.LoadUint8(&o.ADCMPLER.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPLER_CMPLTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPLER.Reg) & 0x1
}

// ADC160.ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
func (o *ADC160_Type) SetADCMPANSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPANSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPANSR0_CMPCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR0.Reg, volatile.LoadUint16(&o.ADCMPANSR0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPANSR0_CMPCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR0.Reg) & 0x1
}

// ADC160.ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
func (o *ADC160_Type) SetADCMPANSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPANSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPANSR1_CMPCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPANSR1.Reg, volatile.LoadUint16(&o.ADCMPANSR1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPANSR1_CMPCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPANSR1.Reg) & 0x1
}

// ADC160.ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
func (o *ADC160_Type) SetADCMPLR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPLR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPLR0_CMPLCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR0.Reg, volatile.LoadUint16(&o.ADCMPLR0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPLR0_CMPLCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR0.Reg) & 0x1
}

// ADC160.ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
func (o *ADC160_Type) SetADCMPLR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPLR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPLR1_CMPLCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPLR1.Reg, volatile.LoadUint16(&o.ADCMPLR1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPLR1_CMPLCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPLR1.Reg) & 0x1
}

// ADC160.ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
func (o *ADC160_Type) SetADCMPDR0(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR0.Reg, value)
}
func (o *ADC160_Type) GetADCMPDR0() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR0.Reg)
}

// ADC160.ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
func (o *ADC160_Type) SetADCMPDR1(value uint16) {
	volatile.StoreUint16(&o.ADCMPDR1.Reg, value)
}
func (o *ADC160_Type) GetADCMPDR1() uint16 {
	return volatile.LoadUint16(&o.ADCMPDR1.Reg)
}

// ADC160.ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
func (o *ADC160_Type) SetADCMPSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA08(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA08() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA07(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA07() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA06(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA06() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA05(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA05() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA04(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA04() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA03(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA03() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA02(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA02() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA01(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA01() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPSR0_CMPSTCHA00(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR0.Reg, volatile.LoadUint16(&o.ADCMPSR0.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPSR0_CMPSTCHA00() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR0.Reg) & 0x1
}

// ADC160.ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
func (o *ADC160_Type) SetADCMPSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0xfe00)|value<<9)
}
func (o *ADC160_Type) GetADCMPSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0xfe00) >> 9
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA24(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x100)|value<<8)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA24() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x100) >> 8
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA23(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA23() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA22(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA22() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA21(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x20)|value<<5)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA21() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x20) >> 5
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA20(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA20() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA19(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA19() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA18(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x4)|value<<2)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA18() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x4) >> 2
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA17(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA17() uint16 {
	return (volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPSR1_CMPSTCHA16(value uint16) {
	volatile.StoreUint16(&o.ADCMPSR1.Reg, volatile.LoadUint16(&o.ADCMPSR1.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPSR1_CMPSTCHA16() uint16 {
	return volatile.LoadUint16(&o.ADCMPSR1.Reg) & 0x1
}

// ADC160.ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
func (o *ADC160_Type) SetADCMPSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADCMPSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADCMPSER_CMPSTOCA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x2)|value<<1)
}
func (o *ADC160_Type) GetADCMPSER_CMPSTOCA() uint8 {
	return (volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x2) >> 1
}
func (o *ADC160_Type) SetADCMPSER_CMPSTTSA(value uint8) {
	volatile.StoreUint8(&o.ADCMPSER.Reg, volatile.LoadUint8(&o.ADCMPSER.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPSER_CMPSTTSA() uint8 {
	return volatile.LoadUint8(&o.ADCMPSER.Reg) & 0x1
}

// ADC160.ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
func (o *ADC160_Type) SetADCMPBNSR_CMPLB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCMPBNSR_CMPLB() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCMPBNSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCMPBNSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCMPBNSR_CMPCHB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBNSR.Reg, volatile.LoadUint8(&o.ADCMPBNSR.Reg)&^(0x3f)|value)
}
func (o *ADC160_Type) GetADCMPBNSR_CMPCHB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBNSR.Reg) & 0x3f
}

// ADC160.ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
func (o *ADC160_Type) SetADWINLLB(value uint16) {
	volatile.StoreUint16(&o.ADWINLLB.Reg, value)
}
func (o *ADC160_Type) GetADWINLLB() uint16 {
	return volatile.LoadUint16(&o.ADWINLLB.Reg)
}

// ADC160.ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
func (o *ADC160_Type) SetADWINULB(value uint16) {
	volatile.StoreUint16(&o.ADWINULB.Reg, value)
}
func (o *ADC160_Type) GetADWINULB() uint16 {
	return volatile.LoadUint16(&o.ADWINULB.Reg)
}

// ADC160.ADCMPBSR: A/D Compare Function Window B Status Register
func (o *ADC160_Type) SetADCMPBSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0xfe)|value<<1)
}
func (o *ADC160_Type) GetADCMPBSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0xfe) >> 1
}
func (o *ADC160_Type) SetADCMPBSR_CMPSTB(value uint8) {
	volatile.StoreUint8(&o.ADCMPBSR.Reg, volatile.LoadUint8(&o.ADCMPBSR.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetADCMPBSR_CMPSTB() uint8 {
	return volatile.LoadUint8(&o.ADCMPBSR.Reg) & 0x1
}

// ADC160.ADSSTRL: A/D Sampling State Register L
func (o *ADC160_Type) SetADSSTRL(value uint8) {
	volatile.StoreUint8(&o.ADSSTRL.Reg, value)
}
func (o *ADC160_Type) GetADSSTRL() uint8 {
	return volatile.LoadUint8(&o.ADSSTRL.Reg)
}

// ADC160.ADSSTRT: A/D Sampling State Register T
func (o *ADC160_Type) SetADSSTRT(value uint8) {
	volatile.StoreUint8(&o.ADSSTRT.Reg, value)
}
func (o *ADC160_Type) GetADSSTRT() uint8 {
	return volatile.LoadUint8(&o.ADSSTRT.Reg)
}

// ADC160.ADSSTRO: A/D Sampling State Register O
func (o *ADC160_Type) SetADSSTRO(value uint8) {
	volatile.StoreUint8(&o.ADSSTRO.Reg, value)
}
func (o *ADC160_Type) GetADSSTRO() uint8 {
	return volatile.LoadUint8(&o.ADSSTRO.Reg)
}

// ADC160.ADSSTR00: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR00(value uint8) {
	volatile.StoreUint8(&o.ADSSTR00.Reg, value)
}
func (o *ADC160_Type) GetADSSTR00() uint8 {
	return volatile.LoadUint8(&o.ADSSTR00.Reg)
}

// ADC160.ADSSTR01: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR01(value uint8) {
	volatile.StoreUint8(&o.ADSSTR01.Reg, value)
}
func (o *ADC160_Type) GetADSSTR01() uint8 {
	return volatile.LoadUint8(&o.ADSSTR01.Reg)
}

// ADC160.ADSSTR02: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR02(value uint8) {
	volatile.StoreUint8(&o.ADSSTR02.Reg, value)
}
func (o *ADC160_Type) GetADSSTR02() uint8 {
	return volatile.LoadUint8(&o.ADSSTR02.Reg)
}

// ADC160.ADSSTR03: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR03(value uint8) {
	volatile.StoreUint8(&o.ADSSTR03.Reg, value)
}
func (o *ADC160_Type) GetADSSTR03() uint8 {
	return volatile.LoadUint8(&o.ADSSTR03.Reg)
}

// ADC160.ADSSTR04: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR04(value uint8) {
	volatile.StoreUint8(&o.ADSSTR04.Reg, value)
}
func (o *ADC160_Type) GetADSSTR04() uint8 {
	return volatile.LoadUint8(&o.ADSSTR04.Reg)
}

// ADC160.ADSSTR05: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR05(value uint8) {
	volatile.StoreUint8(&o.ADSSTR05.Reg, value)
}
func (o *ADC160_Type) GetADSSTR05() uint8 {
	return volatile.LoadUint8(&o.ADSSTR05.Reg)
}

// ADC160.ADSSTR06: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR06(value uint8) {
	volatile.StoreUint8(&o.ADSSTR06.Reg, value)
}
func (o *ADC160_Type) GetADSSTR06() uint8 {
	return volatile.LoadUint8(&o.ADSSTR06.Reg)
}

// ADC160.ADSSTR07: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR07(value uint8) {
	volatile.StoreUint8(&o.ADSSTR07.Reg, value)
}
func (o *ADC160_Type) GetADSSTR07() uint8 {
	return volatile.LoadUint8(&o.ADSSTR07.Reg)
}

// ADC160.ADSSTR08: A/D Sampling State Register %s
func (o *ADC160_Type) SetADSSTR08(value uint8) {
	volatile.StoreUint8(&o.ADSSTR08.Reg, value)
}
func (o *ADC160_Type) GetADSSTR08() uint8 {
	return volatile.LoadUint8(&o.ADSSTR08.Reg)
}

// ADC160.ADANIM: A/D Channel Input Mode Select Register
func (o *ADC160_Type) SetADANIM_Reserved(value uint16) {
	volatile.StoreUint16(&o.ADANIM.Reg, volatile.LoadUint16(&o.ADANIM.Reg)&^(0xfff0)|value<<4)
}
func (o *ADC160_Type) GetADANIM_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ADANIM.Reg) & 0xfff0) >> 4
}
func (o *ADC160_Type) SetADANIM_ANIM(value uint16) {
	volatile.StoreUint16(&o.ADANIM.Reg, volatile.LoadUint16(&o.ADANIM.Reg)&^(0xf)|value)
}
func (o *ADC160_Type) GetADANIM_ANIM() uint16 {
	return volatile.LoadUint16(&o.ADANIM.Reg) & 0xf
}

// ADC160.ADCALEXE: A/D Calibration Execution Register
func (o *ADC160_Type) SetADCALEXE_CALEXE(value uint8) {
	volatile.StoreUint8(&o.ADCALEXE.Reg, volatile.LoadUint8(&o.ADCALEXE.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetADCALEXE_CALEXE() uint8 {
	return (volatile.LoadUint8(&o.ADCALEXE.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetADCALEXE_CALMON(value uint8) {
	volatile.StoreUint8(&o.ADCALEXE.Reg, volatile.LoadUint8(&o.ADCALEXE.Reg)&^(0x40)|value<<6)
}
func (o *ADC160_Type) GetADCALEXE_CALMON() uint8 {
	return (volatile.LoadUint8(&o.ADCALEXE.Reg) & 0x40) >> 6
}
func (o *ADC160_Type) SetADCALEXE_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADCALEXE.Reg, volatile.LoadUint8(&o.ADCALEXE.Reg)&^(0x3f)|value)
}
func (o *ADC160_Type) GetADCALEXE_Reserved() uint8 {
	return volatile.LoadUint8(&o.ADCALEXE.Reg) & 0x3f
}

// ADC160.VREFAMPCNT: A/D Dedicated Reference Voltage Circuit Control Register
func (o *ADC160_Type) SetVREFAMPCNT_ADSLP(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x80)|value<<7)
}
func (o *ADC160_Type) GetVREFAMPCNT_ADSLP() uint8 {
	return (volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x80) >> 7
}
func (o *ADC160_Type) SetVREFAMPCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x60)|value<<5)
}
func (o *ADC160_Type) GetVREFAMPCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x60) >> 5
}
func (o *ADC160_Type) SetVREFAMPCNT_BGREN(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x10)|value<<4)
}
func (o *ADC160_Type) GetVREFAMPCNT_BGREN() uint8 {
	return (volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x10) >> 4
}
func (o *ADC160_Type) SetVREFAMPCNT_VREFADCEN(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x8)|value<<3)
}
func (o *ADC160_Type) GetVREFAMPCNT_VREFADCEN() uint8 {
	return (volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x8) >> 3
}
func (o *ADC160_Type) SetVREFAMPCNT_VREFADCG(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x6)|value<<1)
}
func (o *ADC160_Type) GetVREFAMPCNT_VREFADCG() uint8 {
	return (volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x6) >> 1
}
func (o *ADC160_Type) SetVREFAMPCNT_OLDETEN(value uint8) {
	volatile.StoreUint8(&o.VREFAMPCNT.Reg, volatile.LoadUint8(&o.VREFAMPCNT.Reg)&^(0x1)|value)
}
func (o *ADC160_Type) GetVREFAMPCNT_OLDETEN() uint8 {
	return volatile.LoadUint8(&o.VREFAMPCNT.Reg) & 0x1
}

// ADC160.ADRD: A/D Self-Diagnosis Data Register
func (o *ADC160_Type) SetADRD(value uint16) {
	volatile.StoreUint16(&o.ADRD.Reg, value)
}
func (o *ADC160_Type) GetADRD() uint16 {
	return volatile.LoadUint16(&o.ADRD.Reg)
}

// ADC160.ADRST: A/D Self-Diagnostic Status Register
func (o *ADC160_Type) SetADRST_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADRST.Reg, volatile.LoadUint8(&o.ADRST.Reg)&^(0xfc)|value<<2)
}
func (o *ADC160_Type) GetADRST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADRST.Reg) & 0xfc) >> 2
}
func (o *ADC160_Type) SetADRST_DIAGST(value uint8) {
	volatile.StoreUint8(&o.ADRST.Reg, volatile.LoadUint8(&o.ADRST.Reg)&^(0x3)|value)
}
func (o *ADC160_Type) GetADRST_DIAGST() uint8 {
	return volatile.LoadUint8(&o.ADRST.Reg) & 0x3
}

// Capacitive Touch Sensing Unit
type CTSU_Type struct {
	CTSUCR0    volatile.Register8 // 0x0
	CTSUCR1    volatile.Register8 // 0x1
	CTSUSDPRS  volatile.Register8 // 0x2
	CTSUSST    volatile.Register8 // 0x3
	CTSUMCH0   volatile.Register8 // 0x4
	CTSUMCH1   volatile.Register8 // 0x5
	CTSUCHAC0  volatile.Register8 // 0x6
	CTSUCHAC1  volatile.Register8 // 0x7
	CTSUCHAC2  volatile.Register8 // 0x8
	CTSUCHAC3  volatile.Register8 // 0x9
	_          byte
	CTSUCHTRC0 volatile.Register8 // 0xB
	CTSUCHTRC1 volatile.Register8 // 0xC
	CTSUCHTRC2 volatile.Register8 // 0xD
	CTSUCHTRC3 volatile.Register8 // 0xE
	_          byte
	CTSUDCLKC  volatile.Register8  // 0x10
	CTSUST     volatile.Register8  // 0x11
	CTSUSSC    volatile.Register16 // 0x12
	CTSUSO0    volatile.Register16 // 0x14
	CTSUSO1    volatile.Register16 // 0x16
	CTSUSC     volatile.Register16 // 0x18
	CTSURC     volatile.Register16 // 0x1A
	CTSUERRS   volatile.Register16 // 0x1C
}

// CTSU.CTSUCR0: CTSU Control Register 0
func (o *CTSU_Type) SetCTSUCR0_CTSUINIT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUINIT() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSNZ(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSNZ() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCR0_CTSUCAP(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUCAP() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR0_CTSUSTRT(value uint8) {
	volatile.StoreUint8(&o.CTSUCR0.Reg, volatile.LoadUint8(&o.CTSUCR0.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR0_CTSUSTRT() uint8 {
	return volatile.LoadUint8(&o.CTSUCR0.Reg) & 0x1
}

// CTSU.CTSUCR1: CTSU Control Register 1
func (o *CTSU_Type) SetCTSUCR1_CTSUMD(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUMD() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCLK(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCLK() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUCR1_CTSUATUNE1(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUATUNE1() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUCR1_CTSUATUNE0(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x4)|value<<2)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUATUNE0() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x4) >> 2
}
func (o *CTSU_Type) SetCTSUCR1_CTSUCSW(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x2)|value<<1)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUCSW() uint8 {
	return (volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x2) >> 1
}
func (o *CTSU_Type) SetCTSUCR1_CTSUPON(value uint8) {
	volatile.StoreUint8(&o.CTSUCR1.Reg, volatile.LoadUint8(&o.CTSUCR1.Reg)&^(0x1)|value)
}
func (o *CTSU_Type) GetCTSUCR1_CTSUPON() uint8 {
	return volatile.LoadUint8(&o.CTSUCR1.Reg) & 0x1
}

// CTSU.CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
func (o *CTSU_Type) SetCTSUSDPRS_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUSDPRS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUSOFF(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUSOFF() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRMODE(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRMODE() uint8 {
	return (volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUSDPRS_CTSUPRRATIO(value uint8) {
	volatile.StoreUint8(&o.CTSUSDPRS.Reg, volatile.LoadUint8(&o.CTSUSDPRS.Reg)&^(0xf)|value)
}
func (o *CTSU_Type) GetCTSUSDPRS_CTSUPRRATIO() uint8 {
	return volatile.LoadUint8(&o.CTSUSDPRS.Reg) & 0xf
}

// CTSU.CTSUSST: CTSU Sensor Stabilization Wait Control Register
func (o *CTSU_Type) SetCTSUSST(value uint8) {
	volatile.StoreUint8(&o.CTSUSST.Reg, value)
}
func (o *CTSU_Type) GetCTSUSST() uint8 {
	return volatile.LoadUint8(&o.CTSUSST.Reg)
}

// CTSU.CTSUMCH0: CTSU Measurement Channel Register 0
func (o *CTSU_Type) SetCTSUMCH0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH0.Reg, volatile.LoadUint8(&o.CTSUMCH0.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUMCH0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUMCH0.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUMCH0(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH0.Reg, volatile.LoadUint8(&o.CTSUMCH0.Reg)&^(0x3f)|value)
}
func (o *CTSU_Type) GetCTSUMCH0() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH0.Reg) & 0x3f
}

// CTSU.CTSUMCH1: CTSU Measurement Channel Register 1
func (o *CTSU_Type) SetCTSUMCH1_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH1.Reg, volatile.LoadUint8(&o.CTSUMCH1.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUMCH1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUMCH1.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUMCH1(value uint8) {
	volatile.StoreUint8(&o.CTSUMCH1.Reg, volatile.LoadUint8(&o.CTSUMCH1.Reg)&^(0x3f)|value)
}
func (o *CTSU_Type) GetCTSUMCH1() uint8 {
	return volatile.LoadUint8(&o.CTSUMCH1.Reg) & 0x3f
}

// CTSU.CTSUCHAC0: CTSU Channel Enable Control Register 0
func (o *CTSU_Type) SetCTSUCHAC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC0.Reg)
}

// CTSU.CTSUCHAC1: CTSU Channel Enable Control Register 1
func (o *CTSU_Type) SetCTSUCHAC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC1.Reg)
}

// CTSU.CTSUCHAC2: CTSU Channel Enable Control Register 2
func (o *CTSU_Type) SetCTSUCHAC2(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC2.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC2() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC2.Reg)
}

// CTSU.CTSUCHAC3: CTSU Channel Enable Control Register 3
func (o *CTSU_Type) SetCTSUCHAC3(value uint8) {
	volatile.StoreUint8(&o.CTSUCHAC3.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHAC3() uint8 {
	return volatile.LoadUint8(&o.CTSUCHAC3.Reg)
}

// CTSU.CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
func (o *CTSU_Type) SetCTSUCHTRC0(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC0.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC0() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC0.Reg)
}

// CTSU.CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
func (o *CTSU_Type) SetCTSUCHTRC1(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC1.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC1() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC1.Reg)
}

// CTSU.CTSUCHTRC2: CTSU Channel Transmit/Receive Control Register 2
func (o *CTSU_Type) SetCTSUCHTRC2(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC2.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC2() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC2.Reg)
}

// CTSU.CTSUCHTRC3: CTSU Channel Transmit/Receive Control Register 3
func (o *CTSU_Type) SetCTSUCHTRC3(value uint8) {
	volatile.StoreUint8(&o.CTSUCHTRC3.Reg, value)
}
func (o *CTSU_Type) GetCTSUCHTRC3() uint8 {
	return volatile.LoadUint8(&o.CTSUCHTRC3.Reg)
}

// CTSU.CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
func (o *CTSU_Type) SetCTSUDCLKC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0xc0)|value<<6)
}
func (o *CTSU_Type) GetCTSUDCLKC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0xc0) >> 6
}
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSCNT(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x30)|value<<4)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSCNT() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x30) >> 4
}
func (o *CTSU_Type) SetCTSUDCLKC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0xc)|value<<2)
}
func (o *CTSU_Type) GetCTSUDCLKC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0xc) >> 2
}
func (o *CTSU_Type) SetCTSUDCLKC_CTSUSSMOD(value uint8) {
	volatile.StoreUint8(&o.CTSUDCLKC.Reg, volatile.LoadUint8(&o.CTSUDCLKC.Reg)&^(0x3)|value)
}
func (o *CTSU_Type) GetCTSUDCLKC_CTSUSSMOD() uint8 {
	return volatile.LoadUint8(&o.CTSUDCLKC.Reg) & 0x3
}

// CTSU.CTSUST: CTSU Status Register
func (o *CTSU_Type) SetCTSUST_CTSUPS(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x80)|value<<7)
}
func (o *CTSU_Type) GetCTSUST_CTSUPS() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x80) >> 7
}
func (o *CTSU_Type) SetCTSUST_CTSUROVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x40)|value<<6)
}
func (o *CTSU_Type) GetCTSUST_CTSUROVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x40) >> 6
}
func (o *CTSU_Type) SetCTSUST_CTSUSOVF(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x20)|value<<5)
}
func (o *CTSU_Type) GetCTSUST_CTSUSOVF() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x20) >> 5
}
func (o *CTSU_Type) SetCTSUST_CTSUDTSR(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x10)|value<<4)
}
func (o *CTSU_Type) GetCTSUST_CTSUDTSR() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x10) >> 4
}
func (o *CTSU_Type) SetCTSUST_Reserved(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x8)|value<<3)
}
func (o *CTSU_Type) GetCTSUST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CTSUST.Reg) & 0x8) >> 3
}
func (o *CTSU_Type) SetCTSUST_CTSUSTC(value uint8) {
	volatile.StoreUint8(&o.CTSUST.Reg, volatile.LoadUint8(&o.CTSUST.Reg)&^(0x7)|value)
}
func (o *CTSU_Type) GetCTSUST_CTSUSTC() uint8 {
	return volatile.LoadUint8(&o.CTSUST.Reg) & 0x7
}

// CTSU.CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
func (o *CTSU_Type) SetCTSUSSC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xf000)|value<<12)
}
func (o *CTSU_Type) GetCTSUSSC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xf000) >> 12
}
func (o *CTSU_Type) SetCTSUSSC_CTSUSSDIV(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xf00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSSC_CTSUSSDIV() uint16 {
	return (volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xf00) >> 8
}
func (o *CTSU_Type) SetCTSUSSC_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSSC.Reg, volatile.LoadUint16(&o.CTSUSSC.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSSC_Reserved() uint16 {
	return volatile.LoadUint16(&o.CTSUSSC.Reg) & 0xff
}

// CTSU.CTSUSO0: CTSU Sensor Offset Register 0
func (o *CTSU_Type) SetCTSUSO0_CTSUSNUM(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0xfc00)|value<<10)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSNUM() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO0.Reg) & 0xfc00) >> 10
}
func (o *CTSU_Type) SetCTSUSO0_CTSUSO(value uint16) {
	volatile.StoreUint16(&o.CTSUSO0.Reg, volatile.LoadUint16(&o.CTSUSO0.Reg)&^(0x3ff)|value)
}
func (o *CTSU_Type) GetCTSUSO0_CTSUSO() uint16 {
	return volatile.LoadUint16(&o.CTSUSO0.Reg) & 0x3ff
}

// CTSU.CTSUSO1: CTSU Sensor Offset Register 1
func (o *CTSU_Type) SetCTSUSO1_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUSO1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUSO1_CTSUICOG(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x6000)|value<<13)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUICOG() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x6000) >> 13
}
func (o *CTSU_Type) SetCTSUSO1_CTSUSDPA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0x1f00)|value<<8)
}
func (o *CTSU_Type) GetCTSUSO1_CTSUSDPA() uint16 {
	return (volatile.LoadUint16(&o.CTSUSO1.Reg) & 0x1f00) >> 8
}
func (o *CTSU_Type) SetCTSUSO1_CTSURICOA(value uint16) {
	volatile.StoreUint16(&o.CTSUSO1.Reg, volatile.LoadUint16(&o.CTSUSO1.Reg)&^(0xff)|value)
}
func (o *CTSU_Type) GetCTSUSO1_CTSURICOA() uint16 {
	return volatile.LoadUint16(&o.CTSUSO1.Reg) & 0xff
}

// CTSU.CTSUSC: CTSU Sensor Counter
func (o *CTSU_Type) SetCTSUSC(value uint16) {
	volatile.StoreUint16(&o.CTSUSC.Reg, value)
}
func (o *CTSU_Type) GetCTSUSC() uint16 {
	return volatile.LoadUint16(&o.CTSUSC.Reg)
}

// CTSU.CTSURC: CTSU Reference Counter
func (o *CTSU_Type) SetCTSURC(value uint16) {
	volatile.StoreUint16(&o.CTSURC.Reg, value)
}
func (o *CTSU_Type) GetCTSURC() uint16 {
	return volatile.LoadUint16(&o.CTSURC.Reg)
}

// CTSU.CTSUERRS: CTSU Error Status Register
func (o *CTSU_Type) SetCTSUERRS_CTSUICOMP(value uint16) {
	volatile.StoreUint16(&o.CTSUERRS.Reg, volatile.LoadUint16(&o.CTSUERRS.Reg)&^(0x8000)|value<<15)
}
func (o *CTSU_Type) GetCTSUERRS_CTSUICOMP() uint16 {
	return (volatile.LoadUint16(&o.CTSUERRS.Reg) & 0x8000) >> 15
}
func (o *CTSU_Type) SetCTSUERRS_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTSUERRS.Reg, volatile.LoadUint16(&o.CTSUERRS.Reg)&^(0x7fff)|value)
}
func (o *CTSU_Type) GetCTSUERRS_Reserved() uint16 {
	return volatile.LoadUint16(&o.CTSUERRS.Reg) & 0x7fff
}

// OperationalAmplifier
type OPAMP_Type struct {
	AMPMC   volatile.Register8 // 0x0
	AMPTRM  volatile.Register8 // 0x1
	AMPTRS  volatile.Register8 // 0x2
	AMPC    volatile.Register8 // 0x3
	AMPMON  volatile.Register8 // 0x4
	_       byte
	AMP0OS  volatile.Register8 // 0x6
	AMP0MS  volatile.Register8 // 0x7
	AMP0PS  volatile.Register8 // 0x8
	_       byte
	AMP1MS  volatile.Register8 // 0xA
	AMP1PS  volatile.Register8 // 0xB
	_       byte
	AMP2MS  volatile.Register8 // 0xD
	AMP2PS  volatile.Register8 // 0xE
	_       [3]byte
	AMPCPC  volatile.Register8 // 0x12
	_       [4]byte
	AMPUOTE volatile.Register8 // 0x17
	AMP0OTP volatile.Register8 // 0x18
	AMP0OTN volatile.Register8 // 0x19
	AMP1OTP volatile.Register8 // 0x1A
	AMP1OTN volatile.Register8 // 0x1B
	AMP2OTP volatile.Register8 // 0x1C
	AMP2OTN volatile.Register8 // 0x1D
}

// OPAMP.AMPMC: Operational amplifier mode control register
func (o *OPAMP_Type) SetAMPMC_AMPSP(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0xc0)|value<<6)
}
func (o *OPAMP_Type) GetAMPMC_AMPSP() uint8 {
	return (volatile.LoadUint8(&o.AMPMC.Reg) & 0xc0) >> 6
}
func (o *OPAMP_Type) SetAMPMC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPMC.Reg, volatile.LoadUint8(&o.AMPMC.Reg)&^(0x3f)|value)
}
func (o *OPAMP_Type) GetAMPMC_Reserved() uint8 {
	return volatile.LoadUint8(&o.AMPMC.Reg) & 0x3f
}

// OPAMP.AMPTRM: Operational amplifier trigger mode control register
func (o *OPAMP_Type) SetAMPTRM_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0xc0)|value<<6)
}
func (o *OPAMP_Type) GetAMPTRM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0xc0) >> 6
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM21(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x20)|value<<5)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM21() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x20) >> 5
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM20(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x10)|value<<4)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM20() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x10) >> 4
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM11(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM11() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM10(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM10() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM01(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM01() uint8 {
	return (volatile.LoadUint8(&o.AMPTRM.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPTRM_AMPTRM00(value uint8) {
	volatile.StoreUint8(&o.AMPTRM.Reg, volatile.LoadUint8(&o.AMPTRM.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPTRM_AMPTRM00() uint8 {
	return volatile.LoadUint8(&o.AMPTRM.Reg) & 0x1
}

// OPAMP.AMPTRS: Operational Amplifier Activation Trigger Select Register
func (o *OPAMP_Type) SetAMPTRS(value uint8) {
	volatile.StoreUint8(&o.AMPTRS.Reg, volatile.LoadUint8(&o.AMPTRS.Reg)&^(0x3)|value)
}
func (o *OPAMP_Type) GetAMPTRS() uint8 {
	return volatile.LoadUint8(&o.AMPTRS.Reg) & 0x3
}

// OPAMP.AMPC: Operational amplifier control register
func (o *OPAMP_Type) SetAMPC_IREFE(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMPC_IREFE() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMPC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x78)|value<<3)
}
func (o *OPAMP_Type) GetAMPC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x78) >> 3
}
func (o *OPAMP_Type) SetAMPC_AMPE2(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPC_AMPE2() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPC_AMPE1(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPC_AMPE1() uint8 {
	return (volatile.LoadUint8(&o.AMPC.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPC_AMPE0(value uint8) {
	volatile.StoreUint8(&o.AMPC.Reg, volatile.LoadUint8(&o.AMPC.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPC_AMPE0() uint8 {
	return volatile.LoadUint8(&o.AMPC.Reg) & 0x1
}

// OPAMP.AMPMON: Operational amplifier monitor register
func (o *OPAMP_Type) SetAMPMON_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0xf8)|value<<3)
}
func (o *OPAMP_Type) GetAMPMON_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0xf8) >> 3
}
func (o *OPAMP_Type) SetAMPMON_AMPMON2(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON2() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPMON_AMPMON1(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON1() uint8 {
	return (volatile.LoadUint8(&o.AMPMON.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPMON_AMPMON0(value uint8) {
	volatile.StoreUint8(&o.AMPMON.Reg, volatile.LoadUint8(&o.AMPMON.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPMON_AMPMON0() uint8 {
	return volatile.LoadUint8(&o.AMPMON.Reg) & 0x1
}

// OPAMP.AMP0OS: Operational Amplifier 0 Output Select Register
func (o *OPAMP_Type) SetAMP0OS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP0OS.Reg, volatile.LoadUint8(&o.AMP0OS.Reg)&^(0xf0)|value<<4)
}
func (o *OPAMP_Type) GetAMP0OS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP0OS.Reg) & 0xf0) >> 4
}
func (o *OPAMP_Type) SetAMP0OS_AMPOS3(value uint8) {
	volatile.StoreUint8(&o.AMP0OS.Reg, volatile.LoadUint8(&o.AMP0OS.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMP0OS_AMPOS3() uint8 {
	return (volatile.LoadUint8(&o.AMP0OS.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMP0OS_AMPOS2(value uint8) {
	volatile.StoreUint8(&o.AMP0OS.Reg, volatile.LoadUint8(&o.AMP0OS.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMP0OS_AMPOS2() uint8 {
	return (volatile.LoadUint8(&o.AMP0OS.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMP0OS_AMPOS1(value uint8) {
	volatile.StoreUint8(&o.AMP0OS.Reg, volatile.LoadUint8(&o.AMP0OS.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMP0OS_AMPOS1() uint8 {
	return (volatile.LoadUint8(&o.AMP0OS.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMP0OS_AMPOS0(value uint8) {
	volatile.StoreUint8(&o.AMP0OS.Reg, volatile.LoadUint8(&o.AMP0OS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP0OS_AMPOS0() uint8 {
	return volatile.LoadUint8(&o.AMP0OS.Reg) & 0x1
}

// OPAMP.AMP0MS: Operational Amplifier 0 Minus Input Select Register
func (o *OPAMP_Type) SetAMP0MS_AMPMS7(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS7() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP0MS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x60)|value<<5)
}
func (o *OPAMP_Type) GetAMP0MS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x60) >> 5
}
func (o *OPAMP_Type) SetAMP0MS_AMPMS4(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x10)|value<<4)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS4() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x10) >> 4
}
func (o *OPAMP_Type) SetAMP0MS_AMPMS3(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS3() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMP0MS_AMPMS2(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS2() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMP0MS_AMPMS1(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS1() uint8 {
	return (volatile.LoadUint8(&o.AMP0MS.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMP0MS_AMPMS0(value uint8) {
	volatile.StoreUint8(&o.AMP0MS.Reg, volatile.LoadUint8(&o.AMP0MS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP0MS_AMPMS0() uint8 {
	return volatile.LoadUint8(&o.AMP0MS.Reg) & 0x1
}

// OPAMP.AMP0PS: Operational Amplifier 0 Plus Input Select Register
func (o *OPAMP_Type) SetAMP0PS_AMPMS7(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP0PS_AMPMS7() uint8 {
	return (volatile.LoadUint8(&o.AMP0PS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP0PS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x70)|value<<4)
}
func (o *OPAMP_Type) GetAMP0PS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP0PS.Reg) & 0x70) >> 4
}
func (o *OPAMP_Type) SetAMP0PS_AMPPS3(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMP0PS_AMPPS3() uint8 {
	return (volatile.LoadUint8(&o.AMP0PS.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMP0PS_AMPPS2(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMP0PS_AMPPS2() uint8 {
	return (volatile.LoadUint8(&o.AMP0PS.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMP0PS_AMPPS1(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMP0PS_AMPPS1() uint8 {
	return (volatile.LoadUint8(&o.AMP0PS.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMP0PS_AMPPS0(value uint8) {
	volatile.StoreUint8(&o.AMP0PS.Reg, volatile.LoadUint8(&o.AMP0PS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP0PS_AMPPS0() uint8 {
	return volatile.LoadUint8(&o.AMP0PS.Reg) & 0x1
}

// OPAMP.AMP1MS: Operational Amplifier 1 Minus Input Select Register
func (o *OPAMP_Type) SetAMP1MS_AMPMS7(value uint8) {
	volatile.StoreUint8(&o.AMP1MS.Reg, volatile.LoadUint8(&o.AMP1MS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP1MS_AMPMS7() uint8 {
	return (volatile.LoadUint8(&o.AMP1MS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP1MS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP1MS.Reg, volatile.LoadUint8(&o.AMP1MS.Reg)&^(0x7e)|value<<1)
}
func (o *OPAMP_Type) GetAMP1MS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP1MS.Reg) & 0x7e) >> 1
}
func (o *OPAMP_Type) SetAMP1MS_AMPMS0(value uint8) {
	volatile.StoreUint8(&o.AMP1MS.Reg, volatile.LoadUint8(&o.AMP1MS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP1MS_AMPMS0() uint8 {
	return volatile.LoadUint8(&o.AMP1MS.Reg) & 0x1
}

// OPAMP.AMP1PS: Operational Amplifier 1 Plus Input Select Register
func (o *OPAMP_Type) SetAMP1PS_AMPMS7(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP1PS_AMPMS7() uint8 {
	return (volatile.LoadUint8(&o.AMP1PS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP1PS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x70)|value<<4)
}
func (o *OPAMP_Type) GetAMP1PS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP1PS.Reg) & 0x70) >> 4
}
func (o *OPAMP_Type) SetAMP1PS_AMPPS3(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x8)|value<<3)
}
func (o *OPAMP_Type) GetAMP1PS_AMPPS3() uint8 {
	return (volatile.LoadUint8(&o.AMP1PS.Reg) & 0x8) >> 3
}
func (o *OPAMP_Type) SetAMP1PS_AMPPS2(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMP1PS_AMPPS2() uint8 {
	return (volatile.LoadUint8(&o.AMP1PS.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMP1PS_AMPPS1(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMP1PS_AMPPS1() uint8 {
	return (volatile.LoadUint8(&o.AMP1PS.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMP1PS_AMPPS0(value uint8) {
	volatile.StoreUint8(&o.AMP1PS.Reg, volatile.LoadUint8(&o.AMP1PS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP1PS_AMPPS0() uint8 {
	return volatile.LoadUint8(&o.AMP1PS.Reg) & 0x1
}

// OPAMP.AMP2MS: Operational Amplifier 2 Minus Input Select Register
func (o *OPAMP_Type) SetAMP2MS_AMPMS7(value uint8) {
	volatile.StoreUint8(&o.AMP2MS.Reg, volatile.LoadUint8(&o.AMP2MS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP2MS_AMPMS7() uint8 {
	return (volatile.LoadUint8(&o.AMP2MS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP2MS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP2MS.Reg, volatile.LoadUint8(&o.AMP2MS.Reg)&^(0x7e)|value<<1)
}
func (o *OPAMP_Type) GetAMP2MS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP2MS.Reg) & 0x7e) >> 1
}
func (o *OPAMP_Type) SetAMP2MS_AMPMS0(value uint8) {
	volatile.StoreUint8(&o.AMP2MS.Reg, volatile.LoadUint8(&o.AMP2MS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP2MS_AMPMS0() uint8 {
	return volatile.LoadUint8(&o.AMP2MS.Reg) & 0x1
}

// OPAMP.AMP2PS: Operational Amplifier 2 Plus Input Select Register
func (o *OPAMP_Type) SetAMP2PS_AMPPS7(value uint8) {
	volatile.StoreUint8(&o.AMP2PS.Reg, volatile.LoadUint8(&o.AMP2PS.Reg)&^(0x80)|value<<7)
}
func (o *OPAMP_Type) GetAMP2PS_AMPPS7() uint8 {
	return (volatile.LoadUint8(&o.AMP2PS.Reg) & 0x80) >> 7
}
func (o *OPAMP_Type) SetAMP2PS_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP2PS.Reg, volatile.LoadUint8(&o.AMP2PS.Reg)&^(0x7c)|value<<2)
}
func (o *OPAMP_Type) GetAMP2PS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP2PS.Reg) & 0x7c) >> 2
}
func (o *OPAMP_Type) SetAMP2PS_AMPPS1(value uint8) {
	volatile.StoreUint8(&o.AMP2PS.Reg, volatile.LoadUint8(&o.AMP2PS.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMP2PS_AMPPS1() uint8 {
	return (volatile.LoadUint8(&o.AMP2PS.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMP2PS_AMPPS0(value uint8) {
	volatile.StoreUint8(&o.AMP2PS.Reg, volatile.LoadUint8(&o.AMP2PS.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMP2PS_AMPPS0() uint8 {
	return volatile.LoadUint8(&o.AMP2PS.Reg) & 0x1
}

// OPAMP.AMPCPC: Operational Amplifier Switch Charge Pump Control Register
func (o *OPAMP_Type) SetAMPCPC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPCPC.Reg, volatile.LoadUint8(&o.AMPCPC.Reg)&^(0xf8)|value<<3)
}
func (o *OPAMP_Type) GetAMPCPC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPCPC.Reg) & 0xf8) >> 3
}
func (o *OPAMP_Type) SetAMPCPC_PUMP2EN(value uint8) {
	volatile.StoreUint8(&o.AMPCPC.Reg, volatile.LoadUint8(&o.AMPCPC.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPCPC_PUMP2EN() uint8 {
	return (volatile.LoadUint8(&o.AMPCPC.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPCPC_PUMP1EN(value uint8) {
	volatile.StoreUint8(&o.AMPCPC.Reg, volatile.LoadUint8(&o.AMPCPC.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPCPC_PUMP1EN() uint8 {
	return (volatile.LoadUint8(&o.AMPCPC.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPCPC_PUMP0EN(value uint8) {
	volatile.StoreUint8(&o.AMPCPC.Reg, volatile.LoadUint8(&o.AMPCPC.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPCPC_PUMP0EN() uint8 {
	return volatile.LoadUint8(&o.AMPCPC.Reg) & 0x1
}

// OPAMP.AMPUOTE: Operational Amplifier User Offset Trimming Enable Register
func (o *OPAMP_Type) SetAMPUOTE_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMPUOTE.Reg, volatile.LoadUint8(&o.AMPUOTE.Reg)&^(0xf8)|value<<3)
}
func (o *OPAMP_Type) GetAMPUOTE_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMPUOTE.Reg) & 0xf8) >> 3
}
func (o *OPAMP_Type) SetAMPUOTE_AMP2TE(value uint8) {
	volatile.StoreUint8(&o.AMPUOTE.Reg, volatile.LoadUint8(&o.AMPUOTE.Reg)&^(0x4)|value<<2)
}
func (o *OPAMP_Type) GetAMPUOTE_AMP2TE() uint8 {
	return (volatile.LoadUint8(&o.AMPUOTE.Reg) & 0x4) >> 2
}
func (o *OPAMP_Type) SetAMPUOTE_AMP1TE(value uint8) {
	volatile.StoreUint8(&o.AMPUOTE.Reg, volatile.LoadUint8(&o.AMPUOTE.Reg)&^(0x2)|value<<1)
}
func (o *OPAMP_Type) GetAMPUOTE_AMP1TE() uint8 {
	return (volatile.LoadUint8(&o.AMPUOTE.Reg) & 0x2) >> 1
}
func (o *OPAMP_Type) SetAMPUOTE_AMP0TE(value uint8) {
	volatile.StoreUint8(&o.AMPUOTE.Reg, volatile.LoadUint8(&o.AMPUOTE.Reg)&^(0x1)|value)
}
func (o *OPAMP_Type) GetAMPUOTE_AMP0TE() uint8 {
	return volatile.LoadUint8(&o.AMPUOTE.Reg) & 0x1
}

// OPAMP.AMP0OTP: Operational Amplifier 0 Offset Trimming Pch Register
func (o *OPAMP_Type) SetAMP0OTP_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP0OTP.Reg, volatile.LoadUint8(&o.AMP0OTP.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP0OTP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP0OTP.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP0OTP_TRMP(value uint8) {
	volatile.StoreUint8(&o.AMP0OTP.Reg, volatile.LoadUint8(&o.AMP0OTP.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP0OTP_TRMP() uint8 {
	return volatile.LoadUint8(&o.AMP0OTP.Reg) & 0x1f
}

// OPAMP.AMP0OTN: Operational Amplifier 0 Offset Trimming Nch Register
func (o *OPAMP_Type) SetAMP0OTN_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP0OTN.Reg, volatile.LoadUint8(&o.AMP0OTN.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP0OTN_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP0OTN.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP0OTN_TRMN(value uint8) {
	volatile.StoreUint8(&o.AMP0OTN.Reg, volatile.LoadUint8(&o.AMP0OTN.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP0OTN_TRMN() uint8 {
	return volatile.LoadUint8(&o.AMP0OTN.Reg) & 0x1f
}

// OPAMP.AMP1OTP: Operational Amplifier 1 Offset Trimming Pch Register
func (o *OPAMP_Type) SetAMP1OTP_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP1OTP.Reg, volatile.LoadUint8(&o.AMP1OTP.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP1OTP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP1OTP.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP1OTP_TRMP(value uint8) {
	volatile.StoreUint8(&o.AMP1OTP.Reg, volatile.LoadUint8(&o.AMP1OTP.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP1OTP_TRMP() uint8 {
	return volatile.LoadUint8(&o.AMP1OTP.Reg) & 0x1f
}

// OPAMP.AMP1OTN: Operational Amplifier 1 Offset Trimming Nch Register
func (o *OPAMP_Type) SetAMP1OTN_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP1OTN.Reg, volatile.LoadUint8(&o.AMP1OTN.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP1OTN_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP1OTN.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP1OTN_TRMN(value uint8) {
	volatile.StoreUint8(&o.AMP1OTN.Reg, volatile.LoadUint8(&o.AMP1OTN.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP1OTN_TRMN() uint8 {
	return volatile.LoadUint8(&o.AMP1OTN.Reg) & 0x1f
}

// OPAMP.AMP2OTP: Operational Amplifier 2 Offset Trimming Pch Register
func (o *OPAMP_Type) SetAMP2OTP_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP2OTP.Reg, volatile.LoadUint8(&o.AMP2OTP.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP2OTP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP2OTP.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP2OTP_TRMP(value uint8) {
	volatile.StoreUint8(&o.AMP2OTP.Reg, volatile.LoadUint8(&o.AMP2OTP.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP2OTP_TRMP() uint8 {
	return volatile.LoadUint8(&o.AMP2OTP.Reg) & 0x1f
}

// OPAMP.AMP2OTN: Operational Amplifier 2 Offset Trimming Nch Register
func (o *OPAMP_Type) SetAMP2OTN_Reserved(value uint8) {
	volatile.StoreUint8(&o.AMP2OTN.Reg, volatile.LoadUint8(&o.AMP2OTN.Reg)&^(0xe0)|value<<5)
}
func (o *OPAMP_Type) GetAMP2OTN_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AMP2OTN.Reg) & 0xe0) >> 5
}
func (o *OPAMP_Type) SetAMP2OTN_TRMN(value uint8) {
	volatile.StoreUint8(&o.AMP2OTN.Reg, volatile.LoadUint8(&o.AMP2OTN.Reg)&^(0x1f)|value)
}
func (o *OPAMP_Type) GetAMP2OTN_TRMN() uint8 {
	return volatile.LoadUint8(&o.AMP2OTN.Reg) & 0x1f
}

// 24-Bit Sigma-Delta A/D Converter
type SDADC24_Type struct {
	STC1   volatile.Register16 // 0x0
	_      [2]byte
	STC2   volatile.Register8 // 0x4
	_      [3]byte
	PGAC0  volatile.Register32 // 0x8
	PGAC1  volatile.Register32 // 0xC
	PGAC2  volatile.Register32 // 0x10
	PGAC3  volatile.Register32 // 0x14
	PGAC4  volatile.Register32 // 0x18
	ADC1   volatile.Register32 // 0x1C
	ADC2   volatile.Register8  // 0x20
	_      [3]byte
	ADCR   volatile.Register32 // 0x24
	ADAR   volatile.Register32 // 0x28
	_      [4]byte
	CLBC   volatile.Register8 // 0x30
	_      [3]byte
	CLBSTR volatile.Register8 // 0x34
	_      [7]byte
	CLBSSR volatile.Register8 // 0x3C
}

// SDADC24.STC1: Startup Control Register 1
func (o *SDADC24_Type) SetSTC1_VREFSEL(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetSTC1_VREFSEL() uint16 {
	return (volatile.LoadUint16(&o.STC1.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetSTC1_Reserved(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0x7000)|value<<12)
}
func (o *SDADC24_Type) GetSTC1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.STC1.Reg) & 0x7000) >> 12
}
func (o *SDADC24_Type) SetSTC1_VSBIAS(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0xf00)|value<<8)
}
func (o *SDADC24_Type) GetSTC1_VSBIAS() uint16 {
	return (volatile.LoadUint16(&o.STC1.Reg) & 0xf00) >> 8
}
func (o *SDADC24_Type) SetSTC1_SDADLPM(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0x80)|value<<7)
}
func (o *SDADC24_Type) GetSTC1_SDADLPM() uint16 {
	return (volatile.LoadUint16(&o.STC1.Reg) & 0x80) >> 7
}
func (o *SDADC24_Type) SetSTC1_Reserved(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0x70)|value<<4)
}
func (o *SDADC24_Type) GetSTC1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.STC1.Reg) & 0x70) >> 4
}
func (o *SDADC24_Type) SetSTC1_CLKDIV(value uint16) {
	volatile.StoreUint16(&o.STC1.Reg, volatile.LoadUint16(&o.STC1.Reg)&^(0xf)|value)
}
func (o *SDADC24_Type) GetSTC1_CLKDIV() uint16 {
	return volatile.LoadUint16(&o.STC1.Reg) & 0xf
}

// SDADC24.STC2: Startup Control Register 2
func (o *SDADC24_Type) SetSTC2_Reserved(value uint8) {
	volatile.StoreUint8(&o.STC2.Reg, volatile.LoadUint8(&o.STC2.Reg)&^(0xf8)|value<<3)
}
func (o *SDADC24_Type) GetSTC2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.STC2.Reg) & 0xf8) >> 3
}
func (o *SDADC24_Type) SetSTC2_ADFPWDS(value uint8) {
	volatile.StoreUint8(&o.STC2.Reg, volatile.LoadUint8(&o.STC2.Reg)&^(0x4)|value<<2)
}
func (o *SDADC24_Type) GetSTC2_ADFPWDS() uint8 {
	return (volatile.LoadUint8(&o.STC2.Reg) & 0x4) >> 2
}
func (o *SDADC24_Type) SetSTC2_ADCPON(value uint8) {
	volatile.StoreUint8(&o.STC2.Reg, volatile.LoadUint8(&o.STC2.Reg)&^(0x2)|value<<1)
}
func (o *SDADC24_Type) GetSTC2_ADCPON() uint8 {
	return (volatile.LoadUint8(&o.STC2.Reg) & 0x2) >> 1
}
func (o *SDADC24_Type) SetSTC2_BGRPON(value uint8) {
	volatile.StoreUint8(&o.STC2.Reg, volatile.LoadUint8(&o.STC2.Reg)&^(0x1)|value)
}
func (o *SDADC24_Type) GetSTC2_BGRPON() uint8 {
	return volatile.LoadUint8(&o.STC2.Reg) & 0x1
}

// SDADC24.PGAC0: Input Multiplexer %s Setting Register
func (o *SDADC24_Type) SetPGAC0_PGAASN(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x80000000)|value<<31)
}
func (o *SDADC24_Type) GetPGAC0_PGAASN() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x80000000) >> 31
}
func (o *SDADC24_Type) SetPGAC0_PGACVE(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x40000000)|value<<30)
}
func (o *SDADC24_Type) GetPGAC0_PGACVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x40000000) >> 30
}
func (o *SDADC24_Type) SetPGAC0_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x20000000)|value<<29)
}
func (o *SDADC24_Type) GetPGAC0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x20000000) >> 29
}
func (o *SDADC24_Type) SetPGAC0_PGAREV(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x10000000)|value<<28)
}
func (o *SDADC24_Type) GetPGAC0_PGAREV() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x10000000) >> 28
}
func (o *SDADC24_Type) SetPGAC0_PGAAVE(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0xc000000)|value<<26)
}
func (o *SDADC24_Type) GetPGAC0_PGAAVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0xc000000) >> 26
}
func (o *SDADC24_Type) SetPGAC0_PGAAVN(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x3000000)|value<<24)
}
func (o *SDADC24_Type) GetPGAC0_PGAAVN() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x3000000) >> 24
}
func (o *SDADC24_Type) SetPGAC0_PGACTN(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0xe00000)|value<<21)
}
func (o *SDADC24_Type) GetPGAC0_PGACTN() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0xe00000) >> 21
}
func (o *SDADC24_Type) SetPGAC0_PGACTM(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDADC24_Type) GetPGAC0_PGACTM() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x1f0000) >> 16
}
func (o *SDADC24_Type) SetPGAC0_PGASEL(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetPGAC0_PGASEL() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetPGAC0_PGAPOL(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x4000)|value<<14)
}
func (o *SDADC24_Type) GetPGAC0_PGAPOL() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x4000) >> 14
}
func (o *SDADC24_Type) SetPGAC0_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x2000)|value<<13)
}
func (o *SDADC24_Type) GetPGAC0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x2000) >> 13
}
func (o *SDADC24_Type) SetPGAC0_PGAOFS(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetPGAC0_PGAOFS() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetPGAC0_PGAOSR(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetPGAC0_PGAOSR() uint32 {
	return (volatile.LoadUint32(&o.PGAC0.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetPGAC0_PGAGC(value uint32) {
	volatile.StoreUint32(&o.PGAC0.Reg, volatile.LoadUint32(&o.PGAC0.Reg)&^(0x1f)|value)
}
func (o *SDADC24_Type) GetPGAC0_PGAGC() uint32 {
	return volatile.LoadUint32(&o.PGAC0.Reg) & 0x1f
}

// SDADC24.PGAC1: Input Multiplexer %s Setting Register
func (o *SDADC24_Type) SetPGAC1_PGAASN(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x80000000)|value<<31)
}
func (o *SDADC24_Type) GetPGAC1_PGAASN() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x80000000) >> 31
}
func (o *SDADC24_Type) SetPGAC1_PGACVE(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x40000000)|value<<30)
}
func (o *SDADC24_Type) GetPGAC1_PGACVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x40000000) >> 30
}
func (o *SDADC24_Type) SetPGAC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x20000000)|value<<29)
}
func (o *SDADC24_Type) GetPGAC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x20000000) >> 29
}
func (o *SDADC24_Type) SetPGAC1_PGAREV(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x10000000)|value<<28)
}
func (o *SDADC24_Type) GetPGAC1_PGAREV() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x10000000) >> 28
}
func (o *SDADC24_Type) SetPGAC1_PGAAVE(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0xc000000)|value<<26)
}
func (o *SDADC24_Type) GetPGAC1_PGAAVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0xc000000) >> 26
}
func (o *SDADC24_Type) SetPGAC1_PGAAVN(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x3000000)|value<<24)
}
func (o *SDADC24_Type) GetPGAC1_PGAAVN() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x3000000) >> 24
}
func (o *SDADC24_Type) SetPGAC1_PGACTN(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0xe00000)|value<<21)
}
func (o *SDADC24_Type) GetPGAC1_PGACTN() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0xe00000) >> 21
}
func (o *SDADC24_Type) SetPGAC1_PGACTM(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDADC24_Type) GetPGAC1_PGACTM() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x1f0000) >> 16
}
func (o *SDADC24_Type) SetPGAC1_PGASEL(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetPGAC1_PGASEL() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetPGAC1_PGAPOL(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x4000)|value<<14)
}
func (o *SDADC24_Type) GetPGAC1_PGAPOL() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x4000) >> 14
}
func (o *SDADC24_Type) SetPGAC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x2000)|value<<13)
}
func (o *SDADC24_Type) GetPGAC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x2000) >> 13
}
func (o *SDADC24_Type) SetPGAC1_PGAOFS(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetPGAC1_PGAOFS() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetPGAC1_PGAOSR(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetPGAC1_PGAOSR() uint32 {
	return (volatile.LoadUint32(&o.PGAC1.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetPGAC1_PGAGC(value uint32) {
	volatile.StoreUint32(&o.PGAC1.Reg, volatile.LoadUint32(&o.PGAC1.Reg)&^(0x1f)|value)
}
func (o *SDADC24_Type) GetPGAC1_PGAGC() uint32 {
	return volatile.LoadUint32(&o.PGAC1.Reg) & 0x1f
}

// SDADC24.PGAC2: Input Multiplexer %s Setting Register
func (o *SDADC24_Type) SetPGAC2_PGAASN(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x80000000)|value<<31)
}
func (o *SDADC24_Type) GetPGAC2_PGAASN() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x80000000) >> 31
}
func (o *SDADC24_Type) SetPGAC2_PGACVE(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x40000000)|value<<30)
}
func (o *SDADC24_Type) GetPGAC2_PGACVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x40000000) >> 30
}
func (o *SDADC24_Type) SetPGAC2_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x20000000)|value<<29)
}
func (o *SDADC24_Type) GetPGAC2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x20000000) >> 29
}
func (o *SDADC24_Type) SetPGAC2_PGAREV(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x10000000)|value<<28)
}
func (o *SDADC24_Type) GetPGAC2_PGAREV() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x10000000) >> 28
}
func (o *SDADC24_Type) SetPGAC2_PGAAVE(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0xc000000)|value<<26)
}
func (o *SDADC24_Type) GetPGAC2_PGAAVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0xc000000) >> 26
}
func (o *SDADC24_Type) SetPGAC2_PGAAVN(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x3000000)|value<<24)
}
func (o *SDADC24_Type) GetPGAC2_PGAAVN() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x3000000) >> 24
}
func (o *SDADC24_Type) SetPGAC2_PGACTN(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0xe00000)|value<<21)
}
func (o *SDADC24_Type) GetPGAC2_PGACTN() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0xe00000) >> 21
}
func (o *SDADC24_Type) SetPGAC2_PGACTM(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDADC24_Type) GetPGAC2_PGACTM() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x1f0000) >> 16
}
func (o *SDADC24_Type) SetPGAC2_PGASEL(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetPGAC2_PGASEL() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetPGAC2_PGAPOL(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x4000)|value<<14)
}
func (o *SDADC24_Type) GetPGAC2_PGAPOL() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x4000) >> 14
}
func (o *SDADC24_Type) SetPGAC2_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x2000)|value<<13)
}
func (o *SDADC24_Type) GetPGAC2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x2000) >> 13
}
func (o *SDADC24_Type) SetPGAC2_PGAOFS(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetPGAC2_PGAOFS() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetPGAC2_PGAOSR(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetPGAC2_PGAOSR() uint32 {
	return (volatile.LoadUint32(&o.PGAC2.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetPGAC2_PGAGC(value uint32) {
	volatile.StoreUint32(&o.PGAC2.Reg, volatile.LoadUint32(&o.PGAC2.Reg)&^(0x1f)|value)
}
func (o *SDADC24_Type) GetPGAC2_PGAGC() uint32 {
	return volatile.LoadUint32(&o.PGAC2.Reg) & 0x1f
}

// SDADC24.PGAC3: Input Multiplexer %s Setting Register
func (o *SDADC24_Type) SetPGAC3_PGAASN(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x80000000)|value<<31)
}
func (o *SDADC24_Type) GetPGAC3_PGAASN() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x80000000) >> 31
}
func (o *SDADC24_Type) SetPGAC3_PGACVE(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x40000000)|value<<30)
}
func (o *SDADC24_Type) GetPGAC3_PGACVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x40000000) >> 30
}
func (o *SDADC24_Type) SetPGAC3_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x20000000)|value<<29)
}
func (o *SDADC24_Type) GetPGAC3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x20000000) >> 29
}
func (o *SDADC24_Type) SetPGAC3_PGAREV(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x10000000)|value<<28)
}
func (o *SDADC24_Type) GetPGAC3_PGAREV() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x10000000) >> 28
}
func (o *SDADC24_Type) SetPGAC3_PGAAVE(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0xc000000)|value<<26)
}
func (o *SDADC24_Type) GetPGAC3_PGAAVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0xc000000) >> 26
}
func (o *SDADC24_Type) SetPGAC3_PGAAVN(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x3000000)|value<<24)
}
func (o *SDADC24_Type) GetPGAC3_PGAAVN() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x3000000) >> 24
}
func (o *SDADC24_Type) SetPGAC3_PGACTN(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0xe00000)|value<<21)
}
func (o *SDADC24_Type) GetPGAC3_PGACTN() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0xe00000) >> 21
}
func (o *SDADC24_Type) SetPGAC3_PGACTM(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDADC24_Type) GetPGAC3_PGACTM() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x1f0000) >> 16
}
func (o *SDADC24_Type) SetPGAC3_PGASEL(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetPGAC3_PGASEL() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetPGAC3_PGAPOL(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x4000)|value<<14)
}
func (o *SDADC24_Type) GetPGAC3_PGAPOL() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x4000) >> 14
}
func (o *SDADC24_Type) SetPGAC3_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x2000)|value<<13)
}
func (o *SDADC24_Type) GetPGAC3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x2000) >> 13
}
func (o *SDADC24_Type) SetPGAC3_PGAOFS(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetPGAC3_PGAOFS() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetPGAC3_PGAOSR(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetPGAC3_PGAOSR() uint32 {
	return (volatile.LoadUint32(&o.PGAC3.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetPGAC3_PGAGC(value uint32) {
	volatile.StoreUint32(&o.PGAC3.Reg, volatile.LoadUint32(&o.PGAC3.Reg)&^(0x1f)|value)
}
func (o *SDADC24_Type) GetPGAC3_PGAGC() uint32 {
	return volatile.LoadUint32(&o.PGAC3.Reg) & 0x1f
}

// SDADC24.PGAC4: Input Multiplexer %s Setting Register
func (o *SDADC24_Type) SetPGAC4_PGAASN(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x80000000)|value<<31)
}
func (o *SDADC24_Type) GetPGAC4_PGAASN() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x80000000) >> 31
}
func (o *SDADC24_Type) SetPGAC4_PGACVE(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x40000000)|value<<30)
}
func (o *SDADC24_Type) GetPGAC4_PGACVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x40000000) >> 30
}
func (o *SDADC24_Type) SetPGAC4_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x20000000)|value<<29)
}
func (o *SDADC24_Type) GetPGAC4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x20000000) >> 29
}
func (o *SDADC24_Type) SetPGAC4_PGAREV(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x10000000)|value<<28)
}
func (o *SDADC24_Type) GetPGAC4_PGAREV() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x10000000) >> 28
}
func (o *SDADC24_Type) SetPGAC4_PGAAVE(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0xc000000)|value<<26)
}
func (o *SDADC24_Type) GetPGAC4_PGAAVE() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0xc000000) >> 26
}
func (o *SDADC24_Type) SetPGAC4_PGAAVN(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x3000000)|value<<24)
}
func (o *SDADC24_Type) GetPGAC4_PGAAVN() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x3000000) >> 24
}
func (o *SDADC24_Type) SetPGAC4_PGACTN(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0xe00000)|value<<21)
}
func (o *SDADC24_Type) GetPGAC4_PGACTN() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0xe00000) >> 21
}
func (o *SDADC24_Type) SetPGAC4_PGACTM(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x1f0000)|value<<16)
}
func (o *SDADC24_Type) GetPGAC4_PGACTM() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x1f0000) >> 16
}
func (o *SDADC24_Type) SetPGAC4_PGASEL(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x8000)|value<<15)
}
func (o *SDADC24_Type) GetPGAC4_PGASEL() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x8000) >> 15
}
func (o *SDADC24_Type) SetPGAC4_PGAPOL(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x4000)|value<<14)
}
func (o *SDADC24_Type) GetPGAC4_PGAPOL() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x4000) >> 14
}
func (o *SDADC24_Type) SetPGAC4_Reserved(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x2000)|value<<13)
}
func (o *SDADC24_Type) GetPGAC4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x2000) >> 13
}
func (o *SDADC24_Type) SetPGAC4_PGAOFS(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetPGAC4_PGAOFS() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetPGAC4_PGAOSR(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetPGAC4_PGAOSR() uint32 {
	return (volatile.LoadUint32(&o.PGAC4.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetPGAC4_PGAGC(value uint32) {
	volatile.StoreUint32(&o.PGAC4.Reg, volatile.LoadUint32(&o.PGAC4.Reg)&^(0x1f)|value)
}
func (o *SDADC24_Type) GetPGAC4_PGAGC() uint32 {
	return volatile.LoadUint32(&o.PGAC4.Reg) & 0x1f
}

// SDADC24.ADC1: Sigma-delta A/D Converter Control Register 1
func (o *SDADC24_Type) SetADC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0xffe00000)|value<<21)
}
func (o *SDADC24_Type) GetADC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0xffe00000) >> 21
}
func (o *SDADC24_Type) SetADC1_PGASLFT(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x100000)|value<<20)
}
func (o *SDADC24_Type) GetADC1_PGASLFT() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0x100000) >> 20
}
func (o *SDADC24_Type) SetADC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0xc0000)|value<<18)
}
func (o *SDADC24_Type) GetADC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0xc0000) >> 18
}
func (o *SDADC24_Type) SetADC1_PGADISC(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x20000)|value<<17)
}
func (o *SDADC24_Type) GetADC1_PGADISC() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0x20000) >> 17
}
func (o *SDADC24_Type) SetADC1_PGADISA(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x10000)|value<<16)
}
func (o *SDADC24_Type) GetADC1_PGADISA() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0x10000) >> 16
}
func (o *SDADC24_Type) SetADC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0xe000)|value<<13)
}
func (o *SDADC24_Type) GetADC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0xe000) >> 13
}
func (o *SDADC24_Type) SetADC1_SDADBMP(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x1f00)|value<<8)
}
func (o *SDADC24_Type) GetADC1_SDADBMP() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0x1f00) >> 8
}
func (o *SDADC24_Type) SetADC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0xe0)|value<<5)
}
func (o *SDADC24_Type) GetADC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0xe0) >> 5
}
func (o *SDADC24_Type) SetADC1_SDADTMD(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x10)|value<<4)
}
func (o *SDADC24_Type) GetADC1_SDADTMD() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0x10) >> 4
}
func (o *SDADC24_Type) SetADC1_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0xe)|value<<1)
}
func (o *SDADC24_Type) GetADC1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADC1.Reg) & 0xe) >> 1
}
func (o *SDADC24_Type) SetADC1_SDADSCM(value uint32) {
	volatile.StoreUint32(&o.ADC1.Reg, volatile.LoadUint32(&o.ADC1.Reg)&^(0x1)|value)
}
func (o *SDADC24_Type) GetADC1_SDADSCM() uint32 {
	return volatile.LoadUint32(&o.ADC1.Reg) & 0x1
}

// SDADC24.ADC2: Sigma-delta A/D Converter Control Register 2
func (o *SDADC24_Type) SetADC2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ADC2.Reg, volatile.LoadUint8(&o.ADC2.Reg)&^(0xfe)|value<<1)
}
func (o *SDADC24_Type) GetADC2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ADC2.Reg) & 0xfe) >> 1
}
func (o *SDADC24_Type) SetADC2_SDADST(value uint8) {
	volatile.StoreUint8(&o.ADC2.Reg, volatile.LoadUint8(&o.ADC2.Reg)&^(0x1)|value)
}
func (o *SDADC24_Type) GetADC2_SDADST() uint8 {
	return volatile.LoadUint8(&o.ADC2.Reg) & 0x1
}

// SDADC24.ADCR: Sigma-delta A/D Converter Conversion Result Register
func (o *SDADC24_Type) SetADCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADCR.Reg, volatile.LoadUint32(&o.ADCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SDADC24_Type) GetADCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADCR.Reg) & 0xf0000000) >> 28
}
func (o *SDADC24_Type) SetADCR_SDADCRC(value uint32) {
	volatile.StoreUint32(&o.ADCR.Reg, volatile.LoadUint32(&o.ADCR.Reg)&^(0xe000000)|value<<25)
}
func (o *SDADC24_Type) GetADCR_SDADCRC() uint32 {
	return (volatile.LoadUint32(&o.ADCR.Reg) & 0xe000000) >> 25
}
func (o *SDADC24_Type) SetADCR_SDADCRS(value uint32) {
	volatile.StoreUint32(&o.ADCR.Reg, volatile.LoadUint32(&o.ADCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDADC24_Type) GetADCR_SDADCRS() uint32 {
	return (volatile.LoadUint32(&o.ADCR.Reg) & 0x1000000) >> 24
}
func (o *SDADC24_Type) SetADCR_SDADCRD(value uint32) {
	volatile.StoreUint32(&o.ADCR.Reg, volatile.LoadUint32(&o.ADCR.Reg)&^(0xffffff)|value)
}
func (o *SDADC24_Type) GetADCR_SDADCRD() uint32 {
	return volatile.LoadUint32(&o.ADCR.Reg) & 0xffffff
}
func (o *SDADC24_Type) SetADCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADCR.Reg, volatile.LoadUint32(&o.ADCR.Reg)&^(0xffff)|value)
}
func (o *SDADC24_Type) GetADCR_Reserved() uint32 {
	return volatile.LoadUint32(&o.ADCR.Reg) & 0xffff
}

// SDADC24.ADAR: Sigma-delta A/D Converter Average Value Register
func (o *SDADC24_Type) SetADAR_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADAR.Reg, volatile.LoadUint32(&o.ADAR.Reg)&^(0xf0000000)|value<<28)
}
func (o *SDADC24_Type) GetADAR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.ADAR.Reg) & 0xf0000000) >> 28
}
func (o *SDADC24_Type) SetADAR_SDADMVC(value uint32) {
	volatile.StoreUint32(&o.ADAR.Reg, volatile.LoadUint32(&o.ADAR.Reg)&^(0xe000000)|value<<25)
}
func (o *SDADC24_Type) GetADAR_SDADMVC() uint32 {
	return (volatile.LoadUint32(&o.ADAR.Reg) & 0xe000000) >> 25
}
func (o *SDADC24_Type) SetADAR_SDADMVS(value uint32) {
	volatile.StoreUint32(&o.ADAR.Reg, volatile.LoadUint32(&o.ADAR.Reg)&^(0x1000000)|value<<24)
}
func (o *SDADC24_Type) GetADAR_SDADMVS() uint32 {
	return (volatile.LoadUint32(&o.ADAR.Reg) & 0x1000000) >> 24
}
func (o *SDADC24_Type) SetADAR_SDADMVD(value uint32) {
	volatile.StoreUint32(&o.ADAR.Reg, volatile.LoadUint32(&o.ADAR.Reg)&^(0xffffff)|value)
}
func (o *SDADC24_Type) GetADAR_SDADMVD() uint32 {
	return volatile.LoadUint32(&o.ADAR.Reg) & 0xffffff
}
func (o *SDADC24_Type) SetADAR_Reserved(value uint32) {
	volatile.StoreUint32(&o.ADAR.Reg, volatile.LoadUint32(&o.ADAR.Reg)&^(0xffff)|value)
}
func (o *SDADC24_Type) GetADAR_Reserved() uint32 {
	return volatile.LoadUint32(&o.ADAR.Reg) & 0xffff
}

// SDADC24.CLBC: Calibration Control Register
func (o *SDADC24_Type) SetCLBC_Reserved(value uint8) {
	volatile.StoreUint8(&o.CLBC.Reg, volatile.LoadUint8(&o.CLBC.Reg)&^(0xfc)|value<<2)
}
func (o *SDADC24_Type) GetCLBC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CLBC.Reg) & 0xfc) >> 2
}
func (o *SDADC24_Type) SetCLBC_CLBMD(value uint8) {
	volatile.StoreUint8(&o.CLBC.Reg, volatile.LoadUint8(&o.CLBC.Reg)&^(0x3)|value)
}
func (o *SDADC24_Type) GetCLBC_CLBMD() uint8 {
	return volatile.LoadUint8(&o.CLBC.Reg) & 0x3
}

// SDADC24.CLBSTR: Calibration Start Control Register
func (o *SDADC24_Type) SetCLBSTR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CLBSTR.Reg, volatile.LoadUint8(&o.CLBSTR.Reg)&^(0xfe)|value<<1)
}
func (o *SDADC24_Type) GetCLBSTR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CLBSTR.Reg) & 0xfe) >> 1
}
func (o *SDADC24_Type) SetCLBSTR_CLBST(value uint8) {
	volatile.StoreUint8(&o.CLBSTR.Reg, volatile.LoadUint8(&o.CLBSTR.Reg)&^(0x1)|value)
}
func (o *SDADC24_Type) GetCLBSTR_CLBST() uint8 {
	return volatile.LoadUint8(&o.CLBSTR.Reg) & 0x1
}

// SDADC24.CLBSSR: Calibration Status Register
func (o *SDADC24_Type) SetCLBSSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CLBSSR.Reg, volatile.LoadUint8(&o.CLBSSR.Reg)&^(0xfe)|value<<1)
}
func (o *SDADC24_Type) GetCLBSSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CLBSSR.Reg) & 0xfe) >> 1
}
func (o *SDADC24_Type) SetCLBSSR_CLBSS(value uint8) {
	volatile.StoreUint8(&o.CLBSSR.Reg, volatile.LoadUint8(&o.CLBSSR.Reg)&^(0x1)|value)
}
func (o *SDADC24_Type) GetCLBSSR_CLBSS() uint8 {
	return volatile.LoadUint8(&o.CLBSSR.Reg) & 0x1
}

// Temperature Sensor
type TSN_Type struct {
	_      [552]byte
	TSCDRL volatile.Register8 // 0x228
	TSCDRH volatile.Register8 // 0x229
}

// TSN.TSCDRL: Temperature Sensor Calibration Data Register L
func (o *TSN_Type) SetTSCDRL(value uint8) {
	volatile.StoreUint8(&o.TSCDRL.Reg, value)
}
func (o *TSN_Type) GetTSCDRL() uint8 {
	return volatile.LoadUint8(&o.TSCDRL.Reg)
}

// TSN.TSCDRH: Temperature Sensor Calibration Data Register H
func (o *TSN_Type) SetTSCDRH(value uint8) {
	volatile.StoreUint8(&o.TSCDRH.Reg, value)
}
func (o *TSN_Type) GetTSCDRH() uint8 {
	return volatile.LoadUint8(&o.TSCDRH.Reg)
}

// 12-bit D/A converter
type DAC12_Type struct {
	DADR0    volatile.Register16 // 0x0
	_        [2]byte
	DACR     volatile.Register8 // 0x4
	DADPR    volatile.Register8 // 0x5
	DAADSCR  volatile.Register8 // 0x6
	DAVREFCR volatile.Register8 // 0x7
	_        byte
	DAPC     volatile.Register8 // 0x9
}

// DAC12.DADR0: D/A Data Register 0
func (o *DAC12_Type) SetDADR0(value uint16) {
	volatile.StoreUint16(&o.DADR0.Reg, value)
}
func (o *DAC12_Type) GetDADR0() uint16 {
	return volatile.LoadUint16(&o.DADR0.Reg)
}

// DAC12.DACR: D/A Control Register
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDACR_DAOE0(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x40)|value<<6)
}
func (o *DAC12_Type) GetDACR_DAOE0() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x40) >> 6
}
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x20)|value<<5)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACR.Reg) & 0x20) >> 5
}
func (o *DAC12_Type) SetDACR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACR.Reg, volatile.LoadUint8(&o.DACR.Reg)&^(0x1f)|value)
}
func (o *DAC12_Type) GetDACR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DACR.Reg) & 0x1f
}

// DAC12.DADPR: DADR0 Format Select Register
func (o *DAC12_Type) SetDADPR_DPSEL(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDADPR_DPSEL() uint8 {
	return (volatile.LoadUint8(&o.DADPR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDADPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DADPR.Reg, volatile.LoadUint8(&o.DADPR.Reg)&^(0x7f)|value)
}
func (o *DAC12_Type) GetDADPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DADPR.Reg) & 0x7f
}

// DAC12.DAADSCR: D/A-A/D Synchronous Start Control Register
func (o *DAC12_Type) SetDAADSCR_DAADST(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x80)|value<<7)
}
func (o *DAC12_Type) GetDAADSCR_DAADST() uint8 {
	return (volatile.LoadUint8(&o.DAADSCR.Reg) & 0x80) >> 7
}
func (o *DAC12_Type) SetDAADSCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAADSCR.Reg, volatile.LoadUint8(&o.DAADSCR.Reg)&^(0x7f)|value)
}
func (o *DAC12_Type) GetDAADSCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DAADSCR.Reg) & 0x7f
}

// DAC12.DAVREFCR: D/A VREF Control Register
func (o *DAC12_Type) SetDAVREFCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAVREFCR.Reg, volatile.LoadUint8(&o.DAVREFCR.Reg)&^(0xf8)|value<<3)
}
func (o *DAC12_Type) GetDAVREFCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAVREFCR.Reg) & 0xf8) >> 3
}
func (o *DAC12_Type) SetDAVREFCR_REF(value uint8) {
	volatile.StoreUint8(&o.DAVREFCR.Reg, volatile.LoadUint8(&o.DAVREFCR.Reg)&^(0x7)|value)
}
func (o *DAC12_Type) GetDAVREFCR_REF() uint8 {
	return volatile.LoadUint8(&o.DAVREFCR.Reg) & 0x7
}

// DAC12.DAPC: D/A Switch Charge Pump Control Register
func (o *DAC12_Type) SetDAPC_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAPC.Reg, volatile.LoadUint8(&o.DAPC.Reg)&^(0xfe)|value<<1)
}
func (o *DAC12_Type) GetDAPC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAPC.Reg) & 0xfe) >> 1
}
func (o *DAC12_Type) SetDAPC_PUMPEN(value uint8) {
	volatile.StoreUint8(&o.DAPC.Reg, volatile.LoadUint8(&o.DAPC.Reg)&^(0x1)|value)
}
func (o *DAC12_Type) GetDAPC_PUMPEN() uint8 {
	return volatile.LoadUint8(&o.DAPC.Reg) & 0x1
}

// 8-bit D/A converter
type DAC8_Type struct {
	DACS0    volatile.Register8 // 0x0
	DACS1    volatile.Register8 // 0x1
	_        byte
	DAM      volatile.Register8 // 0x3
	_        [2]byte
	DACADSCR volatile.Register8 // 0x6
	DACPC    volatile.Register8 // 0x7
}

// DAC8.DACS0: D/A Conversion Value Setting Register %s
func (o *DAC8_Type) SetDACS0(value uint8) {
	volatile.StoreUint8(&o.DACS0.Reg, value)
}
func (o *DAC8_Type) GetDACS0() uint8 {
	return volatile.LoadUint8(&o.DACS0.Reg)
}

// DAC8.DACS1: D/A Conversion Value Setting Register %s
func (o *DAC8_Type) SetDACS1(value uint8) {
	volatile.StoreUint8(&o.DACS1.Reg, value)
}
func (o *DAC8_Type) GetDACS1() uint8 {
	return volatile.LoadUint8(&o.DACS1.Reg)
}

// DAC8.DAM: D/A Converter Mode Register
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x80)|value<<7)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x80) >> 7
}
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x40)|value<<6)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x40) >> 6
}
func (o *DAC8_Type) SetDAM_DACE1(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x20)|value<<5)
}
func (o *DAC8_Type) GetDAM_DACE1() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x20) >> 5
}
func (o *DAC8_Type) SetDAM_DACE0(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x10)|value<<4)
}
func (o *DAC8_Type) GetDAM_DACE0() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x10) >> 4
}
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x8)|value<<3)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x8) >> 3
}
func (o *DAC8_Type) SetDAM_Reserved(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x4)|value<<2)
}
func (o *DAC8_Type) GetDAM_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x4) >> 2
}
func (o *DAC8_Type) SetDAM_DAMD1(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x2)|value<<1)
}
func (o *DAC8_Type) GetDAM_DAMD1() uint8 {
	return (volatile.LoadUint8(&o.DAM.Reg) & 0x2) >> 1
}
func (o *DAC8_Type) SetDAM_DAMD0(value uint8) {
	volatile.StoreUint8(&o.DAM.Reg, volatile.LoadUint8(&o.DAM.Reg)&^(0x1)|value)
}
func (o *DAC8_Type) GetDAM_DAMD0() uint8 {
	return volatile.LoadUint8(&o.DAM.Reg) & 0x1
}

// DAC8.DACADSCR: D/A A/D Synchronous Start Control Register
func (o *DAC8_Type) SetDACADSCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACADSCR.Reg, volatile.LoadUint8(&o.DACADSCR.Reg)&^(0xfe)|value<<1)
}
func (o *DAC8_Type) GetDACADSCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACADSCR.Reg) & 0xfe) >> 1
}
func (o *DAC8_Type) SetDACADSCR_DACADST(value uint8) {
	volatile.StoreUint8(&o.DACADSCR.Reg, volatile.LoadUint8(&o.DACADSCR.Reg)&^(0x1)|value)
}
func (o *DAC8_Type) GetDACADSCR_DACADST() uint8 {
	return volatile.LoadUint8(&o.DACADSCR.Reg) & 0x1
}

// DAC8.DACPC: D/A SW Charge Pump Control Register
func (o *DAC8_Type) SetDACPC_Reserved(value uint8) {
	volatile.StoreUint8(&o.DACPC.Reg, volatile.LoadUint8(&o.DACPC.Reg)&^(0xfe)|value<<1)
}
func (o *DAC8_Type) GetDACPC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DACPC.Reg) & 0xfe) >> 1
}
func (o *DAC8_Type) SetDACPC_PUMPEN(value uint8) {
	volatile.StoreUint8(&o.DACPC.Reg, volatile.LoadUint8(&o.DACPC.Reg)&^(0x1)|value)
}
func (o *DAC8_Type) GetDACPC_PUMPEN() uint8 {
	return volatile.LoadUint8(&o.DACPC.Reg) & 0x1
}

// Event Link Controller
type ELC_Type struct {
	ELCR    volatile.Register8 // 0x0
	_       byte
	ELSEGR0 volatile.Register8 // 0x2
	_       byte
	ELSEGR1 volatile.Register8 // 0x4
	_       [11]byte
	ELSR0   volatile.Register16 // 0x10
	_       [2]byte
	ELSR1   volatile.Register16 // 0x14
	_       [2]byte
	ELSR2   volatile.Register16 // 0x18
	_       [2]byte
	ELSR3   volatile.Register16 // 0x1C
	_       [18]byte
	ELSR8   volatile.Register16 // 0x30
	_       [2]byte
	ELSR9   volatile.Register16 // 0x34
	_       [10]byte
	ELSR12  volatile.Register16 // 0x40
	_       [6]byte
	ELSR14  volatile.Register16 // 0x48
	_       [2]byte
	ELSR15  volatile.Register16 // 0x4C
	_       [10]byte
	ELSR18  volatile.Register16 // 0x58
	_       [2]byte
	ELSR19  volatile.Register16 // 0x5C
	_       [2]byte
	ELSR20  volatile.Register16 // 0x60
	_       [6]byte
	ELSR22  volatile.Register16 // 0x68
}

// ELC.ELCR: Event Link Controller Register
func (o *ELC_Type) SetELCR_ELCON(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELCR_ELCON() uint8 {
	return (volatile.LoadUint8(&o.ELCR.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELCR.Reg, volatile.LoadUint8(&o.ELCR.Reg)&^(0x7f)|value)
}
func (o *ELC_Type) GetELCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.ELCR.Reg) & 0x7f
}

// ELC.ELSEGR0: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR0_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR0_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR0_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR0_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x3e)|value<<1)
}
func (o *ELC_Type) GetELSEGR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x3e) >> 1
}
func (o *ELC_Type) SetELSEGR0_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR0.Reg, volatile.LoadUint8(&o.ELSEGR0.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR0_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR0.Reg) & 0x1
}

// ELC.ELSEGR1: Event Link Software Event Generation Register %s
func (o *ELC_Type) SetELSEGR1_WI(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x80)|value<<7)
}
func (o *ELC_Type) GetELSEGR1_WI() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x80) >> 7
}
func (o *ELC_Type) SetELSEGR1_WE(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x40)|value<<6)
}
func (o *ELC_Type) GetELSEGR1_WE() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x40) >> 6
}
func (o *ELC_Type) SetELSEGR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x3e)|value<<1)
}
func (o *ELC_Type) GetELSEGR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x3e) >> 1
}
func (o *ELC_Type) SetELSEGR1_SEG(value uint8) {
	volatile.StoreUint8(&o.ELSEGR1.Reg, volatile.LoadUint8(&o.ELSEGR1.Reg)&^(0x1)|value)
}
func (o *ELC_Type) GetELSEGR1_SEG() uint8 {
	return volatile.LoadUint8(&o.ELSEGR1.Reg) & 0x1
}

// ELC.ELSR0: Event Link Setting Register %s
func (o *ELC_Type) SetELSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR0.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR0_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR0.Reg, volatile.LoadUint16(&o.ELSR0.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR0_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR0.Reg) & 0xff
}

// ELC.ELSR1: Event Link Setting Register %s
func (o *ELC_Type) SetELSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR1.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR1_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR1.Reg, volatile.LoadUint16(&o.ELSR1.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR1_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR1.Reg) & 0xff
}

// ELC.ELSR2: Event Link Setting Register %s
func (o *ELC_Type) SetELSR2_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR2.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR2_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR2.Reg, volatile.LoadUint16(&o.ELSR2.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR2_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR2.Reg) & 0xff
}

// ELC.ELSR3: Event Link Setting Register %s
func (o *ELC_Type) SetELSR3_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR3.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR3_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR3.Reg, volatile.LoadUint16(&o.ELSR3.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR3_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR3.Reg) & 0xff
}

// ELC.ELSR8: Event Link Setting Register %s
func (o *ELC_Type) SetELSR8_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR8_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR8.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR8_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR8.Reg, volatile.LoadUint16(&o.ELSR8.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR8_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR8.Reg) & 0xff
}

// ELC.ELSR9: Event Link Setting Register %s
func (o *ELC_Type) SetELSR9_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR9_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR9.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR9_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR9.Reg, volatile.LoadUint16(&o.ELSR9.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR9_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR9.Reg) & 0xff
}

// ELC.ELSR12: Event Link Setting Register 12
func (o *ELC_Type) SetELSR12_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR12_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR12.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR12_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR12.Reg, volatile.LoadUint16(&o.ELSR12.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR12_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR12.Reg) & 0xff
}

// ELC.ELSR14: Event Link Setting Register %s
func (o *ELC_Type) SetELSR14_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR14_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR14.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR14_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR14.Reg, volatile.LoadUint16(&o.ELSR14.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR14_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR14.Reg) & 0xff
}

// ELC.ELSR15: Event Link Setting Register %s
func (o *ELC_Type) SetELSR15_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR15_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR15.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR15_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR15.Reg, volatile.LoadUint16(&o.ELSR15.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR15_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR15.Reg) & 0xff
}

// ELC.ELSR18: Event Link Setting Register %s
func (o *ELC_Type) SetELSR18_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR18_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR18.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR18_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR18.Reg, volatile.LoadUint16(&o.ELSR18.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR18_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR18.Reg) & 0xff
}

// ELC.ELSR19: Event Link Setting Register %s
func (o *ELC_Type) SetELSR19_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR19.Reg, volatile.LoadUint16(&o.ELSR19.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR19_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR19.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR19_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR19.Reg, volatile.LoadUint16(&o.ELSR19.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR19_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR19.Reg) & 0xff
}

// ELC.ELSR20: Event Link Setting Register %s
func (o *ELC_Type) SetELSR20_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR20.Reg, volatile.LoadUint16(&o.ELSR20.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR20_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR20.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR20_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR20.Reg, volatile.LoadUint16(&o.ELSR20.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR20_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR20.Reg) & 0xff
}

// ELC.ELSR22: Event Link Setting Register 22
func (o *ELC_Type) SetELSR22_Reserved(value uint16) {
	volatile.StoreUint16(&o.ELSR22.Reg, volatile.LoadUint16(&o.ELSR22.Reg)&^(0xff00)|value<<8)
}
func (o *ELC_Type) GetELSR22_Reserved() uint16 {
	return (volatile.LoadUint16(&o.ELSR22.Reg) & 0xff00) >> 8
}
func (o *ELC_Type) SetELSR22_ELS(value uint16) {
	volatile.StoreUint16(&o.ELSR22.Reg, volatile.LoadUint16(&o.ELSR22.Reg)&^(0xff)|value)
}
func (o *ELC_Type) GetELSR22_ELS() uint16 {
	return volatile.LoadUint16(&o.ELSR22.Reg) & 0xff
}

// Independent Watchdog Timer
type IWDT_Type struct {
	IWDTRR volatile.Register8 // 0x0
	_      [3]byte
	IWDTSR volatile.Register16 // 0x4
}

// IWDT.IWDTRR: IWDT Refresh Register
func (o *IWDT_Type) SetIWDTRR(value uint8) {
	volatile.StoreUint8(&o.IWDTRR.Reg, value)
}
func (o *IWDT_Type) GetIWDTRR() uint8 {
	return volatile.LoadUint8(&o.IWDTRR.Reg)
}

// IWDT.IWDTSR: IWDT Status Register
func (o *IWDT_Type) SetIWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *IWDT_Type) GetIWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x8000) >> 15
}
func (o *IWDT_Type) SetIWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *IWDT_Type) GetIWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.IWDTSR.Reg) & 0x4000) >> 14
}
func (o *IWDT_Type) SetIWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.IWDTSR.Reg, volatile.LoadUint16(&o.IWDTSR.Reg)&^(0x3fff)|value)
}
func (o *IWDT_Type) GetIWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.IWDTSR.Reg) & 0x3fff
}

// Key Interrupt Function
type KINT_Type struct {
	KRCTL volatile.Register8 // 0x0
	_     [3]byte
	KRF   volatile.Register8 // 0x4
	_     [3]byte
	KRM   volatile.Register8 // 0x8
}

// KINT.KRCTL: KEY Return Control Register
func (o *KINT_Type) SetKRCTL_KRMD(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRCTL_KRMD() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRCTL_Reserved(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x7e)|value<<1)
}
func (o *KINT_Type) GetKRCTL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.KRCTL.Reg) & 0x7e) >> 1
}
func (o *KINT_Type) SetKRCTL_KREG(value uint8) {
	volatile.StoreUint8(&o.KRCTL.Reg, volatile.LoadUint8(&o.KRCTL.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRCTL_KREG() uint8 {
	return volatile.LoadUint8(&o.KRCTL.Reg) & 0x1
}

// KINT.KRF: KEY Return Flag Register
func (o *KINT_Type) SetKRF_KRF7(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRF_KRF7() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRF_KRF6(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRF_KRF6() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRF_KRF5(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRF_KRF5() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRF_KRF4(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRF_KRF4() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRF_KRF3(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRF_KRF3() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRF_KRF2(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRF_KRF2() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRF_KRF1(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRF_KRF1() uint8 {
	return (volatile.LoadUint8(&o.KRF.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRF_KRF0(value uint8) {
	volatile.StoreUint8(&o.KRF.Reg, volatile.LoadUint8(&o.KRF.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRF_KRF0() uint8 {
	return volatile.LoadUint8(&o.KRF.Reg) & 0x1
}

// KINT.KRM: KEY Return Mode Register
func (o *KINT_Type) SetKRM_KRM7(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x80)|value<<7)
}
func (o *KINT_Type) GetKRM_KRM7() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x80) >> 7
}
func (o *KINT_Type) SetKRM_KRM6(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x40)|value<<6)
}
func (o *KINT_Type) GetKRM_KRM6() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x40) >> 6
}
func (o *KINT_Type) SetKRM_KRM5(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x20)|value<<5)
}
func (o *KINT_Type) GetKRM_KRM5() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x20) >> 5
}
func (o *KINT_Type) SetKRM_KRM4(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x10)|value<<4)
}
func (o *KINT_Type) GetKRM_KRM4() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x10) >> 4
}
func (o *KINT_Type) SetKRM_KRM3(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x8)|value<<3)
}
func (o *KINT_Type) GetKRM_KRM3() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x8) >> 3
}
func (o *KINT_Type) SetKRM_KRM2(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x4)|value<<2)
}
func (o *KINT_Type) GetKRM_KRM2() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x4) >> 2
}
func (o *KINT_Type) SetKRM_KRM1(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x2)|value<<1)
}
func (o *KINT_Type) GetKRM_KRM1() uint8 {
	return (volatile.LoadUint8(&o.KRM.Reg) & 0x2) >> 1
}
func (o *KINT_Type) SetKRM_KRM0(value uint8) {
	volatile.StoreUint8(&o.KRM.Reg, volatile.LoadUint8(&o.KRM.Reg)&^(0x1)|value)
}
func (o *KINT_Type) GetKRM_KRM0() uint8 {
	return volatile.LoadUint8(&o.KRM.Reg) & 0x1
}

// USB 2.0 FS Module
type USBFS_Type struct {
	SYSCFG     volatile.Register16 // 0x0
	_          [2]byte
	SYSSTS0    volatile.Register16 // 0x4
	_          [2]byte
	DVSTCTR0   volatile.Register16 // 0x8
	_          [10]byte
	CFIFO      volatile.Register16 // 0x14
	_          [10]byte
	CFIFOSEL   volatile.Register16 // 0x20
	CFIFOCTR   volatile.Register16 // 0x22
	_          [12]byte
	INTENB0    volatile.Register16 // 0x30
	_          [4]byte
	BRDYENB    volatile.Register16 // 0x36
	NRDYENB    volatile.Register16 // 0x38
	BEMPENB    volatile.Register16 // 0x3A
	SOFCFG     volatile.Register16 // 0x3C
	_          [2]byte
	INTSTS0    volatile.Register16 // 0x40
	_          [4]byte
	BRDYSTS    volatile.Register16 // 0x46
	NRDYSTS    volatile.Register16 // 0x48
	BEMPSTS    volatile.Register16 // 0x4A
	FRMNUM     volatile.Register16 // 0x4C
	_          [6]byte
	USBREQ     volatile.Register16 // 0x54
	USBVAL     volatile.Register16 // 0x56
	USBINDX    volatile.Register16 // 0x58
	USBLENG    volatile.Register16 // 0x5A
	DCPCFG     volatile.Register16 // 0x5C
	DCPMAXP    volatile.Register16 // 0x5E
	DCPCTR     volatile.Register16 // 0x60
	_          [2]byte
	PIPESEL    volatile.Register16 // 0x64
	_          [2]byte
	PIPECFG    volatile.Register16 // 0x68
	_          [2]byte
	PIPEMAXP   volatile.Register16 // 0x6C
	_          [8]byte
	PIPE4CTR   volatile.Register16 // 0x76
	PIPE5CTR   volatile.Register16 // 0x78
	PIPE6CTR   volatile.Register16 // 0x7A
	PIPE7CTR   volatile.Register16 // 0x7C
	_          [30]byte
	PIPE4TRE   volatile.Register16 // 0x9C
	PIPE4TRN   volatile.Register16 // 0x9E
	PIPE5TRE   volatile.Register16 // 0xA0
	PIPE5TRN   volatile.Register16 // 0xA2
	_          [12]byte
	USBBCCTRL0 volatile.Register16 // 0xB0
	_          [18]byte
	UCKSEL     volatile.Register16 // 0xC4
	_          [6]byte
	USBMC      volatile.Register16 // 0xCC
}

// USBFS.SYSCFG: System Configuration Control Register
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0xf800)|value<<11)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0xf800) >> 11
}
func (o *USBFS_Type) SetSYSCFG_SCKE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetSYSCFG_SCKE() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetSYSCFG_CNEN(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSYSCFG_CNEN() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0xe0)|value<<5)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0xe0) >> 5
}
func (o *USBFS_Type) SetSYSCFG_DPRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSYSCFG_DPRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSYSCFG_DMRPU(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetSYSCFG_DMRPU() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetSYSCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x6)|value<<1)
}
func (o *USBFS_Type) GetSYSCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSCFG.Reg) & 0x6) >> 1
}
func (o *USBFS_Type) SetSYSCFG_USBE(value uint16) {
	volatile.StoreUint16(&o.SYSCFG.Reg, volatile.LoadUint16(&o.SYSCFG.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetSYSCFG_USBE() uint16 {
	return volatile.LoadUint16(&o.SYSCFG.Reg) & 0x1
}

// USBFS.SYSSTS0: System Configuration Status Register 0
func (o *USBFS_Type) SetSYSSTS0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0xfffc)|value<<2)
}
func (o *USBFS_Type) GetSYSSTS0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SYSSTS0.Reg) & 0xfffc) >> 2
}
func (o *USBFS_Type) SetSYSSTS0_LNST(value uint16) {
	volatile.StoreUint16(&o.SYSSTS0.Reg, volatile.LoadUint16(&o.SYSSTS0.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetSYSSTS0_LNST() uint16 {
	return volatile.LoadUint16(&o.SYSSTS0.Reg) & 0x3
}

// USBFS.DVSTCTR0: Device State Control Register 0
func (o *USBFS_Type) SetDVSTCTR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0xfe00)|value<<9)
}
func (o *USBFS_Type) GetDVSTCTR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0xfe00) >> 9
}
func (o *USBFS_Type) SetDVSTCTR0_WKUP(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDVSTCTR0_WKUP() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDVSTCTR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0xf8)|value<<3)
}
func (o *USBFS_Type) GetDVSTCTR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0xf8) >> 3
}
func (o *USBFS_Type) SetDVSTCTR0_RHST(value uint16) {
	volatile.StoreUint16(&o.DVSTCTR0.Reg, volatile.LoadUint16(&o.DVSTCTR0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetDVSTCTR0_RHST() uint16 {
	return volatile.LoadUint16(&o.DVSTCTR0.Reg) & 0x7
}

// USBFS.CFIFO: CFIFO Port Register
func (o *USBFS_Type) SetCFIFO(value uint16) {
	volatile.StoreUint16(&o.CFIFO.Reg, value)
}
func (o *USBFS_Type) GetCFIFO() uint16 {
	return volatile.LoadUint16(&o.CFIFO.Reg)
}

// USBFS.CFIFOSEL: CFIFO Port Select Register
func (o *USBFS_Type) SetCFIFOSEL_RCNT(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOSEL_RCNT() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOSEL_REW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOSEL_REW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetCFIFOSEL_MBW(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetCFIFOSEL_MBW() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetCFIFOSEL_BIGEND(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetCFIFOSEL_BIGEND() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xc0)|value<<6)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xc0) >> 6
}
func (o *USBFS_Type) SetCFIFOSEL_ISEL(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetCFIFOSEL_ISEL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetCFIFOSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetCFIFOSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetCFIFOSEL_CURPIPE(value uint16) {
	volatile.StoreUint16(&o.CFIFOSEL.Reg, volatile.LoadUint16(&o.CFIFOSEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetCFIFOSEL_CURPIPE() uint16 {
	return volatile.LoadUint16(&o.CFIFOSEL.Reg) & 0xf
}

// USBFS.CFIFOCTR: CFIFO Port Control Register
func (o *USBFS_Type) SetCFIFOCTR_BVAL(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetCFIFOCTR_BVAL() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetCFIFOCTR_BCLR(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetCFIFOCTR_BCLR() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetCFIFOCTR_FRDY(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetCFIFOCTR_FRDY() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetCFIFOCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1e00)|value<<9)
}
func (o *USBFS_Type) GetCFIFOCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1e00) >> 9
}
func (o *USBFS_Type) SetCFIFOCTR_DTLN(value uint16) {
	volatile.StoreUint16(&o.CFIFOCTR.Reg, volatile.LoadUint16(&o.CFIFOCTR.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetCFIFOCTR_DTLN() uint16 {
	return volatile.LoadUint16(&o.CFIFOCTR.Reg) & 0x1ff
}

// USBFS.INTENB0: Interrupt Enable Register 0
func (o *USBFS_Type) SetINTENB0_VBSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTENB0_VBSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTENB0_RSME(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTENB0_RSME() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTENB0_SOFE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTENB0_SOFE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTENB0_DVSE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTENB0_DVSE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTENB0_CTRE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTENB0_CTRE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTENB0_BEMPE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTENB0_BEMPE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTENB0_NRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTENB0_NRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTENB0_BRDYE(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTENB0_BRDYE() uint16 {
	return (volatile.LoadUint16(&o.INTENB0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTENB0_Reserved(value uint16) {
	volatile.StoreUint16(&o.INTENB0.Reg, volatile.LoadUint16(&o.INTENB0.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetINTENB0_Reserved() uint16 {
	return volatile.LoadUint16(&o.INTENB0.Reg) & 0xff
}

// USBFS.BRDYENB: BRDY Interrupt Enable Register
func (o *USBFS_Type) SetBRDYENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBRDYENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBRDYENB_PIPE9BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYENB_PIPE9BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYENB_PIPE8BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYENB_PIPE8BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYENB_PIPE7BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYENB_PIPE7BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYENB_PIPE6BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYENB_PIPE6BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYENB_PIPE5BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYENB_PIPE5BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYENB_PIPE4BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYENB_PIPE4BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYENB_PIPE3BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYENB_PIPE3BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYENB_PIPE2BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYENB_PIPE2BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYENB_PIPE1BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYENB_PIPE1BRDYE() uint16 {
	return (volatile.LoadUint16(&o.BRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYENB_PIPE0BRDYE(value uint16) {
	volatile.StoreUint16(&o.BRDYENB.Reg, volatile.LoadUint16(&o.BRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYENB_PIPE0BRDYE() uint16 {
	return volatile.LoadUint16(&o.BRDYENB.Reg) & 0x1
}

// USBFS.NRDYENB: NRDY Interrupt Enable Register
func (o *USBFS_Type) SetNRDYENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetNRDYENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetNRDYENB_PIPE9NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYENB_PIPE9NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYENB_PIPE8NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYENB_PIPE8NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYENB_PIPE7NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYENB_PIPE7NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYENB_PIPE6NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYENB_PIPE6NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYENB_PIPE5NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYENB_PIPE5NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYENB_PIPE4NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYENB_PIPE4NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYENB_PIPE3NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYENB_PIPE3NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYENB_PIPE2NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYENB_PIPE2NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYENB_PIPE1NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYENB_PIPE1NRDYE() uint16 {
	return (volatile.LoadUint16(&o.NRDYENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYENB_PIPE0NRDYE(value uint16) {
	volatile.StoreUint16(&o.NRDYENB.Reg, volatile.LoadUint16(&o.NRDYENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYENB_PIPE0NRDYE() uint16 {
	return volatile.LoadUint16(&o.NRDYENB.Reg) & 0x1
}

// USBFS.BEMPENB: BEMP Interrupt Enable Register
func (o *USBFS_Type) SetBEMPENB_Reserved(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBEMPENB_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBEMPENB_PIPE9BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPENB_PIPE9BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPENB_PIPE8BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPENB_PIPE8BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPENB_PIPE7BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPENB_PIPE7BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPENB_PIPE6BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPENB_PIPE6BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPENB_PIPE5BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPENB_PIPE5BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPENB_PIPE4BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPENB_PIPE4BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPENB_PIPE3BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPENB_PIPE3BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPENB_PIPE2BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPENB_PIPE2BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPENB_PIPE1BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPENB_PIPE1BEMPE() uint16 {
	return (volatile.LoadUint16(&o.BEMPENB.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPENB_PIPE0BEMPE(value uint16) {
	volatile.StoreUint16(&o.BEMPENB.Reg, volatile.LoadUint16(&o.BEMPENB.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPENB_PIPE0BEMPE() uint16 {
	return volatile.LoadUint16(&o.BEMPENB.Reg) & 0x1
}

// USBFS.SOFCFG: SOF Output Configuration Register
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0xfe00)|value<<9)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0xfe00) >> 9
}
func (o *USBFS_Type) SetSOFCFG_TRNENSEL(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetSOFCFG_TRNENSEL() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetSOFCFG_BRDYM(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetSOFCFG_BRDYM() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetSOFCFG_EDGESTS(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetSOFCFG_EDGESTS() uint16 {
	return (volatile.LoadUint16(&o.SOFCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetSOFCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.SOFCFG.Reg, volatile.LoadUint16(&o.SOFCFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetSOFCFG_Reserved() uint16 {
	return volatile.LoadUint16(&o.SOFCFG.Reg) & 0xf
}

// USBFS.INTSTS0: Interrupt Status Register 0
func (o *USBFS_Type) SetINTSTS0_VBINT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetINTSTS0_VBINT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetINTSTS0_RESM(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetINTSTS0_RESM() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetINTSTS0_SOFR(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x2000)|value<<13)
}
func (o *USBFS_Type) GetINTSTS0_SOFR() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x2000) >> 13
}
func (o *USBFS_Type) SetINTSTS0_DVST(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x1000)|value<<12)
}
func (o *USBFS_Type) GetINTSTS0_DVST() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x1000) >> 12
}
func (o *USBFS_Type) SetINTSTS0_CTRT(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetINTSTS0_CTRT() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetINTSTS0_BEMP(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetINTSTS0_BEMP() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetINTSTS0_NRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetINTSTS0_NRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetINTSTS0_BRDY(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetINTSTS0_BRDY() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetINTSTS0_VBSTS(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetINTSTS0_VBSTS() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetINTSTS0_DVSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x70)|value<<4)
}
func (o *USBFS_Type) GetINTSTS0_DVSQ() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x70) >> 4
}
func (o *USBFS_Type) SetINTSTS0_VALID(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetINTSTS0_VALID() uint16 {
	return (volatile.LoadUint16(&o.INTSTS0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetINTSTS0_CTSQ(value uint16) {
	volatile.StoreUint16(&o.INTSTS0.Reg, volatile.LoadUint16(&o.INTSTS0.Reg)&^(0x7)|value)
}
func (o *USBFS_Type) GetINTSTS0_CTSQ() uint16 {
	return volatile.LoadUint16(&o.INTSTS0.Reg) & 0x7
}

// USBFS.BRDYSTS: BRDY Interrupt Status Register
func (o *USBFS_Type) SetBRDYSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBRDYSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBRDYSTS_PIPE9BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE9BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBRDYSTS_PIPE8BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE8BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBRDYSTS_PIPE7BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE7BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBRDYSTS_PIPE6BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE6BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBRDYSTS_PIPE5BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE5BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBRDYSTS_PIPE4BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE4BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBRDYSTS_PIPE3BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE3BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBRDYSTS_PIPE2BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE2BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBRDYSTS_PIPE1BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE1BRDY() uint16 {
	return (volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBRDYSTS_PIPE0BRDY(value uint16) {
	volatile.StoreUint16(&o.BRDYSTS.Reg, volatile.LoadUint16(&o.BRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBRDYSTS_PIPE0BRDY() uint16 {
	return volatile.LoadUint16(&o.BRDYSTS.Reg) & 0x1
}

// USBFS.NRDYSTS: NRDY Interrupt Status Register
func (o *USBFS_Type) SetNRDYSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetNRDYSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetNRDYSTS_PIPE9NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE9NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetNRDYSTS_PIPE8NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE8NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetNRDYSTS_PIPE7NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE7NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetNRDYSTS_PIPE6NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE6NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetNRDYSTS_PIPE5NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE5NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetNRDYSTS_PIPE4NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE4NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetNRDYSTS_PIPE3NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE3NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetNRDYSTS_PIPE2NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE2NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetNRDYSTS_PIPE1NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE1NRDY() uint16 {
	return (volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetNRDYSTS_PIPE0NRDY(value uint16) {
	volatile.StoreUint16(&o.NRDYSTS.Reg, volatile.LoadUint16(&o.NRDYSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetNRDYSTS_PIPE0NRDY() uint16 {
	return volatile.LoadUint16(&o.NRDYSTS.Reg) & 0x1
}

// USBFS.BEMPSTS: BEMP Interrupt Status Register
func (o *USBFS_Type) SetBEMPSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetBEMPSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetBEMPSTS_PIPE9BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE9BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetBEMPSTS_PIPE8BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE8BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetBEMPSTS_PIPE7BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE7BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetBEMPSTS_PIPE6BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE6BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetBEMPSTS_PIPE5BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE5BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetBEMPSTS_PIPE4BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE4BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetBEMPSTS_PIPE3BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE3BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetBEMPSTS_PIPE2BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE2BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetBEMPSTS_PIPE1BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE1BEMP() uint16 {
	return (volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetBEMPSTS_PIPE0BEMP(value uint16) {
	volatile.StoreUint16(&o.BEMPSTS.Reg, volatile.LoadUint16(&o.BEMPSTS.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetBEMPSTS_PIPE0BEMP() uint16 {
	return volatile.LoadUint16(&o.BEMPSTS.Reg) & 0x1
}

// USBFS.FRMNUM: Frame Number Register
func (o *USBFS_Type) SetFRMNUM_OVRN(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetFRMNUM_OVRN() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetFRMNUM_CRCE(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetFRMNUM_CRCE() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetFRMNUM_Reserved(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetFRMNUM_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FRMNUM.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetFRMNUM_FRNM(value uint16) {
	volatile.StoreUint16(&o.FRMNUM.Reg, volatile.LoadUint16(&o.FRMNUM.Reg)&^(0x7ff)|value)
}
func (o *USBFS_Type) GetFRMNUM_FRNM() uint16 {
	return volatile.LoadUint16(&o.FRMNUM.Reg) & 0x7ff
}

// USBFS.USBREQ: USB Request Type Register
func (o *USBFS_Type) SetUSBREQ_BREQUEST(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBREQ_BREQUEST() uint16 {
	return (volatile.LoadUint16(&o.USBREQ.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetUSBREQ_BMREQUESTTYPE(value uint16) {
	volatile.StoreUint16(&o.USBREQ.Reg, volatile.LoadUint16(&o.USBREQ.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetUSBREQ_BMREQUESTTYPE() uint16 {
	return volatile.LoadUint16(&o.USBREQ.Reg) & 0xff
}

// USBFS.USBVAL: USB Request Value Register
func (o *USBFS_Type) SetUSBVAL(value uint16) {
	volatile.StoreUint16(&o.USBVAL.Reg, value)
}
func (o *USBFS_Type) GetUSBVAL() uint16 {
	return volatile.LoadUint16(&o.USBVAL.Reg)
}

// USBFS.USBINDX: USB Request Index Register
func (o *USBFS_Type) SetUSBINDX(value uint16) {
	volatile.StoreUint16(&o.USBINDX.Reg, value)
}
func (o *USBFS_Type) GetUSBINDX() uint16 {
	return volatile.LoadUint16(&o.USBINDX.Reg)
}

// USBFS.USBLENG: USB Request Length Register
func (o *USBFS_Type) SetUSBLENG(value uint16) {
	volatile.StoreUint16(&o.USBLENG.Reg, value)
}
func (o *USBFS_Type) GetUSBLENG() uint16 {
	return volatile.LoadUint16(&o.USBLENG.Reg)
}

// USBFS.DCPCFG: DCP Configuration Register
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetDCPCFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x60)|value<<5)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x60) >> 5
}
func (o *USBFS_Type) SetDCPCFG_DIR(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetDCPCFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.DCPCFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetDCPCFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCFG.Reg, volatile.LoadUint16(&o.DCPCFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetDCPCFG_Reserved() uint16 {
	return volatile.LoadUint16(&o.DCPCFG.Reg) & 0xf
}

// USBFS.DCPMAXP: DCP Maximum Packet Size Register
func (o *USBFS_Type) SetDCPMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetDCPMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetDCPMAXP_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0xf80)|value<<7)
}
func (o *USBFS_Type) GetDCPMAXP_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPMAXP.Reg) & 0xf80) >> 7
}
func (o *USBFS_Type) SetDCPMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.DCPMAXP.Reg, volatile.LoadUint16(&o.DCPMAXP.Reg)&^(0x7f)|value)
}
func (o *USBFS_Type) GetDCPMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.DCPMAXP.Reg) & 0x7f
}

// USBFS.DCPCTR: DCP Control Register
func (o *USBFS_Type) SetDCPCTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetDCPCTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetDCPCTR_SUREQ(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetDCPCTR_SUREQ() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3000)|value<<12)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3000) >> 12
}
func (o *USBFS_Type) SetDCPCTR_SUREQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x800)|value<<11)
}
func (o *USBFS_Type) GetDCPCTR_SUREQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x800) >> 11
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x600)|value<<9)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x600) >> 9
}
func (o *USBFS_Type) SetDCPCTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetDCPCTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetDCPCTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetDCPCTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetDCPCTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetDCPCTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetDCPCTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetDCPCTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetDCPCTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x18)|value<<3)
}
func (o *USBFS_Type) GetDCPCTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x18) >> 3
}
func (o *USBFS_Type) SetDCPCTR_CCPL(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetDCPCTR_CCPL() uint16 {
	return (volatile.LoadUint16(&o.DCPCTR.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetDCPCTR_PID(value uint16) {
	volatile.StoreUint16(&o.DCPCTR.Reg, volatile.LoadUint16(&o.DCPCTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetDCPCTR_PID() uint16 {
	return volatile.LoadUint16(&o.DCPCTR.Reg) & 0x3
}

// USBFS.PIPESEL: Pipe Window Select Register
func (o *USBFS_Type) SetPIPESEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xfff0)|value<<4)
}
func (o *USBFS_Type) GetPIPESEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPESEL.Reg) & 0xfff0) >> 4
}
func (o *USBFS_Type) SetPIPESEL(value uint16) {
	volatile.StoreUint16(&o.PIPESEL.Reg, volatile.LoadUint16(&o.PIPESEL.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPESEL() uint16 {
	return volatile.LoadUint16(&o.PIPESEL.Reg) & 0xf
}

// USBFS.PIPECFG: Pipe Configuration Register
func (o *USBFS_Type) SetPIPECFG_TYPE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xc000)|value<<14)
}
func (o *USBFS_Type) GetPIPECFG_TYPE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0xc000) >> 14
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPECFG_BFRE(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPECFG_BFRE() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPECFG_DBLB(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPECFG_DBLB() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPECFG_SHTNAK(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPECFG_SHTNAK() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPECFG_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPECFG_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPECFG_DIR(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetPIPECFG_DIR() uint16 {
	return (volatile.LoadUint16(&o.PIPECFG.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetPIPECFG_EPNUM(value uint16) {
	volatile.StoreUint16(&o.PIPECFG.Reg, volatile.LoadUint16(&o.PIPECFG.Reg)&^(0xf)|value)
}
func (o *USBFS_Type) GetPIPECFG_EPNUM() uint16 {
	return volatile.LoadUint16(&o.PIPECFG.Reg) & 0xf
}

// USBFS.PIPEMAXP: Pipe Maximum Packet Size Register
func (o *USBFS_Type) SetPIPEMAXP_DEVSEL(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xf000)|value<<12)
}
func (o *USBFS_Type) GetPIPEMAXP_DEVSEL() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xf000) >> 12
}
func (o *USBFS_Type) SetPIPEMAXP_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0xe00)|value<<9)
}
func (o *USBFS_Type) GetPIPEMAXP_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0xe00) >> 9
}
func (o *USBFS_Type) SetPIPEMAXP_MXPS(value uint16) {
	volatile.StoreUint16(&o.PIPEMAXP.Reg, volatile.LoadUint16(&o.PIPEMAXP.Reg)&^(0x1ff)|value)
}
func (o *USBFS_Type) GetPIPEMAXP_MXPS() uint16 {
	return volatile.LoadUint16(&o.PIPEMAXP.Reg) & 0x1ff
}

// USBFS.PIPE4CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE4CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE4CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE4CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE4CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE4CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE4CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE4CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE4CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE4CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE4CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE4CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE4CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE4CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE4CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE4CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE4CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE4CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE4CTR.Reg, volatile.LoadUint16(&o.PIPE4CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE4CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE4CTR.Reg) & 0x3
}

// USBFS.PIPE5CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE5CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE5CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE5CTR_INBUFM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x4000)|value<<14)
}
func (o *USBFS_Type) GetPIPE5CTR_INBUFM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x4000) >> 14
}
func (o *USBFS_Type) SetPIPE5CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3800)|value<<11)
}
func (o *USBFS_Type) GetPIPE5CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3800) >> 11
}
func (o *USBFS_Type) SetPIPE5CTR_ATREPM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x400)|value<<10)
}
func (o *USBFS_Type) GetPIPE5CTR_ATREPM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x400) >> 10
}
func (o *USBFS_Type) SetPIPE5CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE5CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE5CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE5CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE5CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE5CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE5CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE5CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE5CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE5CTR.Reg, volatile.LoadUint16(&o.PIPE5CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE5CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE5CTR.Reg) & 0x3
}

// USBFS.PIPE6CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE6CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE6CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE6CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE6CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE6CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE6CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE6CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE6CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE6CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE6CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE6CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE6CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE6CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE6CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE6CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE6CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE6CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE6CTR.Reg, volatile.LoadUint16(&o.PIPE6CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE6CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE6CTR.Reg) & 0x3
}

// USBFS.PIPE7CTR: Pipe %s Control Register
func (o *USBFS_Type) SetPIPE7CTR_BSTS(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x8000)|value<<15)
}
func (o *USBFS_Type) GetPIPE7CTR_BSTS() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x8000) >> 15
}
func (o *USBFS_Type) SetPIPE7CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x7c00)|value<<10)
}
func (o *USBFS_Type) GetPIPE7CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x7c00) >> 10
}
func (o *USBFS_Type) SetPIPE7CTR_ACLRM(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE7CTR_ACLRM() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE7CTR_SQCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE7CTR_SQCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE7CTR_SQSET(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetPIPE7CTR_SQSET() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetPIPE7CTR_SQMON(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetPIPE7CTR_SQMON() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetPIPE7CTR_PBUSY(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetPIPE7CTR_PBUSY() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetPIPE7CTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x1c)|value<<2)
}
func (o *USBFS_Type) GetPIPE7CTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x1c) >> 2
}
func (o *USBFS_Type) SetPIPE7CTR_PID(value uint16) {
	volatile.StoreUint16(&o.PIPE7CTR.Reg, volatile.LoadUint16(&o.PIPE7CTR.Reg)&^(0x3)|value)
}
func (o *USBFS_Type) GetPIPE7CTR_PID() uint16 {
	return volatile.LoadUint16(&o.PIPE7CTR.Reg) & 0x3
}

// USBFS.PIPE4TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE4TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE4TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE4TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE4TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE4TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE4TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE4TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRE.Reg, volatile.LoadUint16(&o.PIPE4TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE4TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRE.Reg) & 0xff
}

// USBFS.PIPE4TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE4TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE4TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE4TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE4TRN.Reg)
}

// USBFS.PIPE5TRE: Pipe %s Transaction Counter Enable Register
func (o *USBFS_Type) SetPIPE5TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetPIPE5TRE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetPIPE5TRE_TRENB(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetPIPE5TRE_TRENB() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetPIPE5TRE_TRCLR(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetPIPE5TRE_TRCLR() uint16 {
	return (volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetPIPE5TRE_Reserved(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRE.Reg, volatile.LoadUint16(&o.PIPE5TRE.Reg)&^(0xff)|value)
}
func (o *USBFS_Type) GetPIPE5TRE_Reserved() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRE.Reg) & 0xff
}

// USBFS.PIPE5TRN: Pipe %s Transaction Counter Register
func (o *USBFS_Type) SetPIPE5TRN(value uint16) {
	volatile.StoreUint16(&o.PIPE5TRN.Reg, value)
}
func (o *USBFS_Type) GetPIPE5TRN() uint16 {
	return volatile.LoadUint16(&o.PIPE5TRN.Reg)
}

// USBFS.USBBCCTRL0: BC Control Register 0
func (o *USBFS_Type) SetUSBBCCTRL0_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0xfc00)|value<<10)
}
func (o *USBFS_Type) GetUSBBCCTRL0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0xfc00) >> 10
}
func (o *USBFS_Type) SetUSBBCCTRL0_PDDETSTS0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x200)|value<<9)
}
func (o *USBFS_Type) GetUSBBCCTRL0_PDDETSTS0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x200) >> 9
}
func (o *USBFS_Type) SetUSBBCCTRL0_CHGDETSTS0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x100)|value<<8)
}
func (o *USBFS_Type) GetUSBBCCTRL0_CHGDETSTS0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x100) >> 8
}
func (o *USBFS_Type) SetUSBBCCTRL0_BATCHGE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetUSBBCCTRL0_BATCHGE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetUSBBCCTRL0_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x40)|value<<6)
}
func (o *USBFS_Type) GetUSBBCCTRL0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x40) >> 6
}
func (o *USBFS_Type) SetUSBBCCTRL0_VDMSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x20)|value<<5)
}
func (o *USBFS_Type) GetUSBBCCTRL0_VDMSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x20) >> 5
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDPSINKE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x10)|value<<4)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDPSINKE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x10) >> 4
}
func (o *USBFS_Type) SetUSBBCCTRL0_VDPSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x8)|value<<3)
}
func (o *USBFS_Type) GetUSBBCCTRL0_VDPSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x8) >> 3
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDMSINKE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x4)|value<<2)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDMSINKE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x4) >> 2
}
func (o *USBFS_Type) SetUSBBCCTRL0_IDPSRCE0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetUSBBCCTRL0_IDPSRCE0() uint16 {
	return (volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetUSBBCCTRL0_RPDME0(value uint16) {
	volatile.StoreUint16(&o.USBBCCTRL0.Reg, volatile.LoadUint16(&o.USBBCCTRL0.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetUSBBCCTRL0_RPDME0() uint16 {
	return volatile.LoadUint16(&o.USBBCCTRL0.Reg) & 0x1
}

// USBFS.UCKSEL: USB Clock Selection Register
func (o *USBFS_Type) SetUCKSEL_Reserved(value uint16) {
	volatile.StoreUint16(&o.UCKSEL.Reg, volatile.LoadUint16(&o.UCKSEL.Reg)&^(0xfffe)|value<<1)
}
func (o *USBFS_Type) GetUCKSEL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.UCKSEL.Reg) & 0xfffe) >> 1
}
func (o *USBFS_Type) SetUCKSEL_UCKSELC(value uint16) {
	volatile.StoreUint16(&o.UCKSEL.Reg, volatile.LoadUint16(&o.UCKSEL.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetUCKSEL_UCKSELC() uint16 {
	return volatile.LoadUint16(&o.UCKSEL.Reg) & 0x1
}

// USBFS.USBMC: USB Module Control Register
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0xff00)|value<<8)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0xff00) >> 8
}
func (o *USBFS_Type) SetUSBMC_VDCEN(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x80)|value<<7)
}
func (o *USBFS_Type) GetUSBMC_VDCEN() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x80) >> 7
}
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x7c)|value<<2)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x7c) >> 2
}
func (o *USBFS_Type) SetUSBMC_Reserved(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x2)|value<<1)
}
func (o *USBFS_Type) GetUSBMC_Reserved() uint16 {
	return (volatile.LoadUint16(&o.USBMC.Reg) & 0x2) >> 1
}
func (o *USBFS_Type) SetUSBMC_VDDUSBE(value uint16) {
	volatile.StoreUint16(&o.USBMC.Reg, volatile.LoadUint16(&o.USBMC.Reg)&^(0x1)|value)
}
func (o *USBFS_Type) GetUSBMC_VDDUSBE() uint16 {
	return volatile.LoadUint16(&o.USBMC.Reg) & 0x1
}

// Watchdog Timer
type WDT_Type struct {
	WDTRR    volatile.Register8 // 0x0
	_        byte
	WDTCR    volatile.Register16 // 0x2
	WDTSR    volatile.Register16 // 0x4
	WDTRCR   volatile.Register8  // 0x6
	_        byte
	WDTCSTPR volatile.Register8 // 0x8
}

// WDT.WDTRR: WDT Refresh Register
func (o *WDT_Type) SetWDTRR(value uint8) {
	volatile.StoreUint8(&o.WDTRR.Reg, value)
}
func (o *WDT_Type) GetWDTRR() uint8 {
	return volatile.LoadUint8(&o.WDTRR.Reg)
}

// WDT.WDTCR: WDT Control Register
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc000)|value<<14)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc000) >> 14
}
func (o *WDT_Type) SetWDTCR_RPSS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3000)|value<<12)
}
func (o *WDT_Type) GetWDTCR_RPSS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x3000) >> 12
}
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc00)|value<<10)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc00) >> 10
}
func (o *WDT_Type) SetWDTCR_RPES(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x300)|value<<8)
}
func (o *WDT_Type) GetWDTCR_RPES() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0x300) >> 8
}
func (o *WDT_Type) SetWDTCR_CKS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xf0)|value<<4)
}
func (o *WDT_Type) GetWDTCR_CKS() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xf0) >> 4
}
func (o *WDT_Type) SetWDTCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0xc)|value<<2)
}
func (o *WDT_Type) GetWDTCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.WDTCR.Reg) & 0xc) >> 2
}
func (o *WDT_Type) SetWDTCR_TOPS(value uint16) {
	volatile.StoreUint16(&o.WDTCR.Reg, volatile.LoadUint16(&o.WDTCR.Reg)&^(0x3)|value)
}
func (o *WDT_Type) GetWDTCR_TOPS() uint16 {
	return volatile.LoadUint16(&o.WDTCR.Reg) & 0x3
}

// WDT.WDTSR: WDT Status Register
func (o *WDT_Type) SetWDTSR_REFEF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x8000)|value<<15)
}
func (o *WDT_Type) GetWDTSR_REFEF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x8000) >> 15
}
func (o *WDT_Type) SetWDTSR_UNDFF(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x4000)|value<<14)
}
func (o *WDT_Type) GetWDTSR_UNDFF() uint16 {
	return (volatile.LoadUint16(&o.WDTSR.Reg) & 0x4000) >> 14
}
func (o *WDT_Type) SetWDTSR_CNTVAL(value uint16) {
	volatile.StoreUint16(&o.WDTSR.Reg, volatile.LoadUint16(&o.WDTSR.Reg)&^(0x3fff)|value)
}
func (o *WDT_Type) GetWDTSR_CNTVAL() uint16 {
	return volatile.LoadUint16(&o.WDTSR.Reg) & 0x3fff
}

// WDT.WDTRCR: WDT Reset Control Register
func (o *WDT_Type) SetWDTRCR_RSTIRQS(value uint8) {
	volatile.StoreUint8(&o.WDTRCR.Reg, volatile.LoadUint8(&o.WDTRCR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTRCR_RSTIRQS() uint8 {
	return (volatile.LoadUint8(&o.WDTRCR.Reg) & 0x80) >> 7
}

// WDT.WDTCSTPR: WDT Count Stop Control Register
func (o *WDT_Type) SetWDTCSTPR_SLCSTP(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x80)|value<<7)
}
func (o *WDT_Type) GetWDTCSTPR_SLCSTP() uint8 {
	return (volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x80) >> 7
}
func (o *WDT_Type) SetWDTCSTPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.WDTCSTPR.Reg, volatile.LoadUint8(&o.WDTCSTPR.Reg)&^(0x7f)|value)
}
func (o *WDT_Type) GetWDTCSTPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.WDTCSTPR.Reg) & 0x7f
}

// Clock Frequency Accuracy Measurement Circuit
type CAC_Type struct {
	CACR0   volatile.Register8 // 0x0
	CACR1   volatile.Register8 // 0x1
	CACR2   volatile.Register8 // 0x2
	CAICR   volatile.Register8 // 0x3
	CASTR   volatile.Register8 // 0x4
	_       byte
	CAULVR  volatile.Register16 // 0x6
	CALLVR  volatile.Register16 // 0x8
	CACNTBR volatile.Register16 // 0xA
}

// CAC.CACR0: CAC Control Register 0
func (o *CAC_Type) SetCACR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0xfe)|value<<1)
}
func (o *CAC_Type) GetCACR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CACR0.Reg) & 0xfe) >> 1
}
func (o *CAC_Type) SetCACR0_CFME(value uint8) {
	volatile.StoreUint8(&o.CACR0.Reg, volatile.LoadUint8(&o.CACR0.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR0_CFME() uint8 {
	return volatile.LoadUint8(&o.CACR0.Reg) & 0x1
}

// CAC.CACR1: CAC Control Register 1
func (o *CAC_Type) SetCACR1_EDGES(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR1_EDGES() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR1_TCSS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR1_TCSS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR1_FMCS(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR1_FMCS() uint8 {
	return (volatile.LoadUint8(&o.CACR1.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR1_CACREFE(value uint8) {
	volatile.StoreUint8(&o.CACR1.Reg, volatile.LoadUint8(&o.CACR1.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR1_CACREFE() uint8 {
	return volatile.LoadUint8(&o.CACR1.Reg) & 0x1
}

// CAC.CACR2: CAC Control Register 2
func (o *CAC_Type) SetCACR2_DFS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xc0)|value<<6)
}
func (o *CAC_Type) GetCACR2_DFS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xc0) >> 6
}
func (o *CAC_Type) SetCACR2_RCDS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x30)|value<<4)
}
func (o *CAC_Type) GetCACR2_RCDS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0x30) >> 4
}
func (o *CAC_Type) SetCACR2_RSCS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0xe)|value<<1)
}
func (o *CAC_Type) GetCACR2_RSCS() uint8 {
	return (volatile.LoadUint8(&o.CACR2.Reg) & 0xe) >> 1
}
func (o *CAC_Type) SetCACR2_RPS(value uint8) {
	volatile.StoreUint8(&o.CACR2.Reg, volatile.LoadUint8(&o.CACR2.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCACR2_RPS() uint8 {
	return volatile.LoadUint8(&o.CACR2.Reg) & 0x1
}

// CAC.CAICR: CAC Interrupt Control Register
func (o *CAC_Type) SetCAICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x80)|value<<7)
}
func (o *CAC_Type) GetCAICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x80) >> 7
}
func (o *CAC_Type) SetCAICR_OVFFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x40)|value<<6)
}
func (o *CAC_Type) GetCAICR_OVFFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x40) >> 6
}
func (o *CAC_Type) SetCAICR_MENDFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x20)|value<<5)
}
func (o *CAC_Type) GetCAICR_MENDFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x20) >> 5
}
func (o *CAC_Type) SetCAICR_FERRFCL(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x10)|value<<4)
}
func (o *CAC_Type) GetCAICR_FERRFCL() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x10) >> 4
}
func (o *CAC_Type) SetCAICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x8)|value<<3)
}
func (o *CAC_Type) GetCAICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x8) >> 3
}
func (o *CAC_Type) SetCAICR_OVFIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCAICR_OVFIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCAICR_MENDIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCAICR_MENDIE() uint8 {
	return (volatile.LoadUint8(&o.CAICR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCAICR_FERRIE(value uint8) {
	volatile.StoreUint8(&o.CAICR.Reg, volatile.LoadUint8(&o.CAICR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCAICR_FERRIE() uint8 {
	return volatile.LoadUint8(&o.CAICR.Reg) & 0x1
}

// CAC.CASTR: CAC Status Register
func (o *CAC_Type) SetCASTR_OVFF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x4)|value<<2)
}
func (o *CAC_Type) GetCASTR_OVFF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x4) >> 2
}
func (o *CAC_Type) SetCASTR_MENDF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x2)|value<<1)
}
func (o *CAC_Type) GetCASTR_MENDF() uint8 {
	return (volatile.LoadUint8(&o.CASTR.Reg) & 0x2) >> 1
}
func (o *CAC_Type) SetCASTR_FERRF(value uint8) {
	volatile.StoreUint8(&o.CASTR.Reg, volatile.LoadUint8(&o.CASTR.Reg)&^(0x1)|value)
}
func (o *CAC_Type) GetCASTR_FERRF() uint8 {
	return volatile.LoadUint8(&o.CASTR.Reg) & 0x1
}

// CAC.CAULVR: CAC Upper-Limit Value Setting Register
func (o *CAC_Type) SetCAULVR(value uint16) {
	volatile.StoreUint16(&o.CAULVR.Reg, value)
}
func (o *CAC_Type) GetCAULVR() uint16 {
	return volatile.LoadUint16(&o.CAULVR.Reg)
}

// CAC.CALLVR: CAC Lower-Limit Value Setting Register
func (o *CAC_Type) SetCALLVR(value uint16) {
	volatile.StoreUint16(&o.CALLVR.Reg, value)
}
func (o *CAC_Type) GetCALLVR() uint16 {
	return volatile.LoadUint16(&o.CALLVR.Reg)
}

// CAC.CACNTBR: CAC Counter Buffer Register
func (o *CAC_Type) SetCACNTBR(value uint16) {
	volatile.StoreUint16(&o.CACNTBR.Reg, value)
}
func (o *CAC_Type) GetCACNTBR() uint16 {
	return volatile.LoadUint16(&o.CACNTBR.Reg)
}

// CRC Calculator
type CRC_Type struct {
	CRCCR0 volatile.Register8 // 0x0
	CRCCR1 volatile.Register8 // 0x1
	_      [2]byte
	CRCDIR volatile.Register32 // 0x4
	CRCDOR volatile.Register32 // 0x8
	CRCSAR volatile.Register16 // 0xC
}

// CRC.CRCCR0: CRC Control Register0
func (o *CRC_Type) SetCRCCR0_DORCLR(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR0_DORCLR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR0_LMS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR0_LMS() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x38)|value<<3)
}
func (o *CRC_Type) GetCRCCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CRCCR0.Reg) & 0x38) >> 3
}
func (o *CRC_Type) SetCRCCR0_GPS(value uint8) {
	volatile.StoreUint8(&o.CRCCR0.Reg, volatile.LoadUint8(&o.CRCCR0.Reg)&^(0x7)|value)
}
func (o *CRC_Type) GetCRCCR0_GPS() uint8 {
	return volatile.LoadUint8(&o.CRCCR0.Reg) & 0x7
}

// CRC.CRCCR1: CRC Control Register1
func (o *CRC_Type) SetCRCCR1_CRCSEN(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x80)|value<<7)
}
func (o *CRC_Type) GetCRCCR1_CRCSEN() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x80) >> 7
}
func (o *CRC_Type) SetCRCCR1_CRCSWR(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x40)|value<<6)
}
func (o *CRC_Type) GetCRCCR1_CRCSWR() uint8 {
	return (volatile.LoadUint8(&o.CRCCR1.Reg) & 0x40) >> 6
}
func (o *CRC_Type) SetCRCCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.CRCCR1.Reg, volatile.LoadUint8(&o.CRCCR1.Reg)&^(0x3f)|value)
}
func (o *CRC_Type) GetCRCCR1_Reserved() uint8 {
	return volatile.LoadUint8(&o.CRCCR1.Reg) & 0x3f
}

// CRC.CRCDIR: CRC Data Input Register
func (o *CRC_Type) SetCRCDIR(value uint32) {
	volatile.StoreUint32(&o.CRCDIR.Reg, value)
}
func (o *CRC_Type) GetCRCDIR() uint32 {
	return volatile.LoadUint32(&o.CRCDIR.Reg)
}

// CRC.CRCDOR: CRC Data Output Register
func (o *CRC_Type) SetCRCDOR(value uint32) {
	volatile.StoreUint32(&o.CRCDOR.Reg, value)
}
func (o *CRC_Type) GetCRCDOR() uint32 {
	return volatile.LoadUint32(&o.CRCDOR.Reg)
}

// CRC.CRCSAR: Snoop Address Register
func (o *CRC_Type) SetCRCSAR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0xc000)|value<<14)
}
func (o *CRC_Type) GetCRCSAR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CRCSAR.Reg) & 0xc000) >> 14
}
func (o *CRC_Type) SetCRCSAR_CRCSA(value uint16) {
	volatile.StoreUint16(&o.CRCSAR.Reg, volatile.LoadUint16(&o.CRCSAR.Reg)&^(0x3fff)|value)
}
func (o *CRC_Type) GetCRCSAR_CRCSA() uint16 {
	return volatile.LoadUint16(&o.CRCSAR.Reg) & 0x3fff
}

// Data Operation Circuit
type DOC_Type struct {
	DOCR  volatile.Register8 // 0x0
	_     byte
	DODIR volatile.Register16 // 0x2
	DODSR volatile.Register16 // 0x4
}

// DOC.DOCR: DOC Control Register
func (o *DOC_Type) SetDOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x80)|value<<7)
}
func (o *DOC_Type) GetDOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x80) >> 7
}
func (o *DOC_Type) SetDOCR_DOPCFCL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x40)|value<<6)
}
func (o *DOC_Type) GetDOCR_DOPCFCL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x40) >> 6
}
func (o *DOC_Type) SetDOCR_DOPCF(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x20)|value<<5)
}
func (o *DOC_Type) GetDOCR_DOPCF() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x20) >> 5
}
func (o *DOC_Type) SetDOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x18)|value<<3)
}
func (o *DOC_Type) GetDOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x18) >> 3
}
func (o *DOC_Type) SetDOCR_DCSEL(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x4)|value<<2)
}
func (o *DOC_Type) GetDOCR_DCSEL() uint8 {
	return (volatile.LoadUint8(&o.DOCR.Reg) & 0x4) >> 2
}
func (o *DOC_Type) SetDOCR_OMS(value uint8) {
	volatile.StoreUint8(&o.DOCR.Reg, volatile.LoadUint8(&o.DOCR.Reg)&^(0x3)|value)
}
func (o *DOC_Type) GetDOCR_OMS() uint8 {
	return volatile.LoadUint8(&o.DOCR.Reg) & 0x3
}

// DOC.DODIR: DOC Data Input Register
func (o *DOC_Type) SetDODIR(value uint16) {
	volatile.StoreUint16(&o.DODIR.Reg, value)
}
func (o *DOC_Type) GetDODIR() uint16 {
	return volatile.LoadUint16(&o.DODIR.Reg)
}

// DOC.DODSR: DOC Data Setting Register
func (o *DOC_Type) SetDODSR(value uint16) {
	volatile.StoreUint16(&o.DODSR.Reg, value)
}
func (o *DOC_Type) GetDODSR() uint16 {
	return volatile.LoadUint16(&o.DODSR.Reg)
}

// Serial Communication Interface 0
type SCI0_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
	DCCR  volatile.Register8  // 0x13
	FCR   volatile.Register16 // 0x14
	FDR   volatile.Register16 // 0x16
	LSR   volatile.Register16 // 0x18
	CDR   volatile.Register16 // 0x1A
	SPTR  volatile.Register8  // 0x1C
}

// SCI0.SMR: Serial Mode Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}

// SCI0.BRR: Bit Rate Register
func (o *SCI0_Type) SetBRR(value uint8) {
	volatile.StoreUint8(&o.BRR.Reg, value)
}
func (o *SCI0_Type) GetBRR() uint8 {
	return volatile.LoadUint8(&o.BRR.Reg)
}

// SCI0.SCR: Serial Control Register (SCMR.SMIF = 0)
func (o *SCI0_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}

// SCI0.TDR: Transmit Data Register
func (o *SCI0_Type) SetTDR(value uint8) {
	volatile.StoreUint8(&o.TDR.Reg, value)
}
func (o *SCI0_Type) GetTDR() uint8 {
	return volatile.LoadUint8(&o.TDR.Reg)
}

// SCI0.SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
func (o *SCI0_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}

// SCI0.RDR: Receive Data Register
func (o *SCI0_Type) SetRDR(value uint8) {
	volatile.StoreUint8(&o.RDR.Reg, value)
}
func (o *SCI0_Type) GetRDR() uint8 {
	return volatile.LoadUint8(&o.RDR.Reg)
}

// SCI0.SCMR: Smart Card Mode Register
func (o *SCI0_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x60)|value<<5)
}
func (o *SCI0_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x60) >> 5
}
func (o *SCI0_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}

// SCI0.SEMR: Serial Extended Mode Register
func (o *SCI0_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSEMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x3)|value)
}
func (o *SCI0_Type) GetSEMR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x3
}

// SCI0.SNFR: Noise Filter Setting Register
func (o *SCI0_Type) SetSNFR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSNFR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNFR.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI0_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI0.SIMR1: I2C Mode Register 1
func (o *SCI0_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSIMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x6)|value<<1)
}
func (o *SCI0_Type) GetSIMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0x6) >> 1
}
func (o *SCI0_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}

// SCI0.SIMR2: I2C Mode Register 2
func (o *SCI0_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1c)|value<<2)
}
func (o *SCI0_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x1c) >> 2
}
func (o *SCI0_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}

// SCI0.SIMR3: IIC Mode Register 3
func (o *SCI0_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}

// SCI0.SISR: IIC Status Register
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0xc0)|value<<6)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0xc0) >> 6
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x30)|value<<4)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x30) >> 4
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI0.SPMR: SPI Mode Register
func (o *SCI0_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}

// SCI0.TDRHL: Transmit 9-bit Data Register
func (o *SCI0_Type) SetTDRHL(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, value)
}
func (o *SCI0_Type) GetTDRHL() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg)
}

// SCI0.RDRHL: Receive 9-bit Data Register
func (o *SCI0_Type) SetRDRHL(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, value)
}
func (o *SCI0_Type) GetRDRHL() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg)
}

// SCI0.MDDR: Modulation Duty Register
func (o *SCI0_Type) SetMDDR(value uint8) {
	volatile.StoreUint8(&o.MDDR.Reg, value)
}
func (o *SCI0_Type) GetMDDR() uint8 {
	return volatile.LoadUint8(&o.MDDR.Reg)
}

// SCI0.DCCR: Data Compare Match Control Register
func (o *SCI0_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI0_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI0_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI0_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x20) >> 5
}
func (o *SCI0_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI0_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI0_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x6)|value<<1)
}
func (o *SCI0_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x6) >> 1
}
func (o *SCI0_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}

// SCI0.FCR: FIFO Control Register
func (o *SCI0_Type) SetFCR_RSTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf000)|value<<12)
}
func (o *SCI0_Type) GetFCR_RSTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf000) >> 12
}
func (o *SCI0_Type) SetFCR_RTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf00)|value<<8)
}
func (o *SCI0_Type) GetFCR_RTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf00) >> 8
}
func (o *SCI0_Type) SetFCR_TTRG(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0xf0)|value<<4)
}
func (o *SCI0_Type) GetFCR_TTRG() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0xf0) >> 4
}
func (o *SCI0_Type) SetFCR_DRES(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI0_Type) GetFCR_DRES() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x8) >> 3
}
func (o *SCI0_Type) SetFCR_TFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetFCR_TFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetFCR_RFRST(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetFCR_RFRST() uint16 {
	return (volatile.LoadUint16(&o.FCR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetFCR_FM(value uint16) {
	volatile.StoreUint16(&o.FCR.Reg, volatile.LoadUint16(&o.FCR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetFCR_FM() uint16 {
	return volatile.LoadUint16(&o.FCR.Reg) & 0x1
}

// SCI0.FDR: FIFO Data Count Register
func (o *SCI0_Type) SetFDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0xe000)|value<<13)
}
func (o *SCI0_Type) GetFDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0xe000) >> 13
}
func (o *SCI0_Type) SetFDR_T(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetFDR_T() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetFDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0xe0)|value<<5)
}
func (o *SCI0_Type) GetFDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FDR.Reg) & 0xe0) >> 5
}
func (o *SCI0_Type) SetFDR_R(value uint16) {
	volatile.StoreUint16(&o.FDR.Reg, volatile.LoadUint16(&o.FDR.Reg)&^(0x1f)|value)
}
func (o *SCI0_Type) GetFDR_R() uint16 {
	return volatile.LoadUint16(&o.FDR.Reg) & 0x1f
}

// SCI0.LSR: Line Status Register
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0xe000)|value<<13)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0xe000) >> 13
}
func (o *SCI0_Type) SetLSR_PNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1f00)|value<<8)
}
func (o *SCI0_Type) GetLSR_PNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x1f00) >> 8
}
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x80) >> 7
}
func (o *SCI0_Type) SetLSR_FNUM(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x7c)|value<<2)
}
func (o *SCI0_Type) GetLSR_FNUM() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x7c) >> 2
}
func (o *SCI0_Type) SetLSR_Reserved(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetLSR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.LSR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetLSR_ORER(value uint16) {
	volatile.StoreUint16(&o.LSR.Reg, volatile.LoadUint16(&o.LSR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetLSR_ORER() uint16 {
	return volatile.LoadUint16(&o.LSR.Reg) & 0x1
}

// SCI0.CDR: Compare Match Data Register
func (o *SCI0_Type) SetCDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0xfe00)|value<<9)
}
func (o *SCI0_Type) GetCDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CDR.Reg) & 0xfe00) >> 9
}
func (o *SCI0_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI0_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI0.SPTR: Serial Port Register
func (o *SCI0_Type) SetSPTR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI0_Type) GetSPTR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0xf8) >> 3
}
func (o *SCI0_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI0_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI0_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI0_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI0_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI0_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}

// Serial Communication Interface 1
type SCI1_Type struct {
	SMR   volatile.Register8  // 0x0
	BRR   volatile.Register8  // 0x1
	SCR   volatile.Register8  // 0x2
	TDR   volatile.Register8  // 0x3
	SSR   volatile.Register8  // 0x4
	RDR   volatile.Register8  // 0x5
	SCMR  volatile.Register8  // 0x6
	SEMR  volatile.Register8  // 0x7
	SNFR  volatile.Register8  // 0x8
	SIMR1 volatile.Register8  // 0x9
	SIMR2 volatile.Register8  // 0xA
	SIMR3 volatile.Register8  // 0xB
	SISR  volatile.Register8  // 0xC
	SPMR  volatile.Register8  // 0xD
	TDRHL volatile.Register16 // 0xE
	RDRHL volatile.Register16 // 0x10
	MDDR  volatile.Register8  // 0x12
	DCCR  volatile.Register8  // 0x13
	_     [6]byte
	CDR   volatile.Register16 // 0x1A
	SPTR  volatile.Register8  // 0x1C
}

// SCI1.SMR: Serial Mode Register (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSMR_CM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSMR_CM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSMR_CHR(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSMR_CHR() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSMR_PE(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSMR_PE() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSMR_PM(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSMR_PM() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSMR_STOP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSMR_STOP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSMR_MP(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSMR_MP() uint8 {
	return (volatile.LoadUint8(&o.SMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSMR_CKS(value uint8) {
	volatile.StoreUint8(&o.SMR.Reg, volatile.LoadUint8(&o.SMR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSMR_CKS() uint8 {
	return volatile.LoadUint8(&o.SMR.Reg) & 0x3
}

// SCI1.BRR: Bit Rate Register
func (o *SCI1_Type) SetBRR(value uint8) {
	volatile.StoreUint8(&o.BRR.Reg, value)
}
func (o *SCI1_Type) GetBRR() uint8 {
	return volatile.LoadUint8(&o.BRR.Reg)
}

// SCI1.SCR: Serial Control Register (SCMR.SMIF = 0)
func (o *SCI1_Type) SetSCR_TIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCR_TIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSCR_RIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSCR_RIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSCR_TE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSCR_TE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSCR_RE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCR_RE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCR_MPIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCR_MPIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCR_TEIE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCR_TEIE() uint8 {
	return (volatile.LoadUint8(&o.SCR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCR_CKE(value uint8) {
	volatile.StoreUint8(&o.SCR.Reg, volatile.LoadUint8(&o.SCR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSCR_CKE() uint8 {
	return volatile.LoadUint8(&o.SCR.Reg) & 0x3
}

// SCI1.TDR: Transmit Data Register
func (o *SCI1_Type) SetTDR(value uint8) {
	volatile.StoreUint8(&o.TDR.Reg, value)
}
func (o *SCI1_Type) GetTDR() uint8 {
	return volatile.LoadUint8(&o.TDR.Reg)
}

// SCI1.SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
func (o *SCI1_Type) SetSSR_TDRE(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSSR_TDRE() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSSR_RDRF(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSSR_RDRF() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSSR_ORER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSSR_ORER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSSR_FER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSSR_FER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSSR_PER(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSSR_PER() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSSR_TEND(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSSR_TEND() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSSR_MPB(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSSR_MPB() uint8 {
	return (volatile.LoadUint8(&o.SSR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSSR_MPBT(value uint8) {
	volatile.StoreUint8(&o.SSR.Reg, volatile.LoadUint8(&o.SSR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSSR_MPBT() uint8 {
	return volatile.LoadUint8(&o.SSR.Reg) & 0x1
}

// SCI1.RDR: Receive Data Register
func (o *SCI1_Type) SetRDR(value uint8) {
	volatile.StoreUint8(&o.RDR.Reg, value)
}
func (o *SCI1_Type) GetRDR() uint8 {
	return volatile.LoadUint8(&o.RDR.Reg)
}

// SCI1.SCMR: Smart Card Mode Register
func (o *SCI1_Type) SetSCMR_BCP2(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSCMR_BCP2() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x60)|value<<5)
}
func (o *SCI1_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x60) >> 5
}
func (o *SCI1_Type) SetSCMR_CHR1(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSCMR_CHR1() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSCMR_SDIR(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSCMR_SDIR() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSCMR_SINV(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSCMR_SINV() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSCMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSCMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCMR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSCMR_SMIF(value uint8) {
	volatile.StoreUint8(&o.SCMR.Reg, volatile.LoadUint8(&o.SCMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSCMR_SMIF() uint8 {
	return volatile.LoadUint8(&o.SCMR.Reg) & 0x1
}

// SCI1.SEMR: Serial Extended Mode Register
func (o *SCI1_Type) SetSEMR_RXDESEL(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSEMR_RXDESEL() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSEMR_BGDM(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSEMR_BGDM() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSEMR_NFEN(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSEMR_NFEN() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSEMR_ABCS(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSEMR_ABCS() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSEMR_ABCSE(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSEMR_ABCSE() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSEMR_BRME(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSEMR_BRME() uint8 {
	return (volatile.LoadUint8(&o.SEMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSEMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SEMR.Reg, volatile.LoadUint8(&o.SEMR.Reg)&^(0x3)|value)
}
func (o *SCI1_Type) GetSEMR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SEMR.Reg) & 0x3
}

// SCI1.SNFR: Noise Filter Setting Register
func (o *SCI1_Type) SetSNFR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI1_Type) GetSNFR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNFR.Reg) & 0xf8) >> 3
}
func (o *SCI1_Type) SetSNFR_NFCS(value uint8) {
	volatile.StoreUint8(&o.SNFR.Reg, volatile.LoadUint8(&o.SNFR.Reg)&^(0x7)|value)
}
func (o *SCI1_Type) GetSNFR_NFCS() uint8 {
	return volatile.LoadUint8(&o.SNFR.Reg) & 0x7
}

// SCI1.SIMR1: I2C Mode Register 1
func (o *SCI1_Type) SetSIMR1_IICDL(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0xf8)|value<<3)
}
func (o *SCI1_Type) GetSIMR1_IICDL() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0xf8) >> 3
}
func (o *SCI1_Type) SetSIMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x6)|value<<1)
}
func (o *SCI1_Type) GetSIMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR1.Reg) & 0x6) >> 1
}
func (o *SCI1_Type) SetSIMR1_IICM(value uint8) {
	volatile.StoreUint8(&o.SIMR1.Reg, volatile.LoadUint8(&o.SIMR1.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR1_IICM() uint8 {
	return volatile.LoadUint8(&o.SIMR1.Reg) & 0x1
}

// SCI1.SIMR2: I2C Mode Register 2
func (o *SCI1_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0xc0)|value<<6)
}
func (o *SCI1_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0xc0) >> 6
}
func (o *SCI1_Type) SetSIMR2_IICACKT(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSIMR2_IICACKT() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSIMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1c)|value<<2)
}
func (o *SCI1_Type) GetSIMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x1c) >> 2
}
func (o *SCI1_Type) SetSIMR2_IICCSC(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR2_IICCSC() uint8 {
	return (volatile.LoadUint8(&o.SIMR2.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR2_IICINTM(value uint8) {
	volatile.StoreUint8(&o.SIMR2.Reg, volatile.LoadUint8(&o.SIMR2.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR2_IICINTM() uint8 {
	return volatile.LoadUint8(&o.SIMR2.Reg) & 0x1
}

// SCI1.SIMR3: IIC Mode Register 3
func (o *SCI1_Type) SetSIMR3_IICSCLS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0xc0)|value<<6)
}
func (o *SCI1_Type) GetSIMR3_IICSCLS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0xc0) >> 6
}
func (o *SCI1_Type) SetSIMR3_IICSDAS(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetSIMR3_IICSDAS() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x30) >> 4
}
func (o *SCI1_Type) SetSIMR3_IICSTIF(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSIMR3_IICSTIF() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSIMR3_IICSTPREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSIMR3_IICSTPREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSIMR3_IICRSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSIMR3_IICRSTAREQ() uint8 {
	return (volatile.LoadUint8(&o.SIMR3.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSIMR3_IICSTAREQ(value uint8) {
	volatile.StoreUint8(&o.SIMR3.Reg, volatile.LoadUint8(&o.SIMR3.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSIMR3_IICSTAREQ() uint8 {
	return volatile.LoadUint8(&o.SIMR3.Reg) & 0x1
}

// SCI1.SISR: IIC Status Register
func (o *SCI1_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0xc0)|value<<6)
}
func (o *SCI1_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0xc0) >> 6
}
func (o *SCI1_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x30)|value<<4)
}
func (o *SCI1_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x30) >> 4
}
func (o *SCI1_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SISR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSISR_IICACKR(value uint8) {
	volatile.StoreUint8(&o.SISR.Reg, volatile.LoadUint8(&o.SISR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSISR_IICACKR() uint8 {
	return volatile.LoadUint8(&o.SISR.Reg) & 0x1
}

// SCI1.SPMR: SPI Mode Register
func (o *SCI1_Type) SetSPMR_CKPH(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetSPMR_CKPH() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetSPMR_CKPOL(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetSPMR_CKPOL() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetSPMR_MFF(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetSPMR_MFF() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetSPMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetSPMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetSPMR_MSS(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSPMR_MSS() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSPMR_CTSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSPMR_CTSE() uint8 {
	return (volatile.LoadUint8(&o.SPMR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSPMR_SSE(value uint8) {
	volatile.StoreUint8(&o.SPMR.Reg, volatile.LoadUint8(&o.SPMR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSPMR_SSE() uint8 {
	return volatile.LoadUint8(&o.SPMR.Reg) & 0x1
}

// SCI1.TDRHL: Transmit 9-bit Data Register
func (o *SCI1_Type) SetTDRHL(value uint16) {
	volatile.StoreUint16(&o.TDRHL.Reg, value)
}
func (o *SCI1_Type) GetTDRHL() uint16 {
	return volatile.LoadUint16(&o.TDRHL.Reg)
}

// SCI1.RDRHL: Receive 9-bit Data Register
func (o *SCI1_Type) SetRDRHL(value uint16) {
	volatile.StoreUint16(&o.RDRHL.Reg, value)
}
func (o *SCI1_Type) GetRDRHL() uint16 {
	return volatile.LoadUint16(&o.RDRHL.Reg)
}

// SCI1.MDDR: Modulation Duty Register
func (o *SCI1_Type) SetMDDR(value uint8) {
	volatile.StoreUint8(&o.MDDR.Reg, value)
}
func (o *SCI1_Type) GetMDDR() uint8 {
	return volatile.LoadUint8(&o.MDDR.Reg)
}

// SCI1.DCCR: Data Compare Match Control Register
func (o *SCI1_Type) SetDCCR_DCME(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x80)|value<<7)
}
func (o *SCI1_Type) GetDCCR_DCME() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x80) >> 7
}
func (o *SCI1_Type) SetDCCR_IDSEL(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x40)|value<<6)
}
func (o *SCI1_Type) GetDCCR_IDSEL() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x40) >> 6
}
func (o *SCI1_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x20)|value<<5)
}
func (o *SCI1_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x20) >> 5
}
func (o *SCI1_Type) SetDCCR_DFER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x10)|value<<4)
}
func (o *SCI1_Type) GetDCCR_DFER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x10) >> 4
}
func (o *SCI1_Type) SetDCCR_DPER(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x8)|value<<3)
}
func (o *SCI1_Type) GetDCCR_DPER() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x8) >> 3
}
func (o *SCI1_Type) SetDCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x6)|value<<1)
}
func (o *SCI1_Type) GetDCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DCCR.Reg) & 0x6) >> 1
}
func (o *SCI1_Type) SetDCCR_DCMF(value uint8) {
	volatile.StoreUint8(&o.DCCR.Reg, volatile.LoadUint8(&o.DCCR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetDCCR_DCMF() uint8 {
	return volatile.LoadUint8(&o.DCCR.Reg) & 0x1
}

// SCI1.CDR: Compare Match Data Register
func (o *SCI1_Type) SetCDR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0xfe00)|value<<9)
}
func (o *SCI1_Type) GetCDR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CDR.Reg) & 0xfe00) >> 9
}
func (o *SCI1_Type) SetCDR_CMPD(value uint16) {
	volatile.StoreUint16(&o.CDR.Reg, volatile.LoadUint16(&o.CDR.Reg)&^(0x1ff)|value)
}
func (o *SCI1_Type) GetCDR_CMPD() uint16 {
	return volatile.LoadUint16(&o.CDR.Reg) & 0x1ff
}

// SCI1.SPTR: Serial Port Register
func (o *SCI1_Type) SetSPTR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0xf8)|value<<3)
}
func (o *SCI1_Type) GetSPTR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0xf8) >> 3
}
func (o *SCI1_Type) SetSPTR_SPB2IO(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x4)|value<<2)
}
func (o *SCI1_Type) GetSPTR_SPB2IO() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x4) >> 2
}
func (o *SCI1_Type) SetSPTR_SPB2DT(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x2)|value<<1)
}
func (o *SCI1_Type) GetSPTR_SPB2DT() uint8 {
	return (volatile.LoadUint8(&o.SPTR.Reg) & 0x2) >> 1
}
func (o *SCI1_Type) SetSPTR_RXDMON(value uint8) {
	volatile.StoreUint8(&o.SPTR.Reg, volatile.LoadUint8(&o.SPTR.Reg)&^(0x1)|value)
}
func (o *SCI1_Type) GetSPTR_RXDMON() uint8 {
	return volatile.LoadUint8(&o.SPTR.Reg) & 0x1
}

// Serial Peripheral Interface 0
type SPI0_Type struct {
	SPCR   volatile.Register8  // 0x0
	SSLP   volatile.Register8  // 0x1
	SPPCR  volatile.Register8  // 0x2
	SPSR   volatile.Register8  // 0x3
	SPDR   volatile.Register32 // 0x4
	_      [2]byte
	SPBR   volatile.Register8  // 0xA
	SPDCR  volatile.Register8  // 0xB
	SPCKD  volatile.Register8  // 0xC
	SSLND  volatile.Register8  // 0xD
	SPND   volatile.Register8  // 0xE
	SPCR2  volatile.Register8  // 0xF
	SPCMD0 volatile.Register16 // 0x10
}

// SPI0.SPCR: SPI Control Register
func (o *SPI0_Type) SetSPCR_SPRIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCR_SPRIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCR_SPE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPCR_SPE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPCR_SPTIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPCR_SPTIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPCR_SPEIE(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR_SPEIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR_MSTR(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR_MSTR() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR_MODFEN(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR_MODFEN() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR_TXMD(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR_TXMD() uint8 {
	return (volatile.LoadUint8(&o.SPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR_SPMS(value uint8) {
	volatile.StoreUint8(&o.SPCR.Reg, volatile.LoadUint8(&o.SPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR_SPMS() uint8 {
	return volatile.LoadUint8(&o.SPCR.Reg) & 0x1
}

// SPI0.SSLP: SPI Slave Select Polarity Register
func (o *SPI0_Type) SetSSLP_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0xf0)|value<<4)
}
func (o *SPI0_Type) GetSSLP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0xf0) >> 4
}
func (o *SPI0_Type) SetSSLP_SSL3P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSSLP_SSL3P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSSLP_SSL2P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSSLP_SSL2P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSSLP_SSL1P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSSLP_SSL1P() uint8 {
	return (volatile.LoadUint8(&o.SSLP.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSSLP_SSL0P(value uint8) {
	volatile.StoreUint8(&o.SSLP.Reg, volatile.LoadUint8(&o.SSLP.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSSLP_SSL0P() uint8 {
	return volatile.LoadUint8(&o.SSLP.Reg) & 0x1
}

// SPI0.SPPCR: SPI Pin Control Register
func (o *SPI0_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPPCR_MOIFE(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPPCR_MOIFE() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPPCR_MOIFV(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPPCR_MOIFV() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPPCR_SPLP2(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPPCR_SPLP2() uint8 {
	return (volatile.LoadUint8(&o.SPPCR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPPCR_SPLP(value uint8) {
	volatile.StoreUint8(&o.SPPCR.Reg, volatile.LoadUint8(&o.SPPCR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPPCR_SPLP() uint8 {
	return volatile.LoadUint8(&o.SPPCR.Reg) & 0x1
}

// SPI0.SPSR: SPI Status Register
func (o *SPI0_Type) SetSPSR_SPRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPSR_SPRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x40)|value<<6)
}
func (o *SPI0_Type) GetSPSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x40) >> 6
}
func (o *SPI0_Type) SetSPSR_SPTEF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPSR_SPTEF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPSR_UDRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPSR_UDRF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPSR_PERF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPSR_PERF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPSR_MODF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPSR_MODF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPSR_IDLNF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPSR_IDLNF() uint8 {
	return (volatile.LoadUint8(&o.SPSR.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPSR_OVRF(value uint8) {
	volatile.StoreUint8(&o.SPSR.Reg, volatile.LoadUint8(&o.SPSR.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPSR_OVRF() uint8 {
	return volatile.LoadUint8(&o.SPSR.Reg) & 0x1
}

// SPI0.SPDR: SPI Data Register
func (o *SPI0_Type) SetSPDR(value uint32) {
	volatile.StoreUint32(&o.SPDR.Reg, value)
}
func (o *SPI0_Type) GetSPDR() uint32 {
	return volatile.LoadUint32(&o.SPDR.Reg)
}

// SPI0.SPBR: SPI Bit Rate Register
func (o *SPI0_Type) SetSPBR(value uint8) {
	volatile.StoreUint8(&o.SPBR.Reg, value)
}
func (o *SPI0_Type) GetSPBR() uint8 {
	return volatile.LoadUint8(&o.SPBR.Reg)
}

// SPI0.SPDCR: SPI Data Control Register
func (o *SPI0_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xc0)|value<<6)
}
func (o *SPI0_Type) GetSPDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0xc0) >> 6
}
func (o *SPI0_Type) SetSPDCR_SPLW(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x20)|value<<5)
}
func (o *SPI0_Type) GetSPDCR_SPLW() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x20) >> 5
}
func (o *SPI0_Type) SetSPDCR_SPRDTD(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPDCR_SPRDTD() uint8 {
	return (volatile.LoadUint8(&o.SPDCR.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPDCR.Reg, volatile.LoadUint8(&o.SPDCR.Reg)&^(0xf)|value)
}
func (o *SPI0_Type) GetSPDCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SPDCR.Reg) & 0xf
}

// SPI0.SPCKD: SPI Clock Delay Register
func (o *SPI0_Type) SetSPCKD_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSPCKD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCKD.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSPCKD_SCKDL(value uint8) {
	volatile.StoreUint8(&o.SPCKD.Reg, volatile.LoadUint8(&o.SPCKD.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPCKD_SCKDL() uint8 {
	return volatile.LoadUint8(&o.SPCKD.Reg) & 0x7
}

// SPI0.SSLND: SPI Slave Select Negation Delay Register
func (o *SPI0_Type) SetSSLND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSSLND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SSLND.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSSLND_SLNDL(value uint8) {
	volatile.StoreUint8(&o.SSLND.Reg, volatile.LoadUint8(&o.SSLND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSSLND_SLNDL() uint8 {
	return volatile.LoadUint8(&o.SSLND.Reg) & 0x7
}

// SPI0.SPND: SPI Next-Access Delay Register
func (o *SPI0_Type) SetSPND_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0xf8)|value<<3)
}
func (o *SPI0_Type) GetSPND_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPND.Reg) & 0xf8) >> 3
}
func (o *SPI0_Type) SetSPND_SPNDL(value uint8) {
	volatile.StoreUint8(&o.SPND.Reg, volatile.LoadUint8(&o.SPND.Reg)&^(0x7)|value)
}
func (o *SPI0_Type) GetSPND_SPNDL() uint8 {
	return volatile.LoadUint8(&o.SPND.Reg) & 0x7
}

// SPI0.SPCR2: SPI Control Register 2
func (o *SPI0_Type) SetSPCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0xe0)|value<<5)
}
func (o *SPI0_Type) GetSPCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0xe0) >> 5
}
func (o *SPI0_Type) SetSPCR2_SCKASE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x10)|value<<4)
}
func (o *SPI0_Type) GetSPCR2_SCKASE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x10) >> 4
}
func (o *SPI0_Type) SetSPCR2_PTE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x8)|value<<3)
}
func (o *SPI0_Type) GetSPCR2_PTE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x8) >> 3
}
func (o *SPI0_Type) SetSPCR2_SPIIE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x4)|value<<2)
}
func (o *SPI0_Type) GetSPCR2_SPIIE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x4) >> 2
}
func (o *SPI0_Type) SetSPCR2_SPOE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCR2_SPOE() uint8 {
	return (volatile.LoadUint8(&o.SPCR2.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCR2_SPPE(value uint8) {
	volatile.StoreUint8(&o.SPCR2.Reg, volatile.LoadUint8(&o.SPCR2.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCR2_SPPE() uint8 {
	return volatile.LoadUint8(&o.SPCR2.Reg) & 0x1
}

// SPI0.SPCMD0: SPI Command Register 0
func (o *SPI0_Type) SetSPCMD0_SCKDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x8000)|value<<15)
}
func (o *SPI0_Type) GetSPCMD0_SCKDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x8000) >> 15
}
func (o *SPI0_Type) SetSPCMD0_SLNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x4000)|value<<14)
}
func (o *SPI0_Type) GetSPCMD0_SLNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x4000) >> 14
}
func (o *SPI0_Type) SetSPCMD0_SPNDEN(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2000)|value<<13)
}
func (o *SPI0_Type) GetSPCMD0_SPNDEN() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2000) >> 13
}
func (o *SPI0_Type) SetSPCMD0_LSBF(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1000)|value<<12)
}
func (o *SPI0_Type) GetSPCMD0_LSBF() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1000) >> 12
}
func (o *SPI0_Type) SetSPCMD0_SPB(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xf00)|value<<8)
}
func (o *SPI0_Type) GetSPCMD0_SPB() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xf00) >> 8
}
func (o *SPI0_Type) SetSPCMD0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x80)|value<<7)
}
func (o *SPI0_Type) GetSPCMD0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x80) >> 7
}
func (o *SPI0_Type) SetSPCMD0_SSLA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x70)|value<<4)
}
func (o *SPI0_Type) GetSPCMD0_SSLA() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x70) >> 4
}
func (o *SPI0_Type) SetSPCMD0_BRDV(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0xc)|value<<2)
}
func (o *SPI0_Type) GetSPCMD0_BRDV() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0xc) >> 2
}
func (o *SPI0_Type) SetSPCMD0_CPOL(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x2)|value<<1)
}
func (o *SPI0_Type) GetSPCMD0_CPOL() uint16 {
	return (volatile.LoadUint16(&o.SPCMD0.Reg) & 0x2) >> 1
}
func (o *SPI0_Type) SetSPCMD0_CPHA(value uint16) {
	volatile.StoreUint16(&o.SPCMD0.Reg, volatile.LoadUint16(&o.SPCMD0.Reg)&^(0x1)|value)
}
func (o *SPI0_Type) GetSPCMD0_CPHA() uint16 {
	return volatile.LoadUint16(&o.SPCMD0.Reg) & 0x1
}

// CAN0 Module
type CAN0_Type struct {
	_       [512]byte
	MB0_ID  volatile.Register32    // 0x200
	MB0_DL  volatile.Register16    // 0x204
	MB0_D0  volatile.Register8     // 0x206
	MB0_D1  volatile.Register8     // 0x207
	MB0_D2  volatile.Register8     // 0x208
	MB0_D3  volatile.Register8     // 0x209
	MB0_D4  volatile.Register8     // 0x20A
	MB0_D5  volatile.Register8     // 0x20B
	MB0_D6  volatile.Register8     // 0x20C
	MB0_D7  volatile.Register8     // 0x20D
	MB0_TS  volatile.Register16    // 0x20E
	MB1_ID  volatile.Register32    // 0x210
	MB1_DL  volatile.Register16    // 0x214
	MB1_D0  volatile.Register8     // 0x216
	MB1_D1  volatile.Register8     // 0x217
	MB1_D2  volatile.Register8     // 0x218
	MB1_D3  volatile.Register8     // 0x219
	MB1_D4  volatile.Register8     // 0x21A
	MB1_D5  volatile.Register8     // 0x21B
	MB1_D6  volatile.Register8     // 0x21C
	MB1_D7  volatile.Register8     // 0x21D
	MB1_TS  volatile.Register16    // 0x21E
	MB2_ID  volatile.Register32    // 0x220
	MB2_DL  volatile.Register16    // 0x224
	MB2_D0  volatile.Register8     // 0x226
	MB2_D1  volatile.Register8     // 0x227
	MB2_D2  volatile.Register8     // 0x228
	MB2_D3  volatile.Register8     // 0x229
	MB2_D4  volatile.Register8     // 0x22A
	MB2_D5  volatile.Register8     // 0x22B
	MB2_D6  volatile.Register8     // 0x22C
	MB2_D7  volatile.Register8     // 0x22D
	MB2_TS  volatile.Register16    // 0x22E
	MB3_ID  volatile.Register32    // 0x230
	MB3_DL  volatile.Register16    // 0x234
	MB3_D0  volatile.Register8     // 0x236
	MB3_D1  volatile.Register8     // 0x237
	MB3_D2  volatile.Register8     // 0x238
	MB3_D3  volatile.Register8     // 0x239
	MB3_D4  volatile.Register8     // 0x23A
	MB3_D5  volatile.Register8     // 0x23B
	MB3_D6  volatile.Register8     // 0x23C
	MB3_D7  volatile.Register8     // 0x23D
	MB3_TS  volatile.Register16    // 0x23E
	MB4_ID  volatile.Register32    // 0x240
	MB4_DL  volatile.Register16    // 0x244
	MB4_D0  volatile.Register8     // 0x246
	MB4_D1  volatile.Register8     // 0x247
	MB4_D2  volatile.Register8     // 0x248
	MB4_D3  volatile.Register8     // 0x249
	MB4_D4  volatile.Register8     // 0x24A
	MB4_D5  volatile.Register8     // 0x24B
	MB4_D6  volatile.Register8     // 0x24C
	MB4_D7  volatile.Register8     // 0x24D
	MB4_TS  volatile.Register16    // 0x24E
	MB5_ID  volatile.Register32    // 0x250
	MB5_DL  volatile.Register16    // 0x254
	MB5_D0  volatile.Register8     // 0x256
	MB5_D1  volatile.Register8     // 0x257
	MB5_D2  volatile.Register8     // 0x258
	MB5_D3  volatile.Register8     // 0x259
	MB5_D4  volatile.Register8     // 0x25A
	MB5_D5  volatile.Register8     // 0x25B
	MB5_D6  volatile.Register8     // 0x25C
	MB5_D7  volatile.Register8     // 0x25D
	MB5_TS  volatile.Register16    // 0x25E
	MB6_ID  volatile.Register32    // 0x260
	MB6_DL  volatile.Register16    // 0x264
	MB6_D0  volatile.Register8     // 0x266
	MB6_D1  volatile.Register8     // 0x267
	MB6_D2  volatile.Register8     // 0x268
	MB6_D3  volatile.Register8     // 0x269
	MB6_D4  volatile.Register8     // 0x26A
	MB6_D5  volatile.Register8     // 0x26B
	MB6_D6  volatile.Register8     // 0x26C
	MB6_D7  volatile.Register8     // 0x26D
	MB6_TS  volatile.Register16    // 0x26E
	MB7_ID  volatile.Register32    // 0x270
	MB7_DL  volatile.Register16    // 0x274
	MB7_D0  volatile.Register8     // 0x276
	MB7_D1  volatile.Register8     // 0x277
	MB7_D2  volatile.Register8     // 0x278
	MB7_D3  volatile.Register8     // 0x279
	MB7_D4  volatile.Register8     // 0x27A
	MB7_D5  volatile.Register8     // 0x27B
	MB7_D6  volatile.Register8     // 0x27C
	MB7_D7  volatile.Register8     // 0x27D
	MB7_TS  volatile.Register16    // 0x27E
	MB8_ID  volatile.Register32    // 0x280
	MB8_DL  volatile.Register16    // 0x284
	MB8_D0  volatile.Register8     // 0x286
	MB8_D1  volatile.Register8     // 0x287
	MB8_D2  volatile.Register8     // 0x288
	MB8_D3  volatile.Register8     // 0x289
	MB8_D4  volatile.Register8     // 0x28A
	MB8_D5  volatile.Register8     // 0x28B
	MB8_D6  volatile.Register8     // 0x28C
	MB8_D7  volatile.Register8     // 0x28D
	MB8_TS  volatile.Register16    // 0x28E
	MB9_ID  volatile.Register32    // 0x290
	MB9_DL  volatile.Register16    // 0x294
	MB9_D0  volatile.Register8     // 0x296
	MB9_D1  volatile.Register8     // 0x297
	MB9_D2  volatile.Register8     // 0x298
	MB9_D3  volatile.Register8     // 0x299
	MB9_D4  volatile.Register8     // 0x29A
	MB9_D5  volatile.Register8     // 0x29B
	MB9_D6  volatile.Register8     // 0x29C
	MB9_D7  volatile.Register8     // 0x29D
	MB9_TS  volatile.Register16    // 0x29E
	MB10_ID volatile.Register32    // 0x2A0
	MB10_DL volatile.Register16    // 0x2A4
	MB10_D0 volatile.Register8     // 0x2A6
	MB10_D1 volatile.Register8     // 0x2A7
	MB10_D2 volatile.Register8     // 0x2A8
	MB10_D3 volatile.Register8     // 0x2A9
	MB10_D4 volatile.Register8     // 0x2AA
	MB10_D5 volatile.Register8     // 0x2AB
	MB10_D6 volatile.Register8     // 0x2AC
	MB10_D7 volatile.Register8     // 0x2AD
	MB10_TS volatile.Register16    // 0x2AE
	MB11_ID volatile.Register32    // 0x2B0
	MB11_DL volatile.Register16    // 0x2B4
	MB11_D0 volatile.Register8     // 0x2B6
	MB11_D1 volatile.Register8     // 0x2B7
	MB11_D2 volatile.Register8     // 0x2B8
	MB11_D3 volatile.Register8     // 0x2B9
	MB11_D4 volatile.Register8     // 0x2BA
	MB11_D5 volatile.Register8     // 0x2BB
	MB11_D6 volatile.Register8     // 0x2BC
	MB11_D7 volatile.Register8     // 0x2BD
	MB11_TS volatile.Register16    // 0x2BE
	MB12_ID volatile.Register32    // 0x2C0
	MB12_DL volatile.Register16    // 0x2C4
	MB12_D0 volatile.Register8     // 0x2C6
	MB12_D1 volatile.Register8     // 0x2C7
	MB12_D2 volatile.Register8     // 0x2C8
	MB12_D3 volatile.Register8     // 0x2C9
	MB12_D4 volatile.Register8     // 0x2CA
	MB12_D5 volatile.Register8     // 0x2CB
	MB12_D6 volatile.Register8     // 0x2CC
	MB12_D7 volatile.Register8     // 0x2CD
	MB12_TS volatile.Register16    // 0x2CE
	MB13_ID volatile.Register32    // 0x2D0
	MB13_DL volatile.Register16    // 0x2D4
	MB13_D0 volatile.Register8     // 0x2D6
	MB13_D1 volatile.Register8     // 0x2D7
	MB13_D2 volatile.Register8     // 0x2D8
	MB13_D3 volatile.Register8     // 0x2D9
	MB13_D4 volatile.Register8     // 0x2DA
	MB13_D5 volatile.Register8     // 0x2DB
	MB13_D6 volatile.Register8     // 0x2DC
	MB13_D7 volatile.Register8     // 0x2DD
	MB13_TS volatile.Register16    // 0x2DE
	MB14_ID volatile.Register32    // 0x2E0
	MB14_DL volatile.Register16    // 0x2E4
	MB14_D0 volatile.Register8     // 0x2E6
	MB14_D1 volatile.Register8     // 0x2E7
	MB14_D2 volatile.Register8     // 0x2E8
	MB14_D3 volatile.Register8     // 0x2E9
	MB14_D4 volatile.Register8     // 0x2EA
	MB14_D5 volatile.Register8     // 0x2EB
	MB14_D6 volatile.Register8     // 0x2EC
	MB14_D7 volatile.Register8     // 0x2ED
	MB14_TS volatile.Register16    // 0x2EE
	MB15_ID volatile.Register32    // 0x2F0
	MB15_DL volatile.Register16    // 0x2F4
	MB15_D0 volatile.Register8     // 0x2F6
	MB15_D1 volatile.Register8     // 0x2F7
	MB15_D2 volatile.Register8     // 0x2F8
	MB15_D3 volatile.Register8     // 0x2F9
	MB15_D4 volatile.Register8     // 0x2FA
	MB15_D5 volatile.Register8     // 0x2FB
	MB15_D6 volatile.Register8     // 0x2FC
	MB15_D7 volatile.Register8     // 0x2FD
	MB15_TS volatile.Register16    // 0x2FE
	MB16_ID volatile.Register32    // 0x300
	MB16_DL volatile.Register16    // 0x304
	MB16_D0 volatile.Register8     // 0x306
	MB16_D1 volatile.Register8     // 0x307
	MB16_D2 volatile.Register8     // 0x308
	MB16_D3 volatile.Register8     // 0x309
	MB16_D4 volatile.Register8     // 0x30A
	MB16_D5 volatile.Register8     // 0x30B
	MB16_D6 volatile.Register8     // 0x30C
	MB16_D7 volatile.Register8     // 0x30D
	MB16_TS volatile.Register16    // 0x30E
	MB17_ID volatile.Register32    // 0x310
	MB17_DL volatile.Register16    // 0x314
	MB17_D0 volatile.Register8     // 0x316
	MB17_D1 volatile.Register8     // 0x317
	MB17_D2 volatile.Register8     // 0x318
	MB17_D3 volatile.Register8     // 0x319
	MB17_D4 volatile.Register8     // 0x31A
	MB17_D5 volatile.Register8     // 0x31B
	MB17_D6 volatile.Register8     // 0x31C
	MB17_D7 volatile.Register8     // 0x31D
	MB17_TS volatile.Register16    // 0x31E
	MB18_ID volatile.Register32    // 0x320
	MB18_DL volatile.Register16    // 0x324
	MB18_D0 volatile.Register8     // 0x326
	MB18_D1 volatile.Register8     // 0x327
	MB18_D2 volatile.Register8     // 0x328
	MB18_D3 volatile.Register8     // 0x329
	MB18_D4 volatile.Register8     // 0x32A
	MB18_D5 volatile.Register8     // 0x32B
	MB18_D6 volatile.Register8     // 0x32C
	MB18_D7 volatile.Register8     // 0x32D
	MB18_TS volatile.Register16    // 0x32E
	MB19_ID volatile.Register32    // 0x330
	MB19_DL volatile.Register16    // 0x334
	MB19_D0 volatile.Register8     // 0x336
	MB19_D1 volatile.Register8     // 0x337
	MB19_D2 volatile.Register8     // 0x338
	MB19_D3 volatile.Register8     // 0x339
	MB19_D4 volatile.Register8     // 0x33A
	MB19_D5 volatile.Register8     // 0x33B
	MB19_D6 volatile.Register8     // 0x33C
	MB19_D7 volatile.Register8     // 0x33D
	MB19_TS volatile.Register16    // 0x33E
	MB20_ID volatile.Register32    // 0x340
	MB20_DL volatile.Register16    // 0x344
	MB20_D0 volatile.Register8     // 0x346
	MB20_D1 volatile.Register8     // 0x347
	MB20_D2 volatile.Register8     // 0x348
	MB20_D3 volatile.Register8     // 0x349
	MB20_D4 volatile.Register8     // 0x34A
	MB20_D5 volatile.Register8     // 0x34B
	MB20_D6 volatile.Register8     // 0x34C
	MB20_D7 volatile.Register8     // 0x34D
	MB20_TS volatile.Register16    // 0x34E
	MB21_ID volatile.Register32    // 0x350
	MB21_DL volatile.Register16    // 0x354
	MB21_D0 volatile.Register8     // 0x356
	MB21_D1 volatile.Register8     // 0x357
	MB21_D2 volatile.Register8     // 0x358
	MB21_D3 volatile.Register8     // 0x359
	MB21_D4 volatile.Register8     // 0x35A
	MB21_D5 volatile.Register8     // 0x35B
	MB21_D6 volatile.Register8     // 0x35C
	MB21_D7 volatile.Register8     // 0x35D
	MB21_TS volatile.Register16    // 0x35E
	MB22_ID volatile.Register32    // 0x360
	MB22_DL volatile.Register16    // 0x364
	MB22_D0 volatile.Register8     // 0x366
	MB22_D1 volatile.Register8     // 0x367
	MB22_D2 volatile.Register8     // 0x368
	MB22_D3 volatile.Register8     // 0x369
	MB22_D4 volatile.Register8     // 0x36A
	MB22_D5 volatile.Register8     // 0x36B
	MB22_D6 volatile.Register8     // 0x36C
	MB22_D7 volatile.Register8     // 0x36D
	MB22_TS volatile.Register16    // 0x36E
	MB23_ID volatile.Register32    // 0x370
	MB23_DL volatile.Register16    // 0x374
	MB23_D0 volatile.Register8     // 0x376
	MB23_D1 volatile.Register8     // 0x377
	MB23_D2 volatile.Register8     // 0x378
	MB23_D3 volatile.Register8     // 0x379
	MB23_D4 volatile.Register8     // 0x37A
	MB23_D5 volatile.Register8     // 0x37B
	MB23_D6 volatile.Register8     // 0x37C
	MB23_D7 volatile.Register8     // 0x37D
	MB23_TS volatile.Register16    // 0x37E
	MB24_ID volatile.Register32    // 0x380
	MB24_DL volatile.Register16    // 0x384
	MB24_D0 volatile.Register8     // 0x386
	MB24_D1 volatile.Register8     // 0x387
	MB24_D2 volatile.Register8     // 0x388
	MB24_D3 volatile.Register8     // 0x389
	MB24_D4 volatile.Register8     // 0x38A
	MB24_D5 volatile.Register8     // 0x38B
	MB24_D6 volatile.Register8     // 0x38C
	MB24_D7 volatile.Register8     // 0x38D
	MB24_TS volatile.Register16    // 0x38E
	MB25_ID volatile.Register32    // 0x390
	MB25_DL volatile.Register16    // 0x394
	MB25_D0 volatile.Register8     // 0x396
	MB25_D1 volatile.Register8     // 0x397
	MB25_D2 volatile.Register8     // 0x398
	MB25_D3 volatile.Register8     // 0x399
	MB25_D4 volatile.Register8     // 0x39A
	MB25_D5 volatile.Register8     // 0x39B
	MB25_D6 volatile.Register8     // 0x39C
	MB25_D7 volatile.Register8     // 0x39D
	MB25_TS volatile.Register16    // 0x39E
	MB26_ID volatile.Register32    // 0x3A0
	MB26_DL volatile.Register16    // 0x3A4
	MB26_D0 volatile.Register8     // 0x3A6
	MB26_D1 volatile.Register8     // 0x3A7
	MB26_D2 volatile.Register8     // 0x3A8
	MB26_D3 volatile.Register8     // 0x3A9
	MB26_D4 volatile.Register8     // 0x3AA
	MB26_D5 volatile.Register8     // 0x3AB
	MB26_D6 volatile.Register8     // 0x3AC
	MB26_D7 volatile.Register8     // 0x3AD
	MB26_TS volatile.Register16    // 0x3AE
	MB27_ID volatile.Register32    // 0x3B0
	MB27_DL volatile.Register16    // 0x3B4
	MB27_D0 volatile.Register8     // 0x3B6
	MB27_D1 volatile.Register8     // 0x3B7
	MB27_D2 volatile.Register8     // 0x3B8
	MB27_D3 volatile.Register8     // 0x3B9
	MB27_D4 volatile.Register8     // 0x3BA
	MB27_D5 volatile.Register8     // 0x3BB
	MB27_D6 volatile.Register8     // 0x3BC
	MB27_D7 volatile.Register8     // 0x3BD
	MB27_TS volatile.Register16    // 0x3BE
	MB28_ID volatile.Register32    // 0x3C0
	MB28_DL volatile.Register16    // 0x3C4
	MB28_D0 volatile.Register8     // 0x3C6
	MB28_D1 volatile.Register8     // 0x3C7
	MB28_D2 volatile.Register8     // 0x3C8
	MB28_D3 volatile.Register8     // 0x3C9
	MB28_D4 volatile.Register8     // 0x3CA
	MB28_D5 volatile.Register8     // 0x3CB
	MB28_D6 volatile.Register8     // 0x3CC
	MB28_D7 volatile.Register8     // 0x3CD
	MB28_TS volatile.Register16    // 0x3CE
	MB29_ID volatile.Register32    // 0x3D0
	MB29_DL volatile.Register16    // 0x3D4
	MB29_D0 volatile.Register8     // 0x3D6
	MB29_D1 volatile.Register8     // 0x3D7
	MB29_D2 volatile.Register8     // 0x3D8
	MB29_D3 volatile.Register8     // 0x3D9
	MB29_D4 volatile.Register8     // 0x3DA
	MB29_D5 volatile.Register8     // 0x3DB
	MB29_D6 volatile.Register8     // 0x3DC
	MB29_D7 volatile.Register8     // 0x3DD
	MB29_TS volatile.Register16    // 0x3DE
	MB30_ID volatile.Register32    // 0x3E0
	MB30_DL volatile.Register16    // 0x3E4
	MB30_D0 volatile.Register8     // 0x3E6
	MB30_D1 volatile.Register8     // 0x3E7
	MB30_D2 volatile.Register8     // 0x3E8
	MB30_D3 volatile.Register8     // 0x3E9
	MB30_D4 volatile.Register8     // 0x3EA
	MB30_D5 volatile.Register8     // 0x3EB
	MB30_D6 volatile.Register8     // 0x3EC
	MB30_D7 volatile.Register8     // 0x3ED
	MB30_TS volatile.Register16    // 0x3EE
	MB31_ID volatile.Register32    // 0x3F0
	MB31_DL volatile.Register16    // 0x3F4
	MB31_D0 volatile.Register8     // 0x3F6
	MB31_D1 volatile.Register8     // 0x3F7
	MB31_D2 volatile.Register8     // 0x3F8
	MB31_D3 volatile.Register8     // 0x3F9
	MB31_D4 volatile.Register8     // 0x3FA
	MB31_D5 volatile.Register8     // 0x3FB
	MB31_D6 volatile.Register8     // 0x3FC
	MB31_D7 volatile.Register8     // 0x3FD
	MB31_TS volatile.Register16    // 0x3FE
	MKR     [8]volatile.Register32 // 0x400
	FIDCR0  volatile.Register32    // 0x420
	FIDCR1  volatile.Register32    // 0x424
	MKIVLR  volatile.Register32    // 0x428
	MIER    volatile.Register32    // 0x42C
	_       [1008]byte
	MCTL_TX [32]volatile.Register8 // 0x820
	CTLR    volatile.Register16    // 0x840
	STR     volatile.Register16    // 0x842
	BCR     volatile.Register32    // 0x844
	RFCR    volatile.Register8     // 0x848
	RFPCR   volatile.Register8     // 0x849
	TFCR    volatile.Register8     // 0x84A
	TFPCR   volatile.Register8     // 0x84B
	EIER    volatile.Register8     // 0x84C
	EIFR    volatile.Register8     // 0x84D
	RECR    volatile.Register8     // 0x84E
	TECR    volatile.Register8     // 0x84F
	ECSR    volatile.Register8     // 0x850
	CSSR    volatile.Register8     // 0x851
	MSSR    volatile.Register8     // 0x852
	MSMR    volatile.Register8     // 0x853
	TSR     volatile.Register16    // 0x854
	AFSR    volatile.Register16    // 0x856
	TCR     volatile.Register8     // 0x858
}

// CAN0.MB0_ID: Mailbox Register
func (o *CAN0_Type) SetMB0_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB0_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB0_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB0_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB0_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB0_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB0_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB0_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB0_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB0_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB0_ID.Reg, volatile.LoadUint32(&o.MB0_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB0_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB0_ID.Reg) & 0x3ffff
}

// CAN0.MB0_DL: Mailbox Register
func (o *CAN0_Type) SetMB0_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB0_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB0_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB0_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB0_DL.Reg, volatile.LoadUint16(&o.MB0_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB0_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB0_DL.Reg) & 0xf
}

// CAN0.MB0_D0: Mailbox Register
func (o *CAN0_Type) SetMB0_D0(value uint8) {
	volatile.StoreUint8(&o.MB0_D0.Reg, value)
}
func (o *CAN0_Type) GetMB0_D0() uint8 {
	return volatile.LoadUint8(&o.MB0_D0.Reg)
}

// CAN0.MB0_D1: Mailbox Register
func (o *CAN0_Type) SetMB0_D1(value uint8) {
	volatile.StoreUint8(&o.MB0_D1.Reg, value)
}
func (o *CAN0_Type) GetMB0_D1() uint8 {
	return volatile.LoadUint8(&o.MB0_D1.Reg)
}

// CAN0.MB0_D2: Mailbox Register
func (o *CAN0_Type) SetMB0_D2(value uint8) {
	volatile.StoreUint8(&o.MB0_D2.Reg, value)
}
func (o *CAN0_Type) GetMB0_D2() uint8 {
	return volatile.LoadUint8(&o.MB0_D2.Reg)
}

// CAN0.MB0_D3: Mailbox Register
func (o *CAN0_Type) SetMB0_D3(value uint8) {
	volatile.StoreUint8(&o.MB0_D3.Reg, value)
}
func (o *CAN0_Type) GetMB0_D3() uint8 {
	return volatile.LoadUint8(&o.MB0_D3.Reg)
}

// CAN0.MB0_D4: Mailbox Register
func (o *CAN0_Type) SetMB0_D4(value uint8) {
	volatile.StoreUint8(&o.MB0_D4.Reg, value)
}
func (o *CAN0_Type) GetMB0_D4() uint8 {
	return volatile.LoadUint8(&o.MB0_D4.Reg)
}

// CAN0.MB0_D5: Mailbox Register
func (o *CAN0_Type) SetMB0_D5(value uint8) {
	volatile.StoreUint8(&o.MB0_D5.Reg, value)
}
func (o *CAN0_Type) GetMB0_D5() uint8 {
	return volatile.LoadUint8(&o.MB0_D5.Reg)
}

// CAN0.MB0_D6: Mailbox Register
func (o *CAN0_Type) SetMB0_D6(value uint8) {
	volatile.StoreUint8(&o.MB0_D6.Reg, value)
}
func (o *CAN0_Type) GetMB0_D6() uint8 {
	return volatile.LoadUint8(&o.MB0_D6.Reg)
}

// CAN0.MB0_D7: Mailbox Register
func (o *CAN0_Type) SetMB0_D7(value uint8) {
	volatile.StoreUint8(&o.MB0_D7.Reg, value)
}
func (o *CAN0_Type) GetMB0_D7() uint8 {
	return volatile.LoadUint8(&o.MB0_D7.Reg)
}

// CAN0.MB0_TS: Mailbox Register
func (o *CAN0_Type) SetMB0_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB0_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB0_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB0_TS.Reg, volatile.LoadUint16(&o.MB0_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB0_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB0_TS.Reg) & 0xff
}

// CAN0.MB1_ID: Mailbox Register
func (o *CAN0_Type) SetMB1_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB1_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB1_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB1_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB1_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB1_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB1_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB1_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB1_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB1_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB1_ID.Reg, volatile.LoadUint32(&o.MB1_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB1_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB1_ID.Reg) & 0x3ffff
}

// CAN0.MB1_DL: Mailbox Register
func (o *CAN0_Type) SetMB1_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB1_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB1_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB1_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB1_DL.Reg, volatile.LoadUint16(&o.MB1_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB1_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB1_DL.Reg) & 0xf
}

// CAN0.MB1_D0: Mailbox Register
func (o *CAN0_Type) SetMB1_D0(value uint8) {
	volatile.StoreUint8(&o.MB1_D0.Reg, value)
}
func (o *CAN0_Type) GetMB1_D0() uint8 {
	return volatile.LoadUint8(&o.MB1_D0.Reg)
}

// CAN0.MB1_D1: Mailbox Register
func (o *CAN0_Type) SetMB1_D1(value uint8) {
	volatile.StoreUint8(&o.MB1_D1.Reg, value)
}
func (o *CAN0_Type) GetMB1_D1() uint8 {
	return volatile.LoadUint8(&o.MB1_D1.Reg)
}

// CAN0.MB1_D2: Mailbox Register
func (o *CAN0_Type) SetMB1_D2(value uint8) {
	volatile.StoreUint8(&o.MB1_D2.Reg, value)
}
func (o *CAN0_Type) GetMB1_D2() uint8 {
	return volatile.LoadUint8(&o.MB1_D2.Reg)
}

// CAN0.MB1_D3: Mailbox Register
func (o *CAN0_Type) SetMB1_D3(value uint8) {
	volatile.StoreUint8(&o.MB1_D3.Reg, value)
}
func (o *CAN0_Type) GetMB1_D3() uint8 {
	return volatile.LoadUint8(&o.MB1_D3.Reg)
}

// CAN0.MB1_D4: Mailbox Register
func (o *CAN0_Type) SetMB1_D4(value uint8) {
	volatile.StoreUint8(&o.MB1_D4.Reg, value)
}
func (o *CAN0_Type) GetMB1_D4() uint8 {
	return volatile.LoadUint8(&o.MB1_D4.Reg)
}

// CAN0.MB1_D5: Mailbox Register
func (o *CAN0_Type) SetMB1_D5(value uint8) {
	volatile.StoreUint8(&o.MB1_D5.Reg, value)
}
func (o *CAN0_Type) GetMB1_D5() uint8 {
	return volatile.LoadUint8(&o.MB1_D5.Reg)
}

// CAN0.MB1_D6: Mailbox Register
func (o *CAN0_Type) SetMB1_D6(value uint8) {
	volatile.StoreUint8(&o.MB1_D6.Reg, value)
}
func (o *CAN0_Type) GetMB1_D6() uint8 {
	return volatile.LoadUint8(&o.MB1_D6.Reg)
}

// CAN0.MB1_D7: Mailbox Register
func (o *CAN0_Type) SetMB1_D7(value uint8) {
	volatile.StoreUint8(&o.MB1_D7.Reg, value)
}
func (o *CAN0_Type) GetMB1_D7() uint8 {
	return volatile.LoadUint8(&o.MB1_D7.Reg)
}

// CAN0.MB1_TS: Mailbox Register
func (o *CAN0_Type) SetMB1_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB1_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB1_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB1_TS.Reg, volatile.LoadUint16(&o.MB1_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB1_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB1_TS.Reg) & 0xff
}

// CAN0.MB2_ID: Mailbox Register
func (o *CAN0_Type) SetMB2_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB2_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB2_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB2_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB2_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB2_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB2_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB2_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB2_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB2_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB2_ID.Reg, volatile.LoadUint32(&o.MB2_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB2_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB2_ID.Reg) & 0x3ffff
}

// CAN0.MB2_DL: Mailbox Register
func (o *CAN0_Type) SetMB2_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB2_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB2_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB2_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB2_DL.Reg, volatile.LoadUint16(&o.MB2_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB2_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB2_DL.Reg) & 0xf
}

// CAN0.MB2_D0: Mailbox Register
func (o *CAN0_Type) SetMB2_D0(value uint8) {
	volatile.StoreUint8(&o.MB2_D0.Reg, value)
}
func (o *CAN0_Type) GetMB2_D0() uint8 {
	return volatile.LoadUint8(&o.MB2_D0.Reg)
}

// CAN0.MB2_D1: Mailbox Register
func (o *CAN0_Type) SetMB2_D1(value uint8) {
	volatile.StoreUint8(&o.MB2_D1.Reg, value)
}
func (o *CAN0_Type) GetMB2_D1() uint8 {
	return volatile.LoadUint8(&o.MB2_D1.Reg)
}

// CAN0.MB2_D2: Mailbox Register
func (o *CAN0_Type) SetMB2_D2(value uint8) {
	volatile.StoreUint8(&o.MB2_D2.Reg, value)
}
func (o *CAN0_Type) GetMB2_D2() uint8 {
	return volatile.LoadUint8(&o.MB2_D2.Reg)
}

// CAN0.MB2_D3: Mailbox Register
func (o *CAN0_Type) SetMB2_D3(value uint8) {
	volatile.StoreUint8(&o.MB2_D3.Reg, value)
}
func (o *CAN0_Type) GetMB2_D3() uint8 {
	return volatile.LoadUint8(&o.MB2_D3.Reg)
}

// CAN0.MB2_D4: Mailbox Register
func (o *CAN0_Type) SetMB2_D4(value uint8) {
	volatile.StoreUint8(&o.MB2_D4.Reg, value)
}
func (o *CAN0_Type) GetMB2_D4() uint8 {
	return volatile.LoadUint8(&o.MB2_D4.Reg)
}

// CAN0.MB2_D5: Mailbox Register
func (o *CAN0_Type) SetMB2_D5(value uint8) {
	volatile.StoreUint8(&o.MB2_D5.Reg, value)
}
func (o *CAN0_Type) GetMB2_D5() uint8 {
	return volatile.LoadUint8(&o.MB2_D5.Reg)
}

// CAN0.MB2_D6: Mailbox Register
func (o *CAN0_Type) SetMB2_D6(value uint8) {
	volatile.StoreUint8(&o.MB2_D6.Reg, value)
}
func (o *CAN0_Type) GetMB2_D6() uint8 {
	return volatile.LoadUint8(&o.MB2_D6.Reg)
}

// CAN0.MB2_D7: Mailbox Register
func (o *CAN0_Type) SetMB2_D7(value uint8) {
	volatile.StoreUint8(&o.MB2_D7.Reg, value)
}
func (o *CAN0_Type) GetMB2_D7() uint8 {
	return volatile.LoadUint8(&o.MB2_D7.Reg)
}

// CAN0.MB2_TS: Mailbox Register
func (o *CAN0_Type) SetMB2_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB2_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB2_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB2_TS.Reg, volatile.LoadUint16(&o.MB2_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB2_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB2_TS.Reg) & 0xff
}

// CAN0.MB3_ID: Mailbox Register
func (o *CAN0_Type) SetMB3_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB3_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB3_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB3_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB3_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB3_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB3_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB3_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB3_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB3_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB3_ID.Reg, volatile.LoadUint32(&o.MB3_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB3_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB3_ID.Reg) & 0x3ffff
}

// CAN0.MB3_DL: Mailbox Register
func (o *CAN0_Type) SetMB3_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB3_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB3_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB3_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB3_DL.Reg, volatile.LoadUint16(&o.MB3_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB3_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB3_DL.Reg) & 0xf
}

// CAN0.MB3_D0: Mailbox Register
func (o *CAN0_Type) SetMB3_D0(value uint8) {
	volatile.StoreUint8(&o.MB3_D0.Reg, value)
}
func (o *CAN0_Type) GetMB3_D0() uint8 {
	return volatile.LoadUint8(&o.MB3_D0.Reg)
}

// CAN0.MB3_D1: Mailbox Register
func (o *CAN0_Type) SetMB3_D1(value uint8) {
	volatile.StoreUint8(&o.MB3_D1.Reg, value)
}
func (o *CAN0_Type) GetMB3_D1() uint8 {
	return volatile.LoadUint8(&o.MB3_D1.Reg)
}

// CAN0.MB3_D2: Mailbox Register
func (o *CAN0_Type) SetMB3_D2(value uint8) {
	volatile.StoreUint8(&o.MB3_D2.Reg, value)
}
func (o *CAN0_Type) GetMB3_D2() uint8 {
	return volatile.LoadUint8(&o.MB3_D2.Reg)
}

// CAN0.MB3_D3: Mailbox Register
func (o *CAN0_Type) SetMB3_D3(value uint8) {
	volatile.StoreUint8(&o.MB3_D3.Reg, value)
}
func (o *CAN0_Type) GetMB3_D3() uint8 {
	return volatile.LoadUint8(&o.MB3_D3.Reg)
}

// CAN0.MB3_D4: Mailbox Register
func (o *CAN0_Type) SetMB3_D4(value uint8) {
	volatile.StoreUint8(&o.MB3_D4.Reg, value)
}
func (o *CAN0_Type) GetMB3_D4() uint8 {
	return volatile.LoadUint8(&o.MB3_D4.Reg)
}

// CAN0.MB3_D5: Mailbox Register
func (o *CAN0_Type) SetMB3_D5(value uint8) {
	volatile.StoreUint8(&o.MB3_D5.Reg, value)
}
func (o *CAN0_Type) GetMB3_D5() uint8 {
	return volatile.LoadUint8(&o.MB3_D5.Reg)
}

// CAN0.MB3_D6: Mailbox Register
func (o *CAN0_Type) SetMB3_D6(value uint8) {
	volatile.StoreUint8(&o.MB3_D6.Reg, value)
}
func (o *CAN0_Type) GetMB3_D6() uint8 {
	return volatile.LoadUint8(&o.MB3_D6.Reg)
}

// CAN0.MB3_D7: Mailbox Register
func (o *CAN0_Type) SetMB3_D7(value uint8) {
	volatile.StoreUint8(&o.MB3_D7.Reg, value)
}
func (o *CAN0_Type) GetMB3_D7() uint8 {
	return volatile.LoadUint8(&o.MB3_D7.Reg)
}

// CAN0.MB3_TS: Mailbox Register
func (o *CAN0_Type) SetMB3_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB3_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB3_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB3_TS.Reg, volatile.LoadUint16(&o.MB3_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB3_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB3_TS.Reg) & 0xff
}

// CAN0.MB4_ID: Mailbox Register
func (o *CAN0_Type) SetMB4_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB4_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB4_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB4_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB4_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB4_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB4_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB4_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB4_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB4_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB4_ID.Reg, volatile.LoadUint32(&o.MB4_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB4_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB4_ID.Reg) & 0x3ffff
}

// CAN0.MB4_DL: Mailbox Register
func (o *CAN0_Type) SetMB4_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB4_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB4_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB4_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB4_DL.Reg, volatile.LoadUint16(&o.MB4_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB4_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB4_DL.Reg) & 0xf
}

// CAN0.MB4_D0: Mailbox Register
func (o *CAN0_Type) SetMB4_D0(value uint8) {
	volatile.StoreUint8(&o.MB4_D0.Reg, value)
}
func (o *CAN0_Type) GetMB4_D0() uint8 {
	return volatile.LoadUint8(&o.MB4_D0.Reg)
}

// CAN0.MB4_D1: Mailbox Register
func (o *CAN0_Type) SetMB4_D1(value uint8) {
	volatile.StoreUint8(&o.MB4_D1.Reg, value)
}
func (o *CAN0_Type) GetMB4_D1() uint8 {
	return volatile.LoadUint8(&o.MB4_D1.Reg)
}

// CAN0.MB4_D2: Mailbox Register
func (o *CAN0_Type) SetMB4_D2(value uint8) {
	volatile.StoreUint8(&o.MB4_D2.Reg, value)
}
func (o *CAN0_Type) GetMB4_D2() uint8 {
	return volatile.LoadUint8(&o.MB4_D2.Reg)
}

// CAN0.MB4_D3: Mailbox Register
func (o *CAN0_Type) SetMB4_D3(value uint8) {
	volatile.StoreUint8(&o.MB4_D3.Reg, value)
}
func (o *CAN0_Type) GetMB4_D3() uint8 {
	return volatile.LoadUint8(&o.MB4_D3.Reg)
}

// CAN0.MB4_D4: Mailbox Register
func (o *CAN0_Type) SetMB4_D4(value uint8) {
	volatile.StoreUint8(&o.MB4_D4.Reg, value)
}
func (o *CAN0_Type) GetMB4_D4() uint8 {
	return volatile.LoadUint8(&o.MB4_D4.Reg)
}

// CAN0.MB4_D5: Mailbox Register
func (o *CAN0_Type) SetMB4_D5(value uint8) {
	volatile.StoreUint8(&o.MB4_D5.Reg, value)
}
func (o *CAN0_Type) GetMB4_D5() uint8 {
	return volatile.LoadUint8(&o.MB4_D5.Reg)
}

// CAN0.MB4_D6: Mailbox Register
func (o *CAN0_Type) SetMB4_D6(value uint8) {
	volatile.StoreUint8(&o.MB4_D6.Reg, value)
}
func (o *CAN0_Type) GetMB4_D6() uint8 {
	return volatile.LoadUint8(&o.MB4_D6.Reg)
}

// CAN0.MB4_D7: Mailbox Register
func (o *CAN0_Type) SetMB4_D7(value uint8) {
	volatile.StoreUint8(&o.MB4_D7.Reg, value)
}
func (o *CAN0_Type) GetMB4_D7() uint8 {
	return volatile.LoadUint8(&o.MB4_D7.Reg)
}

// CAN0.MB4_TS: Mailbox Register
func (o *CAN0_Type) SetMB4_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB4_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB4_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB4_TS.Reg, volatile.LoadUint16(&o.MB4_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB4_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB4_TS.Reg) & 0xff
}

// CAN0.MB5_ID: Mailbox Register
func (o *CAN0_Type) SetMB5_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB5_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB5_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB5_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB5_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB5_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB5_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB5_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB5_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB5_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB5_ID.Reg, volatile.LoadUint32(&o.MB5_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB5_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB5_ID.Reg) & 0x3ffff
}

// CAN0.MB5_DL: Mailbox Register
func (o *CAN0_Type) SetMB5_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB5_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB5_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB5_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB5_DL.Reg, volatile.LoadUint16(&o.MB5_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB5_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB5_DL.Reg) & 0xf
}

// CAN0.MB5_D0: Mailbox Register
func (o *CAN0_Type) SetMB5_D0(value uint8) {
	volatile.StoreUint8(&o.MB5_D0.Reg, value)
}
func (o *CAN0_Type) GetMB5_D0() uint8 {
	return volatile.LoadUint8(&o.MB5_D0.Reg)
}

// CAN0.MB5_D1: Mailbox Register
func (o *CAN0_Type) SetMB5_D1(value uint8) {
	volatile.StoreUint8(&o.MB5_D1.Reg, value)
}
func (o *CAN0_Type) GetMB5_D1() uint8 {
	return volatile.LoadUint8(&o.MB5_D1.Reg)
}

// CAN0.MB5_D2: Mailbox Register
func (o *CAN0_Type) SetMB5_D2(value uint8) {
	volatile.StoreUint8(&o.MB5_D2.Reg, value)
}
func (o *CAN0_Type) GetMB5_D2() uint8 {
	return volatile.LoadUint8(&o.MB5_D2.Reg)
}

// CAN0.MB5_D3: Mailbox Register
func (o *CAN0_Type) SetMB5_D3(value uint8) {
	volatile.StoreUint8(&o.MB5_D3.Reg, value)
}
func (o *CAN0_Type) GetMB5_D3() uint8 {
	return volatile.LoadUint8(&o.MB5_D3.Reg)
}

// CAN0.MB5_D4: Mailbox Register
func (o *CAN0_Type) SetMB5_D4(value uint8) {
	volatile.StoreUint8(&o.MB5_D4.Reg, value)
}
func (o *CAN0_Type) GetMB5_D4() uint8 {
	return volatile.LoadUint8(&o.MB5_D4.Reg)
}

// CAN0.MB5_D5: Mailbox Register
func (o *CAN0_Type) SetMB5_D5(value uint8) {
	volatile.StoreUint8(&o.MB5_D5.Reg, value)
}
func (o *CAN0_Type) GetMB5_D5() uint8 {
	return volatile.LoadUint8(&o.MB5_D5.Reg)
}

// CAN0.MB5_D6: Mailbox Register
func (o *CAN0_Type) SetMB5_D6(value uint8) {
	volatile.StoreUint8(&o.MB5_D6.Reg, value)
}
func (o *CAN0_Type) GetMB5_D6() uint8 {
	return volatile.LoadUint8(&o.MB5_D6.Reg)
}

// CAN0.MB5_D7: Mailbox Register
func (o *CAN0_Type) SetMB5_D7(value uint8) {
	volatile.StoreUint8(&o.MB5_D7.Reg, value)
}
func (o *CAN0_Type) GetMB5_D7() uint8 {
	return volatile.LoadUint8(&o.MB5_D7.Reg)
}

// CAN0.MB5_TS: Mailbox Register
func (o *CAN0_Type) SetMB5_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB5_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB5_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB5_TS.Reg, volatile.LoadUint16(&o.MB5_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB5_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB5_TS.Reg) & 0xff
}

// CAN0.MB6_ID: Mailbox Register
func (o *CAN0_Type) SetMB6_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB6_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB6_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB6_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB6_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB6_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB6_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB6_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB6_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB6_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB6_ID.Reg, volatile.LoadUint32(&o.MB6_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB6_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB6_ID.Reg) & 0x3ffff
}

// CAN0.MB6_DL: Mailbox Register
func (o *CAN0_Type) SetMB6_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB6_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB6_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB6_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB6_DL.Reg, volatile.LoadUint16(&o.MB6_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB6_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB6_DL.Reg) & 0xf
}

// CAN0.MB6_D0: Mailbox Register
func (o *CAN0_Type) SetMB6_D0(value uint8) {
	volatile.StoreUint8(&o.MB6_D0.Reg, value)
}
func (o *CAN0_Type) GetMB6_D0() uint8 {
	return volatile.LoadUint8(&o.MB6_D0.Reg)
}

// CAN0.MB6_D1: Mailbox Register
func (o *CAN0_Type) SetMB6_D1(value uint8) {
	volatile.StoreUint8(&o.MB6_D1.Reg, value)
}
func (o *CAN0_Type) GetMB6_D1() uint8 {
	return volatile.LoadUint8(&o.MB6_D1.Reg)
}

// CAN0.MB6_D2: Mailbox Register
func (o *CAN0_Type) SetMB6_D2(value uint8) {
	volatile.StoreUint8(&o.MB6_D2.Reg, value)
}
func (o *CAN0_Type) GetMB6_D2() uint8 {
	return volatile.LoadUint8(&o.MB6_D2.Reg)
}

// CAN0.MB6_D3: Mailbox Register
func (o *CAN0_Type) SetMB6_D3(value uint8) {
	volatile.StoreUint8(&o.MB6_D3.Reg, value)
}
func (o *CAN0_Type) GetMB6_D3() uint8 {
	return volatile.LoadUint8(&o.MB6_D3.Reg)
}

// CAN0.MB6_D4: Mailbox Register
func (o *CAN0_Type) SetMB6_D4(value uint8) {
	volatile.StoreUint8(&o.MB6_D4.Reg, value)
}
func (o *CAN0_Type) GetMB6_D4() uint8 {
	return volatile.LoadUint8(&o.MB6_D4.Reg)
}

// CAN0.MB6_D5: Mailbox Register
func (o *CAN0_Type) SetMB6_D5(value uint8) {
	volatile.StoreUint8(&o.MB6_D5.Reg, value)
}
func (o *CAN0_Type) GetMB6_D5() uint8 {
	return volatile.LoadUint8(&o.MB6_D5.Reg)
}

// CAN0.MB6_D6: Mailbox Register
func (o *CAN0_Type) SetMB6_D6(value uint8) {
	volatile.StoreUint8(&o.MB6_D6.Reg, value)
}
func (o *CAN0_Type) GetMB6_D6() uint8 {
	return volatile.LoadUint8(&o.MB6_D6.Reg)
}

// CAN0.MB6_D7: Mailbox Register
func (o *CAN0_Type) SetMB6_D7(value uint8) {
	volatile.StoreUint8(&o.MB6_D7.Reg, value)
}
func (o *CAN0_Type) GetMB6_D7() uint8 {
	return volatile.LoadUint8(&o.MB6_D7.Reg)
}

// CAN0.MB6_TS: Mailbox Register
func (o *CAN0_Type) SetMB6_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB6_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB6_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB6_TS.Reg, volatile.LoadUint16(&o.MB6_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB6_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB6_TS.Reg) & 0xff
}

// CAN0.MB7_ID: Mailbox Register
func (o *CAN0_Type) SetMB7_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB7_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB7_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB7_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB7_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB7_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB7_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB7_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB7_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB7_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB7_ID.Reg, volatile.LoadUint32(&o.MB7_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB7_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB7_ID.Reg) & 0x3ffff
}

// CAN0.MB7_DL: Mailbox Register
func (o *CAN0_Type) SetMB7_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB7_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB7_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB7_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB7_DL.Reg, volatile.LoadUint16(&o.MB7_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB7_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB7_DL.Reg) & 0xf
}

// CAN0.MB7_D0: Mailbox Register
func (o *CAN0_Type) SetMB7_D0(value uint8) {
	volatile.StoreUint8(&o.MB7_D0.Reg, value)
}
func (o *CAN0_Type) GetMB7_D0() uint8 {
	return volatile.LoadUint8(&o.MB7_D0.Reg)
}

// CAN0.MB7_D1: Mailbox Register
func (o *CAN0_Type) SetMB7_D1(value uint8) {
	volatile.StoreUint8(&o.MB7_D1.Reg, value)
}
func (o *CAN0_Type) GetMB7_D1() uint8 {
	return volatile.LoadUint8(&o.MB7_D1.Reg)
}

// CAN0.MB7_D2: Mailbox Register
func (o *CAN0_Type) SetMB7_D2(value uint8) {
	volatile.StoreUint8(&o.MB7_D2.Reg, value)
}
func (o *CAN0_Type) GetMB7_D2() uint8 {
	return volatile.LoadUint8(&o.MB7_D2.Reg)
}

// CAN0.MB7_D3: Mailbox Register
func (o *CAN0_Type) SetMB7_D3(value uint8) {
	volatile.StoreUint8(&o.MB7_D3.Reg, value)
}
func (o *CAN0_Type) GetMB7_D3() uint8 {
	return volatile.LoadUint8(&o.MB7_D3.Reg)
}

// CAN0.MB7_D4: Mailbox Register
func (o *CAN0_Type) SetMB7_D4(value uint8) {
	volatile.StoreUint8(&o.MB7_D4.Reg, value)
}
func (o *CAN0_Type) GetMB7_D4() uint8 {
	return volatile.LoadUint8(&o.MB7_D4.Reg)
}

// CAN0.MB7_D5: Mailbox Register
func (o *CAN0_Type) SetMB7_D5(value uint8) {
	volatile.StoreUint8(&o.MB7_D5.Reg, value)
}
func (o *CAN0_Type) GetMB7_D5() uint8 {
	return volatile.LoadUint8(&o.MB7_D5.Reg)
}

// CAN0.MB7_D6: Mailbox Register
func (o *CAN0_Type) SetMB7_D6(value uint8) {
	volatile.StoreUint8(&o.MB7_D6.Reg, value)
}
func (o *CAN0_Type) GetMB7_D6() uint8 {
	return volatile.LoadUint8(&o.MB7_D6.Reg)
}

// CAN0.MB7_D7: Mailbox Register
func (o *CAN0_Type) SetMB7_D7(value uint8) {
	volatile.StoreUint8(&o.MB7_D7.Reg, value)
}
func (o *CAN0_Type) GetMB7_D7() uint8 {
	return volatile.LoadUint8(&o.MB7_D7.Reg)
}

// CAN0.MB7_TS: Mailbox Register
func (o *CAN0_Type) SetMB7_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB7_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB7_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB7_TS.Reg, volatile.LoadUint16(&o.MB7_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB7_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB7_TS.Reg) & 0xff
}

// CAN0.MB8_ID: Mailbox Register
func (o *CAN0_Type) SetMB8_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB8_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB8_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB8_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB8_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB8_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB8_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB8_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB8_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB8_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB8_ID.Reg, volatile.LoadUint32(&o.MB8_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB8_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB8_ID.Reg) & 0x3ffff
}

// CAN0.MB8_DL: Mailbox Register
func (o *CAN0_Type) SetMB8_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB8_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB8_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB8_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB8_DL.Reg, volatile.LoadUint16(&o.MB8_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB8_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB8_DL.Reg) & 0xf
}

// CAN0.MB8_D0: Mailbox Register
func (o *CAN0_Type) SetMB8_D0(value uint8) {
	volatile.StoreUint8(&o.MB8_D0.Reg, value)
}
func (o *CAN0_Type) GetMB8_D0() uint8 {
	return volatile.LoadUint8(&o.MB8_D0.Reg)
}

// CAN0.MB8_D1: Mailbox Register
func (o *CAN0_Type) SetMB8_D1(value uint8) {
	volatile.StoreUint8(&o.MB8_D1.Reg, value)
}
func (o *CAN0_Type) GetMB8_D1() uint8 {
	return volatile.LoadUint8(&o.MB8_D1.Reg)
}

// CAN0.MB8_D2: Mailbox Register
func (o *CAN0_Type) SetMB8_D2(value uint8) {
	volatile.StoreUint8(&o.MB8_D2.Reg, value)
}
func (o *CAN0_Type) GetMB8_D2() uint8 {
	return volatile.LoadUint8(&o.MB8_D2.Reg)
}

// CAN0.MB8_D3: Mailbox Register
func (o *CAN0_Type) SetMB8_D3(value uint8) {
	volatile.StoreUint8(&o.MB8_D3.Reg, value)
}
func (o *CAN0_Type) GetMB8_D3() uint8 {
	return volatile.LoadUint8(&o.MB8_D3.Reg)
}

// CAN0.MB8_D4: Mailbox Register
func (o *CAN0_Type) SetMB8_D4(value uint8) {
	volatile.StoreUint8(&o.MB8_D4.Reg, value)
}
func (o *CAN0_Type) GetMB8_D4() uint8 {
	return volatile.LoadUint8(&o.MB8_D4.Reg)
}

// CAN0.MB8_D5: Mailbox Register
func (o *CAN0_Type) SetMB8_D5(value uint8) {
	volatile.StoreUint8(&o.MB8_D5.Reg, value)
}
func (o *CAN0_Type) GetMB8_D5() uint8 {
	return volatile.LoadUint8(&o.MB8_D5.Reg)
}

// CAN0.MB8_D6: Mailbox Register
func (o *CAN0_Type) SetMB8_D6(value uint8) {
	volatile.StoreUint8(&o.MB8_D6.Reg, value)
}
func (o *CAN0_Type) GetMB8_D6() uint8 {
	return volatile.LoadUint8(&o.MB8_D6.Reg)
}

// CAN0.MB8_D7: Mailbox Register
func (o *CAN0_Type) SetMB8_D7(value uint8) {
	volatile.StoreUint8(&o.MB8_D7.Reg, value)
}
func (o *CAN0_Type) GetMB8_D7() uint8 {
	return volatile.LoadUint8(&o.MB8_D7.Reg)
}

// CAN0.MB8_TS: Mailbox Register
func (o *CAN0_Type) SetMB8_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB8_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB8_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB8_TS.Reg, volatile.LoadUint16(&o.MB8_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB8_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB8_TS.Reg) & 0xff
}

// CAN0.MB9_ID: Mailbox Register
func (o *CAN0_Type) SetMB9_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB9_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB9_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB9_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB9_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB9_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB9_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB9_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB9_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB9_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB9_ID.Reg, volatile.LoadUint32(&o.MB9_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB9_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB9_ID.Reg) & 0x3ffff
}

// CAN0.MB9_DL: Mailbox Register
func (o *CAN0_Type) SetMB9_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB9_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB9_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB9_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB9_DL.Reg, volatile.LoadUint16(&o.MB9_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB9_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB9_DL.Reg) & 0xf
}

// CAN0.MB9_D0: Mailbox Register
func (o *CAN0_Type) SetMB9_D0(value uint8) {
	volatile.StoreUint8(&o.MB9_D0.Reg, value)
}
func (o *CAN0_Type) GetMB9_D0() uint8 {
	return volatile.LoadUint8(&o.MB9_D0.Reg)
}

// CAN0.MB9_D1: Mailbox Register
func (o *CAN0_Type) SetMB9_D1(value uint8) {
	volatile.StoreUint8(&o.MB9_D1.Reg, value)
}
func (o *CAN0_Type) GetMB9_D1() uint8 {
	return volatile.LoadUint8(&o.MB9_D1.Reg)
}

// CAN0.MB9_D2: Mailbox Register
func (o *CAN0_Type) SetMB9_D2(value uint8) {
	volatile.StoreUint8(&o.MB9_D2.Reg, value)
}
func (o *CAN0_Type) GetMB9_D2() uint8 {
	return volatile.LoadUint8(&o.MB9_D2.Reg)
}

// CAN0.MB9_D3: Mailbox Register
func (o *CAN0_Type) SetMB9_D3(value uint8) {
	volatile.StoreUint8(&o.MB9_D3.Reg, value)
}
func (o *CAN0_Type) GetMB9_D3() uint8 {
	return volatile.LoadUint8(&o.MB9_D3.Reg)
}

// CAN0.MB9_D4: Mailbox Register
func (o *CAN0_Type) SetMB9_D4(value uint8) {
	volatile.StoreUint8(&o.MB9_D4.Reg, value)
}
func (o *CAN0_Type) GetMB9_D4() uint8 {
	return volatile.LoadUint8(&o.MB9_D4.Reg)
}

// CAN0.MB9_D5: Mailbox Register
func (o *CAN0_Type) SetMB9_D5(value uint8) {
	volatile.StoreUint8(&o.MB9_D5.Reg, value)
}
func (o *CAN0_Type) GetMB9_D5() uint8 {
	return volatile.LoadUint8(&o.MB9_D5.Reg)
}

// CAN0.MB9_D6: Mailbox Register
func (o *CAN0_Type) SetMB9_D6(value uint8) {
	volatile.StoreUint8(&o.MB9_D6.Reg, value)
}
func (o *CAN0_Type) GetMB9_D6() uint8 {
	return volatile.LoadUint8(&o.MB9_D6.Reg)
}

// CAN0.MB9_D7: Mailbox Register
func (o *CAN0_Type) SetMB9_D7(value uint8) {
	volatile.StoreUint8(&o.MB9_D7.Reg, value)
}
func (o *CAN0_Type) GetMB9_D7() uint8 {
	return volatile.LoadUint8(&o.MB9_D7.Reg)
}

// CAN0.MB9_TS: Mailbox Register
func (o *CAN0_Type) SetMB9_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB9_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB9_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB9_TS.Reg, volatile.LoadUint16(&o.MB9_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB9_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB9_TS.Reg) & 0xff
}

// CAN0.MB10_ID: Mailbox Register
func (o *CAN0_Type) SetMB10_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB10_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB10_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB10_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB10_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB10_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB10_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB10_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB10_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB10_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB10_ID.Reg, volatile.LoadUint32(&o.MB10_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB10_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB10_ID.Reg) & 0x3ffff
}

// CAN0.MB10_DL: Mailbox Register
func (o *CAN0_Type) SetMB10_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB10_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB10_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB10_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB10_DL.Reg, volatile.LoadUint16(&o.MB10_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB10_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB10_DL.Reg) & 0xf
}

// CAN0.MB10_D0: Mailbox Register
func (o *CAN0_Type) SetMB10_D0(value uint8) {
	volatile.StoreUint8(&o.MB10_D0.Reg, value)
}
func (o *CAN0_Type) GetMB10_D0() uint8 {
	return volatile.LoadUint8(&o.MB10_D0.Reg)
}

// CAN0.MB10_D1: Mailbox Register
func (o *CAN0_Type) SetMB10_D1(value uint8) {
	volatile.StoreUint8(&o.MB10_D1.Reg, value)
}
func (o *CAN0_Type) GetMB10_D1() uint8 {
	return volatile.LoadUint8(&o.MB10_D1.Reg)
}

// CAN0.MB10_D2: Mailbox Register
func (o *CAN0_Type) SetMB10_D2(value uint8) {
	volatile.StoreUint8(&o.MB10_D2.Reg, value)
}
func (o *CAN0_Type) GetMB10_D2() uint8 {
	return volatile.LoadUint8(&o.MB10_D2.Reg)
}

// CAN0.MB10_D3: Mailbox Register
func (o *CAN0_Type) SetMB10_D3(value uint8) {
	volatile.StoreUint8(&o.MB10_D3.Reg, value)
}
func (o *CAN0_Type) GetMB10_D3() uint8 {
	return volatile.LoadUint8(&o.MB10_D3.Reg)
}

// CAN0.MB10_D4: Mailbox Register
func (o *CAN0_Type) SetMB10_D4(value uint8) {
	volatile.StoreUint8(&o.MB10_D4.Reg, value)
}
func (o *CAN0_Type) GetMB10_D4() uint8 {
	return volatile.LoadUint8(&o.MB10_D4.Reg)
}

// CAN0.MB10_D5: Mailbox Register
func (o *CAN0_Type) SetMB10_D5(value uint8) {
	volatile.StoreUint8(&o.MB10_D5.Reg, value)
}
func (o *CAN0_Type) GetMB10_D5() uint8 {
	return volatile.LoadUint8(&o.MB10_D5.Reg)
}

// CAN0.MB10_D6: Mailbox Register
func (o *CAN0_Type) SetMB10_D6(value uint8) {
	volatile.StoreUint8(&o.MB10_D6.Reg, value)
}
func (o *CAN0_Type) GetMB10_D6() uint8 {
	return volatile.LoadUint8(&o.MB10_D6.Reg)
}

// CAN0.MB10_D7: Mailbox Register
func (o *CAN0_Type) SetMB10_D7(value uint8) {
	volatile.StoreUint8(&o.MB10_D7.Reg, value)
}
func (o *CAN0_Type) GetMB10_D7() uint8 {
	return volatile.LoadUint8(&o.MB10_D7.Reg)
}

// CAN0.MB10_TS: Mailbox Register
func (o *CAN0_Type) SetMB10_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB10_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB10_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB10_TS.Reg, volatile.LoadUint16(&o.MB10_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB10_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB10_TS.Reg) & 0xff
}

// CAN0.MB11_ID: Mailbox Register
func (o *CAN0_Type) SetMB11_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB11_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB11_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB11_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB11_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB11_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB11_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB11_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB11_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB11_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB11_ID.Reg, volatile.LoadUint32(&o.MB11_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB11_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB11_ID.Reg) & 0x3ffff
}

// CAN0.MB11_DL: Mailbox Register
func (o *CAN0_Type) SetMB11_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB11_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB11_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB11_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB11_DL.Reg, volatile.LoadUint16(&o.MB11_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB11_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB11_DL.Reg) & 0xf
}

// CAN0.MB11_D0: Mailbox Register
func (o *CAN0_Type) SetMB11_D0(value uint8) {
	volatile.StoreUint8(&o.MB11_D0.Reg, value)
}
func (o *CAN0_Type) GetMB11_D0() uint8 {
	return volatile.LoadUint8(&o.MB11_D0.Reg)
}

// CAN0.MB11_D1: Mailbox Register
func (o *CAN0_Type) SetMB11_D1(value uint8) {
	volatile.StoreUint8(&o.MB11_D1.Reg, value)
}
func (o *CAN0_Type) GetMB11_D1() uint8 {
	return volatile.LoadUint8(&o.MB11_D1.Reg)
}

// CAN0.MB11_D2: Mailbox Register
func (o *CAN0_Type) SetMB11_D2(value uint8) {
	volatile.StoreUint8(&o.MB11_D2.Reg, value)
}
func (o *CAN0_Type) GetMB11_D2() uint8 {
	return volatile.LoadUint8(&o.MB11_D2.Reg)
}

// CAN0.MB11_D3: Mailbox Register
func (o *CAN0_Type) SetMB11_D3(value uint8) {
	volatile.StoreUint8(&o.MB11_D3.Reg, value)
}
func (o *CAN0_Type) GetMB11_D3() uint8 {
	return volatile.LoadUint8(&o.MB11_D3.Reg)
}

// CAN0.MB11_D4: Mailbox Register
func (o *CAN0_Type) SetMB11_D4(value uint8) {
	volatile.StoreUint8(&o.MB11_D4.Reg, value)
}
func (o *CAN0_Type) GetMB11_D4() uint8 {
	return volatile.LoadUint8(&o.MB11_D4.Reg)
}

// CAN0.MB11_D5: Mailbox Register
func (o *CAN0_Type) SetMB11_D5(value uint8) {
	volatile.StoreUint8(&o.MB11_D5.Reg, value)
}
func (o *CAN0_Type) GetMB11_D5() uint8 {
	return volatile.LoadUint8(&o.MB11_D5.Reg)
}

// CAN0.MB11_D6: Mailbox Register
func (o *CAN0_Type) SetMB11_D6(value uint8) {
	volatile.StoreUint8(&o.MB11_D6.Reg, value)
}
func (o *CAN0_Type) GetMB11_D6() uint8 {
	return volatile.LoadUint8(&o.MB11_D6.Reg)
}

// CAN0.MB11_D7: Mailbox Register
func (o *CAN0_Type) SetMB11_D7(value uint8) {
	volatile.StoreUint8(&o.MB11_D7.Reg, value)
}
func (o *CAN0_Type) GetMB11_D7() uint8 {
	return volatile.LoadUint8(&o.MB11_D7.Reg)
}

// CAN0.MB11_TS: Mailbox Register
func (o *CAN0_Type) SetMB11_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB11_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB11_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB11_TS.Reg, volatile.LoadUint16(&o.MB11_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB11_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB11_TS.Reg) & 0xff
}

// CAN0.MB12_ID: Mailbox Register
func (o *CAN0_Type) SetMB12_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB12_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB12_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB12_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB12_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB12_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB12_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB12_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB12_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB12_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB12_ID.Reg, volatile.LoadUint32(&o.MB12_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB12_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB12_ID.Reg) & 0x3ffff
}

// CAN0.MB12_DL: Mailbox Register
func (o *CAN0_Type) SetMB12_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB12_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB12_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB12_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB12_DL.Reg, volatile.LoadUint16(&o.MB12_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB12_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB12_DL.Reg) & 0xf
}

// CAN0.MB12_D0: Mailbox Register
func (o *CAN0_Type) SetMB12_D0(value uint8) {
	volatile.StoreUint8(&o.MB12_D0.Reg, value)
}
func (o *CAN0_Type) GetMB12_D0() uint8 {
	return volatile.LoadUint8(&o.MB12_D0.Reg)
}

// CAN0.MB12_D1: Mailbox Register
func (o *CAN0_Type) SetMB12_D1(value uint8) {
	volatile.StoreUint8(&o.MB12_D1.Reg, value)
}
func (o *CAN0_Type) GetMB12_D1() uint8 {
	return volatile.LoadUint8(&o.MB12_D1.Reg)
}

// CAN0.MB12_D2: Mailbox Register
func (o *CAN0_Type) SetMB12_D2(value uint8) {
	volatile.StoreUint8(&o.MB12_D2.Reg, value)
}
func (o *CAN0_Type) GetMB12_D2() uint8 {
	return volatile.LoadUint8(&o.MB12_D2.Reg)
}

// CAN0.MB12_D3: Mailbox Register
func (o *CAN0_Type) SetMB12_D3(value uint8) {
	volatile.StoreUint8(&o.MB12_D3.Reg, value)
}
func (o *CAN0_Type) GetMB12_D3() uint8 {
	return volatile.LoadUint8(&o.MB12_D3.Reg)
}

// CAN0.MB12_D4: Mailbox Register
func (o *CAN0_Type) SetMB12_D4(value uint8) {
	volatile.StoreUint8(&o.MB12_D4.Reg, value)
}
func (o *CAN0_Type) GetMB12_D4() uint8 {
	return volatile.LoadUint8(&o.MB12_D4.Reg)
}

// CAN0.MB12_D5: Mailbox Register
func (o *CAN0_Type) SetMB12_D5(value uint8) {
	volatile.StoreUint8(&o.MB12_D5.Reg, value)
}
func (o *CAN0_Type) GetMB12_D5() uint8 {
	return volatile.LoadUint8(&o.MB12_D5.Reg)
}

// CAN0.MB12_D6: Mailbox Register
func (o *CAN0_Type) SetMB12_D6(value uint8) {
	volatile.StoreUint8(&o.MB12_D6.Reg, value)
}
func (o *CAN0_Type) GetMB12_D6() uint8 {
	return volatile.LoadUint8(&o.MB12_D6.Reg)
}

// CAN0.MB12_D7: Mailbox Register
func (o *CAN0_Type) SetMB12_D7(value uint8) {
	volatile.StoreUint8(&o.MB12_D7.Reg, value)
}
func (o *CAN0_Type) GetMB12_D7() uint8 {
	return volatile.LoadUint8(&o.MB12_D7.Reg)
}

// CAN0.MB12_TS: Mailbox Register
func (o *CAN0_Type) SetMB12_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB12_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB12_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB12_TS.Reg, volatile.LoadUint16(&o.MB12_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB12_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB12_TS.Reg) & 0xff
}

// CAN0.MB13_ID: Mailbox Register
func (o *CAN0_Type) SetMB13_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB13_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB13_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB13_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB13_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB13_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB13_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB13_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB13_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB13_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB13_ID.Reg, volatile.LoadUint32(&o.MB13_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB13_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB13_ID.Reg) & 0x3ffff
}

// CAN0.MB13_DL: Mailbox Register
func (o *CAN0_Type) SetMB13_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB13_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB13_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB13_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB13_DL.Reg, volatile.LoadUint16(&o.MB13_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB13_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB13_DL.Reg) & 0xf
}

// CAN0.MB13_D0: Mailbox Register
func (o *CAN0_Type) SetMB13_D0(value uint8) {
	volatile.StoreUint8(&o.MB13_D0.Reg, value)
}
func (o *CAN0_Type) GetMB13_D0() uint8 {
	return volatile.LoadUint8(&o.MB13_D0.Reg)
}

// CAN0.MB13_D1: Mailbox Register
func (o *CAN0_Type) SetMB13_D1(value uint8) {
	volatile.StoreUint8(&o.MB13_D1.Reg, value)
}
func (o *CAN0_Type) GetMB13_D1() uint8 {
	return volatile.LoadUint8(&o.MB13_D1.Reg)
}

// CAN0.MB13_D2: Mailbox Register
func (o *CAN0_Type) SetMB13_D2(value uint8) {
	volatile.StoreUint8(&o.MB13_D2.Reg, value)
}
func (o *CAN0_Type) GetMB13_D2() uint8 {
	return volatile.LoadUint8(&o.MB13_D2.Reg)
}

// CAN0.MB13_D3: Mailbox Register
func (o *CAN0_Type) SetMB13_D3(value uint8) {
	volatile.StoreUint8(&o.MB13_D3.Reg, value)
}
func (o *CAN0_Type) GetMB13_D3() uint8 {
	return volatile.LoadUint8(&o.MB13_D3.Reg)
}

// CAN0.MB13_D4: Mailbox Register
func (o *CAN0_Type) SetMB13_D4(value uint8) {
	volatile.StoreUint8(&o.MB13_D4.Reg, value)
}
func (o *CAN0_Type) GetMB13_D4() uint8 {
	return volatile.LoadUint8(&o.MB13_D4.Reg)
}

// CAN0.MB13_D5: Mailbox Register
func (o *CAN0_Type) SetMB13_D5(value uint8) {
	volatile.StoreUint8(&o.MB13_D5.Reg, value)
}
func (o *CAN0_Type) GetMB13_D5() uint8 {
	return volatile.LoadUint8(&o.MB13_D5.Reg)
}

// CAN0.MB13_D6: Mailbox Register
func (o *CAN0_Type) SetMB13_D6(value uint8) {
	volatile.StoreUint8(&o.MB13_D6.Reg, value)
}
func (o *CAN0_Type) GetMB13_D6() uint8 {
	return volatile.LoadUint8(&o.MB13_D6.Reg)
}

// CAN0.MB13_D7: Mailbox Register
func (o *CAN0_Type) SetMB13_D7(value uint8) {
	volatile.StoreUint8(&o.MB13_D7.Reg, value)
}
func (o *CAN0_Type) GetMB13_D7() uint8 {
	return volatile.LoadUint8(&o.MB13_D7.Reg)
}

// CAN0.MB13_TS: Mailbox Register
func (o *CAN0_Type) SetMB13_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB13_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB13_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB13_TS.Reg, volatile.LoadUint16(&o.MB13_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB13_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB13_TS.Reg) & 0xff
}

// CAN0.MB14_ID: Mailbox Register
func (o *CAN0_Type) SetMB14_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB14_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB14_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB14_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB14_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB14_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB14_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB14_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB14_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB14_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB14_ID.Reg, volatile.LoadUint32(&o.MB14_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB14_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB14_ID.Reg) & 0x3ffff
}

// CAN0.MB14_DL: Mailbox Register
func (o *CAN0_Type) SetMB14_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB14_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB14_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB14_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB14_DL.Reg, volatile.LoadUint16(&o.MB14_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB14_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB14_DL.Reg) & 0xf
}

// CAN0.MB14_D0: Mailbox Register
func (o *CAN0_Type) SetMB14_D0(value uint8) {
	volatile.StoreUint8(&o.MB14_D0.Reg, value)
}
func (o *CAN0_Type) GetMB14_D0() uint8 {
	return volatile.LoadUint8(&o.MB14_D0.Reg)
}

// CAN0.MB14_D1: Mailbox Register
func (o *CAN0_Type) SetMB14_D1(value uint8) {
	volatile.StoreUint8(&o.MB14_D1.Reg, value)
}
func (o *CAN0_Type) GetMB14_D1() uint8 {
	return volatile.LoadUint8(&o.MB14_D1.Reg)
}

// CAN0.MB14_D2: Mailbox Register
func (o *CAN0_Type) SetMB14_D2(value uint8) {
	volatile.StoreUint8(&o.MB14_D2.Reg, value)
}
func (o *CAN0_Type) GetMB14_D2() uint8 {
	return volatile.LoadUint8(&o.MB14_D2.Reg)
}

// CAN0.MB14_D3: Mailbox Register
func (o *CAN0_Type) SetMB14_D3(value uint8) {
	volatile.StoreUint8(&o.MB14_D3.Reg, value)
}
func (o *CAN0_Type) GetMB14_D3() uint8 {
	return volatile.LoadUint8(&o.MB14_D3.Reg)
}

// CAN0.MB14_D4: Mailbox Register
func (o *CAN0_Type) SetMB14_D4(value uint8) {
	volatile.StoreUint8(&o.MB14_D4.Reg, value)
}
func (o *CAN0_Type) GetMB14_D4() uint8 {
	return volatile.LoadUint8(&o.MB14_D4.Reg)
}

// CAN0.MB14_D5: Mailbox Register
func (o *CAN0_Type) SetMB14_D5(value uint8) {
	volatile.StoreUint8(&o.MB14_D5.Reg, value)
}
func (o *CAN0_Type) GetMB14_D5() uint8 {
	return volatile.LoadUint8(&o.MB14_D5.Reg)
}

// CAN0.MB14_D6: Mailbox Register
func (o *CAN0_Type) SetMB14_D6(value uint8) {
	volatile.StoreUint8(&o.MB14_D6.Reg, value)
}
func (o *CAN0_Type) GetMB14_D6() uint8 {
	return volatile.LoadUint8(&o.MB14_D6.Reg)
}

// CAN0.MB14_D7: Mailbox Register
func (o *CAN0_Type) SetMB14_D7(value uint8) {
	volatile.StoreUint8(&o.MB14_D7.Reg, value)
}
func (o *CAN0_Type) GetMB14_D7() uint8 {
	return volatile.LoadUint8(&o.MB14_D7.Reg)
}

// CAN0.MB14_TS: Mailbox Register
func (o *CAN0_Type) SetMB14_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB14_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB14_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB14_TS.Reg, volatile.LoadUint16(&o.MB14_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB14_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB14_TS.Reg) & 0xff
}

// CAN0.MB15_ID: Mailbox Register
func (o *CAN0_Type) SetMB15_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB15_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB15_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB15_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB15_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB15_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB15_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB15_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB15_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB15_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB15_ID.Reg, volatile.LoadUint32(&o.MB15_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB15_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB15_ID.Reg) & 0x3ffff
}

// CAN0.MB15_DL: Mailbox Register
func (o *CAN0_Type) SetMB15_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB15_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB15_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB15_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB15_DL.Reg, volatile.LoadUint16(&o.MB15_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB15_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB15_DL.Reg) & 0xf
}

// CAN0.MB15_D0: Mailbox Register
func (o *CAN0_Type) SetMB15_D0(value uint8) {
	volatile.StoreUint8(&o.MB15_D0.Reg, value)
}
func (o *CAN0_Type) GetMB15_D0() uint8 {
	return volatile.LoadUint8(&o.MB15_D0.Reg)
}

// CAN0.MB15_D1: Mailbox Register
func (o *CAN0_Type) SetMB15_D1(value uint8) {
	volatile.StoreUint8(&o.MB15_D1.Reg, value)
}
func (o *CAN0_Type) GetMB15_D1() uint8 {
	return volatile.LoadUint8(&o.MB15_D1.Reg)
}

// CAN0.MB15_D2: Mailbox Register
func (o *CAN0_Type) SetMB15_D2(value uint8) {
	volatile.StoreUint8(&o.MB15_D2.Reg, value)
}
func (o *CAN0_Type) GetMB15_D2() uint8 {
	return volatile.LoadUint8(&o.MB15_D2.Reg)
}

// CAN0.MB15_D3: Mailbox Register
func (o *CAN0_Type) SetMB15_D3(value uint8) {
	volatile.StoreUint8(&o.MB15_D3.Reg, value)
}
func (o *CAN0_Type) GetMB15_D3() uint8 {
	return volatile.LoadUint8(&o.MB15_D3.Reg)
}

// CAN0.MB15_D4: Mailbox Register
func (o *CAN0_Type) SetMB15_D4(value uint8) {
	volatile.StoreUint8(&o.MB15_D4.Reg, value)
}
func (o *CAN0_Type) GetMB15_D4() uint8 {
	return volatile.LoadUint8(&o.MB15_D4.Reg)
}

// CAN0.MB15_D5: Mailbox Register
func (o *CAN0_Type) SetMB15_D5(value uint8) {
	volatile.StoreUint8(&o.MB15_D5.Reg, value)
}
func (o *CAN0_Type) GetMB15_D5() uint8 {
	return volatile.LoadUint8(&o.MB15_D5.Reg)
}

// CAN0.MB15_D6: Mailbox Register
func (o *CAN0_Type) SetMB15_D6(value uint8) {
	volatile.StoreUint8(&o.MB15_D6.Reg, value)
}
func (o *CAN0_Type) GetMB15_D6() uint8 {
	return volatile.LoadUint8(&o.MB15_D6.Reg)
}

// CAN0.MB15_D7: Mailbox Register
func (o *CAN0_Type) SetMB15_D7(value uint8) {
	volatile.StoreUint8(&o.MB15_D7.Reg, value)
}
func (o *CAN0_Type) GetMB15_D7() uint8 {
	return volatile.LoadUint8(&o.MB15_D7.Reg)
}

// CAN0.MB15_TS: Mailbox Register
func (o *CAN0_Type) SetMB15_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB15_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB15_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB15_TS.Reg, volatile.LoadUint16(&o.MB15_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB15_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB15_TS.Reg) & 0xff
}

// CAN0.MB16_ID: Mailbox Register
func (o *CAN0_Type) SetMB16_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB16_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB16_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB16_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB16_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB16_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB16_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB16_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB16_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB16_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB16_ID.Reg, volatile.LoadUint32(&o.MB16_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB16_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB16_ID.Reg) & 0x3ffff
}

// CAN0.MB16_DL: Mailbox Register
func (o *CAN0_Type) SetMB16_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB16_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB16_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB16_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB16_DL.Reg, volatile.LoadUint16(&o.MB16_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB16_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB16_DL.Reg) & 0xf
}

// CAN0.MB16_D0: Mailbox Register
func (o *CAN0_Type) SetMB16_D0(value uint8) {
	volatile.StoreUint8(&o.MB16_D0.Reg, value)
}
func (o *CAN0_Type) GetMB16_D0() uint8 {
	return volatile.LoadUint8(&o.MB16_D0.Reg)
}

// CAN0.MB16_D1: Mailbox Register
func (o *CAN0_Type) SetMB16_D1(value uint8) {
	volatile.StoreUint8(&o.MB16_D1.Reg, value)
}
func (o *CAN0_Type) GetMB16_D1() uint8 {
	return volatile.LoadUint8(&o.MB16_D1.Reg)
}

// CAN0.MB16_D2: Mailbox Register
func (o *CAN0_Type) SetMB16_D2(value uint8) {
	volatile.StoreUint8(&o.MB16_D2.Reg, value)
}
func (o *CAN0_Type) GetMB16_D2() uint8 {
	return volatile.LoadUint8(&o.MB16_D2.Reg)
}

// CAN0.MB16_D3: Mailbox Register
func (o *CAN0_Type) SetMB16_D3(value uint8) {
	volatile.StoreUint8(&o.MB16_D3.Reg, value)
}
func (o *CAN0_Type) GetMB16_D3() uint8 {
	return volatile.LoadUint8(&o.MB16_D3.Reg)
}

// CAN0.MB16_D4: Mailbox Register
func (o *CAN0_Type) SetMB16_D4(value uint8) {
	volatile.StoreUint8(&o.MB16_D4.Reg, value)
}
func (o *CAN0_Type) GetMB16_D4() uint8 {
	return volatile.LoadUint8(&o.MB16_D4.Reg)
}

// CAN0.MB16_D5: Mailbox Register
func (o *CAN0_Type) SetMB16_D5(value uint8) {
	volatile.StoreUint8(&o.MB16_D5.Reg, value)
}
func (o *CAN0_Type) GetMB16_D5() uint8 {
	return volatile.LoadUint8(&o.MB16_D5.Reg)
}

// CAN0.MB16_D6: Mailbox Register
func (o *CAN0_Type) SetMB16_D6(value uint8) {
	volatile.StoreUint8(&o.MB16_D6.Reg, value)
}
func (o *CAN0_Type) GetMB16_D6() uint8 {
	return volatile.LoadUint8(&o.MB16_D6.Reg)
}

// CAN0.MB16_D7: Mailbox Register
func (o *CAN0_Type) SetMB16_D7(value uint8) {
	volatile.StoreUint8(&o.MB16_D7.Reg, value)
}
func (o *CAN0_Type) GetMB16_D7() uint8 {
	return volatile.LoadUint8(&o.MB16_D7.Reg)
}

// CAN0.MB16_TS: Mailbox Register
func (o *CAN0_Type) SetMB16_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB16_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB16_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB16_TS.Reg, volatile.LoadUint16(&o.MB16_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB16_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB16_TS.Reg) & 0xff
}

// CAN0.MB17_ID: Mailbox Register
func (o *CAN0_Type) SetMB17_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB17_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB17_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB17_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB17_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB17_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB17_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB17_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB17_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB17_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB17_ID.Reg, volatile.LoadUint32(&o.MB17_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB17_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB17_ID.Reg) & 0x3ffff
}

// CAN0.MB17_DL: Mailbox Register
func (o *CAN0_Type) SetMB17_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB17_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB17_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB17_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB17_DL.Reg, volatile.LoadUint16(&o.MB17_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB17_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB17_DL.Reg) & 0xf
}

// CAN0.MB17_D0: Mailbox Register
func (o *CAN0_Type) SetMB17_D0(value uint8) {
	volatile.StoreUint8(&o.MB17_D0.Reg, value)
}
func (o *CAN0_Type) GetMB17_D0() uint8 {
	return volatile.LoadUint8(&o.MB17_D0.Reg)
}

// CAN0.MB17_D1: Mailbox Register
func (o *CAN0_Type) SetMB17_D1(value uint8) {
	volatile.StoreUint8(&o.MB17_D1.Reg, value)
}
func (o *CAN0_Type) GetMB17_D1() uint8 {
	return volatile.LoadUint8(&o.MB17_D1.Reg)
}

// CAN0.MB17_D2: Mailbox Register
func (o *CAN0_Type) SetMB17_D2(value uint8) {
	volatile.StoreUint8(&o.MB17_D2.Reg, value)
}
func (o *CAN0_Type) GetMB17_D2() uint8 {
	return volatile.LoadUint8(&o.MB17_D2.Reg)
}

// CAN0.MB17_D3: Mailbox Register
func (o *CAN0_Type) SetMB17_D3(value uint8) {
	volatile.StoreUint8(&o.MB17_D3.Reg, value)
}
func (o *CAN0_Type) GetMB17_D3() uint8 {
	return volatile.LoadUint8(&o.MB17_D3.Reg)
}

// CAN0.MB17_D4: Mailbox Register
func (o *CAN0_Type) SetMB17_D4(value uint8) {
	volatile.StoreUint8(&o.MB17_D4.Reg, value)
}
func (o *CAN0_Type) GetMB17_D4() uint8 {
	return volatile.LoadUint8(&o.MB17_D4.Reg)
}

// CAN0.MB17_D5: Mailbox Register
func (o *CAN0_Type) SetMB17_D5(value uint8) {
	volatile.StoreUint8(&o.MB17_D5.Reg, value)
}
func (o *CAN0_Type) GetMB17_D5() uint8 {
	return volatile.LoadUint8(&o.MB17_D5.Reg)
}

// CAN0.MB17_D6: Mailbox Register
func (o *CAN0_Type) SetMB17_D6(value uint8) {
	volatile.StoreUint8(&o.MB17_D6.Reg, value)
}
func (o *CAN0_Type) GetMB17_D6() uint8 {
	return volatile.LoadUint8(&o.MB17_D6.Reg)
}

// CAN0.MB17_D7: Mailbox Register
func (o *CAN0_Type) SetMB17_D7(value uint8) {
	volatile.StoreUint8(&o.MB17_D7.Reg, value)
}
func (o *CAN0_Type) GetMB17_D7() uint8 {
	return volatile.LoadUint8(&o.MB17_D7.Reg)
}

// CAN0.MB17_TS: Mailbox Register
func (o *CAN0_Type) SetMB17_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB17_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB17_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB17_TS.Reg, volatile.LoadUint16(&o.MB17_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB17_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB17_TS.Reg) & 0xff
}

// CAN0.MB18_ID: Mailbox Register
func (o *CAN0_Type) SetMB18_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB18_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB18_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB18_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB18_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB18_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB18_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB18_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB18_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB18_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB18_ID.Reg, volatile.LoadUint32(&o.MB18_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB18_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB18_ID.Reg) & 0x3ffff
}

// CAN0.MB18_DL: Mailbox Register
func (o *CAN0_Type) SetMB18_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB18_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB18_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB18_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB18_DL.Reg, volatile.LoadUint16(&o.MB18_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB18_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB18_DL.Reg) & 0xf
}

// CAN0.MB18_D0: Mailbox Register
func (o *CAN0_Type) SetMB18_D0(value uint8) {
	volatile.StoreUint8(&o.MB18_D0.Reg, value)
}
func (o *CAN0_Type) GetMB18_D0() uint8 {
	return volatile.LoadUint8(&o.MB18_D0.Reg)
}

// CAN0.MB18_D1: Mailbox Register
func (o *CAN0_Type) SetMB18_D1(value uint8) {
	volatile.StoreUint8(&o.MB18_D1.Reg, value)
}
func (o *CAN0_Type) GetMB18_D1() uint8 {
	return volatile.LoadUint8(&o.MB18_D1.Reg)
}

// CAN0.MB18_D2: Mailbox Register
func (o *CAN0_Type) SetMB18_D2(value uint8) {
	volatile.StoreUint8(&o.MB18_D2.Reg, value)
}
func (o *CAN0_Type) GetMB18_D2() uint8 {
	return volatile.LoadUint8(&o.MB18_D2.Reg)
}

// CAN0.MB18_D3: Mailbox Register
func (o *CAN0_Type) SetMB18_D3(value uint8) {
	volatile.StoreUint8(&o.MB18_D3.Reg, value)
}
func (o *CAN0_Type) GetMB18_D3() uint8 {
	return volatile.LoadUint8(&o.MB18_D3.Reg)
}

// CAN0.MB18_D4: Mailbox Register
func (o *CAN0_Type) SetMB18_D4(value uint8) {
	volatile.StoreUint8(&o.MB18_D4.Reg, value)
}
func (o *CAN0_Type) GetMB18_D4() uint8 {
	return volatile.LoadUint8(&o.MB18_D4.Reg)
}

// CAN0.MB18_D5: Mailbox Register
func (o *CAN0_Type) SetMB18_D5(value uint8) {
	volatile.StoreUint8(&o.MB18_D5.Reg, value)
}
func (o *CAN0_Type) GetMB18_D5() uint8 {
	return volatile.LoadUint8(&o.MB18_D5.Reg)
}

// CAN0.MB18_D6: Mailbox Register
func (o *CAN0_Type) SetMB18_D6(value uint8) {
	volatile.StoreUint8(&o.MB18_D6.Reg, value)
}
func (o *CAN0_Type) GetMB18_D6() uint8 {
	return volatile.LoadUint8(&o.MB18_D6.Reg)
}

// CAN0.MB18_D7: Mailbox Register
func (o *CAN0_Type) SetMB18_D7(value uint8) {
	volatile.StoreUint8(&o.MB18_D7.Reg, value)
}
func (o *CAN0_Type) GetMB18_D7() uint8 {
	return volatile.LoadUint8(&o.MB18_D7.Reg)
}

// CAN0.MB18_TS: Mailbox Register
func (o *CAN0_Type) SetMB18_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB18_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB18_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB18_TS.Reg, volatile.LoadUint16(&o.MB18_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB18_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB18_TS.Reg) & 0xff
}

// CAN0.MB19_ID: Mailbox Register
func (o *CAN0_Type) SetMB19_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB19_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB19_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB19_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB19_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB19_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB19_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB19_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB19_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB19_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB19_ID.Reg, volatile.LoadUint32(&o.MB19_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB19_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB19_ID.Reg) & 0x3ffff
}

// CAN0.MB19_DL: Mailbox Register
func (o *CAN0_Type) SetMB19_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB19_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB19_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB19_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB19_DL.Reg, volatile.LoadUint16(&o.MB19_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB19_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB19_DL.Reg) & 0xf
}

// CAN0.MB19_D0: Mailbox Register
func (o *CAN0_Type) SetMB19_D0(value uint8) {
	volatile.StoreUint8(&o.MB19_D0.Reg, value)
}
func (o *CAN0_Type) GetMB19_D0() uint8 {
	return volatile.LoadUint8(&o.MB19_D0.Reg)
}

// CAN0.MB19_D1: Mailbox Register
func (o *CAN0_Type) SetMB19_D1(value uint8) {
	volatile.StoreUint8(&o.MB19_D1.Reg, value)
}
func (o *CAN0_Type) GetMB19_D1() uint8 {
	return volatile.LoadUint8(&o.MB19_D1.Reg)
}

// CAN0.MB19_D2: Mailbox Register
func (o *CAN0_Type) SetMB19_D2(value uint8) {
	volatile.StoreUint8(&o.MB19_D2.Reg, value)
}
func (o *CAN0_Type) GetMB19_D2() uint8 {
	return volatile.LoadUint8(&o.MB19_D2.Reg)
}

// CAN0.MB19_D3: Mailbox Register
func (o *CAN0_Type) SetMB19_D3(value uint8) {
	volatile.StoreUint8(&o.MB19_D3.Reg, value)
}
func (o *CAN0_Type) GetMB19_D3() uint8 {
	return volatile.LoadUint8(&o.MB19_D3.Reg)
}

// CAN0.MB19_D4: Mailbox Register
func (o *CAN0_Type) SetMB19_D4(value uint8) {
	volatile.StoreUint8(&o.MB19_D4.Reg, value)
}
func (o *CAN0_Type) GetMB19_D4() uint8 {
	return volatile.LoadUint8(&o.MB19_D4.Reg)
}

// CAN0.MB19_D5: Mailbox Register
func (o *CAN0_Type) SetMB19_D5(value uint8) {
	volatile.StoreUint8(&o.MB19_D5.Reg, value)
}
func (o *CAN0_Type) GetMB19_D5() uint8 {
	return volatile.LoadUint8(&o.MB19_D5.Reg)
}

// CAN0.MB19_D6: Mailbox Register
func (o *CAN0_Type) SetMB19_D6(value uint8) {
	volatile.StoreUint8(&o.MB19_D6.Reg, value)
}
func (o *CAN0_Type) GetMB19_D6() uint8 {
	return volatile.LoadUint8(&o.MB19_D6.Reg)
}

// CAN0.MB19_D7: Mailbox Register
func (o *CAN0_Type) SetMB19_D7(value uint8) {
	volatile.StoreUint8(&o.MB19_D7.Reg, value)
}
func (o *CAN0_Type) GetMB19_D7() uint8 {
	return volatile.LoadUint8(&o.MB19_D7.Reg)
}

// CAN0.MB19_TS: Mailbox Register
func (o *CAN0_Type) SetMB19_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB19_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB19_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB19_TS.Reg, volatile.LoadUint16(&o.MB19_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB19_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB19_TS.Reg) & 0xff
}

// CAN0.MB20_ID: Mailbox Register
func (o *CAN0_Type) SetMB20_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB20_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB20_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB20_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB20_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB20_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB20_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB20_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB20_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB20_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB20_ID.Reg, volatile.LoadUint32(&o.MB20_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB20_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB20_ID.Reg) & 0x3ffff
}

// CAN0.MB20_DL: Mailbox Register
func (o *CAN0_Type) SetMB20_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB20_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB20_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB20_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB20_DL.Reg, volatile.LoadUint16(&o.MB20_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB20_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB20_DL.Reg) & 0xf
}

// CAN0.MB20_D0: Mailbox Register
func (o *CAN0_Type) SetMB20_D0(value uint8) {
	volatile.StoreUint8(&o.MB20_D0.Reg, value)
}
func (o *CAN0_Type) GetMB20_D0() uint8 {
	return volatile.LoadUint8(&o.MB20_D0.Reg)
}

// CAN0.MB20_D1: Mailbox Register
func (o *CAN0_Type) SetMB20_D1(value uint8) {
	volatile.StoreUint8(&o.MB20_D1.Reg, value)
}
func (o *CAN0_Type) GetMB20_D1() uint8 {
	return volatile.LoadUint8(&o.MB20_D1.Reg)
}

// CAN0.MB20_D2: Mailbox Register
func (o *CAN0_Type) SetMB20_D2(value uint8) {
	volatile.StoreUint8(&o.MB20_D2.Reg, value)
}
func (o *CAN0_Type) GetMB20_D2() uint8 {
	return volatile.LoadUint8(&o.MB20_D2.Reg)
}

// CAN0.MB20_D3: Mailbox Register
func (o *CAN0_Type) SetMB20_D3(value uint8) {
	volatile.StoreUint8(&o.MB20_D3.Reg, value)
}
func (o *CAN0_Type) GetMB20_D3() uint8 {
	return volatile.LoadUint8(&o.MB20_D3.Reg)
}

// CAN0.MB20_D4: Mailbox Register
func (o *CAN0_Type) SetMB20_D4(value uint8) {
	volatile.StoreUint8(&o.MB20_D4.Reg, value)
}
func (o *CAN0_Type) GetMB20_D4() uint8 {
	return volatile.LoadUint8(&o.MB20_D4.Reg)
}

// CAN0.MB20_D5: Mailbox Register
func (o *CAN0_Type) SetMB20_D5(value uint8) {
	volatile.StoreUint8(&o.MB20_D5.Reg, value)
}
func (o *CAN0_Type) GetMB20_D5() uint8 {
	return volatile.LoadUint8(&o.MB20_D5.Reg)
}

// CAN0.MB20_D6: Mailbox Register
func (o *CAN0_Type) SetMB20_D6(value uint8) {
	volatile.StoreUint8(&o.MB20_D6.Reg, value)
}
func (o *CAN0_Type) GetMB20_D6() uint8 {
	return volatile.LoadUint8(&o.MB20_D6.Reg)
}

// CAN0.MB20_D7: Mailbox Register
func (o *CAN0_Type) SetMB20_D7(value uint8) {
	volatile.StoreUint8(&o.MB20_D7.Reg, value)
}
func (o *CAN0_Type) GetMB20_D7() uint8 {
	return volatile.LoadUint8(&o.MB20_D7.Reg)
}

// CAN0.MB20_TS: Mailbox Register
func (o *CAN0_Type) SetMB20_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB20_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB20_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB20_TS.Reg, volatile.LoadUint16(&o.MB20_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB20_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB20_TS.Reg) & 0xff
}

// CAN0.MB21_ID: Mailbox Register
func (o *CAN0_Type) SetMB21_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB21_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB21_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB21_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB21_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB21_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB21_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB21_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB21_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB21_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB21_ID.Reg, volatile.LoadUint32(&o.MB21_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB21_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB21_ID.Reg) & 0x3ffff
}

// CAN0.MB21_DL: Mailbox Register
func (o *CAN0_Type) SetMB21_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB21_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB21_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB21_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB21_DL.Reg, volatile.LoadUint16(&o.MB21_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB21_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB21_DL.Reg) & 0xf
}

// CAN0.MB21_D0: Mailbox Register
func (o *CAN0_Type) SetMB21_D0(value uint8) {
	volatile.StoreUint8(&o.MB21_D0.Reg, value)
}
func (o *CAN0_Type) GetMB21_D0() uint8 {
	return volatile.LoadUint8(&o.MB21_D0.Reg)
}

// CAN0.MB21_D1: Mailbox Register
func (o *CAN0_Type) SetMB21_D1(value uint8) {
	volatile.StoreUint8(&o.MB21_D1.Reg, value)
}
func (o *CAN0_Type) GetMB21_D1() uint8 {
	return volatile.LoadUint8(&o.MB21_D1.Reg)
}

// CAN0.MB21_D2: Mailbox Register
func (o *CAN0_Type) SetMB21_D2(value uint8) {
	volatile.StoreUint8(&o.MB21_D2.Reg, value)
}
func (o *CAN0_Type) GetMB21_D2() uint8 {
	return volatile.LoadUint8(&o.MB21_D2.Reg)
}

// CAN0.MB21_D3: Mailbox Register
func (o *CAN0_Type) SetMB21_D3(value uint8) {
	volatile.StoreUint8(&o.MB21_D3.Reg, value)
}
func (o *CAN0_Type) GetMB21_D3() uint8 {
	return volatile.LoadUint8(&o.MB21_D3.Reg)
}

// CAN0.MB21_D4: Mailbox Register
func (o *CAN0_Type) SetMB21_D4(value uint8) {
	volatile.StoreUint8(&o.MB21_D4.Reg, value)
}
func (o *CAN0_Type) GetMB21_D4() uint8 {
	return volatile.LoadUint8(&o.MB21_D4.Reg)
}

// CAN0.MB21_D5: Mailbox Register
func (o *CAN0_Type) SetMB21_D5(value uint8) {
	volatile.StoreUint8(&o.MB21_D5.Reg, value)
}
func (o *CAN0_Type) GetMB21_D5() uint8 {
	return volatile.LoadUint8(&o.MB21_D5.Reg)
}

// CAN0.MB21_D6: Mailbox Register
func (o *CAN0_Type) SetMB21_D6(value uint8) {
	volatile.StoreUint8(&o.MB21_D6.Reg, value)
}
func (o *CAN0_Type) GetMB21_D6() uint8 {
	return volatile.LoadUint8(&o.MB21_D6.Reg)
}

// CAN0.MB21_D7: Mailbox Register
func (o *CAN0_Type) SetMB21_D7(value uint8) {
	volatile.StoreUint8(&o.MB21_D7.Reg, value)
}
func (o *CAN0_Type) GetMB21_D7() uint8 {
	return volatile.LoadUint8(&o.MB21_D7.Reg)
}

// CAN0.MB21_TS: Mailbox Register
func (o *CAN0_Type) SetMB21_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB21_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB21_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB21_TS.Reg, volatile.LoadUint16(&o.MB21_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB21_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB21_TS.Reg) & 0xff
}

// CAN0.MB22_ID: Mailbox Register
func (o *CAN0_Type) SetMB22_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB22_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB22_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB22_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB22_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB22_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB22_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB22_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB22_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB22_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB22_ID.Reg, volatile.LoadUint32(&o.MB22_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB22_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB22_ID.Reg) & 0x3ffff
}

// CAN0.MB22_DL: Mailbox Register
func (o *CAN0_Type) SetMB22_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB22_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB22_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB22_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB22_DL.Reg, volatile.LoadUint16(&o.MB22_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB22_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB22_DL.Reg) & 0xf
}

// CAN0.MB22_D0: Mailbox Register
func (o *CAN0_Type) SetMB22_D0(value uint8) {
	volatile.StoreUint8(&o.MB22_D0.Reg, value)
}
func (o *CAN0_Type) GetMB22_D0() uint8 {
	return volatile.LoadUint8(&o.MB22_D0.Reg)
}

// CAN0.MB22_D1: Mailbox Register
func (o *CAN0_Type) SetMB22_D1(value uint8) {
	volatile.StoreUint8(&o.MB22_D1.Reg, value)
}
func (o *CAN0_Type) GetMB22_D1() uint8 {
	return volatile.LoadUint8(&o.MB22_D1.Reg)
}

// CAN0.MB22_D2: Mailbox Register
func (o *CAN0_Type) SetMB22_D2(value uint8) {
	volatile.StoreUint8(&o.MB22_D2.Reg, value)
}
func (o *CAN0_Type) GetMB22_D2() uint8 {
	return volatile.LoadUint8(&o.MB22_D2.Reg)
}

// CAN0.MB22_D3: Mailbox Register
func (o *CAN0_Type) SetMB22_D3(value uint8) {
	volatile.StoreUint8(&o.MB22_D3.Reg, value)
}
func (o *CAN0_Type) GetMB22_D3() uint8 {
	return volatile.LoadUint8(&o.MB22_D3.Reg)
}

// CAN0.MB22_D4: Mailbox Register
func (o *CAN0_Type) SetMB22_D4(value uint8) {
	volatile.StoreUint8(&o.MB22_D4.Reg, value)
}
func (o *CAN0_Type) GetMB22_D4() uint8 {
	return volatile.LoadUint8(&o.MB22_D4.Reg)
}

// CAN0.MB22_D5: Mailbox Register
func (o *CAN0_Type) SetMB22_D5(value uint8) {
	volatile.StoreUint8(&o.MB22_D5.Reg, value)
}
func (o *CAN0_Type) GetMB22_D5() uint8 {
	return volatile.LoadUint8(&o.MB22_D5.Reg)
}

// CAN0.MB22_D6: Mailbox Register
func (o *CAN0_Type) SetMB22_D6(value uint8) {
	volatile.StoreUint8(&o.MB22_D6.Reg, value)
}
func (o *CAN0_Type) GetMB22_D6() uint8 {
	return volatile.LoadUint8(&o.MB22_D6.Reg)
}

// CAN0.MB22_D7: Mailbox Register
func (o *CAN0_Type) SetMB22_D7(value uint8) {
	volatile.StoreUint8(&o.MB22_D7.Reg, value)
}
func (o *CAN0_Type) GetMB22_D7() uint8 {
	return volatile.LoadUint8(&o.MB22_D7.Reg)
}

// CAN0.MB22_TS: Mailbox Register
func (o *CAN0_Type) SetMB22_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB22_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB22_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB22_TS.Reg, volatile.LoadUint16(&o.MB22_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB22_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB22_TS.Reg) & 0xff
}

// CAN0.MB23_ID: Mailbox Register
func (o *CAN0_Type) SetMB23_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB23_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB23_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB23_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB23_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB23_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB23_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB23_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB23_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB23_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB23_ID.Reg, volatile.LoadUint32(&o.MB23_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB23_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB23_ID.Reg) & 0x3ffff
}

// CAN0.MB23_DL: Mailbox Register
func (o *CAN0_Type) SetMB23_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB23_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB23_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB23_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB23_DL.Reg, volatile.LoadUint16(&o.MB23_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB23_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB23_DL.Reg) & 0xf
}

// CAN0.MB23_D0: Mailbox Register
func (o *CAN0_Type) SetMB23_D0(value uint8) {
	volatile.StoreUint8(&o.MB23_D0.Reg, value)
}
func (o *CAN0_Type) GetMB23_D0() uint8 {
	return volatile.LoadUint8(&o.MB23_D0.Reg)
}

// CAN0.MB23_D1: Mailbox Register
func (o *CAN0_Type) SetMB23_D1(value uint8) {
	volatile.StoreUint8(&o.MB23_D1.Reg, value)
}
func (o *CAN0_Type) GetMB23_D1() uint8 {
	return volatile.LoadUint8(&o.MB23_D1.Reg)
}

// CAN0.MB23_D2: Mailbox Register
func (o *CAN0_Type) SetMB23_D2(value uint8) {
	volatile.StoreUint8(&o.MB23_D2.Reg, value)
}
func (o *CAN0_Type) GetMB23_D2() uint8 {
	return volatile.LoadUint8(&o.MB23_D2.Reg)
}

// CAN0.MB23_D3: Mailbox Register
func (o *CAN0_Type) SetMB23_D3(value uint8) {
	volatile.StoreUint8(&o.MB23_D3.Reg, value)
}
func (o *CAN0_Type) GetMB23_D3() uint8 {
	return volatile.LoadUint8(&o.MB23_D3.Reg)
}

// CAN0.MB23_D4: Mailbox Register
func (o *CAN0_Type) SetMB23_D4(value uint8) {
	volatile.StoreUint8(&o.MB23_D4.Reg, value)
}
func (o *CAN0_Type) GetMB23_D4() uint8 {
	return volatile.LoadUint8(&o.MB23_D4.Reg)
}

// CAN0.MB23_D5: Mailbox Register
func (o *CAN0_Type) SetMB23_D5(value uint8) {
	volatile.StoreUint8(&o.MB23_D5.Reg, value)
}
func (o *CAN0_Type) GetMB23_D5() uint8 {
	return volatile.LoadUint8(&o.MB23_D5.Reg)
}

// CAN0.MB23_D6: Mailbox Register
func (o *CAN0_Type) SetMB23_D6(value uint8) {
	volatile.StoreUint8(&o.MB23_D6.Reg, value)
}
func (o *CAN0_Type) GetMB23_D6() uint8 {
	return volatile.LoadUint8(&o.MB23_D6.Reg)
}

// CAN0.MB23_D7: Mailbox Register
func (o *CAN0_Type) SetMB23_D7(value uint8) {
	volatile.StoreUint8(&o.MB23_D7.Reg, value)
}
func (o *CAN0_Type) GetMB23_D7() uint8 {
	return volatile.LoadUint8(&o.MB23_D7.Reg)
}

// CAN0.MB23_TS: Mailbox Register
func (o *CAN0_Type) SetMB23_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB23_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB23_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB23_TS.Reg, volatile.LoadUint16(&o.MB23_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB23_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB23_TS.Reg) & 0xff
}

// CAN0.MB24_ID: Mailbox Register
func (o *CAN0_Type) SetMB24_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB24_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB24_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB24_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB24_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB24_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB24_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB24_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB24_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB24_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB24_ID.Reg, volatile.LoadUint32(&o.MB24_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB24_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB24_ID.Reg) & 0x3ffff
}

// CAN0.MB24_DL: Mailbox Register
func (o *CAN0_Type) SetMB24_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB24_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB24_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB24_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB24_DL.Reg, volatile.LoadUint16(&o.MB24_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB24_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB24_DL.Reg) & 0xf
}

// CAN0.MB24_D0: Mailbox Register
func (o *CAN0_Type) SetMB24_D0(value uint8) {
	volatile.StoreUint8(&o.MB24_D0.Reg, value)
}
func (o *CAN0_Type) GetMB24_D0() uint8 {
	return volatile.LoadUint8(&o.MB24_D0.Reg)
}

// CAN0.MB24_D1: Mailbox Register
func (o *CAN0_Type) SetMB24_D1(value uint8) {
	volatile.StoreUint8(&o.MB24_D1.Reg, value)
}
func (o *CAN0_Type) GetMB24_D1() uint8 {
	return volatile.LoadUint8(&o.MB24_D1.Reg)
}

// CAN0.MB24_D2: Mailbox Register
func (o *CAN0_Type) SetMB24_D2(value uint8) {
	volatile.StoreUint8(&o.MB24_D2.Reg, value)
}
func (o *CAN0_Type) GetMB24_D2() uint8 {
	return volatile.LoadUint8(&o.MB24_D2.Reg)
}

// CAN0.MB24_D3: Mailbox Register
func (o *CAN0_Type) SetMB24_D3(value uint8) {
	volatile.StoreUint8(&o.MB24_D3.Reg, value)
}
func (o *CAN0_Type) GetMB24_D3() uint8 {
	return volatile.LoadUint8(&o.MB24_D3.Reg)
}

// CAN0.MB24_D4: Mailbox Register
func (o *CAN0_Type) SetMB24_D4(value uint8) {
	volatile.StoreUint8(&o.MB24_D4.Reg, value)
}
func (o *CAN0_Type) GetMB24_D4() uint8 {
	return volatile.LoadUint8(&o.MB24_D4.Reg)
}

// CAN0.MB24_D5: Mailbox Register
func (o *CAN0_Type) SetMB24_D5(value uint8) {
	volatile.StoreUint8(&o.MB24_D5.Reg, value)
}
func (o *CAN0_Type) GetMB24_D5() uint8 {
	return volatile.LoadUint8(&o.MB24_D5.Reg)
}

// CAN0.MB24_D6: Mailbox Register
func (o *CAN0_Type) SetMB24_D6(value uint8) {
	volatile.StoreUint8(&o.MB24_D6.Reg, value)
}
func (o *CAN0_Type) GetMB24_D6() uint8 {
	return volatile.LoadUint8(&o.MB24_D6.Reg)
}

// CAN0.MB24_D7: Mailbox Register
func (o *CAN0_Type) SetMB24_D7(value uint8) {
	volatile.StoreUint8(&o.MB24_D7.Reg, value)
}
func (o *CAN0_Type) GetMB24_D7() uint8 {
	return volatile.LoadUint8(&o.MB24_D7.Reg)
}

// CAN0.MB24_TS: Mailbox Register
func (o *CAN0_Type) SetMB24_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB24_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB24_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB24_TS.Reg, volatile.LoadUint16(&o.MB24_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB24_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB24_TS.Reg) & 0xff
}

// CAN0.MB25_ID: Mailbox Register
func (o *CAN0_Type) SetMB25_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB25_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB25_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB25_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB25_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB25_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB25_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB25_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB25_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB25_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB25_ID.Reg, volatile.LoadUint32(&o.MB25_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB25_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB25_ID.Reg) & 0x3ffff
}

// CAN0.MB25_DL: Mailbox Register
func (o *CAN0_Type) SetMB25_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB25_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB25_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB25_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB25_DL.Reg, volatile.LoadUint16(&o.MB25_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB25_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB25_DL.Reg) & 0xf
}

// CAN0.MB25_D0: Mailbox Register
func (o *CAN0_Type) SetMB25_D0(value uint8) {
	volatile.StoreUint8(&o.MB25_D0.Reg, value)
}
func (o *CAN0_Type) GetMB25_D0() uint8 {
	return volatile.LoadUint8(&o.MB25_D0.Reg)
}

// CAN0.MB25_D1: Mailbox Register
func (o *CAN0_Type) SetMB25_D1(value uint8) {
	volatile.StoreUint8(&o.MB25_D1.Reg, value)
}
func (o *CAN0_Type) GetMB25_D1() uint8 {
	return volatile.LoadUint8(&o.MB25_D1.Reg)
}

// CAN0.MB25_D2: Mailbox Register
func (o *CAN0_Type) SetMB25_D2(value uint8) {
	volatile.StoreUint8(&o.MB25_D2.Reg, value)
}
func (o *CAN0_Type) GetMB25_D2() uint8 {
	return volatile.LoadUint8(&o.MB25_D2.Reg)
}

// CAN0.MB25_D3: Mailbox Register
func (o *CAN0_Type) SetMB25_D3(value uint8) {
	volatile.StoreUint8(&o.MB25_D3.Reg, value)
}
func (o *CAN0_Type) GetMB25_D3() uint8 {
	return volatile.LoadUint8(&o.MB25_D3.Reg)
}

// CAN0.MB25_D4: Mailbox Register
func (o *CAN0_Type) SetMB25_D4(value uint8) {
	volatile.StoreUint8(&o.MB25_D4.Reg, value)
}
func (o *CAN0_Type) GetMB25_D4() uint8 {
	return volatile.LoadUint8(&o.MB25_D4.Reg)
}

// CAN0.MB25_D5: Mailbox Register
func (o *CAN0_Type) SetMB25_D5(value uint8) {
	volatile.StoreUint8(&o.MB25_D5.Reg, value)
}
func (o *CAN0_Type) GetMB25_D5() uint8 {
	return volatile.LoadUint8(&o.MB25_D5.Reg)
}

// CAN0.MB25_D6: Mailbox Register
func (o *CAN0_Type) SetMB25_D6(value uint8) {
	volatile.StoreUint8(&o.MB25_D6.Reg, value)
}
func (o *CAN0_Type) GetMB25_D6() uint8 {
	return volatile.LoadUint8(&o.MB25_D6.Reg)
}

// CAN0.MB25_D7: Mailbox Register
func (o *CAN0_Type) SetMB25_D7(value uint8) {
	volatile.StoreUint8(&o.MB25_D7.Reg, value)
}
func (o *CAN0_Type) GetMB25_D7() uint8 {
	return volatile.LoadUint8(&o.MB25_D7.Reg)
}

// CAN0.MB25_TS: Mailbox Register
func (o *CAN0_Type) SetMB25_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB25_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB25_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB25_TS.Reg, volatile.LoadUint16(&o.MB25_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB25_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB25_TS.Reg) & 0xff
}

// CAN0.MB26_ID: Mailbox Register
func (o *CAN0_Type) SetMB26_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB26_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB26_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB26_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB26_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB26_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB26_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB26_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB26_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB26_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB26_ID.Reg, volatile.LoadUint32(&o.MB26_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB26_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB26_ID.Reg) & 0x3ffff
}

// CAN0.MB26_DL: Mailbox Register
func (o *CAN0_Type) SetMB26_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB26_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB26_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB26_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB26_DL.Reg, volatile.LoadUint16(&o.MB26_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB26_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB26_DL.Reg) & 0xf
}

// CAN0.MB26_D0: Mailbox Register
func (o *CAN0_Type) SetMB26_D0(value uint8) {
	volatile.StoreUint8(&o.MB26_D0.Reg, value)
}
func (o *CAN0_Type) GetMB26_D0() uint8 {
	return volatile.LoadUint8(&o.MB26_D0.Reg)
}

// CAN0.MB26_D1: Mailbox Register
func (o *CAN0_Type) SetMB26_D1(value uint8) {
	volatile.StoreUint8(&o.MB26_D1.Reg, value)
}
func (o *CAN0_Type) GetMB26_D1() uint8 {
	return volatile.LoadUint8(&o.MB26_D1.Reg)
}

// CAN0.MB26_D2: Mailbox Register
func (o *CAN0_Type) SetMB26_D2(value uint8) {
	volatile.StoreUint8(&o.MB26_D2.Reg, value)
}
func (o *CAN0_Type) GetMB26_D2() uint8 {
	return volatile.LoadUint8(&o.MB26_D2.Reg)
}

// CAN0.MB26_D3: Mailbox Register
func (o *CAN0_Type) SetMB26_D3(value uint8) {
	volatile.StoreUint8(&o.MB26_D3.Reg, value)
}
func (o *CAN0_Type) GetMB26_D3() uint8 {
	return volatile.LoadUint8(&o.MB26_D3.Reg)
}

// CAN0.MB26_D4: Mailbox Register
func (o *CAN0_Type) SetMB26_D4(value uint8) {
	volatile.StoreUint8(&o.MB26_D4.Reg, value)
}
func (o *CAN0_Type) GetMB26_D4() uint8 {
	return volatile.LoadUint8(&o.MB26_D4.Reg)
}

// CAN0.MB26_D5: Mailbox Register
func (o *CAN0_Type) SetMB26_D5(value uint8) {
	volatile.StoreUint8(&o.MB26_D5.Reg, value)
}
func (o *CAN0_Type) GetMB26_D5() uint8 {
	return volatile.LoadUint8(&o.MB26_D5.Reg)
}

// CAN0.MB26_D6: Mailbox Register
func (o *CAN0_Type) SetMB26_D6(value uint8) {
	volatile.StoreUint8(&o.MB26_D6.Reg, value)
}
func (o *CAN0_Type) GetMB26_D6() uint8 {
	return volatile.LoadUint8(&o.MB26_D6.Reg)
}

// CAN0.MB26_D7: Mailbox Register
func (o *CAN0_Type) SetMB26_D7(value uint8) {
	volatile.StoreUint8(&o.MB26_D7.Reg, value)
}
func (o *CAN0_Type) GetMB26_D7() uint8 {
	return volatile.LoadUint8(&o.MB26_D7.Reg)
}

// CAN0.MB26_TS: Mailbox Register
func (o *CAN0_Type) SetMB26_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB26_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB26_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB26_TS.Reg, volatile.LoadUint16(&o.MB26_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB26_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB26_TS.Reg) & 0xff
}

// CAN0.MB27_ID: Mailbox Register
func (o *CAN0_Type) SetMB27_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB27_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB27_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB27_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB27_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB27_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB27_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB27_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB27_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB27_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB27_ID.Reg, volatile.LoadUint32(&o.MB27_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB27_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB27_ID.Reg) & 0x3ffff
}

// CAN0.MB27_DL: Mailbox Register
func (o *CAN0_Type) SetMB27_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB27_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB27_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB27_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB27_DL.Reg, volatile.LoadUint16(&o.MB27_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB27_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB27_DL.Reg) & 0xf
}

// CAN0.MB27_D0: Mailbox Register
func (o *CAN0_Type) SetMB27_D0(value uint8) {
	volatile.StoreUint8(&o.MB27_D0.Reg, value)
}
func (o *CAN0_Type) GetMB27_D0() uint8 {
	return volatile.LoadUint8(&o.MB27_D0.Reg)
}

// CAN0.MB27_D1: Mailbox Register
func (o *CAN0_Type) SetMB27_D1(value uint8) {
	volatile.StoreUint8(&o.MB27_D1.Reg, value)
}
func (o *CAN0_Type) GetMB27_D1() uint8 {
	return volatile.LoadUint8(&o.MB27_D1.Reg)
}

// CAN0.MB27_D2: Mailbox Register
func (o *CAN0_Type) SetMB27_D2(value uint8) {
	volatile.StoreUint8(&o.MB27_D2.Reg, value)
}
func (o *CAN0_Type) GetMB27_D2() uint8 {
	return volatile.LoadUint8(&o.MB27_D2.Reg)
}

// CAN0.MB27_D3: Mailbox Register
func (o *CAN0_Type) SetMB27_D3(value uint8) {
	volatile.StoreUint8(&o.MB27_D3.Reg, value)
}
func (o *CAN0_Type) GetMB27_D3() uint8 {
	return volatile.LoadUint8(&o.MB27_D3.Reg)
}

// CAN0.MB27_D4: Mailbox Register
func (o *CAN0_Type) SetMB27_D4(value uint8) {
	volatile.StoreUint8(&o.MB27_D4.Reg, value)
}
func (o *CAN0_Type) GetMB27_D4() uint8 {
	return volatile.LoadUint8(&o.MB27_D4.Reg)
}

// CAN0.MB27_D5: Mailbox Register
func (o *CAN0_Type) SetMB27_D5(value uint8) {
	volatile.StoreUint8(&o.MB27_D5.Reg, value)
}
func (o *CAN0_Type) GetMB27_D5() uint8 {
	return volatile.LoadUint8(&o.MB27_D5.Reg)
}

// CAN0.MB27_D6: Mailbox Register
func (o *CAN0_Type) SetMB27_D6(value uint8) {
	volatile.StoreUint8(&o.MB27_D6.Reg, value)
}
func (o *CAN0_Type) GetMB27_D6() uint8 {
	return volatile.LoadUint8(&o.MB27_D6.Reg)
}

// CAN0.MB27_D7: Mailbox Register
func (o *CAN0_Type) SetMB27_D7(value uint8) {
	volatile.StoreUint8(&o.MB27_D7.Reg, value)
}
func (o *CAN0_Type) GetMB27_D7() uint8 {
	return volatile.LoadUint8(&o.MB27_D7.Reg)
}

// CAN0.MB27_TS: Mailbox Register
func (o *CAN0_Type) SetMB27_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB27_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB27_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB27_TS.Reg, volatile.LoadUint16(&o.MB27_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB27_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB27_TS.Reg) & 0xff
}

// CAN0.MB28_ID: Mailbox Register
func (o *CAN0_Type) SetMB28_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB28_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB28_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB28_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB28_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB28_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB28_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB28_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB28_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB28_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB28_ID.Reg, volatile.LoadUint32(&o.MB28_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB28_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB28_ID.Reg) & 0x3ffff
}

// CAN0.MB28_DL: Mailbox Register
func (o *CAN0_Type) SetMB28_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB28_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB28_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB28_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB28_DL.Reg, volatile.LoadUint16(&o.MB28_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB28_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB28_DL.Reg) & 0xf
}

// CAN0.MB28_D0: Mailbox Register
func (o *CAN0_Type) SetMB28_D0(value uint8) {
	volatile.StoreUint8(&o.MB28_D0.Reg, value)
}
func (o *CAN0_Type) GetMB28_D0() uint8 {
	return volatile.LoadUint8(&o.MB28_D0.Reg)
}

// CAN0.MB28_D1: Mailbox Register
func (o *CAN0_Type) SetMB28_D1(value uint8) {
	volatile.StoreUint8(&o.MB28_D1.Reg, value)
}
func (o *CAN0_Type) GetMB28_D1() uint8 {
	return volatile.LoadUint8(&o.MB28_D1.Reg)
}

// CAN0.MB28_D2: Mailbox Register
func (o *CAN0_Type) SetMB28_D2(value uint8) {
	volatile.StoreUint8(&o.MB28_D2.Reg, value)
}
func (o *CAN0_Type) GetMB28_D2() uint8 {
	return volatile.LoadUint8(&o.MB28_D2.Reg)
}

// CAN0.MB28_D3: Mailbox Register
func (o *CAN0_Type) SetMB28_D3(value uint8) {
	volatile.StoreUint8(&o.MB28_D3.Reg, value)
}
func (o *CAN0_Type) GetMB28_D3() uint8 {
	return volatile.LoadUint8(&o.MB28_D3.Reg)
}

// CAN0.MB28_D4: Mailbox Register
func (o *CAN0_Type) SetMB28_D4(value uint8) {
	volatile.StoreUint8(&o.MB28_D4.Reg, value)
}
func (o *CAN0_Type) GetMB28_D4() uint8 {
	return volatile.LoadUint8(&o.MB28_D4.Reg)
}

// CAN0.MB28_D5: Mailbox Register
func (o *CAN0_Type) SetMB28_D5(value uint8) {
	volatile.StoreUint8(&o.MB28_D5.Reg, value)
}
func (o *CAN0_Type) GetMB28_D5() uint8 {
	return volatile.LoadUint8(&o.MB28_D5.Reg)
}

// CAN0.MB28_D6: Mailbox Register
func (o *CAN0_Type) SetMB28_D6(value uint8) {
	volatile.StoreUint8(&o.MB28_D6.Reg, value)
}
func (o *CAN0_Type) GetMB28_D6() uint8 {
	return volatile.LoadUint8(&o.MB28_D6.Reg)
}

// CAN0.MB28_D7: Mailbox Register
func (o *CAN0_Type) SetMB28_D7(value uint8) {
	volatile.StoreUint8(&o.MB28_D7.Reg, value)
}
func (o *CAN0_Type) GetMB28_D7() uint8 {
	return volatile.LoadUint8(&o.MB28_D7.Reg)
}

// CAN0.MB28_TS: Mailbox Register
func (o *CAN0_Type) SetMB28_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB28_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB28_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB28_TS.Reg, volatile.LoadUint16(&o.MB28_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB28_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB28_TS.Reg) & 0xff
}

// CAN0.MB29_ID: Mailbox Register
func (o *CAN0_Type) SetMB29_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB29_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB29_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB29_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB29_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB29_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB29_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB29_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB29_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB29_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB29_ID.Reg, volatile.LoadUint32(&o.MB29_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB29_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB29_ID.Reg) & 0x3ffff
}

// CAN0.MB29_DL: Mailbox Register
func (o *CAN0_Type) SetMB29_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB29_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB29_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB29_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB29_DL.Reg, volatile.LoadUint16(&o.MB29_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB29_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB29_DL.Reg) & 0xf
}

// CAN0.MB29_D0: Mailbox Register
func (o *CAN0_Type) SetMB29_D0(value uint8) {
	volatile.StoreUint8(&o.MB29_D0.Reg, value)
}
func (o *CAN0_Type) GetMB29_D0() uint8 {
	return volatile.LoadUint8(&o.MB29_D0.Reg)
}

// CAN0.MB29_D1: Mailbox Register
func (o *CAN0_Type) SetMB29_D1(value uint8) {
	volatile.StoreUint8(&o.MB29_D1.Reg, value)
}
func (o *CAN0_Type) GetMB29_D1() uint8 {
	return volatile.LoadUint8(&o.MB29_D1.Reg)
}

// CAN0.MB29_D2: Mailbox Register
func (o *CAN0_Type) SetMB29_D2(value uint8) {
	volatile.StoreUint8(&o.MB29_D2.Reg, value)
}
func (o *CAN0_Type) GetMB29_D2() uint8 {
	return volatile.LoadUint8(&o.MB29_D2.Reg)
}

// CAN0.MB29_D3: Mailbox Register
func (o *CAN0_Type) SetMB29_D3(value uint8) {
	volatile.StoreUint8(&o.MB29_D3.Reg, value)
}
func (o *CAN0_Type) GetMB29_D3() uint8 {
	return volatile.LoadUint8(&o.MB29_D3.Reg)
}

// CAN0.MB29_D4: Mailbox Register
func (o *CAN0_Type) SetMB29_D4(value uint8) {
	volatile.StoreUint8(&o.MB29_D4.Reg, value)
}
func (o *CAN0_Type) GetMB29_D4() uint8 {
	return volatile.LoadUint8(&o.MB29_D4.Reg)
}

// CAN0.MB29_D5: Mailbox Register
func (o *CAN0_Type) SetMB29_D5(value uint8) {
	volatile.StoreUint8(&o.MB29_D5.Reg, value)
}
func (o *CAN0_Type) GetMB29_D5() uint8 {
	return volatile.LoadUint8(&o.MB29_D5.Reg)
}

// CAN0.MB29_D6: Mailbox Register
func (o *CAN0_Type) SetMB29_D6(value uint8) {
	volatile.StoreUint8(&o.MB29_D6.Reg, value)
}
func (o *CAN0_Type) GetMB29_D6() uint8 {
	return volatile.LoadUint8(&o.MB29_D6.Reg)
}

// CAN0.MB29_D7: Mailbox Register
func (o *CAN0_Type) SetMB29_D7(value uint8) {
	volatile.StoreUint8(&o.MB29_D7.Reg, value)
}
func (o *CAN0_Type) GetMB29_D7() uint8 {
	return volatile.LoadUint8(&o.MB29_D7.Reg)
}

// CAN0.MB29_TS: Mailbox Register
func (o *CAN0_Type) SetMB29_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB29_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB29_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB29_TS.Reg, volatile.LoadUint16(&o.MB29_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB29_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB29_TS.Reg) & 0xff
}

// CAN0.MB30_ID: Mailbox Register
func (o *CAN0_Type) SetMB30_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB30_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB30_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB30_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB30_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB30_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB30_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB30_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB30_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB30_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB30_ID.Reg, volatile.LoadUint32(&o.MB30_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB30_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB30_ID.Reg) & 0x3ffff
}

// CAN0.MB30_DL: Mailbox Register
func (o *CAN0_Type) SetMB30_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB30_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB30_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB30_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB30_DL.Reg, volatile.LoadUint16(&o.MB30_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB30_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB30_DL.Reg) & 0xf
}

// CAN0.MB30_D0: Mailbox Register
func (o *CAN0_Type) SetMB30_D0(value uint8) {
	volatile.StoreUint8(&o.MB30_D0.Reg, value)
}
func (o *CAN0_Type) GetMB30_D0() uint8 {
	return volatile.LoadUint8(&o.MB30_D0.Reg)
}

// CAN0.MB30_D1: Mailbox Register
func (o *CAN0_Type) SetMB30_D1(value uint8) {
	volatile.StoreUint8(&o.MB30_D1.Reg, value)
}
func (o *CAN0_Type) GetMB30_D1() uint8 {
	return volatile.LoadUint8(&o.MB30_D1.Reg)
}

// CAN0.MB30_D2: Mailbox Register
func (o *CAN0_Type) SetMB30_D2(value uint8) {
	volatile.StoreUint8(&o.MB30_D2.Reg, value)
}
func (o *CAN0_Type) GetMB30_D2() uint8 {
	return volatile.LoadUint8(&o.MB30_D2.Reg)
}

// CAN0.MB30_D3: Mailbox Register
func (o *CAN0_Type) SetMB30_D3(value uint8) {
	volatile.StoreUint8(&o.MB30_D3.Reg, value)
}
func (o *CAN0_Type) GetMB30_D3() uint8 {
	return volatile.LoadUint8(&o.MB30_D3.Reg)
}

// CAN0.MB30_D4: Mailbox Register
func (o *CAN0_Type) SetMB30_D4(value uint8) {
	volatile.StoreUint8(&o.MB30_D4.Reg, value)
}
func (o *CAN0_Type) GetMB30_D4() uint8 {
	return volatile.LoadUint8(&o.MB30_D4.Reg)
}

// CAN0.MB30_D5: Mailbox Register
func (o *CAN0_Type) SetMB30_D5(value uint8) {
	volatile.StoreUint8(&o.MB30_D5.Reg, value)
}
func (o *CAN0_Type) GetMB30_D5() uint8 {
	return volatile.LoadUint8(&o.MB30_D5.Reg)
}

// CAN0.MB30_D6: Mailbox Register
func (o *CAN0_Type) SetMB30_D6(value uint8) {
	volatile.StoreUint8(&o.MB30_D6.Reg, value)
}
func (o *CAN0_Type) GetMB30_D6() uint8 {
	return volatile.LoadUint8(&o.MB30_D6.Reg)
}

// CAN0.MB30_D7: Mailbox Register
func (o *CAN0_Type) SetMB30_D7(value uint8) {
	volatile.StoreUint8(&o.MB30_D7.Reg, value)
}
func (o *CAN0_Type) GetMB30_D7() uint8 {
	return volatile.LoadUint8(&o.MB30_D7.Reg)
}

// CAN0.MB30_TS: Mailbox Register
func (o *CAN0_Type) SetMB30_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB30_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB30_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB30_TS.Reg, volatile.LoadUint16(&o.MB30_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB30_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB30_TS.Reg) & 0xff
}

// CAN0.MB31_ID: Mailbox Register
func (o *CAN0_Type) SetMB31_ID_IDE(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMB31_ID_IDE() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMB31_ID_RTR(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMB31_ID_RTR() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMB31_ID_Reserved(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMB31_ID_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMB31_ID_SID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMB31_ID_SID() uint32 {
	return (volatile.LoadUint32(&o.MB31_ID.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMB31_ID_EID(value uint32) {
	volatile.StoreUint32(&o.MB31_ID.Reg, volatile.LoadUint32(&o.MB31_ID.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMB31_ID_EID() uint32 {
	return volatile.LoadUint32(&o.MB31_ID.Reg) & 0x3ffff
}

// CAN0.MB31_DL: Mailbox Register
func (o *CAN0_Type) SetMB31_DL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xfff0)|value<<4)
}
func (o *CAN0_Type) GetMB31_DL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MB31_DL.Reg) & 0xfff0) >> 4
}
func (o *CAN0_Type) SetMB31_DL_DLC(value uint16) {
	volatile.StoreUint16(&o.MB31_DL.Reg, volatile.LoadUint16(&o.MB31_DL.Reg)&^(0xf)|value)
}
func (o *CAN0_Type) GetMB31_DL_DLC() uint16 {
	return volatile.LoadUint16(&o.MB31_DL.Reg) & 0xf
}

// CAN0.MB31_D0: Mailbox Register
func (o *CAN0_Type) SetMB31_D0(value uint8) {
	volatile.StoreUint8(&o.MB31_D0.Reg, value)
}
func (o *CAN0_Type) GetMB31_D0() uint8 {
	return volatile.LoadUint8(&o.MB31_D0.Reg)
}

// CAN0.MB31_D1: Mailbox Register
func (o *CAN0_Type) SetMB31_D1(value uint8) {
	volatile.StoreUint8(&o.MB31_D1.Reg, value)
}
func (o *CAN0_Type) GetMB31_D1() uint8 {
	return volatile.LoadUint8(&o.MB31_D1.Reg)
}

// CAN0.MB31_D2: Mailbox Register
func (o *CAN0_Type) SetMB31_D2(value uint8) {
	volatile.StoreUint8(&o.MB31_D2.Reg, value)
}
func (o *CAN0_Type) GetMB31_D2() uint8 {
	return volatile.LoadUint8(&o.MB31_D2.Reg)
}

// CAN0.MB31_D3: Mailbox Register
func (o *CAN0_Type) SetMB31_D3(value uint8) {
	volatile.StoreUint8(&o.MB31_D3.Reg, value)
}
func (o *CAN0_Type) GetMB31_D3() uint8 {
	return volatile.LoadUint8(&o.MB31_D3.Reg)
}

// CAN0.MB31_D4: Mailbox Register
func (o *CAN0_Type) SetMB31_D4(value uint8) {
	volatile.StoreUint8(&o.MB31_D4.Reg, value)
}
func (o *CAN0_Type) GetMB31_D4() uint8 {
	return volatile.LoadUint8(&o.MB31_D4.Reg)
}

// CAN0.MB31_D5: Mailbox Register
func (o *CAN0_Type) SetMB31_D5(value uint8) {
	volatile.StoreUint8(&o.MB31_D5.Reg, value)
}
func (o *CAN0_Type) GetMB31_D5() uint8 {
	return volatile.LoadUint8(&o.MB31_D5.Reg)
}

// CAN0.MB31_D6: Mailbox Register
func (o *CAN0_Type) SetMB31_D6(value uint8) {
	volatile.StoreUint8(&o.MB31_D6.Reg, value)
}
func (o *CAN0_Type) GetMB31_D6() uint8 {
	return volatile.LoadUint8(&o.MB31_D6.Reg)
}

// CAN0.MB31_D7: Mailbox Register
func (o *CAN0_Type) SetMB31_D7(value uint8) {
	volatile.StoreUint8(&o.MB31_D7.Reg, value)
}
func (o *CAN0_Type) GetMB31_D7() uint8 {
	return volatile.LoadUint8(&o.MB31_D7.Reg)
}

// CAN0.MB31_TS: Mailbox Register
func (o *CAN0_Type) SetMB31_TS_TSH(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff00)|value<<8)
}
func (o *CAN0_Type) GetMB31_TS_TSH() uint16 {
	return (volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff00) >> 8
}
func (o *CAN0_Type) SetMB31_TS_TSL(value uint16) {
	volatile.StoreUint16(&o.MB31_TS.Reg, volatile.LoadUint16(&o.MB31_TS.Reg)&^(0xff)|value)
}
func (o *CAN0_Type) GetMB31_TS_TSL() uint16 {
	return volatile.LoadUint16(&o.MB31_TS.Reg) & 0xff
}

// CAN0.MKR: Mask Register
func (o *CAN0_Type) SetMKR_Reserved(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0xe0000000)|value<<29)
}
func (o *CAN0_Type) GetMKR_Reserved(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0xe0000000) >> 29
}
func (o *CAN0_Type) SetMKR_SID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetMKR_SID(idx int) uint32 {
	return (volatile.LoadUint32(&o.MKR[idx].Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetMKR_EID(idx int, value uint32) {
	volatile.StoreUint32(&o.MKR[idx].Reg, volatile.LoadUint32(&o.MKR[idx].Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetMKR_EID(idx int) uint32 {
	return volatile.LoadUint32(&o.MKR[idx].Reg) & 0x3ffff
}

// CAN0.FIDCR0: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR0_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR0_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR0_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR0_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetFIDCR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetFIDCR0_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR0_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR0.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR0_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR0.Reg, volatile.LoadUint32(&o.FIDCR0.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR0_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR0.Reg) & 0x3ffff
}

// CAN0.FIDCR1: FIFO Received ID Compare Registers
func (o *CAN0_Type) SetFIDCR1_IDE(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetFIDCR1_IDE() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetFIDCR1_RTR(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetFIDCR1_RTR() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetFIDCR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetFIDCR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetFIDCR1_SID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x1ffc0000)|value<<18)
}
func (o *CAN0_Type) GetFIDCR1_SID() uint32 {
	return (volatile.LoadUint32(&o.FIDCR1.Reg) & 0x1ffc0000) >> 18
}
func (o *CAN0_Type) SetFIDCR1_EID(value uint32) {
	volatile.StoreUint32(&o.FIDCR1.Reg, volatile.LoadUint32(&o.FIDCR1.Reg)&^(0x3ffff)|value)
}
func (o *CAN0_Type) GetFIDCR1_EID() uint32 {
	return volatile.LoadUint32(&o.FIDCR1.Reg) & 0x3ffff
}

// CAN0.MKIVLR: Mask Invalid Register
func (o *CAN0_Type) SetMKIVLR_MB31(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMKIVLR_MB31() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMKIVLR_MB30(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMKIVLR_MB30() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMKIVLR_MB29(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMKIVLR_MB29() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMKIVLR_MB28(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMKIVLR_MB28() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMKIVLR_MB27(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMKIVLR_MB27() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMKIVLR_MB26(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMKIVLR_MB26() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMKIVLR_MB25(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMKIVLR_MB25() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMKIVLR_MB24(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMKIVLR_MB24() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMKIVLR_MB23(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMKIVLR_MB23() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMKIVLR_MB22(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMKIVLR_MB22() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMKIVLR_MB21(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMKIVLR_MB21() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMKIVLR_MB20(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMKIVLR_MB20() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMKIVLR_MB19(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMKIVLR_MB19() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMKIVLR_MB18(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMKIVLR_MB18() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMKIVLR_MB17(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMKIVLR_MB17() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMKIVLR_MB16(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMKIVLR_MB16() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMKIVLR_MB15(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMKIVLR_MB15() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMKIVLR_MB14(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMKIVLR_MB14() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMKIVLR_MB13(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMKIVLR_MB13() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMKIVLR_MB12(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMKIVLR_MB12() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMKIVLR_MB11(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMKIVLR_MB11() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMKIVLR_MB10(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMKIVLR_MB10() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMKIVLR_MB9(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMKIVLR_MB9() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMKIVLR_MB8(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMKIVLR_MB8() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMKIVLR_MB7(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMKIVLR_MB7() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMKIVLR_MB6(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMKIVLR_MB6() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMKIVLR_MB5(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMKIVLR_MB5() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMKIVLR_MB4(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMKIVLR_MB4() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMKIVLR_MB3(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMKIVLR_MB3() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMKIVLR_MB2(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMKIVLR_MB2() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMKIVLR_MB1(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMKIVLR_MB1() uint32 {
	return (volatile.LoadUint32(&o.MKIVLR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMKIVLR_MB0(value uint32) {
	volatile.StoreUint32(&o.MKIVLR.Reg, volatile.LoadUint32(&o.MKIVLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMKIVLR_MB0() uint32 {
	return volatile.LoadUint32(&o.MKIVLR.Reg) & 0x1
}

// CAN0.MIER: Mailbox Interrupt Enable Register (Normal mailbox mode)
func (o *CAN0_Type) SetMIER_MB31(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000000)|value<<31)
}
func (o *CAN0_Type) GetMIER_MB31() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000000) >> 31
}
func (o *CAN0_Type) SetMIER_MB30(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000000)|value<<30)
}
func (o *CAN0_Type) GetMIER_MB30() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000000) >> 30
}
func (o *CAN0_Type) SetMIER_MB29(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000000)|value<<29)
}
func (o *CAN0_Type) GetMIER_MB29() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000000) >> 29
}
func (o *CAN0_Type) SetMIER_MB28(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000000)|value<<28)
}
func (o *CAN0_Type) GetMIER_MB28() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000000) >> 28
}
func (o *CAN0_Type) SetMIER_MB27(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000000)|value<<27)
}
func (o *CAN0_Type) GetMIER_MB27() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000000) >> 27
}
func (o *CAN0_Type) SetMIER_MB26(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000000)|value<<26)
}
func (o *CAN0_Type) GetMIER_MB26() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000000) >> 26
}
func (o *CAN0_Type) SetMIER_MB25(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000000)|value<<25)
}
func (o *CAN0_Type) GetMIER_MB25() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000000) >> 25
}
func (o *CAN0_Type) SetMIER_MB24(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000000)|value<<24)
}
func (o *CAN0_Type) GetMIER_MB24() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000000) >> 24
}
func (o *CAN0_Type) SetMIER_MB23(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800000)|value<<23)
}
func (o *CAN0_Type) GetMIER_MB23() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800000) >> 23
}
func (o *CAN0_Type) SetMIER_MB22(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400000)|value<<22)
}
func (o *CAN0_Type) GetMIER_MB22() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400000) >> 22
}
func (o *CAN0_Type) SetMIER_MB21(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200000)|value<<21)
}
func (o *CAN0_Type) GetMIER_MB21() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200000) >> 21
}
func (o *CAN0_Type) SetMIER_MB20(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100000)|value<<20)
}
func (o *CAN0_Type) GetMIER_MB20() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100000) >> 20
}
func (o *CAN0_Type) SetMIER_MB19(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80000)|value<<19)
}
func (o *CAN0_Type) GetMIER_MB19() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80000) >> 19
}
func (o *CAN0_Type) SetMIER_MB18(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40000)|value<<18)
}
func (o *CAN0_Type) GetMIER_MB18() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40000) >> 18
}
func (o *CAN0_Type) SetMIER_MB17(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20000)|value<<17)
}
func (o *CAN0_Type) GetMIER_MB17() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20000) >> 17
}
func (o *CAN0_Type) SetMIER_MB16(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10000)|value<<16)
}
func (o *CAN0_Type) GetMIER_MB16() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10000) >> 16
}
func (o *CAN0_Type) SetMIER_MB15(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetMIER_MB15() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetMIER_MB14(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetMIER_MB14() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetMIER_MB13(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetMIER_MB13() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetMIER_MB12(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetMIER_MB12() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetMIER_MB11(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetMIER_MB11() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetMIER_MB10(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetMIER_MB10() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetMIER_MB9(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetMIER_MB9() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetMIER_MB8(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetMIER_MB8() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetMIER_MB7(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMIER_MB7() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMIER_MB6(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMIER_MB6() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMIER_MB5(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMIER_MB5() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMIER_MB4(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMIER_MB4() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMIER_MB3(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMIER_MB3() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMIER_MB2(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMIER_MB2() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMIER_MB1(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMIER_MB1() uint32 {
	return (volatile.LoadUint32(&o.MIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMIER_MB0(value uint32) {
	volatile.StoreUint32(&o.MIER.Reg, volatile.LoadUint32(&o.MIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMIER_MB0() uint32 {
	return volatile.LoadUint32(&o.MIER.Reg) & 0x1
}

// CAN0.MCTL_TX: Message Control Register(Transmit mode (when the TRMREQ bit is 1 and the RECREQ bit is 0))
func (o *CAN0_Type) SetMCTL_TX_TRMREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMCTL_TX_TRMREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMCTL_TX_RECREQ(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetMCTL_TX_RECREQ(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetMCTL_TX_Reserved(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetMCTL_TX_Reserved(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetMCTL_TX_ONESHOT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetMCTL_TX_ONESHOT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetMCTL_TX_Reserved(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetMCTL_TX_Reserved(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetMCTL_TX_TRMABT(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetMCTL_TX_TRMABT(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetMCTL_TX_TRMACTIVE(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetMCTL_TX_TRMACTIVE(idx int) uint8 {
	return (volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetMCTL_TX_SENTDATA(idx int, value uint8) {
	volatile.StoreUint8(&o.MCTL_TX[idx].Reg, volatile.LoadUint8(&o.MCTL_TX[idx].Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetMCTL_TX_SENTDATA(idx int) uint8 {
	return volatile.LoadUint8(&o.MCTL_TX[idx].Reg) & 0x1
}

// CAN0.CTLR: Control Register
func (o *CAN0_Type) SetCTLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc000)|value<<14)
}
func (o *CAN0_Type) GetCTLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc000) >> 14
}
func (o *CAN0_Type) SetCTLR_RBOC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetCTLR_RBOC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetCTLR_BOM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1800)|value<<11)
}
func (o *CAN0_Type) GetCTLR_BOM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x1800) >> 11
}
func (o *CAN0_Type) SetCTLR_SLPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetCTLR_SLPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetCTLR_CANM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x300)|value<<8)
}
func (o *CAN0_Type) GetCTLR_CANM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x300) >> 8
}
func (o *CAN0_Type) SetCTLR_TSPS(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0xc0)|value<<6)
}
func (o *CAN0_Type) GetCTLR_TSPS() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0xc0) >> 6
}
func (o *CAN0_Type) SetCTLR_TSRC(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetCTLR_TSRC() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetCTLR_TPM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetCTLR_TPM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetCTLR_MLM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetCTLR_MLM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetCTLR_IDFM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetCTLR_IDFM() uint16 {
	return (volatile.LoadUint16(&o.CTLR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetCTLR_MBM(value uint16) {
	volatile.StoreUint16(&o.CTLR.Reg, volatile.LoadUint16(&o.CTLR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetCTLR_MBM() uint16 {
	return volatile.LoadUint16(&o.CTLR.Reg) & 0x1
}

// CAN0.STR: Status Register
func (o *CAN0_Type) SetSTR_Reserved(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8000)|value<<15)
}
func (o *CAN0_Type) GetSTR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8000) >> 15
}
func (o *CAN0_Type) SetSTR_RECST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4000)|value<<14)
}
func (o *CAN0_Type) GetSTR_RECST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4000) >> 14
}
func (o *CAN0_Type) SetSTR_TRMST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2000)|value<<13)
}
func (o *CAN0_Type) GetSTR_TRMST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2000) >> 13
}
func (o *CAN0_Type) SetSTR_BOST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1000)|value<<12)
}
func (o *CAN0_Type) GetSTR_BOST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x1000) >> 12
}
func (o *CAN0_Type) SetSTR_EPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetSTR_EPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetSTR_SLPST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x400)|value<<10)
}
func (o *CAN0_Type) GetSTR_SLPST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x400) >> 10
}
func (o *CAN0_Type) SetSTR_HLTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x200)|value<<9)
}
func (o *CAN0_Type) GetSTR_HLTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x200) >> 9
}
func (o *CAN0_Type) SetSTR_RSTST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x100)|value<<8)
}
func (o *CAN0_Type) GetSTR_RSTST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x100) >> 8
}
func (o *CAN0_Type) SetSTR_EST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetSTR_EST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetSTR_TABST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetSTR_TABST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetSTR_FMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetSTR_FMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetSTR_NMLST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetSTR_NMLST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetSTR_TFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetSTR_TFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetSTR_RFST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetSTR_RFST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetSTR_SDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetSTR_SDST() uint16 {
	return (volatile.LoadUint16(&o.STR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetSTR_NDST(value uint16) {
	volatile.StoreUint16(&o.STR.Reg, volatile.LoadUint16(&o.STR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetSTR_NDST() uint16 {
	return volatile.LoadUint16(&o.STR.Reg) & 0x1
}

// CAN0.BCR: Bit Configuration Register
func (o *CAN0_Type) SetBCR_TSEG1(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xf0000000)|value<<28)
}
func (o *CAN0_Type) GetBCR_TSEG1() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xf0000000) >> 28
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xc000000)|value<<26)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xc000000) >> 26
}
func (o *CAN0_Type) SetBCR_BRP(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3ff0000)|value<<16)
}
func (o *CAN0_Type) GetBCR_BRP() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3ff0000) >> 16
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xc000)|value<<14)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xc000) >> 14
}
func (o *CAN0_Type) SetBCR_SJW(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x3000)|value<<12)
}
func (o *CAN0_Type) GetBCR_SJW() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x3000) >> 12
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x800)|value<<11)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x800) >> 11
}
func (o *CAN0_Type) SetBCR_TSEG2(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x700)|value<<8)
}
func (o *CAN0_Type) GetBCR_TSEG2() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0x700) >> 8
}
func (o *CAN0_Type) SetBCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0xfe)|value<<1)
}
func (o *CAN0_Type) GetBCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.BCR.Reg) & 0xfe) >> 1
}
func (o *CAN0_Type) SetBCR_CCLKS(value uint32) {
	volatile.StoreUint32(&o.BCR.Reg, volatile.LoadUint32(&o.BCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetBCR_CCLKS() uint32 {
	return volatile.LoadUint32(&o.BCR.Reg) & 0x1
}

// CAN0.RFCR: Receive FIFO Control Register
func (o *CAN0_Type) SetRFCR_RFEST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetRFCR_RFEST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetRFCR_RFWST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetRFCR_RFWST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetRFCR_RFFST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetRFCR_RFFST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetRFCR_RFMLF(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetRFCR_RFMLF() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetRFCR_RFUST(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetRFCR_RFUST() uint8 {
	return (volatile.LoadUint8(&o.RFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetRFCR_RFE(value uint8) {
	volatile.StoreUint8(&o.RFCR.Reg, volatile.LoadUint8(&o.RFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetRFCR_RFE() uint8 {
	return volatile.LoadUint8(&o.RFCR.Reg) & 0x1
}

// CAN0.RFPCR: Receive FIFO Pointer Control Register
func (o *CAN0_Type) SetRFPCR(value uint8) {
	volatile.StoreUint8(&o.RFPCR.Reg, value)
}
func (o *CAN0_Type) GetRFPCR() uint8 {
	return volatile.LoadUint8(&o.RFPCR.Reg)
}

// CAN0.TFCR: Transmit FIFO Control Register
func (o *CAN0_Type) SetTFCR_TFEST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetTFCR_TFEST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetTFCR_TFFST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetTFCR_TFFST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetTFCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x30)|value<<4)
}
func (o *CAN0_Type) GetTFCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0x30) >> 4
}
func (o *CAN0_Type) SetTFCR_TFUST(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0xe)|value<<1)
}
func (o *CAN0_Type) GetTFCR_TFUST() uint8 {
	return (volatile.LoadUint8(&o.TFCR.Reg) & 0xe) >> 1
}
func (o *CAN0_Type) SetTFCR_TFE(value uint8) {
	volatile.StoreUint8(&o.TFCR.Reg, volatile.LoadUint8(&o.TFCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTFCR_TFE() uint8 {
	return volatile.LoadUint8(&o.TFCR.Reg) & 0x1
}

// CAN0.TFPCR: Transmit FIFO Pointer Control Register
func (o *CAN0_Type) SetTFPCR(value uint8) {
	volatile.StoreUint8(&o.TFPCR.Reg, value)
}
func (o *CAN0_Type) GetTFPCR() uint8 {
	return volatile.LoadUint8(&o.TFPCR.Reg)
}

// CAN0.EIER: Error Interrupt Enable Register
func (o *CAN0_Type) SetEIER_BLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIER_BLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIER_OLIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIER_OLIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIER_ORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIER_ORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIER_BORIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIER_BORIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIER_BOEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIER_BOEIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIER_EPIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIER_EPIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIER_EWIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIER_EWIE() uint8 {
	return (volatile.LoadUint8(&o.EIER.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIER_BEIE(value uint8) {
	volatile.StoreUint8(&o.EIER.Reg, volatile.LoadUint8(&o.EIER.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIER_BEIE() uint8 {
	return volatile.LoadUint8(&o.EIER.Reg) & 0x1
}

// CAN0.EIFR: Error Interrupt Factor Judge Register
func (o *CAN0_Type) SetEIFR_BLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetEIFR_BLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetEIFR_OLIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetEIFR_OLIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetEIFR_ORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetEIFR_ORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetEIFR_BORIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetEIFR_BORIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetEIFR_BOEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetEIFR_BOEIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetEIFR_EPIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetEIFR_EPIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetEIFR_EWIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetEIFR_EWIF() uint8 {
	return (volatile.LoadUint8(&o.EIFR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetEIFR_BEIF(value uint8) {
	volatile.StoreUint8(&o.EIFR.Reg, volatile.LoadUint8(&o.EIFR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetEIFR_BEIF() uint8 {
	return volatile.LoadUint8(&o.EIFR.Reg) & 0x1
}

// CAN0.RECR: Receive Error Count Register
func (o *CAN0_Type) SetRECR(value uint8) {
	volatile.StoreUint8(&o.RECR.Reg, value)
}
func (o *CAN0_Type) GetRECR() uint8 {
	return volatile.LoadUint8(&o.RECR.Reg)
}

// CAN0.TECR: Transmit Error Count Register
func (o *CAN0_Type) SetTECR(value uint8) {
	volatile.StoreUint8(&o.TECR.Reg, value)
}
func (o *CAN0_Type) GetTECR() uint8 {
	return volatile.LoadUint8(&o.TECR.Reg)
}

// CAN0.ECSR: Error Code Store Register
func (o *CAN0_Type) SetECSR_EDPM(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetECSR_EDPM() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetECSR_ADEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x40)|value<<6)
}
func (o *CAN0_Type) GetECSR_ADEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x40) >> 6
}
func (o *CAN0_Type) SetECSR_BE0F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x20)|value<<5)
}
func (o *CAN0_Type) GetECSR_BE0F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x20) >> 5
}
func (o *CAN0_Type) SetECSR_BE1F(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x10)|value<<4)
}
func (o *CAN0_Type) GetECSR_BE1F() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x10) >> 4
}
func (o *CAN0_Type) SetECSR_CEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x8)|value<<3)
}
func (o *CAN0_Type) GetECSR_CEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x8) >> 3
}
func (o *CAN0_Type) SetECSR_AEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x4)|value<<2)
}
func (o *CAN0_Type) GetECSR_AEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x4) >> 2
}
func (o *CAN0_Type) SetECSR_FEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x2)|value<<1)
}
func (o *CAN0_Type) GetECSR_FEF() uint8 {
	return (volatile.LoadUint8(&o.ECSR.Reg) & 0x2) >> 1
}
func (o *CAN0_Type) SetECSR_SEF(value uint8) {
	volatile.StoreUint8(&o.ECSR.Reg, volatile.LoadUint8(&o.ECSR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetECSR_SEF() uint8 {
	return volatile.LoadUint8(&o.ECSR.Reg) & 0x1
}

// CAN0.CSSR: Channel Search Support Register
func (o *CAN0_Type) SetCSSR(value uint8) {
	volatile.StoreUint8(&o.CSSR.Reg, value)
}
func (o *CAN0_Type) GetCSSR() uint8 {
	return volatile.LoadUint8(&o.CSSR.Reg)
}

// CAN0.MSSR: Mailbox Search Status Register
func (o *CAN0_Type) SetMSSR_SEST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x80)|value<<7)
}
func (o *CAN0_Type) GetMSSR_SEST() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x80) >> 7
}
func (o *CAN0_Type) SetMSSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x60)|value<<5)
}
func (o *CAN0_Type) GetMSSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MSSR.Reg) & 0x60) >> 5
}
func (o *CAN0_Type) SetMSSR_MBNST(value uint8) {
	volatile.StoreUint8(&o.MSSR.Reg, volatile.LoadUint8(&o.MSSR.Reg)&^(0x1f)|value)
}
func (o *CAN0_Type) GetMSSR_MBNST() uint8 {
	return volatile.LoadUint8(&o.MSSR.Reg) & 0x1f
}

// CAN0.MSMR: Mailbox Search Mode Register
func (o *CAN0_Type) SetMSMR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0xfc)|value<<2)
}
func (o *CAN0_Type) GetMSMR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MSMR.Reg) & 0xfc) >> 2
}
func (o *CAN0_Type) SetMSMR_MBSM(value uint8) {
	volatile.StoreUint8(&o.MSMR.Reg, volatile.LoadUint8(&o.MSMR.Reg)&^(0x3)|value)
}
func (o *CAN0_Type) GetMSMR_MBSM() uint8 {
	return volatile.LoadUint8(&o.MSMR.Reg) & 0x3
}

// CAN0.TSR: Time Stamp Register
func (o *CAN0_Type) SetTSR(value uint16) {
	volatile.StoreUint16(&o.TSR.Reg, value)
}
func (o *CAN0_Type) GetTSR() uint16 {
	return volatile.LoadUint16(&o.TSR.Reg)
}

// CAN0.AFSR: Acceptance Filter Support Register
func (o *CAN0_Type) SetAFSR(value uint16) {
	volatile.StoreUint16(&o.AFSR.Reg, value)
}
func (o *CAN0_Type) GetAFSR() uint16 {
	return volatile.LoadUint16(&o.AFSR.Reg)
}

// CAN0.TCR: Test Control Register
func (o *CAN0_Type) SetTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0xf8)|value<<3)
}
func (o *CAN0_Type) GetTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0xf8) >> 3
}
func (o *CAN0_Type) SetTCR_TSTM(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x6)|value<<1)
}
func (o *CAN0_Type) GetTCR_TSTM() uint8 {
	return (volatile.LoadUint8(&o.TCR.Reg) & 0x6) >> 1
}
func (o *CAN0_Type) SetTCR_TSTE(value uint8) {
	volatile.StoreUint8(&o.TCR.Reg, volatile.LoadUint8(&o.TCR.Reg)&^(0x1)|value)
}
func (o *CAN0_Type) GetTCR_TSTE() uint8 {
	return volatile.LoadUint8(&o.TCR.Reg) & 0x1
}

// Inter-Integrated Circuit 0
type IIC0_Type struct {
	ICCR1  volatile.Register8 // 0x0
	ICCR2  volatile.Register8 // 0x1
	ICMR1  volatile.Register8 // 0x2
	ICMR2  volatile.Register8 // 0x3
	ICMR3  volatile.Register8 // 0x4
	ICFER  volatile.Register8 // 0x5
	ICSER  volatile.Register8 // 0x6
	ICIER  volatile.Register8 // 0x7
	ICSR1  volatile.Register8 // 0x8
	ICSR2  volatile.Register8 // 0x9
	SARL0  volatile.Register8 // 0xA
	SARU0  volatile.Register8 // 0xB
	SARL1  volatile.Register8 // 0xC
	SARU1  volatile.Register8 // 0xD
	SARL2  volatile.Register8 // 0xE
	SARU2  volatile.Register8 // 0xF
	ICBRL  volatile.Register8 // 0x10
	ICBRH  volatile.Register8 // 0x11
	ICDRT  volatile.Register8 // 0x12
	ICDRR  volatile.Register8 // 0x13
	_      [2]byte
	ICWUR  volatile.Register8 // 0x16
	ICWUR2 volatile.Register8 // 0x17
}

// IIC0.ICCR1: I2C Bus Control Register 1
func (o *IIC0_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC0.ICCR2: I2C Bus Control Register 2
func (o *IIC0_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICCR2_Reserved() uint8 {
	return volatile.LoadUint8(&o.ICCR2.Reg) & 0x1
}

// IIC0.ICMR1: I2C Bus Mode Register 1
func (o *IIC0_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC0_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC0.ICMR2: I2C Bus Mode Register 2
func (o *IIC0_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC0_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC0_Type) SetICMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC0.ICMR3: I2C Bus Mode Register 3
func (o *IIC0_Type) SetICMR3_SMBS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICMR3_SMBS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC0_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC0.ICFER: I2C Bus Function Enable Register
func (o *IIC0_Type) SetICFER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICFER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC0.ICSER: I2C Bus Status Enable Register
func (o *IIC0_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC0.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC0_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC0.ICSR1: I2C Bus Status Register 1
func (o *IIC0_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC0.ICSR2: I2C Bus Status Register 2
func (o *IIC0_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC0_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC0_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC0.SARL0: Slave Address Register L%s
func (o *IIC0_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC0_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC0.SARU0: Slave Address Register U%s
func (o *IIC0_Type) SetSARU0_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC0.SARL1: Slave Address Register L%s
func (o *IIC0_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC0_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC0.SARU1: Slave Address Register U%s
func (o *IIC0_Type) SetSARU1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC0.SARL2: Slave Address Register L%s
func (o *IIC0_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC0_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC0.SARU2: Slave Address Register U%s
func (o *IIC0_Type) SetSARU2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetSARU2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC0.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC0_Type) SetICBRL_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0xe0)|value<<5)
}
func (o *IIC0_Type) GetICBRL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRL.Reg) & 0xe0) >> 5
}
func (o *IIC0_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC0.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC0_Type) SetICBRH_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0xe0)|value<<5)
}
func (o *IIC0_Type) GetICBRH_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRH.Reg) & 0xe0) >> 5
}
func (o *IIC0_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC0_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC0.ICDRT: I2C Bus Transmit Data Register
func (o *IIC0_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC0_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC0.ICDRR: I2C Bus Receive Data Register
func (o *IIC0_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC0_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// IIC0.ICWUR: I2C Bus Wake Up Unit Register
func (o *IIC0_Type) SetICWUR_WUE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x80)|value<<7)
}
func (o *IIC0_Type) GetICWUR_WUE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x80) >> 7
}
func (o *IIC0_Type) SetICWUR_WUIE(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x40)|value<<6)
}
func (o *IIC0_Type) GetICWUR_WUIE() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x40) >> 6
}
func (o *IIC0_Type) SetICWUR_WUF(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x20)|value<<5)
}
func (o *IIC0_Type) GetICWUR_WUF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x20) >> 5
}
func (o *IIC0_Type) SetICWUR_WUACK(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x10)|value<<4)
}
func (o *IIC0_Type) GetICWUR_WUACK() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0x10) >> 4
}
func (o *IIC0_Type) SetICWUR_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0xe)|value<<1)
}
func (o *IIC0_Type) GetICWUR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICWUR.Reg) & 0xe) >> 1
}
func (o *IIC0_Type) SetICWUR_WUAFA(value uint8) {
	volatile.StoreUint8(&o.ICWUR.Reg, volatile.LoadUint8(&o.ICWUR.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR_WUAFA() uint8 {
	return volatile.LoadUint8(&o.ICWUR.Reg) & 0x1
}

// IIC0.ICWUR2: Reserved
func (o *IIC0_Type) SetICWUR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC0_Type) GetICWUR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0xf8) >> 3
}
func (o *IIC0_Type) SetICWUR2_WUSYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC0_Type) GetICWUR2_WUSYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x4) >> 2
}
func (o *IIC0_Type) SetICWUR2_WUASYF(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC0_Type) GetICWUR2_WUASYF() uint8 {
	return (volatile.LoadUint8(&o.ICWUR2.Reg) & 0x2) >> 1
}
func (o *IIC0_Type) SetICWUR2_WUSEN(value uint8) {
	volatile.StoreUint8(&o.ICWUR2.Reg, volatile.LoadUint8(&o.ICWUR2.Reg)&^(0x1)|value)
}
func (o *IIC0_Type) GetICWUR2_WUSEN() uint8 {
	return volatile.LoadUint8(&o.ICWUR2.Reg) & 0x1
}

// Inter-Integrated Circuit 1
type IIC1_Type struct {
	ICCR1 volatile.Register8 // 0x0
	ICCR2 volatile.Register8 // 0x1
	ICMR1 volatile.Register8 // 0x2
	ICMR2 volatile.Register8 // 0x3
	ICMR3 volatile.Register8 // 0x4
	ICFER volatile.Register8 // 0x5
	ICSER volatile.Register8 // 0x6
	ICIER volatile.Register8 // 0x7
	ICSR1 volatile.Register8 // 0x8
	ICSR2 volatile.Register8 // 0x9
	SARL0 volatile.Register8 // 0xA
	SARU0 volatile.Register8 // 0xB
	SARL1 volatile.Register8 // 0xC
	SARU1 volatile.Register8 // 0xD
	SARL2 volatile.Register8 // 0xE
	SARU2 volatile.Register8 // 0xF
	ICBRL volatile.Register8 // 0x10
	ICBRH volatile.Register8 // 0x11
	ICDRT volatile.Register8 // 0x12
	ICDRR volatile.Register8 // 0x13
}

// IIC1.ICCR1: I2C Bus Control Register 1
func (o *IIC1_Type) SetICCR1_ICE(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR1_ICE() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR1_IICRST(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR1_IICRST() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR1_CLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR1_CLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR1_SOWP(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICCR1_SOWP() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICCR1_SCLO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR1_SCLO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR1_SDAO(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR1_SDAO() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR1_SCLI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR1_SCLI() uint8 {
	return (volatile.LoadUint8(&o.ICCR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICCR1_SDAI(value uint8) {
	volatile.StoreUint8(&o.ICCR1.Reg, volatile.LoadUint8(&o.ICCR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICCR1_SDAI() uint8 {
	return volatile.LoadUint8(&o.ICCR1.Reg) & 0x1
}

// IIC1.ICCR2: I2C Bus Control Register 2
func (o *IIC1_Type) SetICCR2_BBSY(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICCR2_BBSY() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICCR2_MST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICCR2_MST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICCR2_TRS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICCR2_TRS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICCR2_SP(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICCR2_SP() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICCR2_RS(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICCR2_RS() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICCR2_ST(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICCR2_ST() uint8 {
	return (volatile.LoadUint8(&o.ICCR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICCR2.Reg, volatile.LoadUint8(&o.ICCR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICCR2_Reserved() uint8 {
	return volatile.LoadUint8(&o.ICCR2.Reg) & 0x1
}

// IIC1.ICMR1: I2C Bus Mode Register 1
func (o *IIC1_Type) SetICMR1_MTWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR1_MTWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR1_CKS(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR1_CKS() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR1_BCWP(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR1_BCWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR1_BC(value uint8) {
	volatile.StoreUint8(&o.ICMR1.Reg, volatile.LoadUint8(&o.ICMR1.Reg)&^(0x7)|value)
}
func (o *IIC1_Type) GetICMR1_BC() uint8 {
	return volatile.LoadUint8(&o.ICMR1.Reg) & 0x7
}

// IIC1.ICMR2: I2C Bus Mode Register 2
func (o *IIC1_Type) SetICMR2_DLCS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR2_DLCS() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR2_SDDL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x70)|value<<4)
}
func (o *IIC1_Type) GetICMR2_SDDL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x70) >> 4
}
func (o *IIC1_Type) SetICMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR2_TMOH(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR2_TMOH() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR2_TMOL(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICMR2_TMOL() uint8 {
	return (volatile.LoadUint8(&o.ICMR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICMR2_TMOS(value uint8) {
	volatile.StoreUint8(&o.ICMR2.Reg, volatile.LoadUint8(&o.ICMR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICMR2_TMOS() uint8 {
	return volatile.LoadUint8(&o.ICMR2.Reg) & 0x1
}

// IIC1.ICMR3: I2C Bus Mode Register 3
func (o *IIC1_Type) SetICMR3_SMBE(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICMR3_SMBE() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICMR3_WAIT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICMR3_WAIT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICMR3_RDRFS(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICMR3_RDRFS() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICMR3_ACKWP(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICMR3_ACKWP() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICMR3_ACKBT(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICMR3_ACKBT() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICMR3_ACKBR(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICMR3_ACKBR() uint8 {
	return (volatile.LoadUint8(&o.ICMR3.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICMR3_NF(value uint8) {
	volatile.StoreUint8(&o.ICMR3.Reg, volatile.LoadUint8(&o.ICMR3.Reg)&^(0x3)|value)
}
func (o *IIC1_Type) GetICMR3_NF() uint8 {
	return volatile.LoadUint8(&o.ICMR3.Reg) & 0x3
}

// IIC1.ICFER: I2C Bus Function Enable Register
func (o *IIC1_Type) SetICFER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICFER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICFER_SCLE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICFER_SCLE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICFER_NFE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICFER_NFE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICFER_NACKE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICFER_NACKE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICFER_SALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICFER_SALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICFER_NALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICFER_NALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICFER_MALE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICFER_MALE() uint8 {
	return (volatile.LoadUint8(&o.ICFER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICFER_TMOE(value uint8) {
	volatile.StoreUint8(&o.ICFER.Reg, volatile.LoadUint8(&o.ICFER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICFER_TMOE() uint8 {
	return volatile.LoadUint8(&o.ICFER.Reg) & 0x1
}

// IIC1.ICSER: I2C Bus Status Enable Register
func (o *IIC1_Type) SetICSER_HOAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSER_HOAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSER_DIDE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSER_DIDE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSER_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSER_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSER_GCAE(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSER_GCAE() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSER_SAR2E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSER_SAR2E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSER_SAR1E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSER_SAR1E() uint8 {
	return (volatile.LoadUint8(&o.ICSER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSER_SAR0E(value uint8) {
	volatile.StoreUint8(&o.ICSER.Reg, volatile.LoadUint8(&o.ICSER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSER_SAR0E() uint8 {
	return volatile.LoadUint8(&o.ICSER.Reg) & 0x1
}

// IIC1.ICIER: I2C Bus Interrupt Enable Register
func (o *IIC1_Type) SetICIER_TIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICIER_TIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICIER_TEIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICIER_TEIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICIER_RIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICIER_RIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICIER_NAKIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICIER_NAKIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICIER_SPIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICIER_SPIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICIER_STIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICIER_STIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICIER_ALIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICIER_ALIE() uint8 {
	return (volatile.LoadUint8(&o.ICIER.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICIER_TMOIE(value uint8) {
	volatile.StoreUint8(&o.ICIER.Reg, volatile.LoadUint8(&o.ICIER.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICIER_TMOIE() uint8 {
	return volatile.LoadUint8(&o.ICIER.Reg) & 0x1
}

// IIC1.ICSR1: I2C Bus Status Register 1
func (o *IIC1_Type) SetICSR1_HOA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR1_HOA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSR1_DID(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR1_DID() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSR1_GCA(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR1_GCA() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR1_AAS2(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR1_AAS2() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR1_AAS1(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR1_AAS1() uint8 {
	return (volatile.LoadUint8(&o.ICSR1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR1_AAS0(value uint8) {
	volatile.StoreUint8(&o.ICSR1.Reg, volatile.LoadUint8(&o.ICSR1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR1_AAS0() uint8 {
	return volatile.LoadUint8(&o.ICSR1.Reg) & 0x1
}

// IIC1.ICSR2: I2C Bus Status Register 2
func (o *IIC1_Type) SetICSR2_TDRE(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x80)|value<<7)
}
func (o *IIC1_Type) GetICSR2_TDRE() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x80) >> 7
}
func (o *IIC1_Type) SetICSR2_TEND(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x40)|value<<6)
}
func (o *IIC1_Type) GetICSR2_TEND() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x40) >> 6
}
func (o *IIC1_Type) SetICSR2_RDRF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x20)|value<<5)
}
func (o *IIC1_Type) GetICSR2_RDRF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x20) >> 5
}
func (o *IIC1_Type) SetICSR2_NACKF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x10)|value<<4)
}
func (o *IIC1_Type) GetICSR2_NACKF() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x10) >> 4
}
func (o *IIC1_Type) SetICSR2_STOP(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x8)|value<<3)
}
func (o *IIC1_Type) GetICSR2_STOP() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x8) >> 3
}
func (o *IIC1_Type) SetICSR2_START(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetICSR2_START() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetICSR2_AL(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetICSR2_AL() uint8 {
	return (volatile.LoadUint8(&o.ICSR2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetICSR2_TMOF(value uint8) {
	volatile.StoreUint8(&o.ICSR2.Reg, volatile.LoadUint8(&o.ICSR2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetICSR2_TMOF() uint8 {
	return volatile.LoadUint8(&o.ICSR2.Reg) & 0x1
}

// IIC1.SARL0: Slave Address Register L%s
func (o *IIC1_Type) SetSARL0(value uint8) {
	volatile.StoreUint8(&o.SARL0.Reg, value)
}
func (o *IIC1_Type) GetSARL0() uint8 {
	return volatile.LoadUint8(&o.SARL0.Reg)
}

// IIC1.SARU0: Slave Address Register U%s
func (o *IIC1_Type) SetSARU0_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU0_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU0_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU0_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU0_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU0.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU0_FS(value uint8) {
	volatile.StoreUint8(&o.SARU0.Reg, volatile.LoadUint8(&o.SARU0.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU0_FS() uint8 {
	return volatile.LoadUint8(&o.SARU0.Reg) & 0x1
}

// IIC1.SARL1: Slave Address Register L%s
func (o *IIC1_Type) SetSARL1(value uint8) {
	volatile.StoreUint8(&o.SARL1.Reg, value)
}
func (o *IIC1_Type) GetSARL1() uint8 {
	return volatile.LoadUint8(&o.SARL1.Reg)
}

// IIC1.SARU1: Slave Address Register U%s
func (o *IIC1_Type) SetSARU1_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU1_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU1_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU1_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU1_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU1.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU1_FS(value uint8) {
	volatile.StoreUint8(&o.SARU1.Reg, volatile.LoadUint8(&o.SARU1.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU1_FS() uint8 {
	return volatile.LoadUint8(&o.SARU1.Reg) & 0x1
}

// IIC1.SARL2: Slave Address Register L%s
func (o *IIC1_Type) SetSARL2(value uint8) {
	volatile.StoreUint8(&o.SARL2.Reg, value)
}
func (o *IIC1_Type) GetSARL2() uint8 {
	return volatile.LoadUint8(&o.SARL2.Reg)
}

// IIC1.SARU2: Slave Address Register U%s
func (o *IIC1_Type) SetSARU2_Reserved(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0xf8)|value<<3)
}
func (o *IIC1_Type) GetSARU2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0xf8) >> 3
}
func (o *IIC1_Type) SetSARU2_SVA9(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x4)|value<<2)
}
func (o *IIC1_Type) GetSARU2_SVA9() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x4) >> 2
}
func (o *IIC1_Type) SetSARU2_SVA8(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x2)|value<<1)
}
func (o *IIC1_Type) GetSARU2_SVA8() uint8 {
	return (volatile.LoadUint8(&o.SARU2.Reg) & 0x2) >> 1
}
func (o *IIC1_Type) SetSARU2_FS(value uint8) {
	volatile.StoreUint8(&o.SARU2.Reg, volatile.LoadUint8(&o.SARU2.Reg)&^(0x1)|value)
}
func (o *IIC1_Type) GetSARU2_FS() uint8 {
	return volatile.LoadUint8(&o.SARU2.Reg) & 0x1
}

// IIC1.ICBRL: I2C Bus Bit Rate Low-Level Register
func (o *IIC1_Type) SetICBRL_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0xe0)|value<<5)
}
func (o *IIC1_Type) GetICBRL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRL.Reg) & 0xe0) >> 5
}
func (o *IIC1_Type) SetICBRL_BRL(value uint8) {
	volatile.StoreUint8(&o.ICBRL.Reg, volatile.LoadUint8(&o.ICBRL.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRL_BRL() uint8 {
	return volatile.LoadUint8(&o.ICBRL.Reg) & 0x1f
}

// IIC1.ICBRH: I2C Bus Bit Rate High-Level Register
func (o *IIC1_Type) SetICBRH_Reserved(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0xe0)|value<<5)
}
func (o *IIC1_Type) GetICBRH_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ICBRH.Reg) & 0xe0) >> 5
}
func (o *IIC1_Type) SetICBRH_BRH(value uint8) {
	volatile.StoreUint8(&o.ICBRH.Reg, volatile.LoadUint8(&o.ICBRH.Reg)&^(0x1f)|value)
}
func (o *IIC1_Type) GetICBRH_BRH() uint8 {
	return volatile.LoadUint8(&o.ICBRH.Reg) & 0x1f
}

// IIC1.ICDRT: I2C Bus Transmit Data Register
func (o *IIC1_Type) SetICDRT(value uint8) {
	volatile.StoreUint8(&o.ICDRT.Reg, value)
}
func (o *IIC1_Type) GetICDRT() uint8 {
	return volatile.LoadUint8(&o.ICDRT.Reg)
}

// IIC1.ICDRR: I2C Bus Receive Data Register
func (o *IIC1_Type) SetICDRR(value uint8) {
	volatile.StoreUint8(&o.ICDRR.Reg, value)
}
func (o *IIC1_Type) GetICDRR() uint8 {
	return volatile.LoadUint8(&o.ICDRR.Reg)
}

// Memory Mirror Function
type MMF_Type struct {
	MMSFR volatile.Register32 // 0x0
	MMEN  volatile.Register32 // 0x4
}

// MMF.MMSFR: MemMirror Special Function Register
func (o *MMF_Type) SetMMSFR_KEY(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMSFR_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMSFR_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x800000)|value<<23)
}
func (o *MMF_Type) GetMMSFR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0x800000) >> 23
}
func (o *MMF_Type) SetMMSFR_MEMMIRADDR(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x7fff80)|value<<7)
}
func (o *MMF_Type) GetMMSFR_MEMMIRADDR() uint32 {
	return (volatile.LoadUint32(&o.MMSFR.Reg) & 0x7fff80) >> 7
}
func (o *MMF_Type) SetMMSFR_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMSFR.Reg, volatile.LoadUint32(&o.MMSFR.Reg)&^(0x7f)|value)
}
func (o *MMF_Type) GetMMSFR_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMSFR.Reg) & 0x7f
}

// MMF.MMEN: MemMirror Enable Register
func (o *MMF_Type) SetMMEN_KEY(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0xff000000)|value<<24)
}
func (o *MMF_Type) GetMMEN_KEY() uint32 {
	return (volatile.LoadUint32(&o.MMEN.Reg) & 0xff000000) >> 24
}
func (o *MMF_Type) SetMMEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0xfffffe)|value<<1)
}
func (o *MMF_Type) GetMMEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MMEN.Reg) & 0xfffffe) >> 1
}
func (o *MMF_Type) SetMMEN_EN(value uint32) {
	volatile.StoreUint32(&o.MMEN.Reg, volatile.LoadUint32(&o.MMEN.Reg)&^(0x1)|value)
}
func (o *MMF_Type) GetMMEN_EN() uint32 {
	return volatile.LoadUint32(&o.MMEN.Reg) & 0x1
}

// Bus Master MPU
type MMPU_Type struct {
	MMPUCTLA volatile.Register16 // 0x0
	_        [256]byte
	MMPUPTA  volatile.Register16 // 0x102
	_        [252]byte
	MMPUACA0 volatile.Register16 // 0x200
	_        [2]byte
	MMPUSA0  volatile.Register32 // 0x204
	MMPUEA0  volatile.Register32 // 0x208
	_        [4]byte
	MMPUACA1 volatile.Register16 // 0x210
	_        [2]byte
	MMPUSA1  volatile.Register32 // 0x214
	MMPUEA1  volatile.Register32 // 0x218
	_        [4]byte
	MMPUACA2 volatile.Register16 // 0x220
	_        [2]byte
	MMPUSA2  volatile.Register32 // 0x224
	MMPUEA2  volatile.Register32 // 0x228
	_        [4]byte
	MMPUACA3 volatile.Register16 // 0x230
	_        [2]byte
	MMPUSA3  volatile.Register32 // 0x234
	MMPUEA3  volatile.Register32 // 0x238
}

// MMPU.MMPUCTLA: Bus Master MPU Control Register
func (o *MMPU_Type) SetMMPUCTLA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUCTLA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUCTLA_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0xfc)|value<<2)
}
func (o *MMPU_Type) GetMMPUCTLA_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0xfc) >> 2
}
func (o *MMPU_Type) SetMMPUCTLA_OAD(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUCTLA_OAD() uint16 {
	return (volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUCTLA_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUCTLA.Reg, volatile.LoadUint16(&o.MMPUCTLA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUCTLA_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUCTLA.Reg) & 0x1
}

// MMPU.MMPUPTA: Group A Protection of Register
func (o *MMPU_Type) SetMMPUPTA_KEY(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xff00)|value<<8)
}
func (o *MMPU_Type) GetMMPUPTA_KEY() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xff00) >> 8
}
func (o *MMPU_Type) SetMMPUPTA_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0xfe)|value<<1)
}
func (o *MMPU_Type) GetMMPUPTA_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUPTA.Reg) & 0xfe) >> 1
}
func (o *MMPU_Type) SetMMPUPTA_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MMPUPTA.Reg, volatile.LoadUint16(&o.MMPUPTA.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUPTA_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MMPUPTA.Reg) & 0x1
}

// MMPU.MMPUACA0: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA0_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA0_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA0_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA0_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA0_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA0_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA0.Reg, volatile.LoadUint16(&o.MMPUACA0.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA0_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA0.Reg) & 0x1
}

// MMPU.MMPUSA0: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA0(value uint32) {
	volatile.StoreUint32(&o.MMPUSA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA0() uint32 {
	return volatile.LoadUint32(&o.MMPUSA0.Reg)
}
func (o *MMPU_Type) SetMMPUSA0_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUSA0.Reg, volatile.LoadUint32(&o.MMPUSA0.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUSA0_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUSA0.Reg) & 0x3
}

// MMPU.MMPUEA0: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA0(value uint32) {
	volatile.StoreUint32(&o.MMPUEA0.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA0() uint32 {
	return volatile.LoadUint32(&o.MMPUEA0.Reg)
}
func (o *MMPU_Type) SetMMPUEA0_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUEA0.Reg, volatile.LoadUint32(&o.MMPUEA0.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUEA0_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUEA0.Reg) & 0x3
}

// MMPU.MMPUACA1: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA1_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA1_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA1_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA1_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA1_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA1_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA1.Reg, volatile.LoadUint16(&o.MMPUACA1.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA1_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA1.Reg) & 0x1
}

// MMPU.MMPUSA1: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA1(value uint32) {
	volatile.StoreUint32(&o.MMPUSA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA1() uint32 {
	return volatile.LoadUint32(&o.MMPUSA1.Reg)
}
func (o *MMPU_Type) SetMMPUSA1_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUSA1.Reg, volatile.LoadUint32(&o.MMPUSA1.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUSA1_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUSA1.Reg) & 0x3
}

// MMPU.MMPUEA1: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA1(value uint32) {
	volatile.StoreUint32(&o.MMPUEA1.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA1() uint32 {
	return volatile.LoadUint32(&o.MMPUEA1.Reg)
}
func (o *MMPU_Type) SetMMPUEA1_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUEA1.Reg, volatile.LoadUint32(&o.MMPUEA1.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUEA1_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUEA1.Reg) & 0x3
}

// MMPU.MMPUACA2: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA2_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA2_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA2_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA2_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA2_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA2_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA2_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA2.Reg, volatile.LoadUint16(&o.MMPUACA2.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA2_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA2.Reg) & 0x1
}

// MMPU.MMPUSA2: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA2(value uint32) {
	volatile.StoreUint32(&o.MMPUSA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA2() uint32 {
	return volatile.LoadUint32(&o.MMPUSA2.Reg)
}
func (o *MMPU_Type) SetMMPUSA2_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUSA2.Reg, volatile.LoadUint32(&o.MMPUSA2.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUSA2_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUSA2.Reg) & 0x3
}

// MMPU.MMPUEA2: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA2(value uint32) {
	volatile.StoreUint32(&o.MMPUEA2.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA2() uint32 {
	return volatile.LoadUint32(&o.MMPUEA2.Reg)
}
func (o *MMPU_Type) SetMMPUEA2_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUEA2.Reg, volatile.LoadUint32(&o.MMPUEA2.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUEA2_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUEA2.Reg) & 0x3
}

// MMPU.MMPUACA3: Group A Region %s Access Control Register
func (o *MMPU_Type) SetMMPUACA3_Reserved(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0xfff8)|value<<3)
}
func (o *MMPU_Type) GetMMPUACA3_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0xfff8) >> 3
}
func (o *MMPU_Type) SetMMPUACA3_WP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x4)|value<<2)
}
func (o *MMPU_Type) GetMMPUACA3_WP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x4) >> 2
}
func (o *MMPU_Type) SetMMPUACA3_RP(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x2)|value<<1)
}
func (o *MMPU_Type) GetMMPUACA3_RP() uint16 {
	return (volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x2) >> 1
}
func (o *MMPU_Type) SetMMPUACA3_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MMPUACA3.Reg, volatile.LoadUint16(&o.MMPUACA3.Reg)&^(0x1)|value)
}
func (o *MMPU_Type) GetMMPUACA3_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MMPUACA3.Reg) & 0x1
}

// MMPU.MMPUSA3: Group A Region %s Start Address Register
func (o *MMPU_Type) SetMMPUSA3(value uint32) {
	volatile.StoreUint32(&o.MMPUSA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUSA3() uint32 {
	return volatile.LoadUint32(&o.MMPUSA3.Reg)
}
func (o *MMPU_Type) SetMMPUSA3_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUSA3.Reg, volatile.LoadUint32(&o.MMPUSA3.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUSA3_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUSA3.Reg) & 0x3
}

// MMPU.MMPUEA3: Group A Region %s End Address Register
func (o *MMPU_Type) SetMMPUEA3(value uint32) {
	volatile.StoreUint32(&o.MMPUEA3.Reg, value)
}
func (o *MMPU_Type) GetMMPUEA3() uint32 {
	return volatile.LoadUint32(&o.MMPUEA3.Reg)
}
func (o *MMPU_Type) SetMMPUEA3_Reserved(value uint32) {
	volatile.StoreUint32(&o.MMPUEA3.Reg, volatile.LoadUint32(&o.MMPUEA3.Reg)&^(0x3)|value)
}
func (o *MMPU_Type) GetMMPUEA3_Reserved() uint32 {
	return volatile.LoadUint32(&o.MMPUEA3.Reg) & 0x3
}

// Bus Slave MPU
type SMPU_Type struct {
	SMPUCTL   volatile.Register16 // 0x0
	_         [14]byte
	SMPUMBIU  volatile.Register16 // 0x10
	_         [2]byte
	SMPUFBIU  volatile.Register16 // 0x14
	_         [2]byte
	SMPUSRAM0 volatile.Register16 // 0x18
	_         [6]byte
	SMPUP0BIU volatile.Register16 // 0x20
	_         [2]byte
	SMPUP2BIU volatile.Register16 // 0x24
	_         [2]byte
	SMPUP6BIU volatile.Register16 // 0x28
}

// SMPU.SMPUCTL: Slave MPU Control Register
func (o *SMPU_Type) SetSMPUCTL_KEY(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xff00)|value<<8)
}
func (o *SMPU_Type) GetSMPUCTL_KEY() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xff00) >> 8
}
func (o *SMPU_Type) SetSMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0xfc)|value<<2)
}
func (o *SMPU_Type) GetSMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0xfc) >> 2
}
func (o *SMPU_Type) SetSMPUCTL_PROTECT(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUCTL_PROTECT() uint16 {
	return (volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUCTL_OAD(value uint16) {
	volatile.StoreUint16(&o.SMPUCTL.Reg, volatile.LoadUint16(&o.SMPUCTL.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUCTL_OAD() uint16 {
	return volatile.LoadUint16(&o.SMPUCTL.Reg) & 0x1
}

// SMPU.SMPUMBIU: Access Control Register for MBIU
func (o *SMPU_Type) SetSMPUMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUMBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUMBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUMBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUMBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUMBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUMBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUMBIU.Reg, volatile.LoadUint16(&o.SMPUMBIU.Reg)&^(0x3)|value)
}
func (o *SMPU_Type) GetSMPUMBIU_Reserved() uint16 {
	return volatile.LoadUint16(&o.SMPUMBIU.Reg) & 0x3
}

// SMPU.SMPUFBIU: Access Control Register for FBIU
func (o *SMPU_Type) SetSMPUFBIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUFBIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUFBIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUFBIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUFBIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUFBIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUFBIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUFBIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUFBIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUFBIU.Reg, volatile.LoadUint16(&o.SMPUFBIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUFBIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUFBIU.Reg) & 0x1
}

// SMPU.SMPUSRAM0: Access Control Register for SRAM
func (o *SMPU_Type) SetSMPUSRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUSRAM0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUSRAM0_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUSRAM0_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUSRAM0_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUSRAM0_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUSRAM0_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUSRAM0_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUSRAM0_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUSRAM0.Reg, volatile.LoadUint16(&o.SMPUSRAM0.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUSRAM0_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUSRAM0.Reg) & 0x1
}

// SMPU.SMPUP0BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP0BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP0BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP0BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP0BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP0BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP0BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP0BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP0BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP0BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP0BIU.Reg, volatile.LoadUint16(&o.SMPUP0BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP0BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP0BIU.Reg) & 0x1
}

// SMPU.SMPUP2BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP2BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP2BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP2BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP2BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP2BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP2BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP2BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP2BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP2BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP2BIU.Reg, volatile.LoadUint16(&o.SMPUP2BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP2BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP2BIU.Reg) & 0x1
}

// SMPU.SMPUP6BIU: Access Control Register for P%sBIU
func (o *SMPU_Type) SetSMPUP6BIU_Reserved(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0xfff0)|value<<4)
}
func (o *SMPU_Type) GetSMPUP6BIU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0xfff0) >> 4
}
func (o *SMPU_Type) SetSMPUP6BIU_WPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x8)|value<<3)
}
func (o *SMPU_Type) GetSMPUP6BIU_WPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x8) >> 3
}
func (o *SMPU_Type) SetSMPUP6BIU_RPGRPA(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x4)|value<<2)
}
func (o *SMPU_Type) GetSMPUP6BIU_RPGRPA() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x4) >> 2
}
func (o *SMPU_Type) SetSMPUP6BIU_WPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x2)|value<<1)
}
func (o *SMPU_Type) GetSMPUP6BIU_WPCPU() uint16 {
	return (volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x2) >> 1
}
func (o *SMPU_Type) SetSMPUP6BIU_RPCPU(value uint16) {
	volatile.StoreUint16(&o.SMPUP6BIU.Reg, volatile.LoadUint16(&o.SMPUP6BIU.Reg)&^(0x1)|value)
}
func (o *SMPU_Type) GetSMPUP6BIU_RPCPU() uint16 {
	return volatile.LoadUint16(&o.SMPUP6BIU.Reg) & 0x1
}

// CPU Stack Pointer Monitor
type SPMON_Type struct {
	MSPMPUOAD volatile.Register16 // 0x0
	_         [2]byte
	MSPMPUCTL volatile.Register16 // 0x4
	MSPMPUPT  volatile.Register16 // 0x6
	MSPMPUSA  volatile.Register32 // 0x8
	MSPMPUEA  volatile.Register32 // 0xC
	PSPMPUOAD volatile.Register16 // 0x10
	_         [2]byte
	PSPMPUCTL volatile.Register16 // 0x14
	PSPMPUPT  volatile.Register16 // 0x16
	PSPMPUSA  volatile.Register32 // 0x18
	PSPMPUEA  volatile.Register32 // 0x1C
}

// SPMON.MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetMSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUOAD_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUOAD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.MSPMPUOAD.Reg, volatile.LoadUint16(&o.MSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.MSPMPUOAD.Reg) & 0x1
}

// SPMON.MSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetMSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0xfe00)|value<<9)
}
func (o *SPMON_Type) GetMSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0xfe00) >> 9
}
func (o *SPMON_Type) SetMSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetMSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.MSPMPUCTL.Reg, volatile.LoadUint16(&o.MSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.MSPMPUCTL.Reg) & 0x1
}

// SPMON.MSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetMSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetMSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetMSPMPUPT_Reserved(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetMSPMPUPT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetMSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.MSPMPUPT.Reg, volatile.LoadUint16(&o.MSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetMSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.MSPMPUPT.Reg) & 0x1
}

// SPMON.MSPMPUSA: Main Stack Pointer Monitor Start Address Register
func (o *SPMON_Type) SetMSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUSA.Reg, value)
}
func (o *SPMON_Type) GetMSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUSA.Reg)
}

// SPMON.MSPMPUEA: Main Stack Pointer Monitor End Address Register
func (o *SPMON_Type) SetMSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.MSPMPUEA.Reg, value)
}
func (o *SPMON_Type) GetMSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.MSPMPUEA.Reg)
}

// SPMON.PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
func (o *SPMON_Type) SetPSPMPUOAD_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUOAD_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUOAD_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUOAD_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUOAD_OAD(value uint16) {
	volatile.StoreUint16(&o.PSPMPUOAD.Reg, volatile.LoadUint16(&o.PSPMPUOAD.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUOAD_OAD() uint16 {
	return volatile.LoadUint16(&o.PSPMPUOAD.Reg) & 0x1
}

// SPMON.PSPMPUCTL: Stack Pointer Monitor Access Control Register
func (o *SPMON_Type) SetPSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0xfe00)|value<<9)
}
func (o *SPMON_Type) GetPSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0xfe00) >> 9
}
func (o *SPMON_Type) SetPSPMPUCTL_ERROR(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x100)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUCTL_ERROR() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x100) >> 8
}
func (o *SPMON_Type) SetPSPMPUCTL_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUCTL_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUCTL_ENABLE(value uint16) {
	volatile.StoreUint16(&o.PSPMPUCTL.Reg, volatile.LoadUint16(&o.PSPMPUCTL.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUCTL_ENABLE() uint16 {
	return volatile.LoadUint16(&o.PSPMPUCTL.Reg) & 0x1
}

// SPMON.PSPMPUPT: Stack Pointer Monitor Protection Register
func (o *SPMON_Type) SetPSPMPUPT_KEY(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xff00)|value<<8)
}
func (o *SPMON_Type) GetPSPMPUPT_KEY() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xff00) >> 8
}
func (o *SPMON_Type) SetPSPMPUPT_Reserved(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0xfe)|value<<1)
}
func (o *SPMON_Type) GetPSPMPUPT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0xfe) >> 1
}
func (o *SPMON_Type) SetPSPMPUPT_PROTECT(value uint16) {
	volatile.StoreUint16(&o.PSPMPUPT.Reg, volatile.LoadUint16(&o.PSPMPUPT.Reg)&^(0x1)|value)
}
func (o *SPMON_Type) GetPSPMPUPT_PROTECT() uint16 {
	return volatile.LoadUint16(&o.PSPMPUPT.Reg) & 0x1
}

// SPMON.PSPMPUSA: Process Stack Pointer Monitor Start Address Register
func (o *SPMON_Type) SetPSPMPUSA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUSA.Reg, value)
}
func (o *SPMON_Type) GetPSPMPUSA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUSA.Reg)
}

// SPMON.PSPMPUEA: Process Stack Pointer Monitor End Address Register
func (o *SPMON_Type) SetPSPMPUEA(value uint32) {
	volatile.StoreUint32(&o.PSPMPUEA.Reg, value)
}
func (o *SPMON_Type) GetPSPMPUEA() uint32 {
	return volatile.LoadUint32(&o.PSPMPUEA.Reg)
}

// SRAM Control
type SRAM_Type struct {
	PARIOAD   volatile.Register8 // 0x0
	_         [3]byte
	SRAMPRCR  volatile.Register8 // 0x4
	_         [187]byte
	ECCMODE   volatile.Register8 // 0xC0
	ECC2STS   volatile.Register8 // 0xC1
	ECC1STSEN volatile.Register8 // 0xC2
	ECC1STS   volatile.Register8 // 0xC3
	ECCPRCR   volatile.Register8 // 0xC4
	_         [11]byte
	ECCPRCR2  volatile.Register8 // 0xD0
	_         [3]byte
	ECCETST   volatile.Register8 // 0xD4
	_         [3]byte
	ECCOAD    volatile.Register8 // 0xD8
}

// SRAM.PARIOAD: SRAM Parity Error Operation After Detection Register
func (o *SRAM_Type) SetPARIOAD_Reserved(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetPARIOAD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.PARIOAD.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetPARIOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.PARIOAD.Reg, volatile.LoadUint8(&o.PARIOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetPARIOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.PARIOAD.Reg) & 0x1
}

// SRAM.SRAMPRCR: SRAM Protection Register
func (o *SRAM_Type) SetSRAMPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetSRAMPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetSRAMPRCR(value uint8) {
	volatile.StoreUint8(&o.SRAMPRCR.Reg, volatile.LoadUint8(&o.SRAMPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetSRAMPRCR() uint8 {
	return volatile.LoadUint8(&o.SRAMPRCR.Reg) & 0x1
}

// SRAM.ECCMODE: ECC Operating Mode Control Register
func (o *SRAM_Type) SetECCMODE_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0xfc)|value<<2)
}
func (o *SRAM_Type) GetECCMODE_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCMODE.Reg) & 0xfc) >> 2
}
func (o *SRAM_Type) SetECCMODE_ECCMOD(value uint8) {
	volatile.StoreUint8(&o.ECCMODE.Reg, volatile.LoadUint8(&o.ECCMODE.Reg)&^(0x3)|value)
}
func (o *SRAM_Type) GetECCMODE_ECCMOD() uint8 {
	return volatile.LoadUint8(&o.ECCMODE.Reg) & 0x3
}

// SRAM.ECC2STS: ECC 2-Bit Error Status Register
func (o *SRAM_Type) SetECC2STS_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC2STS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC2STS.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC2STS_ECC2ERR(value uint8) {
	volatile.StoreUint8(&o.ECC2STS.Reg, volatile.LoadUint8(&o.ECC2STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC2STS_ECC2ERR() uint8 {
	return volatile.LoadUint8(&o.ECC2STS.Reg) & 0x1
}

// SRAM.ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
func (o *SRAM_Type) SetECC1STSEN_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC1STSEN_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC1STSEN_E1STSEN(value uint8) {
	volatile.StoreUint8(&o.ECC1STSEN.Reg, volatile.LoadUint8(&o.ECC1STSEN.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STSEN_E1STSEN() uint8 {
	return volatile.LoadUint8(&o.ECC1STSEN.Reg) & 0x1
}

// SRAM.ECC1STS: ECC 1-Bit Error Status Register
func (o *SRAM_Type) SetECC1STS_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECC1STS_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECC1STS.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECC1STS_ECC1ERR(value uint8) {
	volatile.StoreUint8(&o.ECC1STS.Reg, volatile.LoadUint8(&o.ECC1STS.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECC1STS_ECC1ERR() uint8 {
	return volatile.LoadUint8(&o.ECC1STS.Reg) & 0x1
}

// SRAM.ECCPRCR: ECC Protection Register
func (o *SRAM_Type) SetECCPRCR_KW(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR_KW() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCPRCR(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR.Reg, volatile.LoadUint8(&o.ECCPRCR.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR.Reg) & 0x1
}

// SRAM.ECCPRCR2: ECC Protection Register 2
func (o *SRAM_Type) SetECCPRCR2_KW(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCPRCR2_KW() uint8 {
	return (volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCPRCR2(value uint8) {
	volatile.StoreUint8(&o.ECCPRCR2.Reg, volatile.LoadUint8(&o.ECCPRCR2.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCPRCR2() uint8 {
	return volatile.LoadUint8(&o.ECCPRCR2.Reg) & 0x1
}

// SRAM.ECCETST: ECC Test Control Register
func (o *SRAM_Type) SetECCETST_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCETST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCETST.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCETST_TSTBYP(value uint8) {
	volatile.StoreUint8(&o.ECCETST.Reg, volatile.LoadUint8(&o.ECCETST.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCETST_TSTBYP() uint8 {
	return volatile.LoadUint8(&o.ECCETST.Reg) & 0x1
}

// SRAM.ECCOAD: SRAM ECC Error Operation After Detection Register
func (o *SRAM_Type) SetECCOAD_Reserved(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0xfe)|value<<1)
}
func (o *SRAM_Type) GetECCOAD_Reserved() uint8 {
	return (volatile.LoadUint8(&o.ECCOAD.Reg) & 0xfe) >> 1
}
func (o *SRAM_Type) SetECCOAD_OAD(value uint8) {
	volatile.StoreUint8(&o.ECCOAD.Reg, volatile.LoadUint8(&o.ECCOAD.Reg)&^(0x1)|value)
}
func (o *SRAM_Type) GetECCOAD_OAD() uint8 {
	return volatile.LoadUint8(&o.ECCOAD.Reg) & 0x1
}

// BUS Control
type BUS_Type struct {
	_           [4104]byte
	BUSMCNTSYS  volatile.Register16 // 0x1008
	_           [2]byte
	BUSMCNTDMA  volatile.Register16 // 0x100C
	_           [242]byte
	BUSSCNTFLI  volatile.Register16 // 0x1100
	_           [10]byte
	BUSSCNTRAM0 volatile.Register16 // 0x110C
	_           [6]byte
	BUSSCNTP0B  volatile.Register16 // 0x1114
	_           [2]byte
	BUSSCNTP2B  volatile.Register16 // 0x1118
	_           [6]byte
	BUSSCNTP4B  volatile.Register16 // 0x1120
	_           [6]byte
	BUSSCNTP6B  volatile.Register16 // 0x1128
	_           [6]byte
	BUSSCNTFBU  volatile.Register16 // 0x1130
	_           [1774]byte
	BUS3ERRADD  volatile.Register32 // 0x1820
	BUS3ERRSTAT volatile.Register8  // 0x1824
	_           [11]byte
	BUS4ERRADD  volatile.Register32 // 0x1830
	BUS4ERRSTAT volatile.Register8  // 0x1834
}

// BUS.BUSMCNTSYS: Master Bus Control Register SYS
func (o *BUS_Type) SetBUSMCNTSYS_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTSYS_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTSYS_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTSYS.Reg, volatile.LoadUint16(&o.BUSMCNTSYS.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTSYS_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTSYS.Reg) & 0x7fff
}

// BUS.BUSMCNTDMA: Master Bus Control Register DMA
func (o *BUS_Type) SetBUSMCNTDMA_IERES(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x8000)|value<<15)
}
func (o *BUS_Type) GetBUSMCNTDMA_IERES() uint16 {
	return (volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x8000) >> 15
}
func (o *BUS_Type) SetBUSMCNTDMA_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSMCNTDMA.Reg, volatile.LoadUint16(&o.BUSMCNTDMA.Reg)&^(0x7fff)|value)
}
func (o *BUS_Type) GetBUSMCNTDMA_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSMCNTDMA.Reg) & 0x7fff
}

// BUS.BUSSCNTFLI: Slave Bus Control Register FLI
func (o *BUS_Type) SetBUSSCNTFLI_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTFLI_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTFLI_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFLI_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTFLI_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFLI.Reg, volatile.LoadUint16(&o.BUSSCNTFLI.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTFLI_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFLI.Reg) & 0xf
}

// BUS.BUSSCNTRAM0: Slave Bus Control Register RAM0
func (o *BUS_Type) SetBUSSCNTRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTRAM0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTRAM0_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTRAM0_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTRAM0_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTRAM0.Reg, volatile.LoadUint16(&o.BUSSCNTRAM0.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTRAM0_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTRAM0.Reg) & 0xf
}

// BUS.BUSSCNTP0B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP0B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP0B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP0B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP0B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP0B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP0B.Reg, volatile.LoadUint16(&o.BUSSCNTP0B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP0B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP0B.Reg) & 0xf
}

// BUS.BUSSCNTP2B: Slave Bus Control Register %s
func (o *BUS_Type) SetBUSSCNTP2B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP2B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP2B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP2B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP2B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP2B.Reg, volatile.LoadUint16(&o.BUSSCNTP2B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP2B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP2B.Reg) & 0xf
}

// BUS.BUSSCNTP4B: Slave Bus Control Register P4B
func (o *BUS_Type) SetBUSSCNTP4B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP4B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP4B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP4B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP4B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP4B.Reg, volatile.LoadUint16(&o.BUSSCNTP4B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP4B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP4B.Reg) & 0xf
}

// BUS.BUSSCNTP6B: Slave Bus Control Register P6B
func (o *BUS_Type) SetBUSSCNTP6B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTP6B_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTP6B_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTP6B_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTP6B_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTP6B.Reg, volatile.LoadUint16(&o.BUSSCNTP6B.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTP6B_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTP6B.Reg) & 0xf
}

// BUS.BUSSCNTFBU: Slave Bus Control Register FBU
func (o *BUS_Type) SetBUSSCNTFBU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0xffc0)|value<<6)
}
func (o *BUS_Type) GetBUSSCNTFBU_Reserved() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0xffc0) >> 6
}
func (o *BUS_Type) SetBUSSCNTFBU_ARBMET(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0x30)|value<<4)
}
func (o *BUS_Type) GetBUSSCNTFBU_ARBMET() uint16 {
	return (volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0x30) >> 4
}
func (o *BUS_Type) SetBUSSCNTFBU_Reserved(value uint16) {
	volatile.StoreUint16(&o.BUSSCNTFBU.Reg, volatile.LoadUint16(&o.BUSSCNTFBU.Reg)&^(0xf)|value)
}
func (o *BUS_Type) GetBUSSCNTFBU_Reserved() uint16 {
	return volatile.LoadUint16(&o.BUSSCNTFBU.Reg) & 0xf
}

// BUS.BUS3ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS3ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS3ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS3ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS3ERRADD.Reg)
}

// BUS.BUS3ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS3ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS3ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS3ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS3ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS3ERRSTAT.Reg, volatile.LoadUint8(&o.BUS3ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS3ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS3ERRSTAT.Reg) & 0x1
}

// BUS.BUS4ERRADD: Bus Error Address Register %s
func (o *BUS_Type) SetBUS4ERRADD(value uint32) {
	volatile.StoreUint32(&o.BUS4ERRADD.Reg, value)
}
func (o *BUS_Type) GetBUS4ERRADD() uint32 {
	return volatile.LoadUint32(&o.BUS4ERRADD.Reg)
}

// BUS.BUS4ERRSTAT: Bus Error Status Register %s
func (o *BUS_Type) SetBUS4ERRSTAT_ERRSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x80)|value<<7)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ERRSTAT() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x80) >> 7
}
func (o *BUS_Type) SetBUS4ERRSTAT_Reserved(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x7e)|value<<1)
}
func (o *BUS_Type) GetBUS4ERRSTAT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x7e) >> 1
}
func (o *BUS_Type) SetBUS4ERRSTAT_ACCSTAT(value uint8) {
	volatile.StoreUint8(&o.BUS4ERRSTAT.Reg, volatile.LoadUint8(&o.BUS4ERRSTAT.Reg)&^(0x1)|value)
}
func (o *BUS_Type) GetBUS4ERRSTAT_ACCSTAT() uint8 {
	return volatile.LoadUint8(&o.BUS4ERRSTAT.Reg) & 0x1
}

// Debug Function
type DBG_Type struct {
	DBGSTR    volatile.Register32 // 0x0
	_         [12]byte
	DBGSTOPCR volatile.Register32 // 0x10
}

// DBG.DBGSTR: Debug Status Register
func (o *DBG_Type) SetDBGSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0xc0000000)|value<<30)
}
func (o *DBG_Type) GetDBGSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0xc0000000) >> 30
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPACK(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x20000000)|value<<29)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPACK() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x20000000) >> 29
}
func (o *DBG_Type) SetDBGSTR_CDBGPWRUPREQ(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0x10000000)|value<<28)
}
func (o *DBG_Type) GetDBGSTR_CDBGPWRUPREQ() uint32 {
	return (volatile.LoadUint32(&o.DBGSTR.Reg) & 0x10000000) >> 28
}
func (o *DBG_Type) SetDBGSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTR.Reg, volatile.LoadUint32(&o.DBGSTR.Reg)&^(0xfffffff)|value)
}
func (o *DBG_Type) GetDBGSTR_Reserved() uint32 {
	return volatile.LoadUint32(&o.DBGSTR.Reg) & 0xfffffff
}

// DBG.DBGSTOPCR: Debug Stop Control Register
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xfc000000)|value<<26)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xfc000000) >> 26
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RECCR(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2000000)|value<<25)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RECCR() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2000000) >> 25
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_RPER(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1000000)|value<<24)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_RPER() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1000000) >> 24
}
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xf80000)|value<<19)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xf80000) >> 19
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_LVD(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x70000)|value<<16)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_LVD() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x70000) >> 16
}
func (o *DBG_Type) SetDBGSTOPCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0xfffc)|value<<2)
}
func (o *DBG_Type) GetDBGSTOPCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0xfffc) >> 2
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_WDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x2)|value<<1)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_WDT() uint32 {
	return (volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x2) >> 1
}
func (o *DBG_Type) SetDBGSTOPCR_DBGSTOP_IWDT(value uint32) {
	volatile.StoreUint32(&o.DBGSTOPCR.Reg, volatile.LoadUint32(&o.DBGSTOPCR.Reg)&^(0x1)|value)
}
func (o *DBG_Type) GetDBGSTOPCR_DBGSTOP_IWDT() uint32 {
	return volatile.LoadUint32(&o.DBGSTOPCR.Reg) & 0x1
}

// Data Transfer Controller
type DTC_Type struct {
	DTCCR  volatile.Register8 // 0x0
	_      [3]byte
	DTCVBR volatile.Register32 // 0x4
	_      [4]byte
	DTCST  volatile.Register8 // 0xC
	_      byte
	DTCSTS volatile.Register16 // 0xE
}

// DTC.DTCCR: DTC Control Register
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0xe0)|value<<5)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0xe0) >> 5
}
func (o *DTC_Type) SetDTCCR_RRS(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x10)|value<<4)
}
func (o *DTC_Type) GetDTCCR_RRS() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x10) >> 4
}
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x8)|value<<3)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCCR.Reg) & 0x8) >> 3
}
func (o *DTC_Type) SetDTCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCCR.Reg, volatile.LoadUint8(&o.DTCCR.Reg)&^(0x7)|value)
}
func (o *DTC_Type) GetDTCCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.DTCCR.Reg) & 0x7
}

// DTC.DTCVBR: DTC Vector Base Register
func (o *DTC_Type) SetDTCVBR(value uint32) {
	volatile.StoreUint32(&o.DTCVBR.Reg, value)
}
func (o *DTC_Type) GetDTCVBR() uint32 {
	return volatile.LoadUint32(&o.DTCVBR.Reg)
}

// DTC.DTCST: DTC Module Start Register
func (o *DTC_Type) SetDTCST_Reserved(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0xfe)|value<<1)
}
func (o *DTC_Type) GetDTCST_Reserved() uint8 {
	return (volatile.LoadUint8(&o.DTCST.Reg) & 0xfe) >> 1
}
func (o *DTC_Type) SetDTCST(value uint8) {
	volatile.StoreUint8(&o.DTCST.Reg, volatile.LoadUint8(&o.DTCST.Reg)&^(0x1)|value)
}
func (o *DTC_Type) GetDTCST() uint8 {
	return volatile.LoadUint8(&o.DTCST.Reg) & 0x1
}

// DTC.DTCSTS: DTC Status Register
func (o *DTC_Type) SetDTCSTS_ACT(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x8000)|value<<15)
}
func (o *DTC_Type) GetDTCSTS_ACT() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x8000) >> 15
}
func (o *DTC_Type) SetDTCSTS_Reserved(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0x7f00)|value<<8)
}
func (o *DTC_Type) GetDTCSTS_Reserved() uint16 {
	return (volatile.LoadUint16(&o.DTCSTS.Reg) & 0x7f00) >> 8
}
func (o *DTC_Type) SetDTCSTS_VECN(value uint16) {
	volatile.StoreUint16(&o.DTCSTS.Reg, volatile.LoadUint16(&o.DTCSTS.Reg)&^(0xff)|value)
}
func (o *DTC_Type) GetDTCSTS_VECN() uint16 {
	return volatile.LoadUint16(&o.DTCSTS.Reg) & 0xff
}

// Interrupt Controller
type ICU_Type struct {
	IRQCR0  volatile.Register8 // 0x0
	IRQCR1  volatile.Register8 // 0x1
	IRQCR2  volatile.Register8 // 0x2
	IRQCR3  volatile.Register8 // 0x3
	IRQCR4  volatile.Register8 // 0x4
	IRQCR5  volatile.Register8 // 0x5
	IRQCR6  volatile.Register8 // 0x6
	IRQCR7  volatile.Register8 // 0x7
	_       [248]byte
	NMICR   volatile.Register8 // 0x100
	_       [31]byte
	NMIER   volatile.Register16 // 0x120
	_       [14]byte
	NMICLR  volatile.Register16 // 0x130
	_       [14]byte
	NMISR   volatile.Register16 // 0x140
	_       [94]byte
	WUPEN   volatile.Register32 // 0x1A0
	_       [92]byte
	SELSR0  volatile.Register16 // 0x200
	_       [254]byte
	IELSR0  volatile.Register32 // 0x300
	IELSR1  volatile.Register32 // 0x304
	IELSR2  volatile.Register32 // 0x308
	IELSR3  volatile.Register32 // 0x30C
	IELSR4  volatile.Register32 // 0x310
	IELSR5  volatile.Register32 // 0x314
	IELSR6  volatile.Register32 // 0x318
	IELSR7  volatile.Register32 // 0x31C
	IELSR8  volatile.Register32 // 0x320
	IELSR9  volatile.Register32 // 0x324
	IELSR10 volatile.Register32 // 0x328
	IELSR11 volatile.Register32 // 0x32C
	IELSR12 volatile.Register32 // 0x330
	IELSR13 volatile.Register32 // 0x334
	IELSR14 volatile.Register32 // 0x338
	IELSR15 volatile.Register32 // 0x33C
	IELSR16 volatile.Register32 // 0x340
	IELSR17 volatile.Register32 // 0x344
	IELSR18 volatile.Register32 // 0x348
	IELSR19 volatile.Register32 // 0x34C
	IELSR20 volatile.Register32 // 0x350
	IELSR21 volatile.Register32 // 0x354
	IELSR22 volatile.Register32 // 0x358
	IELSR23 volatile.Register32 // 0x35C
	IELSR24 volatile.Register32 // 0x360
	IELSR25 volatile.Register32 // 0x364
	IELSR26 volatile.Register32 // 0x368
	IELSR27 volatile.Register32 // 0x36C
	IELSR28 volatile.Register32 // 0x370
	IELSR29 volatile.Register32 // 0x374
	IELSR30 volatile.Register32 // 0x378
	IELSR31 volatile.Register32 // 0x37C
}

// ICU.IRQCR0: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR0_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR0_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR0_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR0_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR0.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR0_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR0.Reg, volatile.LoadUint8(&o.IRQCR0.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR0_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR0.Reg) & 0x3
}

// ICU.IRQCR1: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR1_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR1_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR1_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR1_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR1.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR1_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR1.Reg, volatile.LoadUint8(&o.IRQCR1.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR1_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR1.Reg) & 0x3
}

// ICU.IRQCR2: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR2_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR2_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR2_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR2_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR2.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR2_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR2.Reg, volatile.LoadUint8(&o.IRQCR2.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR2_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR2.Reg) & 0x3
}

// ICU.IRQCR3: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR3_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR3_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR3_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR3_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR3_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR3_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR3_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR3_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR3.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR3_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR3.Reg, volatile.LoadUint8(&o.IRQCR3.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR3_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR3.Reg) & 0x3
}

// ICU.IRQCR4: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR4_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR4_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR4_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR4_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR4.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR4_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR4.Reg, volatile.LoadUint8(&o.IRQCR4.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR4_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR4.Reg) & 0x3
}

// ICU.IRQCR5: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR5_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR5_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR5_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR5_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR5_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR5_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR5_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR5_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR5.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR5_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR5.Reg, volatile.LoadUint8(&o.IRQCR5.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR5_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR5.Reg) & 0x3
}

// ICU.IRQCR6: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR6_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR6_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR6_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR6_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR6_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR6_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR6_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR6_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR6.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR6_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR6.Reg, volatile.LoadUint8(&o.IRQCR6.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR6_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR6.Reg) & 0x3
}

// ICU.IRQCR7: IRQ Control Register %s
func (o *ICU_Type) SetIRQCR7_FLTEN(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetIRQCR7_FLTEN() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetIRQCR7_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetIRQCR7_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetIRQCR7_FCLKSEL(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetIRQCR7_FCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetIRQCR7_Reserved(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0xc)|value<<2)
}
func (o *ICU_Type) GetIRQCR7_Reserved() uint8 {
	return (volatile.LoadUint8(&o.IRQCR7.Reg) & 0xc) >> 2
}
func (o *ICU_Type) SetIRQCR7_IRQMD(value uint8) {
	volatile.StoreUint8(&o.IRQCR7.Reg, volatile.LoadUint8(&o.IRQCR7.Reg)&^(0x3)|value)
}
func (o *ICU_Type) GetIRQCR7_IRQMD() uint8 {
	return volatile.LoadUint8(&o.IRQCR7.Reg) & 0x3
}

// ICU.NMICR: NMI Pin Interrupt Control Register
func (o *ICU_Type) SetNMICR_NFLTEN(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICR_NFLTEN() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICR_NFCLKSEL(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICR_NFCLKSEL() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICR_Reserved(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0xe)|value<<1)
}
func (o *ICU_Type) GetNMICR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.NMICR.Reg) & 0xe) >> 1
}
func (o *ICU_Type) SetNMICR_NMIMD(value uint8) {
	volatile.StoreUint8(&o.NMICR.Reg, volatile.LoadUint8(&o.NMICR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICR_NMIMD() uint8 {
	return volatile.LoadUint8(&o.NMICR.Reg) & 0x1
}

// ICU.NMIER: Non-Maskable Interrupt Enable Register
func (o *ICU_Type) SetNMIER_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMIER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMIER_SPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMIER_SPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMIER_BUSMEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMIER_BUSMEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMIER_BUSSEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMIER_BUSSEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMIER_RECCEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMIER_RECCEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMIER_RPEEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMIER_RPEEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMIER_NMIEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMIER_NMIEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMIER_OSTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMIER_OSTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMIER_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMIER_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMIER_LVD2EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMIER_LVD2EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMIER_LVD1EN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMIER_LVD1EN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMIER_WDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMIER_WDTEN() uint16 {
	return (volatile.LoadUint16(&o.NMIER.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMIER_IWDTEN(value uint16) {
	volatile.StoreUint16(&o.NMIER.Reg, volatile.LoadUint16(&o.NMIER.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMIER_IWDTEN() uint16 {
	return volatile.LoadUint16(&o.NMIER.Reg) & 0x1
}

// ICU.NMICLR: Non-Maskable Interrupt Status Clear Register
func (o *ICU_Type) SetNMICLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMICLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMICLR_SPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMICLR_SPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMICLR_BUSMCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMICLR_BUSMCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMICLR_BUSSCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMICLR_BUSSCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMICLR_RECCCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMICLR_RECCCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMICLR_RPECLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMICLR_RPECLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMICLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMICLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMICLR_OSTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMICLR_OSTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMICLR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMICLR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMICLR_LVD2CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMICLR_LVD2CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMICLR_LVD1CLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMICLR_LVD1CLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMICLR_WDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMICLR_WDTCLR() uint16 {
	return (volatile.LoadUint16(&o.NMICLR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMICLR_IWDTCLR(value uint16) {
	volatile.StoreUint16(&o.NMICLR.Reg, volatile.LoadUint16(&o.NMICLR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMICLR_IWDTCLR() uint16 {
	return volatile.LoadUint16(&o.NMICLR.Reg) & 0x1
}

// ICU.NMISR: Non-Maskable Interrupt Status Register
func (o *ICU_Type) SetNMISR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0xe000)|value<<13)
}
func (o *ICU_Type) GetNMISR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0xe000) >> 13
}
func (o *ICU_Type) SetNMISR_SPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1000)|value<<12)
}
func (o *ICU_Type) GetNMISR_SPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x1000) >> 12
}
func (o *ICU_Type) SetNMISR_BUSMST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x800)|value<<11)
}
func (o *ICU_Type) GetNMISR_BUSMST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x800) >> 11
}
func (o *ICU_Type) SetNMISR_BUSSST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x400)|value<<10)
}
func (o *ICU_Type) GetNMISR_BUSSST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x400) >> 10
}
func (o *ICU_Type) SetNMISR_RECCST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x200)|value<<9)
}
func (o *ICU_Type) GetNMISR_RECCST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x200) >> 9
}
func (o *ICU_Type) SetNMISR_RPEST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x100)|value<<8)
}
func (o *ICU_Type) GetNMISR_RPEST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x100) >> 8
}
func (o *ICU_Type) SetNMISR_NMIST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetNMISR_NMIST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetNMISR_OSTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetNMISR_OSTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetNMISR_Reserved(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x30)|value<<4)
}
func (o *ICU_Type) GetNMISR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x30) >> 4
}
func (o *ICU_Type) SetNMISR_LVD2ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetNMISR_LVD2ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetNMISR_LVD1ST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetNMISR_LVD1ST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetNMISR_WDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetNMISR_WDTST() uint16 {
	return (volatile.LoadUint16(&o.NMISR.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetNMISR_IWDTST(value uint16) {
	volatile.StoreUint16(&o.NMISR.Reg, volatile.LoadUint16(&o.NMISR.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetNMISR_IWDTST() uint16 {
	return volatile.LoadUint16(&o.NMISR.Reg) & 0x1
}

// ICU.WUPEN: Wake Up Interrupt Enable Register
func (o *ICU_Type) SetWUPEN_IIC0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000000)|value<<31)
}
func (o *ICU_Type) GetWUPEN_IIC0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000000) >> 31
}
func (o *ICU_Type) SetWUPEN_AGT1CBWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000000)|value<<30)
}
func (o *ICU_Type) GetWUPEN_AGT1CBWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000000) >> 30
}
func (o *ICU_Type) SetWUPEN_AGT1CAWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000000)|value<<29)
}
func (o *ICU_Type) GetWUPEN_AGT1CAWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000000) >> 29
}
func (o *ICU_Type) SetWUPEN_AGT1UDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000000)|value<<28)
}
func (o *ICU_Type) GetWUPEN_AGT1UDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000000) >> 28
}
func (o *ICU_Type) SetWUPEN_USBFSWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8000000)|value<<27)
}
func (o *ICU_Type) GetWUPEN_USBFSWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8000000) >> 27
}
func (o *ICU_Type) SetWUPEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4000000)|value<<26)
}
func (o *ICU_Type) GetWUPEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4000000) >> 26
}
func (o *ICU_Type) SetWUPEN_RTCPRDWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2000000)|value<<25)
}
func (o *ICU_Type) GetWUPEN_RTCPRDWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2000000) >> 25
}
func (o *ICU_Type) SetWUPEN_RTCALMWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetWUPEN_RTCALMWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetWUPEN_ACMPLP0WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x800000)|value<<23)
}
func (o *ICU_Type) GetWUPEN_ACMPLP0WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x800000) >> 23
}
func (o *ICU_Type) SetWUPEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x700000)|value<<20)
}
func (o *ICU_Type) GetWUPEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x700000) >> 20
}
func (o *ICU_Type) SetWUPEN_LVD2WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80000)|value<<19)
}
func (o *ICU_Type) GetWUPEN_LVD2WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80000) >> 19
}
func (o *ICU_Type) SetWUPEN_LVD1WUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40000)|value<<18)
}
func (o *ICU_Type) GetWUPEN_LVD1WUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40000) >> 18
}
func (o *ICU_Type) SetWUPEN_KEYWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20000)|value<<17)
}
func (o *ICU_Type) GetWUPEN_KEYWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20000) >> 17
}
func (o *ICU_Type) SetWUPEN_IWDTWUPEN(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetWUPEN_IWDTWUPEN() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetWUPEN_Reserved(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetWUPEN_Reserved() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN7(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x80)|value<<7)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN7() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x80) >> 7
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN6(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x40)|value<<6)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN6() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x40) >> 6
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN5(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x20)|value<<5)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN5() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x20) >> 5
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN4(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x10)|value<<4)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN4() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x10) >> 4
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN3(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x8)|value<<3)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN3() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x8) >> 3
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN2(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x4)|value<<2)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN2() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x4) >> 2
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN1(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x2)|value<<1)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN1() uint32 {
	return (volatile.LoadUint32(&o.WUPEN.Reg) & 0x2) >> 1
}
func (o *ICU_Type) SetWUPEN_IRQWUPEN0(value uint32) {
	volatile.StoreUint32(&o.WUPEN.Reg, volatile.LoadUint32(&o.WUPEN.Reg)&^(0x1)|value)
}
func (o *ICU_Type) GetWUPEN_IRQWUPEN0() uint32 {
	return volatile.LoadUint32(&o.WUPEN.Reg) & 0x1
}

// ICU.SELSR0: SYS Event Link Setting Register
func (o *ICU_Type) SetSELSR0_Reserved(value uint16) {
	volatile.StoreUint16(&o.SELSR0.Reg, volatile.LoadUint16(&o.SELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetSELSR0_Reserved() uint16 {
	return (volatile.LoadUint16(&o.SELSR0.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetSELSR0_SELS(value uint16) {
	volatile.StoreUint16(&o.SELSR0.Reg, volatile.LoadUint16(&o.SELSR0.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetSELSR0_SELS() uint16 {
	return volatile.LoadUint16(&o.SELSR0.Reg) & 0xff
}

// ICU.IELSR0: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR0_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR0_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR0_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR0_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR0_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR0_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR0.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR0_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR0.Reg, volatile.LoadUint32(&o.IELSR0.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR0_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR0.Reg) & 0xff
}

// ICU.IELSR1: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR1_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR1_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR1_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR1_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR1_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR1_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR1.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR1_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR1.Reg, volatile.LoadUint32(&o.IELSR1.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR1_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR1.Reg) & 0xff
}

// ICU.IELSR2: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR2_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR2_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR2_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR2_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR2_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR2_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR2.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR2_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR2.Reg, volatile.LoadUint32(&o.IELSR2.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR2_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR2.Reg) & 0xff
}

// ICU.IELSR3: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR3_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR3_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR3_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR3_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR3_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR3_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR3.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR3_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR3.Reg, volatile.LoadUint32(&o.IELSR3.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR3_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR3.Reg) & 0xff
}

// ICU.IELSR4: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR4_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR4_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR4_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR4_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR4_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR4_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR4.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR4_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR4.Reg, volatile.LoadUint32(&o.IELSR4.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR4_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR4.Reg) & 0xff
}

// ICU.IELSR5: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR5_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR5_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR5_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR5_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR5_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR5_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR5.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR5_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR5.Reg, volatile.LoadUint32(&o.IELSR5.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR5_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR5.Reg) & 0xff
}

// ICU.IELSR6: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR6_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR6_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR6_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR6_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR6_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR6_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR6.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR6_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR6.Reg, volatile.LoadUint32(&o.IELSR6.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR6_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR6.Reg) & 0xff
}

// ICU.IELSR7: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR7_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR7_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR7_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR7_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR7_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR7_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR7.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR7_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR7.Reg, volatile.LoadUint32(&o.IELSR7.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR7_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR7.Reg) & 0xff
}

// ICU.IELSR8: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR8_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR8_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR8_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR8_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR8_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR8_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR8.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR8_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR8.Reg, volatile.LoadUint32(&o.IELSR8.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR8_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR8.Reg) & 0xff
}

// ICU.IELSR9: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR9_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR9_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR9_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR9_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR9_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR9_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR9.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR9_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR9.Reg, volatile.LoadUint32(&o.IELSR9.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR9_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR9.Reg) & 0xff
}

// ICU.IELSR10: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR10_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR10_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR10_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR10_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR10_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR10_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR10.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR10_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR10.Reg, volatile.LoadUint32(&o.IELSR10.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR10_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR10.Reg) & 0xff
}

// ICU.IELSR11: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR11_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR11_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR11_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR11_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR11_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR11_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR11.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR11_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR11.Reg, volatile.LoadUint32(&o.IELSR11.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR11_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR11.Reg) & 0xff
}

// ICU.IELSR12: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR12_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR12_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR12_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR12_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR12_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR12_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR12.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR12_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR12.Reg, volatile.LoadUint32(&o.IELSR12.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR12_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR12.Reg) & 0xff
}

// ICU.IELSR13: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR13_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR13_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR13_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR13_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR13_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR13_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR13.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR13_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR13.Reg, volatile.LoadUint32(&o.IELSR13.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR13_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR13.Reg) & 0xff
}

// ICU.IELSR14: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR14_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR14_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR14_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR14_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR14_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR14_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR14.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR14_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR14.Reg, volatile.LoadUint32(&o.IELSR14.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR14_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR14.Reg) & 0xff
}

// ICU.IELSR15: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR15_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR15_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR15_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR15_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR15_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR15_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR15.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR15_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR15.Reg, volatile.LoadUint32(&o.IELSR15.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR15_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR15.Reg) & 0xff
}

// ICU.IELSR16: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR16_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR16_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR16_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR16_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR16_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR16_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR16.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR16_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR16.Reg, volatile.LoadUint32(&o.IELSR16.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR16_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR16.Reg) & 0xff
}

// ICU.IELSR17: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR17_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR17_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR17_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR17_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR17_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR17_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR17.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR17_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR17.Reg, volatile.LoadUint32(&o.IELSR17.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR17_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR17.Reg) & 0xff
}

// ICU.IELSR18: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR18_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR18_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR18_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR18_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR18_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR18_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR18.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR18_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR18.Reg, volatile.LoadUint32(&o.IELSR18.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR18_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR18.Reg) & 0xff
}

// ICU.IELSR19: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR19_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR19_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR19_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR19_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR19_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR19_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR19.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR19_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR19.Reg, volatile.LoadUint32(&o.IELSR19.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR19_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR19.Reg) & 0xff
}

// ICU.IELSR20: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR20_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR20_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR20_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR20_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR20_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR20_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR20.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR20_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR20.Reg, volatile.LoadUint32(&o.IELSR20.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR20_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR20.Reg) & 0xff
}

// ICU.IELSR21: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR21_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR21_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR21_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR21_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR21_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR21_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR21.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR21_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR21.Reg, volatile.LoadUint32(&o.IELSR21.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR21_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR21.Reg) & 0xff
}

// ICU.IELSR22: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR22_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR22_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR22_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR22_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR22_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR22_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR22.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR22_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR22.Reg, volatile.LoadUint32(&o.IELSR22.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR22_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR22.Reg) & 0xff
}

// ICU.IELSR23: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR23_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR23_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR23_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR23_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR23_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR23_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR23.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR23_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR23.Reg, volatile.LoadUint32(&o.IELSR23.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR23_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR23.Reg) & 0xff
}

// ICU.IELSR24: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR24_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR24_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR24_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR24_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR24_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR24_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR24.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR24_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR24.Reg, volatile.LoadUint32(&o.IELSR24.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR24_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR24.Reg) & 0xff
}

// ICU.IELSR25: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR25_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR25_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR25_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR25_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR25_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR25_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR25.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR25_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR25.Reg, volatile.LoadUint32(&o.IELSR25.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR25_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR25.Reg) & 0xff
}

// ICU.IELSR26: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR26_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR26_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR26_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR26_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR26_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR26_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR26.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR26_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR26.Reg, volatile.LoadUint32(&o.IELSR26.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR26_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR26.Reg) & 0xff
}

// ICU.IELSR27: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR27_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR27_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR27_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR27_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR27_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR27_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR27.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR27_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR27.Reg, volatile.LoadUint32(&o.IELSR27.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR27_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR27.Reg) & 0xff
}

// ICU.IELSR28: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR28_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR28_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR28_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR28_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR28_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR28_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR28.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR28_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR28.Reg, volatile.LoadUint32(&o.IELSR28.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR28_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR28.Reg) & 0xff
}

// ICU.IELSR29: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR29_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR29_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR29_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR29_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR29_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR29_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR29.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR29_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR29.Reg, volatile.LoadUint32(&o.IELSR29.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR29_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR29.Reg) & 0xff
}

// ICU.IELSR30: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR30_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR30_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR30_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR30_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR30_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR30_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR30.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR30_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR30.Reg, volatile.LoadUint32(&o.IELSR30.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR30_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR30.Reg) & 0xff
}

// ICU.IELSR31: ICU Event Link Setting Register %s
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xfe000000)|value<<25)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xfe000000) >> 25
}
func (o *ICU_Type) SetIELSR31_DTCE(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x1000000)|value<<24)
}
func (o *ICU_Type) GetIELSR31_DTCE() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x1000000) >> 24
}
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xfe0000)|value<<17)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xfe0000) >> 17
}
func (o *ICU_Type) SetIELSR31_IR(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0x10000)|value<<16)
}
func (o *ICU_Type) GetIELSR31_IR() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0x10000) >> 16
}
func (o *ICU_Type) SetIELSR31_Reserved(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xff00)|value<<8)
}
func (o *ICU_Type) GetIELSR31_Reserved() uint32 {
	return (volatile.LoadUint32(&o.IELSR31.Reg) & 0xff00) >> 8
}
func (o *ICU_Type) SetIELSR31_IELS(value uint32) {
	volatile.StoreUint32(&o.IELSR31.Reg, volatile.LoadUint32(&o.IELSR31.Reg)&^(0xff)|value)
}
func (o *ICU_Type) GetIELSR31_IELS() uint32 {
	return volatile.LoadUint32(&o.IELSR31.Reg) & 0xff
}

// System Control
type SYSTEM_Type struct {
	_         [12]byte
	SBYCR     volatile.Register16 // 0xC
	_         [14]byte
	MSTPCRA   volatile.Register32 // 0x1C
	SCKDIVCR  volatile.Register32 // 0x20
	_         [2]byte
	SCKSCR    volatile.Register8 // 0x26
	_         [10]byte
	MEMWAIT   volatile.Register8 // 0x31
	MOSCCR    volatile.Register8 // 0x32
	_         [3]byte
	HOCOCR    volatile.Register8 // 0x36
	_         byte
	MOCOCR    volatile.Register8 // 0x38
	_         [3]byte
	OSCSF     volatile.Register8 // 0x3C
	_         byte
	CKOCR     volatile.Register8 // 0x3E
	_         byte
	OSTDCR    volatile.Register8 // 0x40
	OSTDSR    volatile.Register8 // 0x41
	_         [31]byte
	MOCOUTCR  volatile.Register8 // 0x61
	HOCOUTCR  volatile.Register8 // 0x62
	_         [47]byte
	SNZCR     volatile.Register8 // 0x92
	_         byte
	SNZEDCR   volatile.Register8 // 0x94
	_         [3]byte
	SNZREQCR  volatile.Register32 // 0x98
	_         [2]byte
	FLSTOP    volatile.Register8 // 0x9E
	_         byte
	OPCCR     volatile.Register8 // 0xA0
	_         byte
	MOSCWTCR  volatile.Register8 // 0xA2
	_         [2]byte
	HOCOWTCR  volatile.Register8 // 0xA5
	_         [4]byte
	SOPCCR    volatile.Register8 // 0xAA
	_         [21]byte
	RSTSR1    volatile.Register16 // 0xC0
	_         [15]byte
	SDADCCKCR volatile.Register8 // 0xD1
	_         [14]byte
	LVD1CR1   volatile.Register8 // 0xE0
	LVD1SR    volatile.Register8 // 0xE1
	LVD2CR1   volatile.Register8 // 0xE2
	LVD2SR    volatile.Register8 // 0xE3
	_         [794]byte
	PRCR      volatile.Register16 // 0x3FE
	_         [14]byte
	SYOCDCR   volatile.Register8 // 0x40E
	_         byte
	RSTSR0    volatile.Register8 // 0x410
	RSTSR2    volatile.Register8 // 0x411
	_         byte
	MOMCR     volatile.Register8 // 0x413
	_         [3]byte
	LVCMPCR   volatile.Register8 // 0x417
	LVDLVLR   volatile.Register8 // 0x418
	_         byte
	LVD1CR0   volatile.Register8 // 0x41A
	LVD2CR0   volatile.Register8 // 0x41B
	_         [100]byte
	SOSCCR    volatile.Register8 // 0x480
	SOMCR     volatile.Register8 // 0x481
	_         [14]byte
	LOCOCR    volatile.Register8 // 0x490
	_         byte
	LOCOUTCR  volatile.Register8 // 0x492
}

// SYSTEM.SBYCR: Standby Control Register
func (o *SYSTEM_Type) SetSBYCR_SSBY(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x8000)|value<<15)
}
func (o *SYSTEM_Type) GetSBYCR_SSBY() uint16 {
	return (volatile.LoadUint16(&o.SBYCR.Reg) & 0x8000) >> 15
}
func (o *SYSTEM_Type) SetSBYCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.SBYCR.Reg, volatile.LoadUint16(&o.SBYCR.Reg)&^(0x7fff)|value)
}
func (o *SYSTEM_Type) GetSBYCR_Reserved() uint16 {
	return volatile.LoadUint16(&o.SBYCR.Reg) & 0x7fff
}

// SYSTEM.MSTPCRA: Module Stop Control Register A
func (o *SYSTEM_Type) SetMSTPCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0xff800000)|value<<23)
}
func (o *SYSTEM_Type) GetMSTPCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0xff800000) >> 23
}
func (o *SYSTEM_Type) SetMSTPCRA_MSTPA22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x400000)|value<<22)
}
func (o *SYSTEM_Type) GetMSTPCRA_MSTPA22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x400000) >> 22
}
func (o *SYSTEM_Type) SetMSTPCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRA.Reg, volatile.LoadUint32(&o.MSTPCRA.Reg)&^(0x3fffff)|value)
}
func (o *SYSTEM_Type) GetMSTPCRA_Reserved() uint32 {
	return volatile.LoadUint32(&o.MSTPCRA.Reg) & 0x3fffff
}

// SYSTEM.SCKDIVCR: System Clock Division Control Register
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x80000000) >> 31
}
func (o *SYSTEM_Type) SetSCKDIVCR_FCK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x70000000)|value<<28)
}
func (o *SYSTEM_Type) GetSCKDIVCR_FCK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x70000000) >> 28
}
func (o *SYSTEM_Type) SetSCKDIVCR_ICK(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7000000)|value<<24)
}
func (o *SYSTEM_Type) GetSCKDIVCR_ICK() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7000000) >> 24
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0xfff800)|value<<11)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0xfff800) >> 11
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKB(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x700)|value<<8)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKB() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x700) >> 8
}
func (o *SYSTEM_Type) SetSCKDIVCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetSCKDIVCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetSCKDIVCR_PCKD(value uint32) {
	volatile.StoreUint32(&o.SCKDIVCR.Reg, volatile.LoadUint32(&o.SCKDIVCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKDIVCR_PCKD() uint32 {
	return volatile.LoadUint32(&o.SCKDIVCR.Reg) & 0x7
}

// SYSTEM.SCKSCR: System Clock Source Control Register
func (o *SYSTEM_Type) SetSCKSCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetSCKSCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SCKSCR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetSCKSCR_CKSEL(value uint8) {
	volatile.StoreUint8(&o.SCKSCR.Reg, volatile.LoadUint8(&o.SCKSCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetSCKSCR_CKSEL() uint8 {
	return volatile.LoadUint8(&o.SCKSCR.Reg) & 0x7
}

// SYSTEM.MEMWAIT: Memory Wait Cycle Control Register
func (o *SYSTEM_Type) SetMEMWAIT_Reserved(value uint8) {
	volatile.StoreUint8(&o.MEMWAIT.Reg, volatile.LoadUint8(&o.MEMWAIT.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMEMWAIT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MEMWAIT.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMEMWAIT(value uint8) {
	volatile.StoreUint8(&o.MEMWAIT.Reg, volatile.LoadUint8(&o.MEMWAIT.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMEMWAIT() uint8 {
	return volatile.LoadUint8(&o.MEMWAIT.Reg) & 0x1
}

// SYSTEM.MOSCCR: Main Clock Oscillator Control Register
func (o *SYSTEM_Type) SetMOSCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMOSCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOSCCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMOSCCR_MOSTP(value uint8) {
	volatile.StoreUint8(&o.MOSCCR.Reg, volatile.LoadUint8(&o.MOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOSCCR_MOSTP() uint8 {
	return volatile.LoadUint8(&o.MOSCCR.Reg) & 0x1
}

// SYSTEM.HOCOCR: High-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetHOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetHOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.HOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetHOCOCR_HCSTP(value uint8) {
	volatile.StoreUint8(&o.HOCOCR.Reg, volatile.LoadUint8(&o.HOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetHOCOCR_HCSTP() uint8 {
	return volatile.LoadUint8(&o.HOCOCR.Reg) & 0x1
}

// SYSTEM.MOCOCR: Middle-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetMOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetMOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetMOCOCR_MCSTP(value uint8) {
	volatile.StoreUint8(&o.MOCOCR.Reg, volatile.LoadUint8(&o.MOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetMOCOCR_MCSTP() uint8 {
	return volatile.LoadUint8(&o.MOCOCR.Reg) & 0x1
}

// SYSTEM.OSCSF: Oscillation Stabilization Flag Register
func (o *SYSTEM_Type) SetOSCSF_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetOSCSF_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetOSCSF_MOSCSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetOSCSF_MOSCSF() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetOSCSF_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x6)|value<<1)
}
func (o *SYSTEM_Type) GetOSCSF_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSCSF.Reg) & 0x6) >> 1
}
func (o *SYSTEM_Type) SetOSCSF_HOCOSF(value uint8) {
	volatile.StoreUint8(&o.OSCSF.Reg, volatile.LoadUint8(&o.OSCSF.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSCSF_HOCOSF() uint8 {
	return volatile.LoadUint8(&o.OSCSF.Reg) & 0x1
}

// SYSTEM.CKOCR: Clock Out Control Register
func (o *SYSTEM_Type) SetCKOCR_CKOEN(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetCKOCR_CKOEN() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetCKOCR_CKODIV(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x70)|value<<4)
}
func (o *SYSTEM_Type) GetCKOCR_CKODIV() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x70) >> 4
}
func (o *SYSTEM_Type) SetCKOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetCKOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.CKOCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetCKOCR_CKOSEL(value uint8) {
	volatile.StoreUint8(&o.CKOCR.Reg, volatile.LoadUint8(&o.CKOCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetCKOCR_CKOSEL() uint8 {
	return volatile.LoadUint8(&o.CKOCR.Reg) & 0x7
}

// SYSTEM.OSTDCR: Oscillation Stop Detection Control Register
func (o *SYSTEM_Type) SetOSTDCR_OSTDE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDE() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetOSTDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x7e)|value<<1)
}
func (o *SYSTEM_Type) GetOSTDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSTDCR.Reg) & 0x7e) >> 1
}
func (o *SYSTEM_Type) SetOSTDCR_OSTDIE(value uint8) {
	volatile.StoreUint8(&o.OSTDCR.Reg, volatile.LoadUint8(&o.OSTDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDCR_OSTDIE() uint8 {
	return volatile.LoadUint8(&o.OSTDCR.Reg) & 0x1
}

// SYSTEM.OSTDSR: Oscillation Stop Detection Status Register
func (o *SYSTEM_Type) SetOSTDSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetOSTDSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OSTDSR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetOSTDSR_OSTDF(value uint8) {
	volatile.StoreUint8(&o.OSTDSR.Reg, volatile.LoadUint8(&o.OSTDSR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetOSTDSR_OSTDF() uint8 {
	return volatile.LoadUint8(&o.OSTDSR.Reg) & 0x1
}

// SYSTEM.MOCOUTCR: MOCO User Trimming Control Register
func (o *SYSTEM_Type) SetMOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.MOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetMOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.MOCOUTCR.Reg)
}

// SYSTEM.HOCOUTCR: HOCO User Trimming Control Register
func (o *SYSTEM_Type) SetHOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.HOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetHOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.HOCOUTCR.Reg)
}

// SYSTEM.SNZCR: Snooze Control Register
func (o *SYSTEM_Type) SetSNZCR_SNZE(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZCR_SNZE() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x7c)|value<<2)
}
func (o *SYSTEM_Type) GetSNZCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x7c) >> 2
}
func (o *SYSTEM_Type) SetSNZCR_SNZDTCEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZCR_SNZDTCEN() uint8 {
	return (volatile.LoadUint8(&o.SNZCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZCR_RXDREQEN(value uint8) {
	volatile.StoreUint8(&o.SNZCR.Reg, volatile.LoadUint8(&o.SNZCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZCR_RXDREQEN() uint8 {
	return volatile.LoadUint8(&o.SNZCR.Reg) & 0x1
}

// SYSTEM.SNZEDCR: Snooze End Control Register
func (o *SYSTEM_Type) SetSNZEDCR_SCI0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZEDCR_SCI0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZEDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x60)|value<<5)
}
func (o *SYSTEM_Type) GetSNZEDCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x60) >> 5
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0UMTED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0UMTED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZEDCR_AD0MATED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZEDCR_AD0MATED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCNZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCNZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZEDCR_DTCZRED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZEDCR_DTCZRED() uint8 {
	return (volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZEDCR_AGTUNFED(value uint8) {
	volatile.StoreUint8(&o.SNZEDCR.Reg, volatile.LoadUint8(&o.SNZEDCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZEDCR_AGTUNFED() uint8 {
	return volatile.LoadUint8(&o.SNZEDCR.Reg) & 0x1
}

// SYSTEM.SNZREQCR: Snooze Request Control Register
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x80000000)|value<<31)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x80000000) >> 31
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN30(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40000000)|value<<30)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN30() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40000000) >> 30
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN29(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000000)|value<<29)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN29() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000000) >> 29
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN28(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10000000)|value<<28)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN28() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10000000) >> 28
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0xc000000)|value<<26)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0xc000000) >> 26
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN25(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2000000)|value<<25)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN25() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2000000) >> 25
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN24(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1000000)|value<<24)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN24() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1000000) >> 24
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN23(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x800000)|value<<23)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN23() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x800000) >> 23
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x7c0000)|value<<18)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x7c0000) >> 18
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN17(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20000)|value<<17)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN17() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20000) >> 17
}
func (o *SYSTEM_Type) SetSNZREQCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1ff00)|value<<8)
}
func (o *SYSTEM_Type) GetSNZREQCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1ff00) >> 8
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN7(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN7() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN6(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN6() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN5(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN5() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN4(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN4() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN3(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN3() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN2(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN2() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN1(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN1() uint32 {
	return (volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetSNZREQCR_SNZREQEN0(value uint32) {
	volatile.StoreUint32(&o.SNZREQCR.Reg, volatile.LoadUint32(&o.SNZREQCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSNZREQCR_SNZREQEN0() uint32 {
	return volatile.LoadUint32(&o.SNZREQCR.Reg) & 0x1
}

// SYSTEM.FLSTOP: Flash Operation Control Register
func (o *SYSTEM_Type) SetFLSTOP_Reserved(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetFLSTOP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetFLSTOP_FLSTPF(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetFLSTOP_FLSTPF() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetFLSTOP_Reserved(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0xe)|value<<1)
}
func (o *SYSTEM_Type) GetFLSTOP_Reserved() uint8 {
	return (volatile.LoadUint8(&o.FLSTOP.Reg) & 0xe) >> 1
}
func (o *SYSTEM_Type) SetFLSTOP(value uint8) {
	volatile.StoreUint8(&o.FLSTOP.Reg, volatile.LoadUint8(&o.FLSTOP.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetFLSTOP() uint8 {
	return volatile.LoadUint8(&o.FLSTOP.Reg) & 0x1
}

// SYSTEM.OPCCR: Operating Power Control Register
func (o *SYSTEM_Type) SetOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetOPCCR_OPCMTSF(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetOPCCR_OPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0xc)|value<<2)
}
func (o *SYSTEM_Type) GetOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.OPCCR.Reg) & 0xc) >> 2
}
func (o *SYSTEM_Type) SetOPCCR_OPCM(value uint8) {
	volatile.StoreUint8(&o.OPCCR.Reg, volatile.LoadUint8(&o.OPCCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetOPCCR_OPCM() uint8 {
	return volatile.LoadUint8(&o.OPCCR.Reg) & 0x3
}

// SYSTEM.MOSCWTCR: Main Clock Oscillator Wait Control Register
func (o *SYSTEM_Type) SetMOSCWTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetMOSCWTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetMOSCWTCR_MSTS(value uint8) {
	volatile.StoreUint8(&o.MOSCWTCR.Reg, volatile.LoadUint8(&o.MOSCWTCR.Reg)&^(0xf)|value)
}
func (o *SYSTEM_Type) GetMOSCWTCR_MSTS() uint8 {
	return volatile.LoadUint8(&o.MOSCWTCR.Reg) & 0xf
}

// SYSTEM.HOCOWTCR: High-Speed On-Chip Oscillator Wait Control Register
func (o *SYSTEM_Type) SetHOCOWTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.HOCOWTCR.Reg, volatile.LoadUint8(&o.HOCOWTCR.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetHOCOWTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.HOCOWTCR.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetHOCOWTCR_HSTS(value uint8) {
	volatile.StoreUint8(&o.HOCOWTCR.Reg, volatile.LoadUint8(&o.HOCOWTCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetHOCOWTCR_HSTS() uint8 {
	return volatile.LoadUint8(&o.HOCOWTCR.Reg) & 0x7
}

// SYSTEM.SOPCCR: Sub Operating Power Control Register
func (o *SYSTEM_Type) SetSOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetSOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetSOPCCR_SOPCMTSF(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x10)|value<<4)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCMTSF() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0x10) >> 4
}
func (o *SYSTEM_Type) SetSOPCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0xe)|value<<1)
}
func (o *SYSTEM_Type) GetSOPCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOPCCR.Reg) & 0xe) >> 1
}
func (o *SYSTEM_Type) SetSOPCCR_SOPCM(value uint8) {
	volatile.StoreUint8(&o.SOPCCR.Reg, volatile.LoadUint8(&o.SOPCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOPCCR_SOPCM() uint8 {
	return volatile.LoadUint8(&o.SOPCCR.Reg) & 0x1
}

// SYSTEM.RSTSR1: Reset Status Register 1
func (o *SYSTEM_Type) SetRSTSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0xe000)|value<<13)
}
func (o *SYSTEM_Type) GetRSTSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0xe000) >> 13
}
func (o *SYSTEM_Type) SetRSTSR1_SPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1000)|value<<12)
}
func (o *SYSTEM_Type) GetRSTSR1_SPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1000) >> 12
}
func (o *SYSTEM_Type) SetRSTSR1_BUSMRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x800)|value<<11)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSMRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x800) >> 11
}
func (o *SYSTEM_Type) SetRSTSR1_BUSSRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x400)|value<<10)
}
func (o *SYSTEM_Type) GetRSTSR1_BUSSRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x400) >> 10
}
func (o *SYSTEM_Type) SetRSTSR1_REERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x200)|value<<9)
}
func (o *SYSTEM_Type) GetRSTSR1_REERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x200) >> 9
}
func (o *SYSTEM_Type) SetRSTSR1_RPERF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x100)|value<<8)
}
func (o *SYSTEM_Type) GetRSTSR1_RPERF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x100) >> 8
}
func (o *SYSTEM_Type) SetRSTSR1_Reserved(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetRSTSR1_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetRSTSR1_SWRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR1_SWRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR1_WDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR1_WDTRF() uint16 {
	return (volatile.LoadUint16(&o.RSTSR1.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR1_IWDTRF(value uint16) {
	volatile.StoreUint16(&o.RSTSR1.Reg, volatile.LoadUint16(&o.RSTSR1.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR1_IWDTRF() uint16 {
	return volatile.LoadUint16(&o.RSTSR1.Reg) & 0x1
}

// SYSTEM.SDADCCKCR: 24-bit Sigma-Delta A/D Converter Clock Control Register
func (o *SYSTEM_Type) SetSDADCCKCR_SDADCCKEN(value uint8) {
	volatile.StoreUint8(&o.SDADCCKCR.Reg, volatile.LoadUint8(&o.SDADCCKCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSDADCCKCR_SDADCCKEN() uint8 {
	return (volatile.LoadUint8(&o.SDADCCKCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSDADCCKCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SDADCCKCR.Reg, volatile.LoadUint8(&o.SDADCCKCR.Reg)&^(0x7e)|value<<1)
}
func (o *SYSTEM_Type) GetSDADCCKCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SDADCCKCR.Reg) & 0x7e) >> 1
}
func (o *SYSTEM_Type) SetSDADCCKCR_SDADCCKSEL(value uint8) {
	volatile.StoreUint8(&o.SDADCCKCR.Reg, volatile.LoadUint8(&o.SDADCCKCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSDADCCKCR_SDADCCKSEL() uint8 {
	return volatile.LoadUint8(&o.SDADCCKCR.Reg) & 0x1
}

// SYSTEM.LVD1CR1: Voltage Monitor 1 Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD1CR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetLVD1CR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetLVD1CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD1CR1.Reg, volatile.LoadUint8(&o.LVD1CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD1CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD1CR1.Reg) & 0x3
}

// SYSTEM.LVD1SR: Voltage Monitor 1 Circuit Status Register
func (o *SYSTEM_Type) SetLVD1SR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1SR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetLVD1SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD1SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD1SR.Reg, volatile.LoadUint8(&o.LVD1SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD1SR.Reg) & 0x1
}

// SYSTEM.LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
func (o *SYSTEM_Type) SetLVD2CR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0xf8)|value<<3)
}
func (o *SYSTEM_Type) GetLVD2CR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0xf8) >> 3
}
func (o *SYSTEM_Type) SetLVD2CR1_IRQSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR1_IRQSEL() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR1_IDTSEL(value uint8) {
	volatile.StoreUint8(&o.LVD2CR1.Reg, volatile.LoadUint8(&o.LVD2CR1.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetLVD2CR1_IDTSEL() uint8 {
	return volatile.LoadUint8(&o.LVD2CR1.Reg) & 0x3
}

// SYSTEM.LVD2SR: Voltage Monitor 2 Circuit Status Register
func (o *SYSTEM_Type) SetLVD2SR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2SR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetLVD2SR_MON(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2SR_MON() uint8 {
	return (volatile.LoadUint8(&o.LVD2SR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2SR_DET(value uint8) {
	volatile.StoreUint8(&o.LVD2SR.Reg, volatile.LoadUint8(&o.LVD2SR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2SR_DET() uint8 {
	return volatile.LoadUint8(&o.LVD2SR.Reg) & 0x1
}

// SYSTEM.PRCR: Protect Register
func (o *SYSTEM_Type) SetPRCR_PRKEY(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xff00)|value<<8)
}
func (o *SYSTEM_Type) GetPRCR_PRKEY() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xff00) >> 8
}
func (o *SYSTEM_Type) SetPRCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetPRCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetPRCR_PRC3(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetPRCR_PRC3() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetPRCR_Reserved(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetPRCR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetPRCR_PRC1(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetPRCR_PRC1() uint16 {
	return (volatile.LoadUint16(&o.PRCR.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetPRCR_PRC0(value uint16) {
	volatile.StoreUint16(&o.PRCR.Reg, volatile.LoadUint16(&o.PRCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetPRCR_PRC0() uint16 {
	return volatile.LoadUint16(&o.PRCR.Reg) & 0x1
}

// SYSTEM.SYOCDCR: System Control OCD Control Register
func (o *SYSTEM_Type) SetSYOCDCR_DBGEN(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetSYOCDCR_DBGEN() uint8 {
	return (volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetSYOCDCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SYOCDCR.Reg, volatile.LoadUint8(&o.SYOCDCR.Reg)&^(0x7f)|value)
}
func (o *SYSTEM_Type) GetSYOCDCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.SYOCDCR.Reg) & 0x7f
}

// SYSTEM.RSTSR0: Reset Status Register 0
func (o *SYSTEM_Type) SetRSTSR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0xf0)|value<<4)
}
func (o *SYSTEM_Type) GetRSTSR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0xf0) >> 4
}
func (o *SYSTEM_Type) SetRSTSR0_LVD2RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD2RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetRSTSR0_LVD1RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD1RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetRSTSR0_LVD0RF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR0_LVD0RF() uint8 {
	return (volatile.LoadUint8(&o.RSTSR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetRSTSR0_PORF(value uint8) {
	volatile.StoreUint8(&o.RSTSR0.Reg, volatile.LoadUint8(&o.RSTSR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR0_PORF() uint8 {
	return volatile.LoadUint8(&o.RSTSR0.Reg) & 0x1
}

// SYSTEM.RSTSR2: Reset Status Register 2
func (o *SYSTEM_Type) SetRSTSR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetRSTSR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RSTSR2.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetRSTSR2_CWSF(value uint8) {
	volatile.StoreUint8(&o.RSTSR2.Reg, volatile.LoadUint8(&o.RSTSR2.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetRSTSR2_CWSF() uint8 {
	return volatile.LoadUint8(&o.RSTSR2.Reg) & 0x1
}

// SYSTEM.MOMCR: Main Clock Oscillator Mode Oscillation Control Register
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetMOMCR_MOSEL(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetMOMCR_MOSEL() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x30)|value<<4)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x30) >> 4
}
func (o *SYSTEM_Type) SetMOMCR_MODRV1(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x8)|value<<3)
}
func (o *SYSTEM_Type) GetMOMCR_MODRV1() uint8 {
	return (volatile.LoadUint8(&o.MOMCR.Reg) & 0x8) >> 3
}
func (o *SYSTEM_Type) SetMOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.MOMCR.Reg, volatile.LoadUint8(&o.MOMCR.Reg)&^(0x7)|value)
}
func (o *SYSTEM_Type) GetMOMCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.MOMCR.Reg) & 0x7
}

// SYSTEM.LVCMPCR: Voltage Monitor Circuit Control Register
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVCMPCR_LVD2E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD2E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVCMPCR_LVD1E(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x20)|value<<5)
}
func (o *SYSTEM_Type) GetLVCMPCR_LVD1E() uint8 {
	return (volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x20) >> 5
}
func (o *SYSTEM_Type) SetLVCMPCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVCMPCR.Reg, volatile.LoadUint8(&o.LVCMPCR.Reg)&^(0x1f)|value)
}
func (o *SYSTEM_Type) GetLVCMPCR_Reserved() uint8 {
	return volatile.LoadUint8(&o.LVCMPCR.Reg) & 0x1f
}

// SYSTEM.LVDLVLR: Voltage Detection Level Select Register
func (o *SYSTEM_Type) SetLVDLVLR_LVD2LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0xe0)|value<<5)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD2LVL() uint8 {
	return (volatile.LoadUint8(&o.LVDLVLR.Reg) & 0xe0) >> 5
}
func (o *SYSTEM_Type) SetLVDLVLR_LVD1LVL(value uint8) {
	volatile.StoreUint8(&o.LVDLVLR.Reg, volatile.LoadUint8(&o.LVDLVLR.Reg)&^(0x1f)|value)
}
func (o *SYSTEM_Type) GetLVDLVLR_LVD1LVL() uint8 {
	return volatile.LoadUint8(&o.LVDLVLR.Reg) & 0x1f
}

// SYSTEM.LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD1CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD1CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD1CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD1CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD1CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x38)|value<<3)
}
func (o *SYSTEM_Type) GetLVD1CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x38) >> 3
}
func (o *SYSTEM_Type) SetLVD1CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD1CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD1CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD1CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD1CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD1CR0.Reg, volatile.LoadUint8(&o.LVD1CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD1CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD1CR0.Reg) & 0x1
}

// SYSTEM.LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
func (o *SYSTEM_Type) SetLVD2CR0_RN(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x80)|value<<7)
}
func (o *SYSTEM_Type) GetLVD2CR0_RN() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x80) >> 7
}
func (o *SYSTEM_Type) SetLVD2CR0_RI(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x40)|value<<6)
}
func (o *SYSTEM_Type) GetLVD2CR0_RI() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x40) >> 6
}
func (o *SYSTEM_Type) SetLVD2CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x38)|value<<3)
}
func (o *SYSTEM_Type) GetLVD2CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x38) >> 3
}
func (o *SYSTEM_Type) SetLVD2CR0_CMPE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x4)|value<<2)
}
func (o *SYSTEM_Type) GetLVD2CR0_CMPE() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x4) >> 2
}
func (o *SYSTEM_Type) SetLVD2CR0_Reserved(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x2)|value<<1)
}
func (o *SYSTEM_Type) GetLVD2CR0_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x2) >> 1
}
func (o *SYSTEM_Type) SetLVD2CR0_RIE(value uint8) {
	volatile.StoreUint8(&o.LVD2CR0.Reg, volatile.LoadUint8(&o.LVD2CR0.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLVD2CR0_RIE() uint8 {
	return volatile.LoadUint8(&o.LVD2CR0.Reg) & 0x1
}

// SYSTEM.SOSCCR: Sub-clock Oscillator Control Register
func (o *SYSTEM_Type) SetSOSCCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetSOSCCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOSCCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetSOSCCR_SOSTP(value uint8) {
	volatile.StoreUint8(&o.SOSCCR.Reg, volatile.LoadUint8(&o.SOSCCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetSOSCCR_SOSTP() uint8 {
	return volatile.LoadUint8(&o.SOSCCR.Reg) & 0x1
}

// SYSTEM.SOMCR: Sub-clock Oscillator Mode Control Register
func (o *SYSTEM_Type) SetSOMCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0xfc)|value<<2)
}
func (o *SYSTEM_Type) GetSOMCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.SOMCR.Reg) & 0xfc) >> 2
}
func (o *SYSTEM_Type) SetSOMCR_SODRV(value uint8) {
	volatile.StoreUint8(&o.SOMCR.Reg, volatile.LoadUint8(&o.SOMCR.Reg)&^(0x3)|value)
}
func (o *SYSTEM_Type) GetSOMCR_SODRV() uint8 {
	return volatile.LoadUint8(&o.SOMCR.Reg) & 0x3
}

// SYSTEM.LOCOCR: Low-Speed On-Chip Oscillator Control Register
func (o *SYSTEM_Type) SetLOCOCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0xfe)|value<<1)
}
func (o *SYSTEM_Type) GetLOCOCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.LOCOCR.Reg) & 0xfe) >> 1
}
func (o *SYSTEM_Type) SetLOCOCR_LCSTP(value uint8) {
	volatile.StoreUint8(&o.LOCOCR.Reg, volatile.LoadUint8(&o.LOCOCR.Reg)&^(0x1)|value)
}
func (o *SYSTEM_Type) GetLOCOCR_LCSTP() uint8 {
	return volatile.LoadUint8(&o.LOCOCR.Reg) & 0x1
}

// SYSTEM.LOCOUTCR: LOCO User Trimming Control Register
func (o *SYSTEM_Type) SetLOCOUTCR(value uint8) {
	volatile.StoreUint8(&o.LOCOUTCR.Reg, value)
}
func (o *SYSTEM_Type) GetLOCOUTCR() uint8 {
	return volatile.LoadUint8(&o.LOCOUTCR.Reg)
}

// Module Stop Control B,C,D
type MSTP_Type struct {
	MSTPCRB volatile.Register32 // 0x0
	MSTPCRC volatile.Register32 // 0x4
	MSTPCRD volatile.Register32 // 0x8
}

// MSTP.MSTPCRB: Module Stop Control Register B
func (o *MSTP_Type) SetMSTPCRB_MSTPB31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB30(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB30() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x3f800000)|value<<23)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x3f800000) >> 23
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB22(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400000)|value<<22)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB22() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400000) >> 22
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x300000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x300000) >> 20
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB18(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB18() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x3f000)|value<<12)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x3f000) >> 12
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB11(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x800)|value<<11)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB11() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x800) >> 11
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x400)|value<<10)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x400) >> 10
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB9(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x200)|value<<9)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB9() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x200) >> 9
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB8(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x100)|value<<8)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB8() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x100) >> 8
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0xf8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0xf8) >> 3
}
func (o *MSTP_Type) SetMSTPCRB_MSTPB2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRB_MSTPB2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRB.Reg, volatile.LoadUint32(&o.MSTPCRB.Reg)&^(0x3)|value)
}
func (o *MSTP_Type) GetMSTPCRB_Reserved() uint32 {
	return volatile.LoadUint32(&o.MSTPCRB.Reg) & 0x3
}

// MSTP.MSTPCRC: Module Stop Control Register C
func (o *MSTP_Type) SetMSTPCRC_MSTPC31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x60000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x60000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0xfff8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0xfff8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC13(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2000)|value<<13)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC13() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2000) >> 13
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1ff0)|value<<4)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1ff0) >> 4
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC1(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x2)|value<<1)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC1() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x2) >> 1
}
func (o *MSTP_Type) SetMSTPCRC_MSTPC0(value uint32) {
	volatile.StoreUint32(&o.MSTPCRC.Reg, volatile.LoadUint32(&o.MSTPCRC.Reg)&^(0x1)|value)
}
func (o *MSTP_Type) GetMSTPCRC_MSTPC0() uint32 {
	return volatile.LoadUint32(&o.MSTPCRC.Reg) & 0x1
}

// MSTP.MSTPCRD: Module Stop Control Register D
func (o *MSTP_Type) SetMSTPCRD_MSTPD31(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x80000000)|value<<31)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD31() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x80000000) >> 31
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40000000)|value<<30)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40000000) >> 30
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD29(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20000000)|value<<29)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD29() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20000000) >> 29
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD28(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000000)|value<<28)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD28() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000000) >> 28
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0xfe00000)|value<<21)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0xfe00000) >> 21
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD20(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x100000)|value<<20)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD20() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x100000) >> 20
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD19(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x80000)|value<<19)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD19() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x80000) >> 19
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40000)|value<<18)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40000) >> 18
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD17(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20000)|value<<17)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD17() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20000) >> 17
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD16(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10000)|value<<16)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD16() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10000) >> 16
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8000)|value<<15)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8000) >> 15
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD14(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4000)|value<<14)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD14() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4000) >> 14
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x3f80)|value<<7)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x3f80) >> 7
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD6(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x40)|value<<6)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD6() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x40) >> 6
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD5(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x20)|value<<5)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD5() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x20) >> 5
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x10)|value<<4)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x10) >> 4
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD3(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x8)|value<<3)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD3() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x8) >> 3
}
func (o *MSTP_Type) SetMSTPCRD_MSTPD2(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x4)|value<<2)
}
func (o *MSTP_Type) GetMSTPCRD_MSTPD2() uint32 {
	return (volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x4) >> 2
}
func (o *MSTP_Type) SetMSTPCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.MSTPCRD.Reg, volatile.LoadUint32(&o.MSTPCRD.Reg)&^(0x3)|value)
}
func (o *MSTP_Type) GetMSTPCRD_Reserved() uint32 {
	return volatile.LoadUint32(&o.MSTPCRD.Reg) & 0x3
}

// Asynchronous General purpose Timer 0
type AGT0_Type struct {
	AGT      volatile.Register16 // 0x0
	AGTCMA   volatile.Register16 // 0x2
	AGTCMB   volatile.Register16 // 0x4
	_        [2]byte
	AGTCR    volatile.Register8 // 0x8
	AGTMR1   volatile.Register8 // 0x9
	AGTMR2   volatile.Register8 // 0xA
	_        byte
	AGTIOC   volatile.Register8 // 0xC
	AGTISR   volatile.Register8 // 0xD
	AGTCMSR  volatile.Register8 // 0xE
	AGTIOSEL volatile.Register8 // 0xF
}

// AGT0.AGT: AGT Counter Register
func (o *AGT0_Type) SetAGT(value uint16) {
	volatile.StoreUint16(&o.AGT.Reg, value)
}
func (o *AGT0_Type) GetAGT() uint16 {
	return volatile.LoadUint16(&o.AGT.Reg)
}

// AGT0.AGTCMA: AGT Compare Match A Register
func (o *AGT0_Type) SetAGTCMA(value uint16) {
	volatile.StoreUint16(&o.AGTCMA.Reg, value)
}
func (o *AGT0_Type) GetAGTCMA() uint16 {
	return volatile.LoadUint16(&o.AGTCMA.Reg)
}

// AGT0.AGTCMB: AGT Compare Match B Register
func (o *AGT0_Type) SetAGTCMB(value uint16) {
	volatile.StoreUint16(&o.AGTCMB.Reg, value)
}
func (o *AGT0_Type) GetAGTCMB() uint16 {
	return volatile.LoadUint16(&o.AGTCMB.Reg)
}

// AGT0.AGTCR: AGT Control Register
func (o *AGT0_Type) SetAGTCR_TCMBF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCR_TCMBF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTCR_TCMAF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCR_TCMAF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCR_TUNDF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCR_TUNDF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCR_TEDGF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCR_TEDGF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTCR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTCR_TSTOP(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCR_TSTOP() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCR_TCSTF(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCR_TCSTF() uint8 {
	return (volatile.LoadUint8(&o.AGTCR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCR_TSTART(value uint8) {
	volatile.StoreUint8(&o.AGTCR.Reg, volatile.LoadUint8(&o.AGTCR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCR_TSTART() uint8 {
	return volatile.LoadUint8(&o.AGTCR.Reg) & 0x1
}

// AGT0.AGTMR1: AGT Mode Register 1
func (o *AGT0_Type) SetAGTMR1_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR1_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTMR1_TCK(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x70)|value<<4)
}
func (o *AGT0_Type) GetAGTMR1_TCK() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x70) >> 4
}
func (o *AGT0_Type) SetAGTMR1_TEDGPL(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTMR1_TEDGPL() uint8 {
	return (volatile.LoadUint8(&o.AGTMR1.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTMR1_TMOD(value uint8) {
	volatile.StoreUint8(&o.AGTMR1.Reg, volatile.LoadUint8(&o.AGTMR1.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR1_TMOD() uint8 {
	return volatile.LoadUint8(&o.AGTMR1.Reg) & 0x7
}

// AGT0.AGTMR2: AGT Mode Register 2
func (o *AGT0_Type) SetAGTMR2_LPM(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTMR2_LPM() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTMR2_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x78)|value<<3)
}
func (o *AGT0_Type) GetAGTMR2_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTMR2.Reg) & 0x78) >> 3
}
func (o *AGT0_Type) SetAGTMR2_CKS(value uint8) {
	volatile.StoreUint8(&o.AGTMR2.Reg, volatile.LoadUint8(&o.AGTMR2.Reg)&^(0x7)|value)
}
func (o *AGT0_Type) GetAGTMR2_CKS() uint8 {
	return volatile.LoadUint8(&o.AGTMR2.Reg) & 0x7
}

// AGT0.AGTIOC: AGT I/O Control Register
func (o *AGT0_Type) SetAGTIOC_TIOGT(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0xc0)|value<<6)
}
func (o *AGT0_Type) GetAGTIOC_TIOGT() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0xc0) >> 6
}
func (o *AGT0_Type) SetAGTIOC_TIPF(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x30)|value<<4)
}
func (o *AGT0_Type) GetAGTIOC_TIPF() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x30) >> 4
}
func (o *AGT0_Type) SetAGTIOC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTIOC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTIOC_TOE(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTIOC_TOE() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTIOC_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTIOC_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOC.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTIOC_TEDGSEL(value uint8) {
	volatile.StoreUint8(&o.AGTIOC.Reg, volatile.LoadUint8(&o.AGTIOC.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTIOC_TEDGSEL() uint8 {
	return volatile.LoadUint8(&o.AGTIOC.Reg) & 0x1
}

// AGT0.AGTISR: AGT Event Pin Select Register
func (o *AGT0_Type) SetAGTISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0xf8)|value<<3)
}
func (o *AGT0_Type) GetAGTISR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0xf8) >> 3
}
func (o *AGT0_Type) SetAGTISR_EEPS(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTISR_EEPS() uint8 {
	return (volatile.LoadUint8(&o.AGTISR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTISR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTISR.Reg, volatile.LoadUint8(&o.AGTISR.Reg)&^(0x3)|value)
}
func (o *AGT0_Type) GetAGTISR_Reserved() uint8 {
	return volatile.LoadUint8(&o.AGTISR.Reg) & 0x3
}

// AGT0.AGTCMSR: AGT Compare Match Function Select Register
func (o *AGT0_Type) SetAGTCMSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x80)|value<<7)
}
func (o *AGT0_Type) GetAGTCMSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x80) >> 7
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x40)|value<<6)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x40) >> 6
}
func (o *AGT0_Type) SetAGTCMSR_TOEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x20)|value<<5)
}
func (o *AGT0_Type) GetAGTCMSR_TOEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x20) >> 5
}
func (o *AGT0_Type) SetAGTCMSR_TCMEB(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEB() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTCMSR_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x8)|value<<3)
}
func (o *AGT0_Type) GetAGTCMSR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x8) >> 3
}
func (o *AGT0_Type) SetAGTCMSR_TOPOLA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x4)|value<<2)
}
func (o *AGT0_Type) GetAGTCMSR_TOPOLA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x4) >> 2
}
func (o *AGT0_Type) SetAGTCMSR_TOEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x2)|value<<1)
}
func (o *AGT0_Type) GetAGTCMSR_TOEA() uint8 {
	return (volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x2) >> 1
}
func (o *AGT0_Type) SetAGTCMSR_TCMEA(value uint8) {
	volatile.StoreUint8(&o.AGTCMSR.Reg, volatile.LoadUint8(&o.AGTCMSR.Reg)&^(0x1)|value)
}
func (o *AGT0_Type) GetAGTCMSR_TCMEA() uint8 {
	return volatile.LoadUint8(&o.AGTCMSR.Reg) & 0x1
}

// AGT0.AGTIOSEL: AGT Pin Select Register
func (o *AGT0_Type) SetAGTIOSEL_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0xe0)|value<<5)
}
func (o *AGT0_Type) GetAGTIOSEL_Reserved() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0xe0) >> 5
}
func (o *AGT0_Type) SetAGTIOSEL_TIES(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0x10)|value<<4)
}
func (o *AGT0_Type) GetAGTIOSEL_TIES() uint8 {
	return (volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0x10) >> 4
}
func (o *AGT0_Type) SetAGTIOSEL_Reserved(value uint8) {
	volatile.StoreUint8(&o.AGTIOSEL.Reg, volatile.LoadUint8(&o.AGTIOSEL.Reg)&^(0xf)|value)
}
func (o *AGT0_Type) GetAGTIOSEL_Reserved() uint8 {
	return volatile.LoadUint8(&o.AGTIOSEL.Reg) & 0xf
}

// General PWM Timer 0 (32-bit)
type GPT320_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT320.GTWP: General PWM Timer Write-Protection Register
func (o *GPT320_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT320_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xffff0000) >> 16
}
func (o *GPT320_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT320_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT320_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xfe)|value<<1)
}
func (o *GPT320_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xfe) >> 1
}
func (o *GPT320_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT320.GTSTR: General PWM Timer Software Start Register
func (o *GPT320_Type) SetGTSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT320_Type) GetGTSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0xffffff80) >> 7
}
func (o *GPT320_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT320.GTSTP: General PWM Timer Software Stop Register
func (o *GPT320_Type) SetGTSTP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT320_Type) GetGTSTP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0xffffff80) >> 7
}
func (o *GPT320_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT320.GTCLR: General PWM Timer Software Clear Register
func (o *GPT320_Type) SetGTCLR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT320_Type) GetGTCLR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0xffffff80) >> 7
}
func (o *GPT320_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT320.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT320_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT320_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT320_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT320.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT320_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT320_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT320_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT320.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT320_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT320_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT320_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT320_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT320_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT320_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0xf0) >> 4
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT320.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT320_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT320.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT320_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT320.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT320_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT320.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT320_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT320_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT320_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT320_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT320_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT320_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT320_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT320_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT320_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT320_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT320.GTCR: General PWM Timer Control Register
func (o *GPT320_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT320_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT320_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xf80000)|value<<19)
}
func (o *GPT320_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xf80000) >> 19
}
func (o *GPT320_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT320_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT320_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xfffe)|value<<1)
}
func (o *GPT320_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xfffe) >> 1
}
func (o *GPT320_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT320.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT320_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT320_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTUDDTYC_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0xf00000)|value<<20)
}
func (o *GPT320_Type) GetGTUDDTYC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0xf00000) >> 20
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT320_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT320_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT320.GTIOR: General PWM Timer I/O Control Register
func (o *GPT320_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT320_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT320_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x18000000)|value<<27)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x18000000) >> 27
}
func (o *GPT320_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT320_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT320_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT320_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT320_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x200000) >> 21
}
func (o *GPT320_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT320_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT320_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT320_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT320_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT320_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1800)|value<<11)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1800) >> 11
}
func (o *GPT320_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT320_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT320_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT320_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT320_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT320_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT320.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT320_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT320_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x1c000000)|value<<26)
}
func (o *GPT320_Type) GetGTINTAD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x1c000000) >> 26
}
func (o *GPT320_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT320_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT320_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0xffffff)|value)
}
func (o *GPT320_Type) GetGTINTAD_Reserved() uint32 {
	return volatile.LoadUint32(&o.GTINTAD.Reg) & 0xffffff
}

// GPT320.GTST: General PWM Timer Status Register
func (o *GPT320_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT320_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT320_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT320_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1e000000)|value<<25)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1e000000) >> 25
}
func (o *GPT320_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT320_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0xff0000)|value<<16)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0xff0000) >> 16
}
func (o *GPT320_Type) SetGTST_GTCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT320_Type) GetGTST_GTCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT320_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x7f00)|value<<8)
}
func (o *GPT320_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x7f00) >> 8
}
func (o *GPT320_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT320_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT320_Type) SetGTST_TCPFO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT320_Type) GetGTST_TCPFO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT320_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT320_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT320_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT320_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT320_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT320_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT320_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT320_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT320_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT320_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT320_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT320.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT320_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT320_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT320_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT320_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT320_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT320_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT320_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT320_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT320_Type) SetGTBER_BD(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x3)|value)
}
func (o *GPT320_Type) GetGTBER_BD() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x3
}

// GPT320.GTCNT: General PWM Timer Counter
func (o *GPT320_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT320_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT320.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT320_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, value)
}
func (o *GPT320_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg)
}

// GPT320.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT320_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, value)
}
func (o *GPT320_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg)
}

// GPT320.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT320_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, value)
}
func (o *GPT320_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg)
}

// GPT320.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT320_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, value)
}
func (o *GPT320_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg)
}

// GPT320.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT320_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, value)
}
func (o *GPT320_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg)
}

// GPT320.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT320_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, value)
}
func (o *GPT320_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg)
}

// GPT320.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT320_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, value)
}
func (o *GPT320_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg)
}

// GPT320.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT320_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, value)
}
func (o *GPT320_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg)
}

// GPT320.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT320_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xfffffffe)|value<<1)
}
func (o *GPT320_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xfffffffe) >> 1
}
func (o *GPT320_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT320_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT320.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT320_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, value)
}
func (o *GPT320_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg)
}

// Output Phase Switching Controller
type GPT_OPS_Type struct {
	OPSCR volatile.Register32 // 0x0
}

// GPT_OPS.OPSCR: Output Phase Switching Control Register
func (o *GPT_OPS_Type) SetOPSCR_NFCS(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT_OPS_Type) GetOPSCR_NFCS() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc0000000) >> 30
}
func (o *GPT_OPS_Type) SetOPSCR_NFEN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT_OPS_Type) GetOPSCR_NFEN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000000) >> 29
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10000000)|value<<28)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10000000) >> 28
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x8000000) >> 27
}
func (o *GPT_OPS_Type) SetOPSCR_GODF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT_OPS_Type) GetOPSCR_GODF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4000000) >> 26
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x2000000)|value<<25)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x2000000) >> 25
}
func (o *GPT_OPS_Type) SetOPSCR_GRP(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT_OPS_Type) GetOPSCR_GRP() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x1000000) >> 24
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xc00000)|value<<22)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xc00000) >> 22
}
func (o *GPT_OPS_Type) SetOPSCR_ALIGN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT_OPS_Type) GetOPSCR_ALIGN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x200000) >> 21
}
func (o *GPT_OPS_Type) SetOPSCR_RV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100000)|value<<20)
}
func (o *GPT_OPS_Type) GetOPSCR_RV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100000) >> 20
}
func (o *GPT_OPS_Type) SetOPSCR_INV(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT_OPS_Type) GetOPSCR_INV() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80000) >> 19
}
func (o *GPT_OPS_Type) SetOPSCR_N(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT_OPS_Type) GetOPSCR_N() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40000) >> 18
}
func (o *GPT_OPS_Type) SetOPSCR_P(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT_OPS_Type) GetOPSCR_P() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20000) >> 17
}
func (o *GPT_OPS_Type) SetOPSCR_FB(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT_OPS_Type) GetOPSCR_FB() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10000) >> 16
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0xfe00)|value<<9)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0xfe00) >> 9
}
func (o *GPT_OPS_Type) SetOPSCR_EN(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x100)|value<<8)
}
func (o *GPT_OPS_Type) GetOPSCR_EN() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x100) >> 8
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x80)|value<<7)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x80) >> 7
}
func (o *GPT_OPS_Type) SetOPSCR_W(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x40)|value<<6)
}
func (o *GPT_OPS_Type) GetOPSCR_W() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x40) >> 6
}
func (o *GPT_OPS_Type) SetOPSCR_V(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x20)|value<<5)
}
func (o *GPT_OPS_Type) GetOPSCR_V() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x20) >> 5
}
func (o *GPT_OPS_Type) SetOPSCR_U(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x10)|value<<4)
}
func (o *GPT_OPS_Type) GetOPSCR_U() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x10) >> 4
}
func (o *GPT_OPS_Type) SetOPSCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x8)|value<<3)
}
func (o *GPT_OPS_Type) GetOPSCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x8) >> 3
}
func (o *GPT_OPS_Type) SetOPSCR_WF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x4)|value<<2)
}
func (o *GPT_OPS_Type) GetOPSCR_WF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x4) >> 2
}
func (o *GPT_OPS_Type) SetOPSCR_VF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x2)|value<<1)
}
func (o *GPT_OPS_Type) GetOPSCR_VF() uint32 {
	return (volatile.LoadUint32(&o.OPSCR.Reg) & 0x2) >> 1
}
func (o *GPT_OPS_Type) SetOPSCR_UF(value uint32) {
	volatile.StoreUint32(&o.OPSCR.Reg, volatile.LoadUint32(&o.OPSCR.Reg)&^(0x1)|value)
}
func (o *GPT_OPS_Type) GetOPSCR_UF() uint32 {
	return volatile.LoadUint32(&o.OPSCR.Reg) & 0x1
}

// General PWM Timer 1 (16-bit)
type GPT161_Type struct {
	GTWP     volatile.Register32 // 0x0
	GTSTR    volatile.Register32 // 0x4
	GTSTP    volatile.Register32 // 0x8
	GTCLR    volatile.Register32 // 0xC
	GTSSR    volatile.Register32 // 0x10
	GTPSR    volatile.Register32 // 0x14
	GTCSR    volatile.Register32 // 0x18
	GTUPSR   volatile.Register32 // 0x1C
	GTDNSR   volatile.Register32 // 0x20
	GTICASR  volatile.Register32 // 0x24
	GTICBSR  volatile.Register32 // 0x28
	GTCR     volatile.Register32 // 0x2C
	GTUDDTYC volatile.Register32 // 0x30
	GTIOR    volatile.Register32 // 0x34
	GTINTAD  volatile.Register32 // 0x38
	GTST     volatile.Register32 // 0x3C
	GTBER    volatile.Register32 // 0x40
	_        [4]byte
	GTCNT    volatile.Register32 // 0x48
	GTCCRA   volatile.Register32 // 0x4C
	GTCCRB   volatile.Register32 // 0x50
	GTCCRC   volatile.Register32 // 0x54
	GTCCRE   volatile.Register32 // 0x58
	GTCCRD   volatile.Register32 // 0x5C
	GTCCRF   volatile.Register32 // 0x60
	GTPR     volatile.Register32 // 0x64
	GTPBR    volatile.Register32 // 0x68
	_        [28]byte
	GTDTCR   volatile.Register32 // 0x88
	GTDVU    volatile.Register32 // 0x8C
}

// GPT161.GTWP: General PWM Timer Write-Protection Register
func (o *GPT161_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTWP_PRKEY(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xff00)|value<<8)
}
func (o *GPT161_Type) GetGTWP_PRKEY() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xff00) >> 8
}
func (o *GPT161_Type) SetGTWP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0xfe)|value<<1)
}
func (o *GPT161_Type) GetGTWP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTWP.Reg) & 0xfe) >> 1
}
func (o *GPT161_Type) SetGTWP_WP(value uint32) {
	volatile.StoreUint32(&o.GTWP.Reg, volatile.LoadUint32(&o.GTWP.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTWP_WP() uint32 {
	return volatile.LoadUint32(&o.GTWP.Reg) & 0x1
}

// GPT161.GTSTR: General PWM Timer Software Start Register
func (o *GPT161_Type) SetGTSTR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT161_Type) GetGTSTR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0xffffff80) >> 7
}
func (o *GPT161_Type) SetGTSTR_CSTRT6(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x40)|value<<6)
}
func (o *GPT161_Type) GetGTSTR_CSTRT6() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x40) >> 6
}
func (o *GPT161_Type) SetGTSTR_CSTRT5(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x20)|value<<5)
}
func (o *GPT161_Type) GetGTSTR_CSTRT5() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x20) >> 5
}
func (o *GPT161_Type) SetGTSTR_CSTRT4(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x10)|value<<4)
}
func (o *GPT161_Type) GetGTSTR_CSTRT4() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x10) >> 4
}
func (o *GPT161_Type) SetGTSTR_CSTRT3(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTSTR_CSTRT3() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTSTR_CSTRT2(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTSTR_CSTRT2() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTSTR_CSTRT1(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTSTR_CSTRT1() uint32 {
	return (volatile.LoadUint32(&o.GTSTR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTSTR_CSTRT0(value uint32) {
	volatile.StoreUint32(&o.GTSTR.Reg, volatile.LoadUint32(&o.GTSTR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTSTR_CSTRT0() uint32 {
	return volatile.LoadUint32(&o.GTSTR.Reg) & 0x1
}

// GPT161.GTSTP: General PWM Timer Software Stop Register
func (o *GPT161_Type) SetGTSTP_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT161_Type) GetGTSTP_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0xffffff80) >> 7
}
func (o *GPT161_Type) SetGTSTP_CSTOP6(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x40)|value<<6)
}
func (o *GPT161_Type) GetGTSTP_CSTOP6() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x40) >> 6
}
func (o *GPT161_Type) SetGTSTP_CSTOP5(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x20)|value<<5)
}
func (o *GPT161_Type) GetGTSTP_CSTOP5() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x20) >> 5
}
func (o *GPT161_Type) SetGTSTP_CSTOP4(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x10)|value<<4)
}
func (o *GPT161_Type) GetGTSTP_CSTOP4() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x10) >> 4
}
func (o *GPT161_Type) SetGTSTP_CSTOP3(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTSTP_CSTOP3() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTSTP_CSTOP2(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTSTP_CSTOP2() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTSTP_CSTOP1(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTSTP_CSTOP1() uint32 {
	return (volatile.LoadUint32(&o.GTSTP.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTSTP_CSTOP0(value uint32) {
	volatile.StoreUint32(&o.GTSTP.Reg, volatile.LoadUint32(&o.GTSTP.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTSTP_CSTOP0() uint32 {
	return volatile.LoadUint32(&o.GTSTP.Reg) & 0x1
}

// GPT161.GTCLR: General PWM Timer Software Clear Register
func (o *GPT161_Type) SetGTCLR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0xffffff80)|value<<7)
}
func (o *GPT161_Type) GetGTCLR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0xffffff80) >> 7
}
func (o *GPT161_Type) SetGTCLR_CCLR6(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x40)|value<<6)
}
func (o *GPT161_Type) GetGTCLR_CCLR6() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x40) >> 6
}
func (o *GPT161_Type) SetGTCLR_CCLR5(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x20)|value<<5)
}
func (o *GPT161_Type) GetGTCLR_CCLR5() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x20) >> 5
}
func (o *GPT161_Type) SetGTCLR_CCLR4(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x10)|value<<4)
}
func (o *GPT161_Type) GetGTCLR_CCLR4() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x10) >> 4
}
func (o *GPT161_Type) SetGTCLR_CCLR3(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTCLR_CCLR3() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTCLR_CCLR2(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTCLR_CCLR2() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTCLR_CCLR1(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTCLR_CCLR1() uint32 {
	return (volatile.LoadUint32(&o.GTCLR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTCLR_CCLR0(value uint32) {
	volatile.StoreUint32(&o.GTCLR.Reg, volatile.LoadUint32(&o.GTCLR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTCLR_CCLR0() uint32 {
	return volatile.LoadUint32(&o.GTCLR.Reg) & 0x1
}

// GPT161.GTSSR: General PWM Timer Start Source Select Register
func (o *GPT161_Type) SetGTSSR_CSTRT(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT161_Type) GetGTSSR_CSTRT() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000000) >> 31
}
func (o *GPT161_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT161_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT161_Type) SetGTSSR_SSELCD(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTSSR_SSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTSSR_SSELCC(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTSSR_SSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTSSR_SSELCB(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTSSR_SSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTSSR_SSELCA(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTSSR_SSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTSSR_SSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTSSR_SSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTSSR_SSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTSSR_SSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTSSR_SSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTSSR_SSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTSSR_SSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTSSR_SSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTSSR_SSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTSSR_SSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTSSR_SSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTSSR_SSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTSSR_SSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTSSR_SSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTSSR_SSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTSSR_SSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTSSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT161_Type) GetGTSSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0xf0) >> 4
}
func (o *GPT161_Type) SetGTSSR_SSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTSSR_SSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTSSR_SSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTSSR_SSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTSSR_SSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTSSR_SSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTSSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTSSR_SSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTSSR.Reg, volatile.LoadUint32(&o.GTSSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTSSR_SSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTSSR.Reg) & 0x1
}

// GPT161.GTPSR: General PWM Timer Stop Source Select Register
func (o *GPT161_Type) SetGTPSR_CSTOP(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT161_Type) GetGTPSR_CSTOP() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000000) >> 31
}
func (o *GPT161_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT161_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT161_Type) SetGTPSR_PSELCD(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTPSR_PSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTPSR_PSELCC(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTPSR_PSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTPSR_PSELCB(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTPSR_PSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTPSR_PSELCA(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTPSR_PSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTPSR_PSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTPSR_PSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTPSR_PSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTPSR_PSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTPSR_PSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTPSR_PSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTPSR_PSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTPSR_PSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTPSR_PSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTPSR_PSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTPSR_PSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTPSR_PSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTPSR_PSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTPSR_PSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTPSR_PSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTPSR_PSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTPSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT161_Type) GetGTPSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0xf0) >> 4
}
func (o *GPT161_Type) SetGTPSR_PSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTPSR_PSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTPSR_PSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTPSR_PSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTPSR_PSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTPSR_PSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTPSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTPSR_PSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTPSR.Reg, volatile.LoadUint32(&o.GTPSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTPSR_PSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTPSR.Reg) & 0x1
}

// GPT161.GTCSR: General PWM Timer Clear Source Select Register
func (o *GPT161_Type) SetGTCSR_CCLR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000000)|value<<31)
}
func (o *GPT161_Type) GetGTCSR_CCLR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000000) >> 31
}
func (o *GPT161_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x7ff00000)|value<<20)
}
func (o *GPT161_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x7ff00000) >> 20
}
func (o *GPT161_Type) SetGTCSR_CSELCD(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTCSR_CSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTCSR_CSELCC(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTCSR_CSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTCSR_CSELCB(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTCSR_CSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTCSR_CSELCA(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTCSR_CSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTCSR_CSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTCSR_CSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTCSR_CSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTCSR_CSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTCSR_CSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTCSR_CSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTCSR_CSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTCSR_CSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTCSR_CSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTCSR_CSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTCSR_CSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTCSR_CSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTCSR_CSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTCSR_CSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTCSR_CSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTCSR_CSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTCSR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0xf0)|value<<4)
}
func (o *GPT161_Type) GetGTCSR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0xf0) >> 4
}
func (o *GPT161_Type) SetGTCSR_CSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTCSR_CSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTCSR_CSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTCSR_CSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTCSR_CSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTCSR_CSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTCSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTCSR_CSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTCSR.Reg, volatile.LoadUint32(&o.GTCSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTCSR_CSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTCSR.Reg) & 0x1
}

// GPT161.GTUPSR: General PWM Timer Up Count Source Select Register
func (o *GPT161_Type) SetGTUPSR_USELCD(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTUPSR_USELCD() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTUPSR_USELCC(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTUPSR_USELCC() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTUPSR_USELCB(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTUPSR_USELCB() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTUPSR_USELCA(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTUPSR_USELCA() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTUPSR_USCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTUPSR_USCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTUPSR_USCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTUPSR_USCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTUPSR_USCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTUPSR_USCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTUPSR_USCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTUPSR_USCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTUPSR_USCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTUPSR_USCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTUPSR_USCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTUPSR_USCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTUPSR_USCARBH(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTUPSR_USCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTUPSR_USCARBL(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTUPSR_USCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTUPSR_USGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTUPSR_USGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTUPSR_USGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTUPSR_USGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTUPSR_USGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTUPSR_USGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTUPSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTUPSR_USGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTUPSR.Reg, volatile.LoadUint32(&o.GTUPSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTUPSR_USGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTUPSR.Reg) & 0x1
}

// GPT161.GTDNSR: General PWM Timer Down Count Source Select Register
func (o *GPT161_Type) SetGTDNSR_DSELCD(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTDNSR_DSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTDNSR_DSELCC(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTDNSR_DSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTDNSR_DSELCB(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTDNSR_DSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTDNSR_DSELCA(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTDNSR_DSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTDNSR_DSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTDNSR_DSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTDNSR_DSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTDNSR_DSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTDNSR_DSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTDNSR_DSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTDNSR_DSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTDNSR_DSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTDNSR_DSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTDNSR_DSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTDNSR_DSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTDNSR_DSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTDNSR_DSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTDNSR_DSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTDNSR_DSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTDNSR_DSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTDNSR_DSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTDNSR_DSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTDNSR_DSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTDNSR_DSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTDNSR_DSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTDNSR_DSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTDNSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTDNSR_DSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTDNSR.Reg, volatile.LoadUint32(&o.GTDNSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTDNSR_DSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTDNSR.Reg) & 0x1
}

// GPT161.GTICASR: General PWM Timer Input Capture Source Select Register A
func (o *GPT161_Type) SetGTICASR_ASELCD(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTICASR_ASELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTICASR_ASELCC(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTICASR_ASELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTICASR_ASELCB(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTICASR_ASELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTICASR_ASELCA(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTICASR_ASELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTICASR_ASCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTICASR_ASCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTICASR_ASCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTICASR_ASCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTICASR_ASCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTICASR_ASCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTICASR_ASCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTICASR_ASCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTICASR_ASCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTICASR_ASCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTICASR_ASCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTICASR_ASCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTICASR_ASCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTICASR_ASCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTICASR_ASCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTICASR_ASCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTICASR_ASGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTICASR_ASGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTICASR_ASGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTICASR_ASGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTICASR_ASGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTICASR_ASGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICASR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTICASR_ASGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICASR.Reg, volatile.LoadUint32(&o.GTICASR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTICASR_ASGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICASR.Reg) & 0x1
}

// GPT161.GTICBSR: General PWM Timer Input Capture Source Select Register B
func (o *GPT161_Type) SetGTICBSR_BSELCD(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTICBSR_BSELCD() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTICBSR_BSELCC(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTICBSR_BSELCC() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTICBSR_BSELCB(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x20000)|value<<17)
}
func (o *GPT161_Type) GetGTICBSR_BSELCB() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x20000) >> 17
}
func (o *GPT161_Type) SetGTICBSR_BSELCA(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x10000)|value<<16)
}
func (o *GPT161_Type) GetGTICBSR_BSELCA() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x10000) >> 16
}
func (o *GPT161_Type) SetGTICBSR_BSCBFAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTICBSR_BSCBFAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTICBSR_BSCBFAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4000)|value<<14)
}
func (o *GPT161_Type) GetGTICBSR_BSCBFAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4000) >> 14
}
func (o *GPT161_Type) SetGTICBSR_BSCBRAH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTICBSR_BSCBRAH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTICBSR_BSCBRAL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1000)|value<<12)
}
func (o *GPT161_Type) GetGTICBSR_BSCBRAL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1000) >> 12
}
func (o *GPT161_Type) SetGTICBSR_BSCAFBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x800)|value<<11)
}
func (o *GPT161_Type) GetGTICBSR_BSCAFBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x800) >> 11
}
func (o *GPT161_Type) SetGTICBSR_BSCAFBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x400)|value<<10)
}
func (o *GPT161_Type) GetGTICBSR_BSCAFBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x400) >> 10
}
func (o *GPT161_Type) SetGTICBSR_BSCARBH(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x200)|value<<9)
}
func (o *GPT161_Type) GetGTICBSR_BSCARBH() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x200) >> 9
}
func (o *GPT161_Type) SetGTICBSR_BSCARBL(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTICBSR_BSCARBL() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTICBSR_BSGTRGBF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTICBSR_BSGTRGBF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTICBSR_BSGTRGBR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTICBSR_BSGTRGBR() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTICBSR_BSGTRGAF(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTICBSR_BSGTRGAF() uint32 {
	return (volatile.LoadUint32(&o.GTICBSR.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTICBSR_BSGTRGAR(value uint32) {
	volatile.StoreUint32(&o.GTICBSR.Reg, volatile.LoadUint32(&o.GTICBSR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTICBSR_BSGTRGAR() uint32 {
	return volatile.LoadUint32(&o.GTICBSR.Reg) & 0x1
}

// GPT161.GTCR: General PWM Timer Control Register
func (o *GPT161_Type) SetGTCR_TPCS(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x7000000)|value<<24)
}
func (o *GPT161_Type) GetGTCR_TPCS() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x7000000) >> 24
}
func (o *GPT161_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xf80000)|value<<19)
}
func (o *GPT161_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xf80000) >> 19
}
func (o *GPT161_Type) SetGTCR_MD(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x70000)|value<<16)
}
func (o *GPT161_Type) GetGTCR_MD() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0x70000) >> 16
}
func (o *GPT161_Type) SetGTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0xfffe)|value<<1)
}
func (o *GPT161_Type) GetGTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCR.Reg) & 0xfffe) >> 1
}
func (o *GPT161_Type) SetGTCR_CST(value uint32) {
	volatile.StoreUint32(&o.GTCR.Reg, volatile.LoadUint32(&o.GTCR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTCR_CST() uint32 {
	return volatile.LoadUint32(&o.GTCR.Reg) & 0x1
}

// GPT161.GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
func (o *GPT161_Type) SetGTUDDTYC_OBDTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x8000000)|value<<27)
}
func (o *GPT161_Type) GetGTUDDTYC_OBDTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x8000000) >> 27
}
func (o *GPT161_Type) SetGTUDDTYC_OBDTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x4000000)|value<<26)
}
func (o *GPT161_Type) GetGTUDDTYC_OBDTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x4000000) >> 26
}
func (o *GPT161_Type) SetGTUDDTYC_OBDTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT161_Type) GetGTUDDTYC_OBDTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x3000000) >> 24
}
func (o *GPT161_Type) SetGTUDDTYC_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0xf00000)|value<<20)
}
func (o *GPT161_Type) GetGTUDDTYC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0xf00000) >> 20
}
func (o *GPT161_Type) SetGTUDDTYC_OADTYR(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x80000)|value<<19)
}
func (o *GPT161_Type) GetGTUDDTYC_OADTYR() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x80000) >> 19
}
func (o *GPT161_Type) SetGTUDDTYC_OADTYF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x40000)|value<<18)
}
func (o *GPT161_Type) GetGTUDDTYC_OADTYF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x40000) >> 18
}
func (o *GPT161_Type) SetGTUDDTYC_OADTY(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x30000)|value<<16)
}
func (o *GPT161_Type) GetGTUDDTYC_OADTY() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x30000) >> 16
}
func (o *GPT161_Type) SetGTUDDTYC_UDF(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTUDDTYC_UDF() uint32 {
	return (volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTUDDTYC_UD(value uint32) {
	volatile.StoreUint32(&o.GTUDDTYC.Reg, volatile.LoadUint32(&o.GTUDDTYC.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTUDDTYC_UD() uint32 {
	return volatile.LoadUint32(&o.GTUDDTYC.Reg) & 0x1
}

// GPT161.GTIOR: General PWM Timer I/O Control Register
func (o *GPT161_Type) SetGTIOR_NFCSB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc0000000)|value<<30)
}
func (o *GPT161_Type) GetGTIOR_NFCSB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc0000000) >> 30
}
func (o *GPT161_Type) SetGTIOR_NFBEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT161_Type) GetGTIOR_NFBEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20000000) >> 29
}
func (o *GPT161_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x18000000)|value<<27)
}
func (o *GPT161_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x18000000) >> 27
}
func (o *GPT161_Type) SetGTIOR_OBDF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x6000000)|value<<25)
}
func (o *GPT161_Type) GetGTIOR_OBDF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x6000000) >> 25
}
func (o *GPT161_Type) SetGTIOR_OBE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT161_Type) GetGTIOR_OBE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1000000) >> 24
}
func (o *GPT161_Type) SetGTIOR_OBHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x800000)|value<<23)
}
func (o *GPT161_Type) GetGTIOR_OBHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x800000) >> 23
}
func (o *GPT161_Type) SetGTIOR_OBDFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x400000)|value<<22)
}
func (o *GPT161_Type) GetGTIOR_OBDFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x400000) >> 22
}
func (o *GPT161_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x200000)|value<<21)
}
func (o *GPT161_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x200000) >> 21
}
func (o *GPT161_Type) SetGTIOR_GTIOB(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f0000)|value<<16)
}
func (o *GPT161_Type) GetGTIOR_GTIOB() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f0000) >> 16
}
func (o *GPT161_Type) SetGTIOR_NFCSA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0xc000)|value<<14)
}
func (o *GPT161_Type) GetGTIOR_NFCSA() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0xc000) >> 14
}
func (o *GPT161_Type) SetGTIOR_NFAEN(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x2000)|value<<13)
}
func (o *GPT161_Type) GetGTIOR_NFAEN() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x2000) >> 13
}
func (o *GPT161_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1800)|value<<11)
}
func (o *GPT161_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x1800) >> 11
}
func (o *GPT161_Type) SetGTIOR_OADF(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x600)|value<<9)
}
func (o *GPT161_Type) GetGTIOR_OADF() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x600) >> 9
}
func (o *GPT161_Type) SetGTIOR_OAE(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x100)|value<<8)
}
func (o *GPT161_Type) GetGTIOR_OAE() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x100) >> 8
}
func (o *GPT161_Type) SetGTIOR_OAHLD(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x80)|value<<7)
}
func (o *GPT161_Type) GetGTIOR_OAHLD() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x80) >> 7
}
func (o *GPT161_Type) SetGTIOR_OADFLT(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x40)|value<<6)
}
func (o *GPT161_Type) GetGTIOR_OADFLT() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x40) >> 6
}
func (o *GPT161_Type) SetGTIOR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x20)|value<<5)
}
func (o *GPT161_Type) GetGTIOR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTIOR.Reg) & 0x20) >> 5
}
func (o *GPT161_Type) SetGTIOR_GTIOA(value uint32) {
	volatile.StoreUint32(&o.GTIOR.Reg, volatile.LoadUint32(&o.GTIOR.Reg)&^(0x1f)|value)
}
func (o *GPT161_Type) GetGTIOR_GTIOA() uint32 {
	return volatile.LoadUint32(&o.GTIOR.Reg) & 0x1f
}

// GPT161.GTINTAD: General PWM Timer Interrupt Output Setting Register
func (o *GPT161_Type) SetGTINTAD_GRPABL(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT161_Type) GetGTINTAD_GRPABL() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x40000000) >> 30
}
func (o *GPT161_Type) SetGTINTAD_GRPABH(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT161_Type) GetGTINTAD_GRPABH() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x20000000) >> 29
}
func (o *GPT161_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x1c000000)|value<<26)
}
func (o *GPT161_Type) GetGTINTAD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x1c000000) >> 26
}
func (o *GPT161_Type) SetGTINTAD_GRP(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0x3000000)|value<<24)
}
func (o *GPT161_Type) GetGTINTAD_GRP() uint32 {
	return (volatile.LoadUint32(&o.GTINTAD.Reg) & 0x3000000) >> 24
}
func (o *GPT161_Type) SetGTINTAD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTINTAD.Reg, volatile.LoadUint32(&o.GTINTAD.Reg)&^(0xffffff)|value)
}
func (o *GPT161_Type) GetGTINTAD_Reserved() uint32 {
	return volatile.LoadUint32(&o.GTINTAD.Reg) & 0xffffff
}

// GPT161.GTST: General PWM Timer Status Register
func (o *GPT161_Type) SetGTST_OABLF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40000000)|value<<30)
}
func (o *GPT161_Type) GetGTST_OABLF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40000000) >> 30
}
func (o *GPT161_Type) SetGTST_OABHF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20000000)|value<<29)
}
func (o *GPT161_Type) GetGTST_OABHF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20000000) >> 29
}
func (o *GPT161_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1e000000)|value<<25)
}
func (o *GPT161_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1e000000) >> 25
}
func (o *GPT161_Type) SetGTST_ODF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1000000)|value<<24)
}
func (o *GPT161_Type) GetGTST_ODF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x1000000) >> 24
}
func (o *GPT161_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0xff0000)|value<<16)
}
func (o *GPT161_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0xff0000) >> 16
}
func (o *GPT161_Type) SetGTST_GTCF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8000)|value<<15)
}
func (o *GPT161_Type) GetGTST_GTCF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8000) >> 15
}
func (o *GPT161_Type) SetGTST_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x7f00)|value<<8)
}
func (o *GPT161_Type) GetGTST_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x7f00) >> 8
}
func (o *GPT161_Type) SetGTST_TCFPU(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x80)|value<<7)
}
func (o *GPT161_Type) GetGTST_TCFPU() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x80) >> 7
}
func (o *GPT161_Type) SetGTST_TCPFO(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x40)|value<<6)
}
func (o *GPT161_Type) GetGTST_TCPFO() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x40) >> 6
}
func (o *GPT161_Type) SetGTST_TCFF(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x20)|value<<5)
}
func (o *GPT161_Type) GetGTST_TCFF() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x20) >> 5
}
func (o *GPT161_Type) SetGTST_TCFE(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x10)|value<<4)
}
func (o *GPT161_Type) GetGTST_TCFE() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x10) >> 4
}
func (o *GPT161_Type) SetGTST_TCFD(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x8)|value<<3)
}
func (o *GPT161_Type) GetGTST_TCFD() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x8) >> 3
}
func (o *GPT161_Type) SetGTST_TCFC(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x4)|value<<2)
}
func (o *GPT161_Type) GetGTST_TCFC() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x4) >> 2
}
func (o *GPT161_Type) SetGTST_TCFB(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x2)|value<<1)
}
func (o *GPT161_Type) GetGTST_TCFB() uint32 {
	return (volatile.LoadUint32(&o.GTST.Reg) & 0x2) >> 1
}
func (o *GPT161_Type) SetGTST_TCFA(value uint32) {
	volatile.StoreUint32(&o.GTST.Reg, volatile.LoadUint32(&o.GTST.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTST_TCFA() uint32 {
	return volatile.LoadUint32(&o.GTST.Reg) & 0x1
}

// GPT161.GTBER: General PWM Timer Buffer Enable Register
func (o *GPT161_Type) SetGTBER_CCRSWT(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x400000)|value<<22)
}
func (o *GPT161_Type) GetGTBER_CCRSWT() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x400000) >> 22
}
func (o *GPT161_Type) SetGTBER_PR(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x300000)|value<<20)
}
func (o *GPT161_Type) GetGTBER_PR() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x300000) >> 20
}
func (o *GPT161_Type) SetGTBER_CCRB(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0xc0000)|value<<18)
}
func (o *GPT161_Type) GetGTBER_CCRB() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0xc0000) >> 18
}
func (o *GPT161_Type) SetGTBER_CCRA(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x30000)|value<<16)
}
func (o *GPT161_Type) GetGTBER_CCRA() uint32 {
	return (volatile.LoadUint32(&o.GTBER.Reg) & 0x30000) >> 16
}
func (o *GPT161_Type) SetGTBER_BD(value uint32) {
	volatile.StoreUint32(&o.GTBER.Reg, volatile.LoadUint32(&o.GTBER.Reg)&^(0x3)|value)
}
func (o *GPT161_Type) GetGTBER_BD() uint32 {
	return volatile.LoadUint32(&o.GTBER.Reg) & 0x3
}

// GPT161.GTCNT: General PWM Timer Counter
func (o *GPT161_Type) SetGTCNT(value uint32) {
	volatile.StoreUint32(&o.GTCNT.Reg, value)
}
func (o *GPT161_Type) GetGTCNT() uint32 {
	return volatile.LoadUint32(&o.GTCNT.Reg)
}

// GPT161.GTCCRA: General PWM Timer Compare Capture Register A
func (o *GPT161_Type) SetGTCCRA_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, volatile.LoadUint32(&o.GTCCRA.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRA.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRA(value uint32) {
	volatile.StoreUint32(&o.GTCCRA.Reg, volatile.LoadUint32(&o.GTCCRA.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRA() uint32 {
	return volatile.LoadUint32(&o.GTCCRA.Reg) & 0xffff
}

// GPT161.GTCCRB: General PWM Timer Compare Capture Register B
func (o *GPT161_Type) SetGTCCRB_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, volatile.LoadUint32(&o.GTCCRB.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRB.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRB(value uint32) {
	volatile.StoreUint32(&o.GTCCRB.Reg, volatile.LoadUint32(&o.GTCCRB.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRB() uint32 {
	return volatile.LoadUint32(&o.GTCCRB.Reg) & 0xffff
}

// GPT161.GTCCRC: General PWM Timer Compare Capture Register C
func (o *GPT161_Type) SetGTCCRC_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, volatile.LoadUint32(&o.GTCCRC.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRC_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRC.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRC(value uint32) {
	volatile.StoreUint32(&o.GTCCRC.Reg, volatile.LoadUint32(&o.GTCCRC.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRC() uint32 {
	return volatile.LoadUint32(&o.GTCCRC.Reg) & 0xffff
}

// GPT161.GTCCRE: General PWM Timer Compare Capture Register E
func (o *GPT161_Type) SetGTCCRE_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, volatile.LoadUint32(&o.GTCCRE.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRE_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRE.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRE(value uint32) {
	volatile.StoreUint32(&o.GTCCRE.Reg, volatile.LoadUint32(&o.GTCCRE.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRE() uint32 {
	return volatile.LoadUint32(&o.GTCCRE.Reg) & 0xffff
}

// GPT161.GTCCRD: General PWM Timer Compare Capture Register D
func (o *GPT161_Type) SetGTCCRD_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, volatile.LoadUint32(&o.GTCCRD.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRD_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRD.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRD(value uint32) {
	volatile.StoreUint32(&o.GTCCRD.Reg, volatile.LoadUint32(&o.GTCCRD.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRD() uint32 {
	return volatile.LoadUint32(&o.GTCCRD.Reg) & 0xffff
}

// GPT161.GTCCRF: General PWM Timer Compare Capture Register F
func (o *GPT161_Type) SetGTCCRF_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, volatile.LoadUint32(&o.GTCCRF.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTCCRF_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTCCRF.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTCCRF(value uint32) {
	volatile.StoreUint32(&o.GTCCRF.Reg, volatile.LoadUint32(&o.GTCCRF.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTCCRF() uint32 {
	return volatile.LoadUint32(&o.GTCCRF.Reg) & 0xffff
}

// GPT161.GTPR: General PWM Timer Cycle Setting Register
func (o *GPT161_Type) SetGTPR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTPR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPR.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTPR(value uint32) {
	volatile.StoreUint32(&o.GTPR.Reg, volatile.LoadUint32(&o.GTPR.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTPR() uint32 {
	return volatile.LoadUint32(&o.GTPR.Reg) & 0xffff
}

// GPT161.GTPBR: General PWM Timer Cycle Setting Buffer Register
func (o *GPT161_Type) SetGTPBR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, volatile.LoadUint32(&o.GTPBR.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTPBR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTPBR.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTPBR(value uint32) {
	volatile.StoreUint32(&o.GTPBR.Reg, volatile.LoadUint32(&o.GTPBR.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTPBR() uint32 {
	return volatile.LoadUint32(&o.GTPBR.Reg) & 0xffff
}

// GPT161.GTDTCR: General PWM Timer Dead Time Control Register
func (o *GPT161_Type) SetGTDTCR_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0xfffffffe)|value<<1)
}
func (o *GPT161_Type) GetGTDTCR_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDTCR.Reg) & 0xfffffffe) >> 1
}
func (o *GPT161_Type) SetGTDTCR_TDE(value uint32) {
	volatile.StoreUint32(&o.GTDTCR.Reg, volatile.LoadUint32(&o.GTDTCR.Reg)&^(0x1)|value)
}
func (o *GPT161_Type) GetGTDTCR_TDE() uint32 {
	return volatile.LoadUint32(&o.GTDTCR.Reg) & 0x1
}

// GPT161.GTDVU: General PWM Timer Dead Time Value Register U
func (o *GPT161_Type) SetGTDVU_Reserved(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, volatile.LoadUint32(&o.GTDVU.Reg)&^(0xffff0000)|value<<16)
}
func (o *GPT161_Type) GetGTDVU_Reserved() uint32 {
	return (volatile.LoadUint32(&o.GTDVU.Reg) & 0xffff0000) >> 16
}
func (o *GPT161_Type) SetGTDVU(value uint32) {
	volatile.StoreUint32(&o.GTDVU.Reg, volatile.LoadUint32(&o.GTDVU.Reg)&^(0xffff)|value)
}
func (o *GPT161_Type) GetGTDVU() uint32 {
	return volatile.LoadUint32(&o.GTDVU.Reg) & 0xffff
}

// Port Output Enable Module for GPT
type POEG_Type struct {
	POEGGA volatile.Register32 // 0x0
	_      [252]byte
	POEGGB volatile.Register32 // 0x100
}

// POEG.POEGGA: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGA_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGA_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGA_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGA_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGA_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGA_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGA_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xffe0000)|value<<17)
}
func (o *POEG_Type) GetPOEGGA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xffe0000) >> 17
}
func (o *POEG_Type) SetPOEGGA_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGA_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGA_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xc000)|value<<14)
}
func (o *POEG_Type) GetPOEGGA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xc000) >> 14
}
func (o *POEG_Type) SetPOEGGA_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGA_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGA_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGA_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGA_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0xe00)|value<<9)
}
func (o *POEG_Type) GetPOEGGA_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0xe00) >> 9
}
func (o *POEG_Type) SetPOEGGA_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGA_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGA_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGA_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGA_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGA_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGA_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGA_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGA_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGA_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGA_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGA_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGA_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGA_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGA.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGA_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGA.Reg, volatile.LoadUint32(&o.POEGGA.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGA_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGA.Reg) & 0x1
}

// POEG.POEGGB: POEG Group %s Setting Register
func (o *POEG_Type) SetPOEGGB_NFCS(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc0000000)|value<<30)
}
func (o *POEG_Type) GetPOEGGB_NFCS() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc0000000) >> 30
}
func (o *POEG_Type) SetPOEGGB_NFEN(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20000000)|value<<29)
}
func (o *POEG_Type) GetPOEGGB_NFEN() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20000000) >> 29
}
func (o *POEG_Type) SetPOEGGB_INV(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000000)|value<<28)
}
func (o *POEG_Type) GetPOEGGB_INV() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000000) >> 28
}
func (o *POEG_Type) SetPOEGGB_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xffe0000)|value<<17)
}
func (o *POEG_Type) GetPOEGGB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xffe0000) >> 17
}
func (o *POEG_Type) SetPOEGGB_ST(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10000)|value<<16)
}
func (o *POEG_Type) GetPOEGGB_ST() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10000) >> 16
}
func (o *POEG_Type) SetPOEGGB_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xc000)|value<<14)
}
func (o *POEG_Type) GetPOEGGB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xc000) >> 14
}
func (o *POEG_Type) SetPOEGGB_CDRE5(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2000)|value<<13)
}
func (o *POEG_Type) GetPOEGGB_CDRE5() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2000) >> 13
}
func (o *POEG_Type) SetPOEGGB_CDRE4(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1000)|value<<12)
}
func (o *POEG_Type) GetPOEGGB_CDRE4() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x1000) >> 12
}
func (o *POEG_Type) SetPOEGGB_Reserved(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0xe00)|value<<9)
}
func (o *POEG_Type) GetPOEGGB_Reserved() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0xe00) >> 9
}
func (o *POEG_Type) SetPOEGGB_CDRE0(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x100)|value<<8)
}
func (o *POEG_Type) GetPOEGGB_CDRE0() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x100) >> 8
}
func (o *POEG_Type) SetPOEGGB_OSTPE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x40)|value<<6)
}
func (o *POEG_Type) GetPOEGGB_OSTPE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x40) >> 6
}
func (o *POEG_Type) SetPOEGGB_IOCE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x20)|value<<5)
}
func (o *POEG_Type) GetPOEGGB_IOCE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x20) >> 5
}
func (o *POEG_Type) SetPOEGGB_PIDE(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x10)|value<<4)
}
func (o *POEG_Type) GetPOEGGB_PIDE() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x10) >> 4
}
func (o *POEG_Type) SetPOEGGB_SSF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x8)|value<<3)
}
func (o *POEG_Type) GetPOEGGB_SSF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x8) >> 3
}
func (o *POEG_Type) SetPOEGGB_OSTPF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x4)|value<<2)
}
func (o *POEG_Type) GetPOEGGB_OSTPF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x4) >> 2
}
func (o *POEG_Type) SetPOEGGB_IOCF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x2)|value<<1)
}
func (o *POEG_Type) GetPOEGGB_IOCF() uint32 {
	return (volatile.LoadUint32(&o.POEGGB.Reg) & 0x2) >> 1
}
func (o *POEG_Type) SetPOEGGB_PIDF(value uint32) {
	volatile.StoreUint32(&o.POEGGB.Reg, volatile.LoadUint32(&o.POEGGB.Reg)&^(0x1)|value)
}
func (o *POEG_Type) GetPOEGGB_PIDF() uint32 {
	return volatile.LoadUint32(&o.POEGGB.Reg) & 0x1
}

// Realtime Clock
type RTC_Type struct {
	R64CNT  volatile.Register8 // 0x0
	_       byte
	RSECCNT volatile.Register8 // 0x2
	_       byte
	RMINCNT volatile.Register8 // 0x4
	_       byte
	RHRCNT  volatile.Register8 // 0x6
	_       byte
	RWKCNT  volatile.Register8 // 0x8
	_       byte
	RDAYCNT volatile.Register8 // 0xA
	_       byte
	RMONCNT volatile.Register8 // 0xC
	_       byte
	RYRCNT  volatile.Register16 // 0xE
	RSECAR  volatile.Register8  // 0x10
	_       byte
	RMINAR  volatile.Register8 // 0x12
	_       byte
	RHRAR   volatile.Register8 // 0x14
	_       byte
	RWKAR   volatile.Register8 // 0x16
	_       byte
	RDAYAR  volatile.Register8 // 0x18
	_       byte
	RMONAR  volatile.Register8 // 0x1A
	_       byte
	RYRAR   volatile.Register16 // 0x1C
	RYRAREN volatile.Register8  // 0x1E
	_       [3]byte
	RCR1    volatile.Register8 // 0x22
	_       byte
	RCR2    volatile.Register8 // 0x24
	_       [3]byte
	RCR4    volatile.Register8 // 0x28
	_       byte
	RFRH    volatile.Register16 // 0x2A
	RFRL    volatile.Register16 // 0x2C
	RADJ    volatile.Register8  // 0x2E
}

// RTC.R64CNT: 64-Hz Counter
func (o *RTC_Type) SetR64CNT_F1HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetR64CNT_F1HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetR64CNT_F2HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetR64CNT_F2HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetR64CNT_F4HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetR64CNT_F4HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetR64CNT_F8HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetR64CNT_F8HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetR64CNT_F16HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetR64CNT_F16HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetR64CNT_F32HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetR64CNT_F32HZ() uint8 {
	return (volatile.LoadUint8(&o.R64CNT.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetR64CNT_F64HZ(value uint8) {
	volatile.StoreUint8(&o.R64CNT.Reg, volatile.LoadUint8(&o.R64CNT.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetR64CNT_F64HZ() uint8 {
	return volatile.LoadUint8(&o.R64CNT.Reg) & 0x1
}

// RTC.RSECCNT: Second Counter
func (o *RTC_Type) SetRSECCNT_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECCNT_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECCNT_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECCNT.Reg, volatile.LoadUint8(&o.RSECCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECCNT_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECCNT.Reg) & 0xf
}

// RTC.RMINCNT: Minute Counter
func (o *RTC_Type) SetRMINCNT_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINCNT_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINCNT.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINCNT_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINCNT.Reg, volatile.LoadUint8(&o.RMINCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINCNT_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINCNT.Reg) & 0xf
}

// RTC.RHRCNT: Hour Counter
func (o *RTC_Type) SetRHRCNT_PM(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRCNT_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRCNT_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRCNT_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRCNT_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRCNT.Reg, volatile.LoadUint8(&o.RHRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRCNT_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRCNT.Reg) & 0xf
}

// RTC.RWKCNT: Day-of-Week Counter
func (o *RTC_Type) SetRWKCNT_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKCNT.Reg, volatile.LoadUint8(&o.RWKCNT.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKCNT_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKCNT.Reg) & 0x7
}

// RTC.RDAYCNT: Day Counter
func (o *RTC_Type) SetRDAYCNT_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYCNT_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYCNT.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYCNT_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYCNT.Reg, volatile.LoadUint8(&o.RDAYCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYCNT_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYCNT.Reg) & 0xf
}

// RTC.RMONCNT: Month Counter
func (o *RTC_Type) SetRMONCNT_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xe0)|value<<5)
}
func (o *RTC_Type) GetRMONCNT_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0xe0) >> 5
}
func (o *RTC_Type) SetRMONCNT_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONCNT_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONCNT.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONCNT_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONCNT.Reg, volatile.LoadUint8(&o.RMONCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONCNT_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONCNT.Reg) & 0xf
}

// RTC.RYRCNT: Year Counter
func (o *RTC_Type) SetRYRCNT_Reserved(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetRYRCNT_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetRYRCNT_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRCNT_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRCNT_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRCNT.Reg, volatile.LoadUint16(&o.RYRCNT.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRCNT_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRCNT.Reg) & 0xf
}

// RTC.RSECAR: Second Alarm Register
func (o *RTC_Type) SetRSECAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRSECAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRSECAR_SEC10(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRSECAR_SEC10() uint8 {
	return (volatile.LoadUint8(&o.RSECAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRSECAR_SEC1(value uint8) {
	volatile.StoreUint8(&o.RSECAR.Reg, volatile.LoadUint8(&o.RSECAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRSECAR_SEC1() uint8 {
	return volatile.LoadUint8(&o.RSECAR.Reg) & 0xf
}

// RTC.RMINAR: Minute Alarm Register
func (o *RTC_Type) SetRMINAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMINAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMINAR_MIN10(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0x70)|value<<4)
}
func (o *RTC_Type) GetRMINAR_MIN10() uint8 {
	return (volatile.LoadUint8(&o.RMINAR.Reg) & 0x70) >> 4
}
func (o *RTC_Type) SetRMINAR_MIN1(value uint8) {
	volatile.StoreUint8(&o.RMINAR.Reg, volatile.LoadUint8(&o.RMINAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMINAR_MIN1() uint8 {
	return volatile.LoadUint8(&o.RMINAR.Reg) & 0xf
}

// RTC.RHRAR: Hour Alarm Register
func (o *RTC_Type) SetRHRAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRHRAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRHRAR_PM(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRHRAR_PM() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRHRAR_HR10(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRHRAR_HR10() uint8 {
	return (volatile.LoadUint8(&o.RHRAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRHRAR_HR1(value uint8) {
	volatile.StoreUint8(&o.RHRAR.Reg, volatile.LoadUint8(&o.RHRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRHRAR_HR1() uint8 {
	return volatile.LoadUint8(&o.RHRAR.Reg) & 0xf
}

// RTC.RWKAR: Day-of-Week Alarm Register
func (o *RTC_Type) SetRWKAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRWKAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RWKAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRWKAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x78)|value<<3)
}
func (o *RTC_Type) GetRWKAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RWKAR.Reg) & 0x78) >> 3
}
func (o *RTC_Type) SetRWKAR_DAYW(value uint8) {
	volatile.StoreUint8(&o.RWKAR.Reg, volatile.LoadUint8(&o.RWKAR.Reg)&^(0x7)|value)
}
func (o *RTC_Type) GetRWKAR_DAYW() uint8 {
	return volatile.LoadUint8(&o.RWKAR.Reg) & 0x7
}

// RTC.RDAYAR: Date Alarm Register
func (o *RTC_Type) SetRDAYAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRDAYAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRDAYAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRDAYAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRDAYAR_DATE10(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0x30)|value<<4)
}
func (o *RTC_Type) GetRDAYAR_DATE10() uint8 {
	return (volatile.LoadUint8(&o.RDAYAR.Reg) & 0x30) >> 4
}
func (o *RTC_Type) SetRDAYAR_DATE1(value uint8) {
	volatile.StoreUint8(&o.RDAYAR.Reg, volatile.LoadUint8(&o.RDAYAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRDAYAR_DATE1() uint8 {
	return volatile.LoadUint8(&o.RDAYAR.Reg) & 0xf
}

// RTC.RMONAR: Month Alarm Register
func (o *RTC_Type) SetRMONAR_ENB(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRMONAR_ENB() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRMONAR_Reserved(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x60)|value<<5)
}
func (o *RTC_Type) GetRMONAR_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x60) >> 5
}
func (o *RTC_Type) SetRMONAR_MON10(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRMONAR_MON10() uint8 {
	return (volatile.LoadUint8(&o.RMONAR.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRMONAR_MON1(value uint8) {
	volatile.StoreUint8(&o.RMONAR.Reg, volatile.LoadUint8(&o.RMONAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRMONAR_MON1() uint8 {
	return volatile.LoadUint8(&o.RMONAR.Reg) & 0xf
}

// RTC.RYRAR: Year Alarm Register
func (o *RTC_Type) SetRYRAR_Reserved(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xff00)|value<<8)
}
func (o *RTC_Type) GetRYRAR_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RYRAR.Reg) & 0xff00) >> 8
}
func (o *RTC_Type) SetRYRAR_YR10(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRYRAR_YR10() uint16 {
	return (volatile.LoadUint16(&o.RYRAR.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRYRAR_YR1(value uint16) {
	volatile.StoreUint16(&o.RYRAR.Reg, volatile.LoadUint16(&o.RYRAR.Reg)&^(0xf)|value)
}
func (o *RTC_Type) GetRYRAR_YR1() uint16 {
	return volatile.LoadUint16(&o.RYRAR.Reg) & 0xf
}

// RTC.RYRAREN: Year Alarm Enable Register
func (o *RTC_Type) SetRYRAREN_ENB(value uint8) {
	volatile.StoreUint8(&o.RYRAREN.Reg, volatile.LoadUint8(&o.RYRAREN.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRYRAREN_ENB() uint8 {
	return (volatile.LoadUint8(&o.RYRAREN.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRYRAREN_Reserved(value uint8) {
	volatile.StoreUint8(&o.RYRAREN.Reg, volatile.LoadUint8(&o.RYRAREN.Reg)&^(0x7f)|value)
}
func (o *RTC_Type) GetRYRAREN_Reserved() uint8 {
	return volatile.LoadUint8(&o.RYRAREN.Reg) & 0x7f
}

// RTC.RCR1: RTC Control Register 1
func (o *RTC_Type) SetRCR1_PES(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0xf0)|value<<4)
}
func (o *RTC_Type) GetRCR1_PES() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0xf0) >> 4
}
func (o *RTC_Type) SetRCR1_RTCOS(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR1_RTCOS() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR1_PIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR1_PIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR1_CIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR1_CIE() uint8 {
	return (volatile.LoadUint8(&o.RCR1.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR1_AIE(value uint8) {
	volatile.StoreUint8(&o.RCR1.Reg, volatile.LoadUint8(&o.RCR1.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR1_AIE() uint8 {
	return volatile.LoadUint8(&o.RCR1.Reg) & 0x1
}

// RTC.RCR2: RTC Control Register 2
func (o *RTC_Type) SetRCR2_CNTMD(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x80)|value<<7)
}
func (o *RTC_Type) GetRCR2_CNTMD() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x80) >> 7
}
func (o *RTC_Type) SetRCR2_HR24(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x40)|value<<6)
}
func (o *RTC_Type) GetRCR2_HR24() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x40) >> 6
}
func (o *RTC_Type) SetRCR2_AADJP(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x20)|value<<5)
}
func (o *RTC_Type) GetRCR2_AADJP() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x20) >> 5
}
func (o *RTC_Type) SetRCR2_AADJE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x10)|value<<4)
}
func (o *RTC_Type) GetRCR2_AADJE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x10) >> 4
}
func (o *RTC_Type) SetRCR2_RTCOE(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x8)|value<<3)
}
func (o *RTC_Type) GetRCR2_RTCOE() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x8) >> 3
}
func (o *RTC_Type) SetRCR2_ADJ30(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x4)|value<<2)
}
func (o *RTC_Type) GetRCR2_ADJ30() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x4) >> 2
}
func (o *RTC_Type) SetRCR2_RESET(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x2)|value<<1)
}
func (o *RTC_Type) GetRCR2_RESET() uint8 {
	return (volatile.LoadUint8(&o.RCR2.Reg) & 0x2) >> 1
}
func (o *RTC_Type) SetRCR2_START(value uint8) {
	volatile.StoreUint8(&o.RCR2.Reg, volatile.LoadUint8(&o.RCR2.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR2_START() uint8 {
	return volatile.LoadUint8(&o.RCR2.Reg) & 0x1
}

// RTC.RCR4: RTC Control Register 4
func (o *RTC_Type) SetRCR4_Reserved(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0xfe)|value<<1)
}
func (o *RTC_Type) GetRCR4_Reserved() uint8 {
	return (volatile.LoadUint8(&o.RCR4.Reg) & 0xfe) >> 1
}
func (o *RTC_Type) SetRCR4_RCKSEL(value uint8) {
	volatile.StoreUint8(&o.RCR4.Reg, volatile.LoadUint8(&o.RCR4.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRCR4_RCKSEL() uint8 {
	return volatile.LoadUint8(&o.RCR4.Reg) & 0x1
}

// RTC.RFRH: Frequency Register H
func (o *RTC_Type) SetRFRH_Reserved(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0xfffe)|value<<1)
}
func (o *RTC_Type) GetRFRH_Reserved() uint16 {
	return (volatile.LoadUint16(&o.RFRH.Reg) & 0xfffe) >> 1
}
func (o *RTC_Type) SetRFRH_RFC16(value uint16) {
	volatile.StoreUint16(&o.RFRH.Reg, volatile.LoadUint16(&o.RFRH.Reg)&^(0x1)|value)
}
func (o *RTC_Type) GetRFRH_RFC16() uint16 {
	return volatile.LoadUint16(&o.RFRH.Reg) & 0x1
}

// RTC.RFRL: Frequency Register L
func (o *RTC_Type) SetRFRL(value uint16) {
	volatile.StoreUint16(&o.RFRL.Reg, value)
}
func (o *RTC_Type) GetRFRL() uint16 {
	return volatile.LoadUint16(&o.RFRL.Reg)
}

// RTC.RADJ: Time Error Adjustment Register
func (o *RTC_Type) SetRADJ_PMADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0xc0)|value<<6)
}
func (o *RTC_Type) GetRADJ_PMADJ() uint8 {
	return (volatile.LoadUint8(&o.RADJ.Reg) & 0xc0) >> 6
}
func (o *RTC_Type) SetRADJ_ADJ(value uint8) {
	volatile.StoreUint8(&o.RADJ.Reg, volatile.LoadUint8(&o.RADJ.Reg)&^(0x3f)|value)
}
func (o *RTC_Type) GetRADJ_ADJ() uint8 {
	return volatile.LoadUint8(&o.RADJ.Reg) & 0x3f
}

// Flash Cache
type FCACHE_Type struct {
	_        [256]byte
	FCACHEE  volatile.Register16 // 0x100
	_        [2]byte
	FCACHEIV volatile.Register16 // 0x104
}

// FCACHE.FCACHEE: Flash Cache Enable Register
func (o *FCACHE_Type) SetFCACHEE_Reserved(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0xfffe)|value<<1)
}
func (o *FCACHE_Type) GetFCACHEE_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FCACHEE.Reg) & 0xfffe) >> 1
}
func (o *FCACHE_Type) SetFCACHEE_FCACHEEN(value uint16) {
	volatile.StoreUint16(&o.FCACHEE.Reg, volatile.LoadUint16(&o.FCACHEE.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEE_FCACHEEN() uint16 {
	return volatile.LoadUint16(&o.FCACHEE.Reg) & 0x1
}

// FCACHE.FCACHEIV: Flash Cache Invalidate Register
func (o *FCACHE_Type) SetFCACHEIV_Reserved(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0xfffe)|value<<1)
}
func (o *FCACHE_Type) GetFCACHEIV_Reserved() uint16 {
	return (volatile.LoadUint16(&o.FCACHEIV.Reg) & 0xfffe) >> 1
}
func (o *FCACHE_Type) SetFCACHEIV(value uint16) {
	volatile.StoreUint16(&o.FCACHEIV.Reg, volatile.LoadUint16(&o.FCACHEIV.Reg)&^(0x1)|value)
}
func (o *FCACHE_Type) GetFCACHEIV() uint16 {
	return volatile.LoadUint16(&o.FCACHEIV.Reg) & 0x1
}

// Port 0 Control Registers
type PORT0_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
}

// Port 1 Control Registers
type PORT1_Type struct {
	PCNTR1 volatile.Register32 // 0x0
	PCNTR2 volatile.Register32 // 0x4
	PCNTR3 volatile.Register32 // 0x8
	PCNTR4 volatile.Register32 // 0xC
}

// Pmn Pin Function Control Register
type PFS_Type struct {
	P000PFS volatile.Register32 // 0x0
	P001PFS volatile.Register32 // 0x4
	P002PFS volatile.Register32 // 0x8
	P003PFS volatile.Register32 // 0xC
	_       [32]byte
	P012PFS volatile.Register32 // 0x30
	P013PFS volatile.Register32 // 0x34
	P014PFS volatile.Register32 // 0x38
	P015PFS volatile.Register32 // 0x3C
	P100PFS volatile.Register32 // 0x40
	P101PFS volatile.Register32 // 0x44
	P102PFS volatile.Register32 // 0x48
	P103PFS volatile.Register32 // 0x4C
	P104PFS volatile.Register32 // 0x50
	P105PFS volatile.Register32 // 0x54
	P106PFS volatile.Register32 // 0x58
	P107PFS volatile.Register32 // 0x5C
	P108PFS volatile.Register32 // 0x60
	P109PFS volatile.Register32 // 0x64
	P110PFS volatile.Register32 // 0x68
	P111PFS volatile.Register32 // 0x6C
	P112PFS volatile.Register32 // 0x70
	_       [12]byte
	P200PFS volatile.Register32 // 0x80
	P201PFS volatile.Register32 // 0x84
	_       [8]byte
	P204PFS volatile.Register32 // 0x90
	P205PFS volatile.Register32 // 0x94
	P206PFS volatile.Register32 // 0x98
	_       [20]byte
	P212PFS volatile.Register32 // 0xB0
	P213PFS volatile.Register32 // 0xB4
	P214PFS volatile.Register32 // 0xB8
	P215PFS volatile.Register32 // 0xBC
	P300PFS volatile.Register32 // 0xC0
	P301PFS volatile.Register32 // 0xC4
	P302PFS volatile.Register32 // 0xC8
	P303PFS volatile.Register32 // 0xCC
	P304PFS volatile.Register32 // 0xD0
	_       [44]byte
	P400PFS volatile.Register32 // 0x100
	P401PFS volatile.Register32 // 0x104
	P402PFS volatile.Register32 // 0x108
	P403PFS volatile.Register32 // 0x10C
	_       [12]byte
	P407PFS volatile.Register32 // 0x11C
	P408PFS volatile.Register32 // 0x120
	P409PFS volatile.Register32 // 0x124
	P410PFS volatile.Register32 // 0x128
	P411PFS volatile.Register32 // 0x12C
	_       [16]byte
	P500PFS volatile.Register32 // 0x140
	P501PFS volatile.Register32 // 0x144
	P502PFS volatile.Register32 // 0x148
	_       [300]byte
	P914PFS volatile.Register32 // 0x278
	P915PFS volatile.Register32 // 0x27C
}

// PFS.P000PFS: P000 Pin Function Control Register
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP000PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP000PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP000PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP000PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP000PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP000PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP000PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP000PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x3800)|value<<11)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x3800) >> 11
}
func (o *PFS_Type) SetP000PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP000PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP000PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP000PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP000PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP000PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP000PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP000PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP000PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP000PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP000PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP000PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P000PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP000PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P000PFS.Reg, volatile.LoadUint32(&o.P000PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP000PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P000PFS.Reg) & 0x1
}

// PFS.P100PFS: P100 Pin Function Control Register
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP100PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP100PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP100PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP100PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP100PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP100PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP100PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP100PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP100PFS_EOFR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP100PFS_EOFR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP100PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP100PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP100PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP100PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP100PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP100PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP100PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP100PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP100PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP100PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP100PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP100PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P100PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP100PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P100PFS.Reg, volatile.LoadUint32(&o.P100PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP100PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P100PFS.Reg) & 0x1
}

// PFS.P407PFS: P407 Pin Function Control Register
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0xe0000000)|value<<29)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0xe0000000) >> 29
}
func (o *PFS_Type) SetP407PFS_PSEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1f000000)|value<<24)
}
func (o *PFS_Type) GetP407PFS_PSEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x1f000000) >> 24
}
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0xfe0000)|value<<17)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0xfe0000) >> 17
}
func (o *PFS_Type) SetP407PFS_PMR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10000)|value<<16)
}
func (o *PFS_Type) GetP407PFS_PMR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10000) >> 16
}
func (o *PFS_Type) SetP407PFS_ASEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x8000)|value<<15)
}
func (o *PFS_Type) GetP407PFS_ASEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x8000) >> 15
}
func (o *PFS_Type) SetP407PFS_ISEL(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4000)|value<<14)
}
func (o *PFS_Type) GetP407PFS_ISEL() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4000) >> 14
}
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x3000)|value<<12)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x3000) >> 12
}
func (o *PFS_Type) SetP407PFS_DSCR1(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x800)|value<<11)
}
func (o *PFS_Type) GetP407PFS_DSCR1() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x800) >> 11
}
func (o *PFS_Type) SetP407PFS_DSCR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x400)|value<<10)
}
func (o *PFS_Type) GetP407PFS_DSCR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x400) >> 10
}
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x380)|value<<7)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x380) >> 7
}
func (o *PFS_Type) SetP407PFS_NCODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x40)|value<<6)
}
func (o *PFS_Type) GetP407PFS_NCODR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x40) >> 6
}
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x20)|value<<5)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x20) >> 5
}
func (o *PFS_Type) SetP407PFS_PCR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x10)|value<<4)
}
func (o *PFS_Type) GetP407PFS_PCR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x10) >> 4
}
func (o *PFS_Type) SetP407PFS_Reserved(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x8)|value<<3)
}
func (o *PFS_Type) GetP407PFS_Reserved() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x8) >> 3
}
func (o *PFS_Type) SetP407PFS_PDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x4)|value<<2)
}
func (o *PFS_Type) GetP407PFS_PDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x4) >> 2
}
func (o *PFS_Type) SetP407PFS_PIDR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x2)|value<<1)
}
func (o *PFS_Type) GetP407PFS_PIDR() uint32 {
	return (volatile.LoadUint32(&o.P407PFS.Reg) & 0x2) >> 1
}
func (o *PFS_Type) SetP407PFS_PODR(value uint32) {
	volatile.StoreUint32(&o.P407PFS.Reg, volatile.LoadUint32(&o.P407PFS.Reg)&^(0x1)|value)
}
func (o *PFS_Type) GetP407PFS_PODR() uint32 {
	return volatile.LoadUint32(&o.P407PFS.Reg) & 0x1
}

// Miscellaneous Port Control Register
type PMISC_Type struct {
	_    [3]byte
	PWPR volatile.Register8 // 0x3
}

// PMISC.PWPR: Write-Protect Register
func (o *PMISC_Type) SetPWPR_B0WI(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x80)|value<<7)
}
func (o *PMISC_Type) GetPWPR_B0WI() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x80) >> 7
}
func (o *PMISC_Type) SetPWPR_PFSWE(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x40)|value<<6)
}
func (o *PMISC_Type) GetPWPR_PFSWE() uint8 {
	return (volatile.LoadUint8(&o.PWPR.Reg) & 0x40) >> 6
}
func (o *PMISC_Type) SetPWPR_Reserved(value uint8) {
	volatile.StoreUint8(&o.PWPR.Reg, volatile.LoadUint8(&o.PWPR.Reg)&^(0x3f)|value)
}
func (o *PMISC_Type) GetPWPR_Reserved() uint8 {
	return volatile.LoadUint8(&o.PWPR.Reg) & 0x3f
}

// Constants for ACMPHS0: High-Speed Analog Comparator 0
const (
	// CMPCTL: Comparator Control Register
	// Position of HCMPON field.
	ACMPHS0_CMPCTL_HCMPON_Pos = 0x7
	// Bit mask of HCMPON field.
	ACMPHS0_CMPCTL_HCMPON_Msk = 0x80
	// Bit HCMPON.
	ACMPHS0_CMPCTL_HCMPON = 0x80
	// Operation stopped (the comparator outputs a low-level signal)
	ACMPHS0_CMPCTL_HCMPON_0 = 0x0
	// Operation enabled (input to the comparator pins is enabled
	ACMPHS0_CMPCTL_HCMPON_1 = 0x1
	// Position of CDFS field.
	ACMPHS0_CMPCTL_CDFS_Pos = 0x5
	// Bit mask of CDFS field.
	ACMPHS0_CMPCTL_CDFS_Msk = 0x60
	// Noise filter not used.
	ACMPHS0_CMPCTL_CDFS_00 = 0x0
	// Noise filter sampling frequency is 2^3/PCLKB.
	ACMPHS0_CMPCTL_CDFS_01 = 0x1
	// Noise filter sampling frequency is 2^4/PCLKB.
	ACMPHS0_CMPCTL_CDFS_10 = 0x2
	// Noise filter sampling frequency is 2^5/PCLKB.
	ACMPHS0_CMPCTL_CDFS_11 = 0x3
	// Position of CEG field.
	ACMPHS0_CMPCTL_CEG_Pos = 0x3
	// Bit mask of CEG field.
	ACMPHS0_CMPCTL_CEG_Msk = 0x18
	// No edge selection.
	ACMPHS0_CMPCTL_CEG_00 = 0x0
	// Rising edge selection.
	ACMPHS0_CMPCTL_CEG_01 = 0x1
	// Falling edge selection
	ACMPHS0_CMPCTL_CEG_10 = 0x2
	// Both-edge selection
	ACMPHS0_CMPCTL_CEG_11 = 0x3
	// Position of Reserved field.
	ACMPHS0_CMPCTL_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ACMPHS0_CMPCTL_Reserved_Msk = 0x4
	// Bit Reserved.
	ACMPHS0_CMPCTL_Reserved = 0x4
	// Position of COE field.
	ACMPHS0_CMPCTL_COE_Pos = 0x1
	// Bit mask of COE field.
	ACMPHS0_CMPCTL_COE_Msk = 0x2
	// Bit COE.
	ACMPHS0_CMPCTL_COE = 0x2
	// Comparator output disabled (the output signal is low level).
	ACMPHS0_CMPCTL_COE_0 = 0x0
	// Comparator output enabled
	ACMPHS0_CMPCTL_COE_1 = 0x1
	// Position of CINV field.
	ACMPHS0_CMPCTL_CINV_Pos = 0x0
	// Bit mask of CINV field.
	ACMPHS0_CMPCTL_CINV_Msk = 0x1
	// Bit CINV.
	ACMPHS0_CMPCTL_CINV = 0x1
	// Comparator output not inverted
	ACMPHS0_CMPCTL_CINV_0 = 0x0
	// Comparator output inverted
	ACMPHS0_CMPCTL_CINV_1 = 0x1

	// CMPSEL0: Comparator Input Select Register
	// Position of CMPSEL field.
	ACMPHS0_CMPSEL0_CMPSEL_Pos = 0x0
	// Bit mask of CMPSEL field.
	ACMPHS0_CMPSEL0_CMPSEL_Msk = 0x7
	// No input
	ACMPHS0_CMPSEL0_CMPSEL_000 = 0x0
	// IVCMP0 selected
	ACMPHS0_CMPSEL0_CMPSEL_001 = 0x1
	// IVCMP1 selected
	ACMPHS0_CMPSEL0_CMPSEL_010 = 0x2
	// IVCMP2 selected
	ACMPHS0_CMPSEL0_CMPSEL_100 = 0x4

	// CMPSEL1: Comparator Reference Voltage Select Register
	// Position of CRVS field.
	ACMPHS0_CMPSEL1_CRVS_Pos = 0x0
	// Bit mask of CRVS field.
	ACMPHS0_CMPSEL1_CRVS_Msk = 0x3f
	// No reference voltage
	ACMPHS0_CMPSEL1_CRVS_000000 = 0x0
	// IVREF0 selected
	ACMPHS0_CMPSEL1_CRVS_000001 = 0x1
	// IVREF1 selected
	ACMPHS0_CMPSEL1_CRVS_000010 = 0x2
	// IVREF2 selected
	ACMPHS0_CMPSEL1_CRVS_000100 = 0x4
	// IVREF3 selected
	ACMPHS0_CMPSEL1_CRVS_001000 = 0x8
	// IVREF4 selected
	ACMPHS0_CMPSEL1_CRVS_010000 = 0x10
	// IVREF5 selected
	ACMPHS0_CMPSEL1_CRVS_100000 = 0x20

	// CMPMON: Comparator Output Monitor Register
	// Position of Reserved field.
	ACMPHS0_CMPMON_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ACMPHS0_CMPMON_Reserved_Msk = 0xfe
	// Position of CMPMON field.
	ACMPHS0_CMPMON_CMPMON_Pos = 0x0
	// Bit mask of CMPMON field.
	ACMPHS0_CMPMON_CMPMON_Msk = 0x1
	// Bit CMPMON.
	ACMPHS0_CMPMON_CMPMON = 0x1
	// Comparator output Low
	ACMPHS0_CMPMON_CMPMON_0 = 0x0
	// Comparator output High
	ACMPHS0_CMPMON_CMPMON_1 = 0x1

	// CPIOC: Comparator Output Control Register
	// Position of VREFEN field.
	ACMPHS0_CPIOC_VREFEN_Pos = 0x7
	// Bit mask of VREFEN field.
	ACMPHS0_CPIOC_VREFEN_Msk = 0x80
	// Bit VREFEN.
	ACMPHS0_CPIOC_VREFEN = 0x80
	// Internal Vref disable
	ACMPHS0_CPIOC_VREFEN_0 = 0x0
	// Internal Vref enable
	ACMPHS0_CPIOC_VREFEN_1 = 0x1
	// Position of Reserved field.
	ACMPHS0_CPIOC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ACMPHS0_CPIOC_Reserved_Msk = 0x7e
	// Position of CPOE field.
	ACMPHS0_CPIOC_CPOE_Pos = 0x0
	// Bit mask of CPOE field.
	ACMPHS0_CPIOC_CPOE_Msk = 0x1
	// Bit CPOE.
	ACMPHS0_CPIOC_CPOE = 0x1
	// VCOUT pin output of the comparator is disabled (the output signal is low level).
	ACMPHS0_CPIOC_CPOE_0 = 0x0
	// VCOUT pin output of the comparator is enabled
	ACMPHS0_CPIOC_CPOE_1 = 0x1
)

// Constants for ACMPLP: Low-Power Analog Comparator
const (
	// COMPMDR: ACMPLP Mode Setting Register
	// Position of C1MON field.
	ACMPLP_COMPMDR_C1MON_Pos = 0x7
	// Bit mask of C1MON field.
	ACMPLP_COMPMDR_C1MON_Msk = 0x80
	// Bit C1MON.
	ACMPLP_COMPMDR_C1MON = 0x80
	// IVCMP1 < Comparator1 Reference level(When the window function is disabled)/IVCMP1 < IVREF0 or IVCMP1 > IVREF1(When the window function is enabled)
	ACMPLP_COMPMDR_C1MON_0 = 0x0
	// IVCMP1 > Comparator1 Reference level(When the window function is disabled)/IVREF0 < IVCMP1 < IVREF1(When the window function is enabled)
	ACMPLP_COMPMDR_C1MON_1 = 0x1
	// Position of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Pos = 0x6
	// Bit mask of C1VRF field.
	ACMPLP_COMPMDR_C1VRF_Msk = 0x40
	// Bit C1VRF.
	ACMPLP_COMPMDR_C1VRF = 0x40
	// CMPREF1 input
	ACMPLP_COMPMDR_C1VRF_0 = 0x0
	// internal reference voltage (Vref)
	ACMPLP_COMPMDR_C1VRF_1 = 0x1
	// Position of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Pos = 0x5
	// Bit mask of C1WDE field.
	ACMPLP_COMPMDR_C1WDE_Msk = 0x20
	// Bit C1WDE.
	ACMPLP_COMPMDR_C1WDE = 0x20
	// Disabled
	ACMPLP_COMPMDR_C1WDE_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C1WDE_1 = 0x1
	// Position of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Pos = 0x4
	// Bit mask of C1ENB field.
	ACMPLP_COMPMDR_C1ENB_Msk = 0x10
	// Bit C1ENB.
	ACMPLP_COMPMDR_C1ENB = 0x10
	// Disabled
	ACMPLP_COMPMDR_C1ENB_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C1ENB_1 = 0x1
	// Position of C0MON field.
	ACMPLP_COMPMDR_C0MON_Pos = 0x3
	// Bit mask of C0MON field.
	ACMPLP_COMPMDR_C0MON_Msk = 0x8
	// Bit C0MON.
	ACMPLP_COMPMDR_C0MON = 0x8
	// IVCMP0 < Comparator0 Reference level(When the window function is disabled)/IVCMP0 < IVREF0 or IVCMP0 > IVREF1(When the window function is enabled)
	ACMPLP_COMPMDR_C0MON_0 = 0x0
	// IVCMP0 > Comparator0 Reference level(When the window function is disabled)/IVREF0 < IVCMP0 < IVREF1(When the window function is enabled)
	ACMPLP_COMPMDR_C0MON_1 = 0x1
	// Position of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Pos = 0x2
	// Bit mask of C0VRF field.
	ACMPLP_COMPMDR_C0VRF_Msk = 0x4
	// Bit C0VRF.
	ACMPLP_COMPMDR_C0VRF = 0x4
	// CMPREF0 input
	ACMPLP_COMPMDR_C0VRF_0 = 0x0
	// internal reference voltage (Vref)
	ACMPLP_COMPMDR_C0VRF_1 = 0x1
	// Position of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Pos = 0x1
	// Bit mask of C0WDE field.
	ACMPLP_COMPMDR_C0WDE_Msk = 0x2
	// Bit C0WDE.
	ACMPLP_COMPMDR_C0WDE = 0x2
	// Disabled
	ACMPLP_COMPMDR_C0WDE_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C0WDE_1 = 0x1
	// Position of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Pos = 0x0
	// Bit mask of C0ENB field.
	ACMPLP_COMPMDR_C0ENB_Msk = 0x1
	// Bit C0ENB.
	ACMPLP_COMPMDR_C0ENB = 0x1
	// Disabled
	ACMPLP_COMPMDR_C0ENB_0 = 0x0
	// Enabled
	ACMPLP_COMPMDR_C0ENB_1 = 0x1

	// COMPFIR: ACMPLP Filter Control Register
	// Position of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Pos = 0x7
	// Bit mask of C1EDG field.
	ACMPLP_COMPFIR_C1EDG_Msk = 0x80
	// Bit C1EDG.
	ACMPLP_COMPFIR_C1EDG = 0x80
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C1EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C1EDG_1 = 0x1
	// Position of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Pos = 0x6
	// Bit mask of C1EPO field.
	ACMPLP_COMPFIR_C1EPO_Msk = 0x40
	// Bit C1EPO.
	ACMPLP_COMPFIR_C1EPO = 0x40
	// Interrupt and ELC event request at rising edge
	ACMPLP_COMPFIR_C1EPO_0 = 0x0
	// Interrupt and ELC event request at falling edge
	ACMPLP_COMPFIR_C1EPO_1 = 0x1
	// Position of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Pos = 0x4
	// Bit mask of C1FCK field.
	ACMPLP_COMPFIR_C1FCK_Msk = 0x30
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C1FCK_00 = 0x0
	// Sampling at PCLK
	ACMPLP_COMPFIR_C1FCK_01 = 0x1
	// Sampling at PCLK/8
	ACMPLP_COMPFIR_C1FCK_10 = 0x2
	// Sampling at PCLK/32
	ACMPLP_COMPFIR_C1FCK_11 = 0x3
	// Position of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Pos = 0x3
	// Bit mask of C0EDG field.
	ACMPLP_COMPFIR_C0EDG_Msk = 0x8
	// Bit C0EDG.
	ACMPLP_COMPFIR_C0EDG = 0x8
	// Interrupt and ELC event request by one-edge detection
	ACMPLP_COMPFIR_C0EDG_0 = 0x0
	// Interrupt and ELC event request by both-edge detection
	ACMPLP_COMPFIR_C0EDG_1 = 0x1
	// Position of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Pos = 0x2
	// Bit mask of C0EPO field.
	ACMPLP_COMPFIR_C0EPO_Msk = 0x4
	// Bit C0EPO.
	ACMPLP_COMPFIR_C0EPO = 0x4
	// Interrupt and ELC event request at rising edge
	ACMPLP_COMPFIR_C0EPO_0 = 0x0
	// Interrupt and ELC event request at falling edge
	ACMPLP_COMPFIR_C0EPO_1 = 0x1
	// Position of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Pos = 0x0
	// Bit mask of C0FCK field.
	ACMPLP_COMPFIR_C0FCK_Msk = 0x3
	// No Sampling (bypass)
	ACMPLP_COMPFIR_C0FCK_00 = 0x0
	// Sampling at PCLK
	ACMPLP_COMPFIR_C0FCK_01 = 0x1
	// Sampling at PCLK/8
	ACMPLP_COMPFIR_C0FCK_10 = 0x2
	// Sampling at PCLK/32
	ACMPLP_COMPFIR_C0FCK_11 = 0x3

	// COMPOCR: ACMPLP Output Control Register
	// Position of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Pos = 0x7
	// Bit mask of SPDMD field.
	ACMPLP_COMPOCR_SPDMD_Msk = 0x80
	// Bit SPDMD.
	ACMPLP_COMPOCR_SPDMD = 0x80
	// Comparator low-speed mode
	ACMPLP_COMPOCR_SPDMD_0 = 0x0
	// Comparator high-speed mode
	ACMPLP_COMPOCR_SPDMD_1 = 0x1
	// Position of C1OP field.
	ACMPLP_COMPOCR_C1OP_Pos = 0x6
	// Bit mask of C1OP field.
	ACMPLP_COMPOCR_C1OP_Msk = 0x40
	// Bit C1OP.
	ACMPLP_COMPOCR_C1OP = 0x40
	// Non inverted
	ACMPLP_COMPOCR_C1OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C1OP_1 = 0x1
	// Position of C1OE field.
	ACMPLP_COMPOCR_C1OE_Pos = 0x5
	// Bit mask of C1OE field.
	ACMPLP_COMPOCR_C1OE_Msk = 0x20
	// Bit C1OE.
	ACMPLP_COMPOCR_C1OE = 0x20
	// Disabled
	ACMPLP_COMPOCR_C1OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C1OE_1 = 0x1
	// Position of Reserved field.
	ACMPLP_COMPOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ACMPLP_COMPOCR_Reserved_Msk = 0x18
	// Position of C0OP field.
	ACMPLP_COMPOCR_C0OP_Pos = 0x2
	// Bit mask of C0OP field.
	ACMPLP_COMPOCR_C0OP_Msk = 0x4
	// Bit C0OP.
	ACMPLP_COMPOCR_C0OP = 0x4
	// Non inverted
	ACMPLP_COMPOCR_C0OP_0 = 0x0
	// Inverted
	ACMPLP_COMPOCR_C0OP_1 = 0x1
	// Position of C0OE field.
	ACMPLP_COMPOCR_C0OE_Pos = 0x1
	// Bit mask of C0OE field.
	ACMPLP_COMPOCR_C0OE_Msk = 0x2
	// Bit C0OE.
	ACMPLP_COMPOCR_C0OE = 0x2
	// Disabled
	ACMPLP_COMPOCR_C0OE_0 = 0x0
	// Enabled
	ACMPLP_COMPOCR_C0OE_1 = 0x1
	// Position of Reserved field.
	ACMPLP_COMPOCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ACMPLP_COMPOCR_Reserved_Msk = 0x1
	// Bit Reserved.
	ACMPLP_COMPOCR_Reserved = 0x1

	// COMPSEL0: Comparator Input Select Register
	// Position of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Msk = 0xc0
	// Position of CMPSEL54 field.
	ACMPLP_COMPSEL0_CMPSEL54_Pos = 0x4
	// Bit mask of CMPSEL54 field.
	ACMPLP_COMPSEL0_CMPSEL54_Msk = 0x30
	// No input
	ACMPLP_COMPSEL0_CMPSEL54_00 = 0x0
	// CMPIN1 input selected
	ACMPLP_COMPSEL0_CMPSEL54_01 = 0x1
	// AMP1O output selected
	ACMPLP_COMPSEL0_CMPSEL54_10 = 0x2
	// Position of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL0_Reserved_Msk = 0xc
	// Position of CMPSEL10 field.
	ACMPLP_COMPSEL0_CMPSEL10_Pos = 0x0
	// Bit mask of CMPSEL10 field.
	ACMPLP_COMPSEL0_CMPSEL10_Msk = 0x3
	// No input
	ACMPLP_COMPSEL0_CMPSEL10_00 = 0x0
	// CMPIN0 input selected
	ACMPLP_COMPSEL0_CMPSEL10_01 = 0x1
	// AMP0O output selected
	ACMPLP_COMPSEL0_CMPSEL10_10 = 0x2

	// COMPSEL1: Comparator Reference voltage Select Register
	// Position of C1VRF2 field.
	ACMPLP_COMPSEL1_C1VRF2_Pos = 0x7
	// Bit mask of C1VRF2 field.
	ACMPLP_COMPSEL1_C1VRF2_Msk = 0x80
	// Bit C1VRF2.
	ACMPLP_COMPSEL1_C1VRF2 = 0x80
	// IVREF0 selected
	ACMPLP_COMPSEL1_C1VRF2_0 = 0x0
	// IVREF1 selected
	ACMPLP_COMPSEL1_C1VRF2_1 = 0x1
	// Position of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Msk = 0x40
	// Bit Reserved.
	ACMPLP_COMPSEL1_Reserved = 0x40
	// Position of CRVS54 field.
	ACMPLP_COMPSEL1_CRVS54_Pos = 0x4
	// Bit mask of CRVS54 field.
	ACMPLP_COMPSEL1_CRVS54_Msk = 0x30
	// No reference voltage
	ACMPLP_COMPSEL1_CRVS54_00 = 0x0
	// CMPREF1 selected
	ACMPLP_COMPSEL1_CRVS54_01 = 0x1
	// DA8_1 output selected
	ACMPLP_COMPSEL1_CRVS54_10 = 0x2
	// Position of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ACMPLP_COMPSEL1_Reserved_Msk = 0xc
	// Position of CRVS10 field.
	ACMPLP_COMPSEL1_CRVS10_Pos = 0x0
	// Bit mask of CRVS10 field.
	ACMPLP_COMPSEL1_CRVS10_Msk = 0x3
	// No reference voltage
	ACMPLP_COMPSEL1_CRVS10_00 = 0x0
	// CMPREF0 selected
	ACMPLP_COMPSEL1_CRVS10_01 = 0x1
	// DA8_0 output selected
	ACMPLP_COMPSEL1_CRVS10_10 = 0x2
)

// Constants for ADC160: 16-bit A/D Converter
const (
	// ADCSR: A/D Control Register
	// Position of ADST field.
	ADC160_ADCSR_ADST_Pos = 0xf
	// Bit mask of ADST field.
	ADC160_ADCSR_ADST_Msk = 0x8000
	// Bit ADST.
	ADC160_ADCSR_ADST = 0x8000
	// Stops A/D conversion process.
	ADC160_ADCSR_ADST_0 = 0x0
	// Starts A/D conversion process.
	ADC160_ADCSR_ADST_1 = 0x1
	// Position of ADCS field.
	ADC160_ADCSR_ADCS_Pos = 0xd
	// Bit mask of ADCS field.
	ADC160_ADCSR_ADCS_Msk = 0x6000
	// Single scan mode
	ADC160_ADCSR_ADCS_00 = 0x0
	// Group scan mode
	ADC160_ADCSR_ADCS_01 = 0x1
	// Continuous scan mode
	ADC160_ADCSR_ADCS_10 = 0x2
	// Setting prohibited
	ADC160_ADCSR_ADCS_11 = 0x3
	// Position of Reserved field.
	ADC160_ADCSR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	ADC160_ADCSR_Reserved_Msk = 0x1800
	// Position of ADHSC field.
	ADC160_ADCSR_ADHSC_Pos = 0xa
	// Bit mask of ADHSC field.
	ADC160_ADCSR_ADHSC_Msk = 0x400
	// Bit ADHSC.
	ADC160_ADCSR_ADHSC = 0x400
	// High speed A/D conversion mode
	ADC160_ADCSR_ADHSC_0 = 0x0
	// Low current A/D conversion mode
	ADC160_ADCSR_ADHSC_1 = 0x1
	// Position of TRGE field.
	ADC160_ADCSR_TRGE_Pos = 0x9
	// Bit mask of TRGE field.
	ADC160_ADCSR_TRGE_Msk = 0x200
	// Bit TRGE.
	ADC160_ADCSR_TRGE = 0x200
	// Disables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC160_ADCSR_TRGE_0 = 0x0
	// Enables A/D conversion to be started by the synchronous or asynchronous trigger.
	ADC160_ADCSR_TRGE_1 = 0x1
	// Position of EXTRG field.
	ADC160_ADCSR_EXTRG_Pos = 0x8
	// Bit mask of EXTRG field.
	ADC160_ADCSR_EXTRG_Msk = 0x100
	// Bit EXTRG.
	ADC160_ADCSR_EXTRG = 0x100
	// A/D conversion is started by the synchronous trigger (ELC).
	ADC160_ADCSR_EXTRG_0 = 0x0
	// A/D conversion is started by the asynchronous trigger (ADTRG0).
	ADC160_ADCSR_EXTRG_1 = 0x1
	// Position of DBLE field.
	ADC160_ADCSR_DBLE_Pos = 0x7
	// Bit mask of DBLE field.
	ADC160_ADCSR_DBLE_Msk = 0x80
	// Bit DBLE.
	ADC160_ADCSR_DBLE = 0x80
	// Double trigger mode non-selection
	ADC160_ADCSR_DBLE_0 = 0x0
	// Double trigger mode selection
	ADC160_ADCSR_DBLE_1 = 0x1
	// Position of GBADIE field.
	ADC160_ADCSR_GBADIE_Pos = 0x6
	// Bit mask of GBADIE field.
	ADC160_ADCSR_GBADIE_Msk = 0x40
	// Bit GBADIE.
	ADC160_ADCSR_GBADIE = 0x40
	// Disables ADC160_GBADI interrupt generation upon group B scan completion.
	ADC160_ADCSR_GBADIE_0 = 0x0
	// Enables ADC160_GBADI interrupt generation upon group B scan completion.
	ADC160_ADCSR_GBADIE_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ADC160_ADCSR_Reserved_Msk = 0x20
	// Bit Reserved.
	ADC160_ADCSR_Reserved = 0x20
	// Position of DBLANS field.
	ADC160_ADCSR_DBLANS_Pos = 0x0
	// Bit mask of DBLANS field.
	ADC160_ADCSR_DBLANS_Msk = 0x1f

	// ADANSA0: A/D Channel Select Register A0
	// Position of Reserved field.
	ADC160_ADANSA0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADANSA0_Reserved_Msk = 0xfe00
	// Position of ANSA08 field.
	ADC160_ADANSA0_ANSA08_Pos = 0x8
	// Bit mask of ANSA08 field.
	ADC160_ADANSA0_ANSA08_Msk = 0x100
	// Bit ANSA08.
	ADC160_ADANSA0_ANSA08 = 0x100
	// AN008 is not selected
	ADC160_ADANSA0_ANSA08_0 = 0x0
	// AN008 is selected
	ADC160_ADANSA0_ANSA08_1 = 0x1
	// Position of ANSA07 field.
	ADC160_ADANSA0_ANSA07_Pos = 0x7
	// Bit mask of ANSA07 field.
	ADC160_ADANSA0_ANSA07_Msk = 0x80
	// Bit ANSA07.
	ADC160_ADANSA0_ANSA07 = 0x80
	// AN007 is not selected
	ADC160_ADANSA0_ANSA07_0 = 0x0
	// AN007 is selected
	ADC160_ADANSA0_ANSA07_1 = 0x1
	// Position of ANSA06 field.
	ADC160_ADANSA0_ANSA06_Pos = 0x6
	// Bit mask of ANSA06 field.
	ADC160_ADANSA0_ANSA06_Msk = 0x40
	// Bit ANSA06.
	ADC160_ADANSA0_ANSA06 = 0x40
	// AN006 is not selected
	ADC160_ADANSA0_ANSA06_0 = 0x0
	// AN006 is selected
	ADC160_ADANSA0_ANSA06_1 = 0x1
	// Position of ANSA05 field.
	ADC160_ADANSA0_ANSA05_Pos = 0x5
	// Bit mask of ANSA05 field.
	ADC160_ADANSA0_ANSA05_Msk = 0x20
	// Bit ANSA05.
	ADC160_ADANSA0_ANSA05 = 0x20
	// AN005 is not selected
	ADC160_ADANSA0_ANSA05_0 = 0x0
	// AN005 is selected
	ADC160_ADANSA0_ANSA05_1 = 0x1
	// Position of ANSA04 field.
	ADC160_ADANSA0_ANSA04_Pos = 0x4
	// Bit mask of ANSA04 field.
	ADC160_ADANSA0_ANSA04_Msk = 0x10
	// Bit ANSA04.
	ADC160_ADANSA0_ANSA04 = 0x10
	// AN004 is not selected
	ADC160_ADANSA0_ANSA04_0 = 0x0
	// AN004 is selected
	ADC160_ADANSA0_ANSA04_1 = 0x1
	// Position of ANSA03 field.
	ADC160_ADANSA0_ANSA03_Pos = 0x3
	// Bit mask of ANSA03 field.
	ADC160_ADANSA0_ANSA03_Msk = 0x8
	// Bit ANSA03.
	ADC160_ADANSA0_ANSA03 = 0x8
	// AN003 is not selected
	ADC160_ADANSA0_ANSA03_0 = 0x0
	// AN003 is selected
	ADC160_ADANSA0_ANSA03_1 = 0x1
	// Position of ANSA02 field.
	ADC160_ADANSA0_ANSA02_Pos = 0x2
	// Bit mask of ANSA02 field.
	ADC160_ADANSA0_ANSA02_Msk = 0x4
	// Bit ANSA02.
	ADC160_ADANSA0_ANSA02 = 0x4
	// AN002 is not selected
	ADC160_ADANSA0_ANSA02_0 = 0x0
	// AN002 is selected
	ADC160_ADANSA0_ANSA02_1 = 0x1
	// Position of ANSA01 field.
	ADC160_ADANSA0_ANSA01_Pos = 0x1
	// Bit mask of ANSA01 field.
	ADC160_ADANSA0_ANSA01_Msk = 0x2
	// Bit ANSA01.
	ADC160_ADANSA0_ANSA01 = 0x2
	// AN001 is not selected
	ADC160_ADANSA0_ANSA01_0 = 0x0
	// AN001 is selected
	ADC160_ADANSA0_ANSA01_1 = 0x1
	// Position of ANSA00 field.
	ADC160_ADANSA0_ANSA00_Pos = 0x0
	// Bit mask of ANSA00 field.
	ADC160_ADANSA0_ANSA00_Msk = 0x1
	// Bit ANSA00.
	ADC160_ADANSA0_ANSA00 = 0x1
	// AN000 is not selected
	ADC160_ADANSA0_ANSA00_0 = 0x0
	// AN000 is selected
	ADC160_ADANSA0_ANSA00_1 = 0x1

	// ADANSA1: A/D Channel Select Register A1
	// Position of Reserved field.
	ADC160_ADANSA1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADANSA1_Reserved_Msk = 0xfe00
	// Position of ANSA24 field.
	ADC160_ADANSA1_ANSA24_Pos = 0x8
	// Bit mask of ANSA24 field.
	ADC160_ADANSA1_ANSA24_Msk = 0x100
	// Bit ANSA24.
	ADC160_ADANSA1_ANSA24 = 0x100
	// AN024 is not selected
	ADC160_ADANSA1_ANSA24_0 = 0x0
	// AN024 is selected
	ADC160_ADANSA1_ANSA24_1 = 0x1
	// Position of ANSA23 field.
	ADC160_ADANSA1_ANSA23_Pos = 0x7
	// Bit mask of ANSA23 field.
	ADC160_ADANSA1_ANSA23_Msk = 0x80
	// Bit ANSA23.
	ADC160_ADANSA1_ANSA23 = 0x80
	// AN023 is not selected
	ADC160_ADANSA1_ANSA23_0 = 0x0
	// AN023 is selected
	ADC160_ADANSA1_ANSA23_1 = 0x1
	// Position of ANSA22 field.
	ADC160_ADANSA1_ANSA22_Pos = 0x6
	// Bit mask of ANSA22 field.
	ADC160_ADANSA1_ANSA22_Msk = 0x40
	// Bit ANSA22.
	ADC160_ADANSA1_ANSA22 = 0x40
	// AN022 is not selected
	ADC160_ADANSA1_ANSA22_0 = 0x0
	// AN022 is selected
	ADC160_ADANSA1_ANSA22_1 = 0x1
	// Position of ANSA21 field.
	ADC160_ADANSA1_ANSA21_Pos = 0x5
	// Bit mask of ANSA21 field.
	ADC160_ADANSA1_ANSA21_Msk = 0x20
	// Bit ANSA21.
	ADC160_ADANSA1_ANSA21 = 0x20
	// AN021 is not selected
	ADC160_ADANSA1_ANSA21_0 = 0x0
	// AN021 is selected
	ADC160_ADANSA1_ANSA21_1 = 0x1
	// Position of ANSA20 field.
	ADC160_ADANSA1_ANSA20_Pos = 0x4
	// Bit mask of ANSA20 field.
	ADC160_ADANSA1_ANSA20_Msk = 0x10
	// Bit ANSA20.
	ADC160_ADANSA1_ANSA20 = 0x10
	// AN020 is not selected
	ADC160_ADANSA1_ANSA20_0 = 0x0
	// AN020 is selected
	ADC160_ADANSA1_ANSA20_1 = 0x1
	// Position of ANSA19 field.
	ADC160_ADANSA1_ANSA19_Pos = 0x3
	// Bit mask of ANSA19 field.
	ADC160_ADANSA1_ANSA19_Msk = 0x8
	// Bit ANSA19.
	ADC160_ADANSA1_ANSA19 = 0x8
	// AN019 is not selected
	ADC160_ADANSA1_ANSA19_0 = 0x0
	// AN019 is selected
	ADC160_ADANSA1_ANSA19_1 = 0x1
	// Position of ANSA18 field.
	ADC160_ADANSA1_ANSA18_Pos = 0x2
	// Bit mask of ANSA18 field.
	ADC160_ADANSA1_ANSA18_Msk = 0x4
	// Bit ANSA18.
	ADC160_ADANSA1_ANSA18 = 0x4
	// AN018 is not selected
	ADC160_ADANSA1_ANSA18_0 = 0x0
	// AN018 is selected
	ADC160_ADANSA1_ANSA18_1 = 0x1
	// Position of ANSA17 field.
	ADC160_ADANSA1_ANSA17_Pos = 0x1
	// Bit mask of ANSA17 field.
	ADC160_ADANSA1_ANSA17_Msk = 0x2
	// Bit ANSA17.
	ADC160_ADANSA1_ANSA17 = 0x2
	// AN017 is not selected
	ADC160_ADANSA1_ANSA17_0 = 0x0
	// AN017 is selected
	ADC160_ADANSA1_ANSA17_1 = 0x1
	// Position of ANSA16 field.
	ADC160_ADANSA1_ANSA16_Pos = 0x0
	// Bit mask of ANSA16 field.
	ADC160_ADANSA1_ANSA16_Msk = 0x1
	// Bit ANSA16.
	ADC160_ADANSA1_ANSA16 = 0x1
	// AN016 is not selected
	ADC160_ADANSA1_ANSA16_0 = 0x0
	// AN016 is selected
	ADC160_ADANSA1_ANSA16_1 = 0x1

	// ADADS0: A/D-Converted Value Average Channel Select Register 0
	// Position of Reserved field.
	ADC160_ADADS0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADADS0_Reserved_Msk = 0xfe00
	// Position of ADS08 field.
	ADC160_ADADS0_ADS08_Pos = 0x8
	// Bit mask of ADS08 field.
	ADC160_ADADS0_ADS08_Msk = 0x100
	// Bit ADS08.
	ADC160_ADADS0_ADS08 = 0x100
	// AN008 is not selected.
	ADC160_ADADS0_ADS08_0 = 0x0
	// AN008 is selected.
	ADC160_ADADS0_ADS08_1 = 0x1
	// Position of ADS07 field.
	ADC160_ADADS0_ADS07_Pos = 0x7
	// Bit mask of ADS07 field.
	ADC160_ADADS0_ADS07_Msk = 0x80
	// Bit ADS07.
	ADC160_ADADS0_ADS07 = 0x80
	// AN007 is not selected.
	ADC160_ADADS0_ADS07_0 = 0x0
	// AN007 is selected.
	ADC160_ADADS0_ADS07_1 = 0x1
	// Position of ADS06 field.
	ADC160_ADADS0_ADS06_Pos = 0x6
	// Bit mask of ADS06 field.
	ADC160_ADADS0_ADS06_Msk = 0x40
	// Bit ADS06.
	ADC160_ADADS0_ADS06 = 0x40
	// AN006 is not selected.
	ADC160_ADADS0_ADS06_0 = 0x0
	// AN006 is selected.
	ADC160_ADADS0_ADS06_1 = 0x1
	// Position of ADS05 field.
	ADC160_ADADS0_ADS05_Pos = 0x5
	// Bit mask of ADS05 field.
	ADC160_ADADS0_ADS05_Msk = 0x20
	// Bit ADS05.
	ADC160_ADADS0_ADS05 = 0x20
	// AN005 is not selected.
	ADC160_ADADS0_ADS05_0 = 0x0
	// AN005 is selected.
	ADC160_ADADS0_ADS05_1 = 0x1
	// Position of ADS04 field.
	ADC160_ADADS0_ADS04_Pos = 0x4
	// Bit mask of ADS04 field.
	ADC160_ADADS0_ADS04_Msk = 0x10
	// Bit ADS04.
	ADC160_ADADS0_ADS04 = 0x10
	// AN004 is not selected.
	ADC160_ADADS0_ADS04_0 = 0x0
	// AN004 is selected.
	ADC160_ADADS0_ADS04_1 = 0x1
	// Position of ADS03 field.
	ADC160_ADADS0_ADS03_Pos = 0x3
	// Bit mask of ADS03 field.
	ADC160_ADADS0_ADS03_Msk = 0x8
	// Bit ADS03.
	ADC160_ADADS0_ADS03 = 0x8
	// AN003 is not selected.
	ADC160_ADADS0_ADS03_0 = 0x0
	// AN003 is selected.
	ADC160_ADADS0_ADS03_1 = 0x1
	// Position of ADS02 field.
	ADC160_ADADS0_ADS02_Pos = 0x2
	// Bit mask of ADS02 field.
	ADC160_ADADS0_ADS02_Msk = 0x4
	// Bit ADS02.
	ADC160_ADADS0_ADS02 = 0x4
	// AN002 is not selected.
	ADC160_ADADS0_ADS02_0 = 0x0
	// AN002 is selected.
	ADC160_ADADS0_ADS02_1 = 0x1
	// Position of ADS01 field.
	ADC160_ADADS0_ADS01_Pos = 0x1
	// Bit mask of ADS01 field.
	ADC160_ADADS0_ADS01_Msk = 0x2
	// Bit ADS01.
	ADC160_ADADS0_ADS01 = 0x2
	// AN001 is not selected.
	ADC160_ADADS0_ADS01_0 = 0x0
	// AN001 is selected.
	ADC160_ADADS0_ADS01_1 = 0x1
	// Position of ADS00 field.
	ADC160_ADADS0_ADS00_Pos = 0x0
	// Bit mask of ADS00 field.
	ADC160_ADADS0_ADS00_Msk = 0x1
	// Bit ADS00.
	ADC160_ADADS0_ADS00 = 0x1
	// AN000 is not selected.
	ADC160_ADADS0_ADS00_0 = 0x0
	// AN000 is selected.
	ADC160_ADADS0_ADS00_1 = 0x1

	// ADADS1: A/D-Converted Value Average Channel Select Register 1
	// Position of Reserved field.
	ADC160_ADADS1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADADS1_Reserved_Msk = 0xfe00
	// Position of ADS24 field.
	ADC160_ADADS1_ADS24_Pos = 0x8
	// Bit mask of ADS24 field.
	ADC160_ADADS1_ADS24_Msk = 0x100
	// Bit ADS24.
	ADC160_ADADS1_ADS24 = 0x100
	// AN024 is not selected.
	ADC160_ADADS1_ADS24_0 = 0x0
	// AN024 is selected.
	ADC160_ADADS1_ADS24_1 = 0x1
	// Position of ADS23 field.
	ADC160_ADADS1_ADS23_Pos = 0x7
	// Bit mask of ADS23 field.
	ADC160_ADADS1_ADS23_Msk = 0x80
	// Bit ADS23.
	ADC160_ADADS1_ADS23 = 0x80
	// AN023 is not selected.
	ADC160_ADADS1_ADS23_0 = 0x0
	// AN023 is selected.
	ADC160_ADADS1_ADS23_1 = 0x1
	// Position of ADS22 field.
	ADC160_ADADS1_ADS22_Pos = 0x6
	// Bit mask of ADS22 field.
	ADC160_ADADS1_ADS22_Msk = 0x40
	// Bit ADS22.
	ADC160_ADADS1_ADS22 = 0x40
	// AN022 is not selected.
	ADC160_ADADS1_ADS22_0 = 0x0
	// AN022 is selected.
	ADC160_ADADS1_ADS22_1 = 0x1
	// Position of ADS21 field.
	ADC160_ADADS1_ADS21_Pos = 0x5
	// Bit mask of ADS21 field.
	ADC160_ADADS1_ADS21_Msk = 0x20
	// Bit ADS21.
	ADC160_ADADS1_ADS21 = 0x20
	// AN021 is not selected.
	ADC160_ADADS1_ADS21_0 = 0x0
	// AN021 is selected.
	ADC160_ADADS1_ADS21_1 = 0x1
	// Position of ADS20 field.
	ADC160_ADADS1_ADS20_Pos = 0x4
	// Bit mask of ADS20 field.
	ADC160_ADADS1_ADS20_Msk = 0x10
	// Bit ADS20.
	ADC160_ADADS1_ADS20 = 0x10
	// AN020 is not selected.
	ADC160_ADADS1_ADS20_0 = 0x0
	// AN020 is selected.
	ADC160_ADADS1_ADS20_1 = 0x1
	// Position of ADS19 field.
	ADC160_ADADS1_ADS19_Pos = 0x3
	// Bit mask of ADS19 field.
	ADC160_ADADS1_ADS19_Msk = 0x8
	// Bit ADS19.
	ADC160_ADADS1_ADS19 = 0x8
	// AN019 is not selected.
	ADC160_ADADS1_ADS19_0 = 0x0
	// AN019 is selected.
	ADC160_ADADS1_ADS19_1 = 0x1
	// Position of ADS18 field.
	ADC160_ADADS1_ADS18_Pos = 0x2
	// Bit mask of ADS18 field.
	ADC160_ADADS1_ADS18_Msk = 0x4
	// Bit ADS18.
	ADC160_ADADS1_ADS18 = 0x4
	// AN018 is not selected.
	ADC160_ADADS1_ADS18_0 = 0x0
	// AN018 is selected.
	ADC160_ADADS1_ADS18_1 = 0x1
	// Position of ADS17 field.
	ADC160_ADADS1_ADS17_Pos = 0x1
	// Bit mask of ADS17 field.
	ADC160_ADADS1_ADS17_Msk = 0x2
	// Bit ADS17.
	ADC160_ADADS1_ADS17 = 0x2
	// AN017 is not selected.
	ADC160_ADADS1_ADS17_0 = 0x0
	// AN017 is selected.
	ADC160_ADADS1_ADS17_1 = 0x1
	// Position of ADS16 field.
	ADC160_ADADS1_ADS16_Pos = 0x0
	// Bit mask of ADS16 field.
	ADC160_ADADS1_ADS16_Msk = 0x1
	// Bit ADS16.
	ADC160_ADADS1_ADS16 = 0x1
	// AN016 is not selected.
	ADC160_ADADS1_ADS16_0 = 0x0
	// AN016 is selected.
	ADC160_ADADS1_ADS16_1 = 0x1

	// ADADC: A/D-Converted Value Average Count Select Register
	// Position of Reserved field.
	ADC160_ADADC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	ADC160_ADADC_Reserved_Msk = 0xf8
	// Position of ADC field.
	ADC160_ADADC_ADC_Pos = 0x0
	// Bit mask of ADC field.
	ADC160_ADADC_ADC_Msk = 0x7
	// 1-time conversion (same as normal conversion)
	ADC160_ADADC_ADC_000 = 0x0
	// 2-time conversion (acquire the average of 2-time conversion)
	ADC160_ADADC_ADC_001 = 0x1
	// 4-time conversion (acquire the average of 4-time conversion)
	ADC160_ADADC_ADC_011 = 0x3
	// 8-time conversion (acquire the average of 8-time conversion)
	ADC160_ADADC_ADC_100 = 0x4
	// 16-time conversion (acquire the average of 16-time conversion)
	ADC160_ADADC_ADC_101 = 0x5

	// ADCER: A/D Control Extended Register
	// Position of Reserved field.
	ADC160_ADCER_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	ADC160_ADCER_Reserved_Msk = 0x8000
	// Bit Reserved.
	ADC160_ADCER_Reserved = 0x8000
	// Position of ADINV field.
	ADC160_ADCER_ADINV_Pos = 0xe
	// Bit mask of ADINV field.
	ADC160_ADCER_ADINV_Msk = 0x4000
	// Bit ADINV.
	ADC160_ADCER_ADINV = 0x4000
	// Data is stored in a range of -32768 to 0
	ADC160_ADCER_ADINV_0 = 0x0
	// Data is stored in a range of 0 to 32767
	ADC160_ADCER_ADINV_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCER_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC160_ADCER_Reserved_Msk = 0x3000
	// Position of DIAGM field.
	ADC160_ADCER_DIAGM_Pos = 0xb
	// Bit mask of DIAGM field.
	ADC160_ADCER_DIAGM_Msk = 0x800
	// Bit DIAGM.
	ADC160_ADCER_DIAGM = 0x800
	// Self-diagnosis of ADC16 disabled
	ADC160_ADCER_DIAGM_0 = 0x0
	// Self-diagnosis of ADC16 enabled.
	ADC160_ADCER_DIAGM_1 = 0x1
	// Position of DIAGLD field.
	ADC160_ADCER_DIAGLD_Pos = 0xa
	// Bit mask of DIAGLD field.
	ADC160_ADCER_DIAGLD_Msk = 0x400
	// Bit DIAGLD.
	ADC160_ADCER_DIAGLD = 0x400
	// Rotation mode for self-diagnosis voltage
	ADC160_ADCER_DIAGLD_0 = 0x0
	// Fixed mode for self-diagnosis voltage
	ADC160_ADCER_DIAGLD_1 = 0x1
	// Position of DIAGVAL field.
	ADC160_ADCER_DIAGVAL_Pos = 0x8
	// Bit mask of DIAGVAL field.
	ADC160_ADCER_DIAGVAL_Msk = 0x300
	// Setting prohibited when self-diagnosis is enabled
	ADC160_ADCER_DIAGVAL_00 = 0x0
	// -VREFH0 (Ideal value of A/D conversion result is 8000h)
	ADC160_ADCER_DIAGVAL_01 = 0x1
	// VREFL0 (Ideal value of A/D conversion result is 0000h)
	ADC160_ADCER_DIAGVAL_10 = 0x2
	// VREFH0 (Ideal value of A/D conversion result is 7FFFh).
	ADC160_ADCER_DIAGVAL_11 = 0x3
	// Position of Reserved field.
	ADC160_ADCER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC160_ADCER_Reserved_Msk = 0xc0
	// Position of ACE field.
	ADC160_ADCER_ACE_Pos = 0x5
	// Bit mask of ACE field.
	ADC160_ADCER_ACE_Msk = 0x20
	// Bit ACE.
	ADC160_ADCER_ACE = 0x20
	// Automatic clearing disabled
	ADC160_ADCER_ACE_0 = 0x0
	// Automatic clearing enabled.
	ADC160_ADCER_ACE_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCER_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ADC160_ADCER_Reserved_Msk = 0x1f

	// ADSTRGR: A/D Conversion Start Trigger Select Register
	// Position of Reserved field.
	ADC160_ADSTRGR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	ADC160_ADSTRGR_Reserved_Msk = 0xc000
	// Position of TRSA field.
	ADC160_ADSTRGR_TRSA_Pos = 0x8
	// Bit mask of TRSA field.
	ADC160_ADSTRGR_TRSA_Msk = 0x3f00
	// Position of Reserved field.
	ADC160_ADSTRGR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC160_ADSTRGR_Reserved_Msk = 0xc0
	// Position of TRSB field.
	ADC160_ADSTRGR_TRSB_Pos = 0x0
	// Bit mask of TRSB field.
	ADC160_ADSTRGR_TRSB_Msk = 0x3f

	// ADEXICR: A/D Conversion Extended Input Control Register
	// Position of Reserved field.
	ADC160_ADEXICR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	ADC160_ADEXICR_Reserved_Msk = 0xfc00
	// Position of OCSA field.
	ADC160_ADEXICR_OCSA_Pos = 0x9
	// Bit mask of OCSA field.
	ADC160_ADEXICR_OCSA_Msk = 0x200
	// Bit OCSA.
	ADC160_ADEXICR_OCSA = 0x200
	// A/D conversion of internal reference voltage disabled
	ADC160_ADEXICR_OCSA_0 = 0x0
	// A/D conversion of internal reference voltage enabled
	ADC160_ADEXICR_OCSA_1 = 0x1
	// Position of TSSA field.
	ADC160_ADEXICR_TSSA_Pos = 0x8
	// Bit mask of TSSA field.
	ADC160_ADEXICR_TSSA_Msk = 0x100
	// Bit TSSA.
	ADC160_ADEXICR_TSSA = 0x100
	// A/D conversion of temperature sensor output disabled
	ADC160_ADEXICR_TSSA_0 = 0x0
	// A/D conversion of temperature sensor output enabled
	ADC160_ADEXICR_TSSA_1 = 0x1
	// Position of Reserved field.
	ADC160_ADEXICR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADEXICR_Reserved_Msk = 0xfc
	// Position of OCSAD field.
	ADC160_ADEXICR_OCSAD_Pos = 0x1
	// Bit mask of OCSAD field.
	ADC160_ADEXICR_OCSAD_Msk = 0x2
	// Bit OCSAD.
	ADC160_ADEXICR_OCSAD = 0x2
	// Internal reference voltage A/D-converted value average mode not selected
	ADC160_ADEXICR_OCSAD_0 = 0x0
	// Internal reference voltage A/D-converted value average mode selected
	ADC160_ADEXICR_OCSAD_1 = 0x1
	// Position of TSSAD field.
	ADC160_ADEXICR_TSSAD_Pos = 0x0
	// Bit mask of TSSAD field.
	ADC160_ADEXICR_TSSAD_Msk = 0x1
	// Bit TSSAD.
	ADC160_ADEXICR_TSSAD = 0x1
	// Temperature sensor output A/D-converted value average mode not selected
	ADC160_ADEXICR_TSSAD_0 = 0x0
	// Temperature sensor output A/D-converted value average mode selected
	ADC160_ADEXICR_TSSAD_1 = 0x1

	// ADANSB0: A/D Channel Select Register B0
	// Position of Reserved field.
	ADC160_ADANSB0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADANSB0_Reserved_Msk = 0xfe00
	// Position of ANSB08 field.
	ADC160_ADANSB0_ANSB08_Pos = 0x8
	// Bit mask of ANSB08 field.
	ADC160_ADANSB0_ANSB08_Msk = 0x100
	// Bit ANSB08.
	ADC160_ADANSB0_ANSB08 = 0x100
	// AN008 is not selected
	ADC160_ADANSB0_ANSB08_0 = 0x0
	// AN008 is selected
	ADC160_ADANSB0_ANSB08_1 = 0x1
	// Position of ANSB07 field.
	ADC160_ADANSB0_ANSB07_Pos = 0x7
	// Bit mask of ANSB07 field.
	ADC160_ADANSB0_ANSB07_Msk = 0x80
	// Bit ANSB07.
	ADC160_ADANSB0_ANSB07 = 0x80
	// AN007 is not selected
	ADC160_ADANSB0_ANSB07_0 = 0x0
	// AN007 is selected
	ADC160_ADANSB0_ANSB07_1 = 0x1
	// Position of ANSB06 field.
	ADC160_ADANSB0_ANSB06_Pos = 0x6
	// Bit mask of ANSB06 field.
	ADC160_ADANSB0_ANSB06_Msk = 0x40
	// Bit ANSB06.
	ADC160_ADANSB0_ANSB06 = 0x40
	// AN006 is not selected
	ADC160_ADANSB0_ANSB06_0 = 0x0
	// AN006 is selected
	ADC160_ADANSB0_ANSB06_1 = 0x1
	// Position of ANSB05 field.
	ADC160_ADANSB0_ANSB05_Pos = 0x5
	// Bit mask of ANSB05 field.
	ADC160_ADANSB0_ANSB05_Msk = 0x20
	// Bit ANSB05.
	ADC160_ADANSB0_ANSB05 = 0x20
	// AN005 is not selected
	ADC160_ADANSB0_ANSB05_0 = 0x0
	// AN005 is selected
	ADC160_ADANSB0_ANSB05_1 = 0x1
	// Position of ANSB04 field.
	ADC160_ADANSB0_ANSB04_Pos = 0x4
	// Bit mask of ANSB04 field.
	ADC160_ADANSB0_ANSB04_Msk = 0x10
	// Bit ANSB04.
	ADC160_ADANSB0_ANSB04 = 0x10
	// AN004 is not selected
	ADC160_ADANSB0_ANSB04_0 = 0x0
	// AN004 is selected
	ADC160_ADANSB0_ANSB04_1 = 0x1
	// Position of ANSB03 field.
	ADC160_ADANSB0_ANSB03_Pos = 0x3
	// Bit mask of ANSB03 field.
	ADC160_ADANSB0_ANSB03_Msk = 0x8
	// Bit ANSB03.
	ADC160_ADANSB0_ANSB03 = 0x8
	// AN003 is not selected
	ADC160_ADANSB0_ANSB03_0 = 0x0
	// AN003 is selected
	ADC160_ADANSB0_ANSB03_1 = 0x1
	// Position of ANSB02 field.
	ADC160_ADANSB0_ANSB02_Pos = 0x2
	// Bit mask of ANSB02 field.
	ADC160_ADANSB0_ANSB02_Msk = 0x4
	// Bit ANSB02.
	ADC160_ADANSB0_ANSB02 = 0x4
	// AN002 is not selected
	ADC160_ADANSB0_ANSB02_0 = 0x0
	// AN002 is selected
	ADC160_ADANSB0_ANSB02_1 = 0x1
	// Position of ANSB01 field.
	ADC160_ADANSB0_ANSB01_Pos = 0x1
	// Bit mask of ANSB01 field.
	ADC160_ADANSB0_ANSB01_Msk = 0x2
	// Bit ANSB01.
	ADC160_ADANSB0_ANSB01 = 0x2
	// AN001 is not selected
	ADC160_ADANSB0_ANSB01_0 = 0x0
	// AN001 is selected
	ADC160_ADANSB0_ANSB01_1 = 0x1
	// Position of ANSB00 field.
	ADC160_ADANSB0_ANSB00_Pos = 0x0
	// Bit mask of ANSB00 field.
	ADC160_ADANSB0_ANSB00_Msk = 0x1
	// Bit ANSB00.
	ADC160_ADANSB0_ANSB00 = 0x1
	// AN000 is not selected
	ADC160_ADANSB0_ANSB00_0 = 0x0
	// AN000 is selected
	ADC160_ADANSB0_ANSB00_1 = 0x1

	// ADANSB1: A/D Channel Select Register B1
	// Position of Reserved field.
	ADC160_ADANSB1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADANSB1_Reserved_Msk = 0xfe00
	// Position of ANSB24 field.
	ADC160_ADANSB1_ANSB24_Pos = 0x8
	// Bit mask of ANSB24 field.
	ADC160_ADANSB1_ANSB24_Msk = 0x100
	// Bit ANSB24.
	ADC160_ADANSB1_ANSB24 = 0x100
	// AN024 is not selected
	ADC160_ADANSB1_ANSB24_0 = 0x0
	// AN024 is selected
	ADC160_ADANSB1_ANSB24_1 = 0x1
	// Position of ANSB23 field.
	ADC160_ADANSB1_ANSB23_Pos = 0x7
	// Bit mask of ANSB23 field.
	ADC160_ADANSB1_ANSB23_Msk = 0x80
	// Bit ANSB23.
	ADC160_ADANSB1_ANSB23 = 0x80
	// AN023 is not selected
	ADC160_ADANSB1_ANSB23_0 = 0x0
	// AN023 is selected
	ADC160_ADANSB1_ANSB23_1 = 0x1
	// Position of ANSB22 field.
	ADC160_ADANSB1_ANSB22_Pos = 0x6
	// Bit mask of ANSB22 field.
	ADC160_ADANSB1_ANSB22_Msk = 0x40
	// Bit ANSB22.
	ADC160_ADANSB1_ANSB22 = 0x40
	// AN022 is not selected
	ADC160_ADANSB1_ANSB22_0 = 0x0
	// AN022 is selected
	ADC160_ADANSB1_ANSB22_1 = 0x1
	// Position of ANSB21 field.
	ADC160_ADANSB1_ANSB21_Pos = 0x5
	// Bit mask of ANSB21 field.
	ADC160_ADANSB1_ANSB21_Msk = 0x20
	// Bit ANSB21.
	ADC160_ADANSB1_ANSB21 = 0x20
	// AN021 is not selected
	ADC160_ADANSB1_ANSB21_0 = 0x0
	// AN021 is selected
	ADC160_ADANSB1_ANSB21_1 = 0x1
	// Position of ANSB20 field.
	ADC160_ADANSB1_ANSB20_Pos = 0x4
	// Bit mask of ANSB20 field.
	ADC160_ADANSB1_ANSB20_Msk = 0x10
	// Bit ANSB20.
	ADC160_ADANSB1_ANSB20 = 0x10
	// AN020 is not selected
	ADC160_ADANSB1_ANSB20_0 = 0x0
	// AN020 is selected
	ADC160_ADANSB1_ANSB20_1 = 0x1
	// Position of ANSB19 field.
	ADC160_ADANSB1_ANSB19_Pos = 0x3
	// Bit mask of ANSB19 field.
	ADC160_ADANSB1_ANSB19_Msk = 0x8
	// Bit ANSB19.
	ADC160_ADANSB1_ANSB19 = 0x8
	// AN019 is not selected
	ADC160_ADANSB1_ANSB19_0 = 0x0
	// AN019 is selected
	ADC160_ADANSB1_ANSB19_1 = 0x1
	// Position of ANSB18 field.
	ADC160_ADANSB1_ANSB18_Pos = 0x2
	// Bit mask of ANSB18 field.
	ADC160_ADANSB1_ANSB18_Msk = 0x4
	// Bit ANSB18.
	ADC160_ADANSB1_ANSB18 = 0x4
	// AN018 is not selected
	ADC160_ADANSB1_ANSB18_0 = 0x0
	// AN018 is selected
	ADC160_ADANSB1_ANSB18_1 = 0x1
	// Position of ANSB17 field.
	ADC160_ADANSB1_ANSB17_Pos = 0x1
	// Bit mask of ANSB17 field.
	ADC160_ADANSB1_ANSB17_Msk = 0x2
	// Bit ANSB17.
	ADC160_ADANSB1_ANSB17 = 0x2
	// AN017 is not selected
	ADC160_ADANSB1_ANSB17_0 = 0x0
	// AN017 is selected
	ADC160_ADANSB1_ANSB17_1 = 0x1
	// Position of ANSB16 field.
	ADC160_ADANSB1_ANSB16_Pos = 0x0
	// Bit mask of ANSB16 field.
	ADC160_ADANSB1_ANSB16_Msk = 0x1
	// Bit ANSB16.
	ADC160_ADANSB1_ANSB16 = 0x1
	// AN016 is not selected
	ADC160_ADANSB1_ANSB16_0 = 0x0
	// AN016 is selected
	ADC160_ADANSB1_ANSB16_1 = 0x1

	// ADDBLDR: A/D Data Duplexing Register
	// Position of ADDBLDR field.
	ADC160_ADDBLDR_ADDBLDR_Pos = 0x0
	// Bit mask of ADDBLDR field.
	ADC160_ADDBLDR_ADDBLDR_Msk = 0xffff

	// ADTSDR: A/D Temperature Sensor Data Register
	// Position of ADTSDR field.
	ADC160_ADTSDR_ADTSDR_Pos = 0x0
	// Bit mask of ADTSDR field.
	ADC160_ADTSDR_ADTSDR_Msk = 0xffff

	// ADOCDR: A/D Internal Reference Voltage Data Register
	// Position of ADOCDR field.
	ADC160_ADOCDR_ADOCDR_Pos = 0x0
	// Bit mask of ADOCDR field.
	ADC160_ADOCDR_ADOCDR_Msk = 0xffff

	// ADDR0: A/D Data Register %s
	// Position of ADDR field.
	ADC160_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC160_ADDR_ADDR_Msk = 0xffff

	// ADDR16: A/D Data Register %s
	// Position of ADDR field.
	ADC160_ADDR_ADDR_Pos = 0x0
	// Bit mask of ADDR field.
	ADC160_ADDR_ADDR_Msk = 0xffff

	// ADDISCR: A/D Disconnection Detection Control Register
	// Position of Reserved field.
	ADC160_ADDISCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC160_ADDISCR_Reserved_Msk = 0xc0
	// Position of PCHG1 field.
	ADC160_ADDISCR_PCHG1_Pos = 0x5
	// Bit mask of PCHG1 field.
	ADC160_ADDISCR_PCHG1_Msk = 0x20
	// Bit PCHG1.
	ADC160_ADDISCR_PCHG1 = 0x20
	// The analog input path 1 voltage is discharged
	ADC160_ADDISCR_PCHG1_0 = 0x0
	// The analog input path 1 voltage is precharged.
	ADC160_ADDISCR_PCHG1_1 = 0x1
	// Position of PCHG2 field.
	ADC160_ADDISCR_PCHG2_Pos = 0x4
	// Bit mask of PCHG2 field.
	ADC160_ADDISCR_PCHG2_Msk = 0x10
	// Bit PCHG2.
	ADC160_ADDISCR_PCHG2 = 0x10
	// The analog input path 2 voltage is discharged
	ADC160_ADDISCR_PCHG2_0 = 0x0
	// The analog input path 2 voltage is precharged.
	ADC160_ADDISCR_PCHG2_1 = 0x1
	// Position of ADNDIS field.
	ADC160_ADDISCR_ADNDIS_Pos = 0x0
	// Bit mask of ADNDIS field.
	ADC160_ADDISCR_ADNDIS_Msk = 0xf
	// The disconnection detection assist function is disabled
	ADC160_ADDISCR_ADNDIS_0000 = 0x0
	// Setting prohibited
	ADC160_ADDISCR_ADNDIS_0001 = 0x1

	// ADICR: A/D Interrupt Control Register
	// Position of Reserved field.
	ADC160_ADICR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADICR_Reserved_Msk = 0xfc
	// Position of ADIC field.
	ADC160_ADICR_ADIC_Pos = 0x0
	// Bit mask of ADIC field.
	ADC160_ADICR_ADIC_Msk = 0x3
	// ADC160_ADI is generated at the end of A/D scan
	ADC160_ADICR_ADIC_00 = 0x0
	// ADC160_ADI is generated at the end of calibration
	ADC160_ADICR_ADIC_11 = 0x3

	// ADGSPCR: A/D Group Scan Priority Control Register
	// Position of GBRP field.
	ADC160_ADGSPCR_GBRP_Pos = 0xf
	// Bit mask of GBRP field.
	ADC160_ADGSPCR_GBRP_Msk = 0x8000
	// Bit GBRP.
	ADC160_ADGSPCR_GBRP = 0x8000
	// Single scan for group B is not continuously activated.
	ADC160_ADGSPCR_GBRP_0 = 0x0
	// Single scan for group B is continuously activated.
	ADC160_ADGSPCR_GBRP_1 = 0x1
	// Position of Reserved field.
	ADC160_ADGSPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADGSPCR_Reserved_Msk = 0x7ffc
	// Position of GBRSCN field.
	ADC160_ADGSPCR_GBRSCN_Pos = 0x1
	// Bit mask of GBRSCN field.
	ADC160_ADGSPCR_GBRSCN_Msk = 0x2
	// Bit GBRSCN.
	ADC160_ADGSPCR_GBRSCN = 0x2
	// Scanning for group B is not restarted after having been discontinued due to group A priority control.
	ADC160_ADGSPCR_GBRSCN_0 = 0x0
	// Scanning for group B is restarted after having been discontinued due to group A priority control.
	ADC160_ADGSPCR_GBRSCN_1 = 0x1
	// Position of PGS field.
	ADC160_ADGSPCR_PGS_Pos = 0x0
	// Bit mask of PGS field.
	ADC160_ADGSPCR_PGS_Msk = 0x1
	// Bit PGS.
	ADC160_ADGSPCR_PGS = 0x1
	// Operation is without group A priority control
	ADC160_ADGSPCR_PGS_0 = 0x0
	// Operation is with group A priority control
	ADC160_ADGSPCR_PGS_1 = 0x1

	// ADDBLDRA: A/D Data Duplexing Register A
	// Position of ADDBLDRA field.
	ADC160_ADDBLDRA_ADDBLDRA_Pos = 0x0
	// Bit mask of ADDBLDRA field.
	ADC160_ADDBLDRA_ADDBLDRA_Msk = 0xffff

	// ADDBLDRB: A/D Data Duplexing Register B
	// Position of ADDBLDRB field.
	ADC160_ADDBLDRB_ADDBLDRB_Pos = 0x0
	// Bit mask of ADDBLDRB field.
	ADC160_ADDBLDRB_ADDBLDRB_Msk = 0xffff

	// ADWINMON: A/D Compare Function Window A/B Status Monitor Register
	// Position of Reserved field.
	ADC160_ADWINMON_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC160_ADWINMON_Reserved_Msk = 0xc0
	// Position of MONCMPB field.
	ADC160_ADWINMON_MONCMPB_Pos = 0x5
	// Bit mask of MONCMPB field.
	ADC160_ADWINMON_MONCMPB_Msk = 0x20
	// Bit MONCMPB.
	ADC160_ADWINMON_MONCMPB = 0x20
	// Window B comparison conditions are not met.
	ADC160_ADWINMON_MONCMPB_0 = 0x0
	// Window B comparison conditions are met.
	ADC160_ADWINMON_MONCMPB_1 = 0x1
	// Position of MONCMPA field.
	ADC160_ADWINMON_MONCMPA_Pos = 0x4
	// Bit mask of MONCMPA field.
	ADC160_ADWINMON_MONCMPA_Msk = 0x10
	// Bit MONCMPA.
	ADC160_ADWINMON_MONCMPA = 0x10
	// Window A comparison conditions are not met.
	ADC160_ADWINMON_MONCMPA_0 = 0x0
	// Window A comparison conditions are met.
	ADC160_ADWINMON_MONCMPA_1 = 0x1
	// Position of Reserved field.
	ADC160_ADWINMON_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ADC160_ADWINMON_Reserved_Msk = 0xe
	// Position of MONCOMB field.
	ADC160_ADWINMON_MONCOMB_Pos = 0x0
	// Bit mask of MONCOMB field.
	ADC160_ADWINMON_MONCOMB_Msk = 0x1
	// Bit MONCOMB.
	ADC160_ADWINMON_MONCOMB = 0x1
	// Window A / window B composite conditions are not met.
	ADC160_ADWINMON_MONCOMB_0 = 0x0
	// Window A / window B composite conditions are met.
	ADC160_ADWINMON_MONCOMB_1 = 0x1

	// ADCMPCR: A/D Compare Function Control Register
	// Position of CMPAIE field.
	ADC160_ADCMPCR_CMPAIE_Pos = 0xf
	// Bit mask of CMPAIE field.
	ADC160_ADCMPCR_CMPAIE_Msk = 0x8000
	// Bit CMPAIE.
	ADC160_ADCMPCR_CMPAIE = 0x8000
	// ADC160_CMPAI interrupt is disabled when comparison conditions (window A) are met.
	ADC160_ADCMPCR_CMPAIE_0 = 0x0
	// ADC160_CMPAI interrupt is enabled when comparison conditions (window A) are met.
	ADC160_ADCMPCR_CMPAIE_1 = 0x1
	// Position of WCMPE field.
	ADC160_ADCMPCR_WCMPE_Pos = 0xe
	// Bit mask of WCMPE field.
	ADC160_ADCMPCR_WCMPE_Msk = 0x4000
	// Bit WCMPE.
	ADC160_ADCMPCR_WCMPE = 0x4000
	// Window function is disabled. Window A and window B operate as a comparator to comparator the single value on the lower side with the A/D conversion result.
	ADC160_ADCMPCR_WCMPE_0 = 0x0
	// Window function is enabled. Window A and window B operate as a comparator to comparator the two values on the upper and lower sides with the A/D conversion result.
	ADC160_ADCMPCR_WCMPE_1 = 0x1
	// Position of CMPBIE field.
	ADC160_ADCMPCR_CMPBIE_Pos = 0xd
	// Bit mask of CMPBIE field.
	ADC160_ADCMPCR_CMPBIE_Msk = 0x2000
	// Bit CMPBIE.
	ADC160_ADCMPCR_CMPBIE = 0x2000
	// ADC160_CMPBI interrupt is disabled when comparison conditions (window B) are met.
	ADC160_ADCMPCR_CMPBIE_0 = 0x0
	// ADC160_CMPBI interrupt is enabled when comparison conditions (window B) are met.
	ADC160_ADCMPCR_CMPBIE_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCMPCR_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	ADC160_ADCMPCR_Reserved_Msk = 0x1000
	// Bit Reserved.
	ADC160_ADCMPCR_Reserved = 0x1000
	// Position of CMPAE field.
	ADC160_ADCMPCR_CMPAE_Pos = 0xb
	// Bit mask of CMPAE field.
	ADC160_ADCMPCR_CMPAE_Msk = 0x800
	// Bit CMPAE.
	ADC160_ADCMPCR_CMPAE = 0x800
	// Compare window A operation is disabled. ADC160_WCMPM and ADC160_WCMPUM outputs are disabled.
	ADC160_ADCMPCR_CMPAE_0 = 0x0
	// Compare window A operation is enabled.
	ADC160_ADCMPCR_CMPAE_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCMPCR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	ADC160_ADCMPCR_Reserved_Msk = 0x400
	// Bit Reserved.
	ADC160_ADCMPCR_Reserved = 0x400
	// Position of CMPBE field.
	ADC160_ADCMPCR_CMPBE_Pos = 0x9
	// Bit mask of CMPBE field.
	ADC160_ADCMPCR_CMPBE_Msk = 0x200
	// Bit CMPBE.
	ADC160_ADCMPCR_CMPBE = 0x200
	// Compare window B operation is disabled. ADC160_WCMPM and ADC160_WCMPUM outputs are disabled.
	ADC160_ADCMPCR_CMPBE_0 = 0x0
	// Compare window B operation is enabled.
	ADC160_ADCMPCR_CMPBE_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCMPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADCMPCR_Reserved_Msk = 0x1fc
	// Position of CMPAB field.
	ADC160_ADCMPCR_CMPAB_Pos = 0x0
	// Bit mask of CMPAB field.
	ADC160_ADCMPCR_CMPAB_Msk = 0x3
	// ADC160_WCMPM is output when window A comparison conditions are met OR window B comparison conditions are met. ADC160_WCMPUM is output in other cases.
	ADC160_ADCMPCR_CMPAB_00 = 0x0
	// ADC160_WCMPM is output when window A comparison conditions are met EXOR window B comparison conditions are met. ADC160_WCMPUM is output in other cases.
	ADC160_ADCMPCR_CMPAB_01 = 0x1
	// ADC160_WCMPM is output when window A comparison conditions are met and window B comparison conditions are met. ADC160_WCMPUM is output in other cases.
	ADC160_ADCMPCR_CMPAB_10 = 0x2
	// Setting prohibited.
	ADC160_ADCMPCR_CMPAB_11 = 0x3

	// ADCMPANSER: A/D Compare Function Window A Extended Input Select Register
	// Position of Reserved field.
	ADC160_ADCMPANSER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADCMPANSER_Reserved_Msk = 0xfc
	// Position of CMPOCA field.
	ADC160_ADCMPANSER_CMPOCA_Pos = 0x1
	// Bit mask of CMPOCA field.
	ADC160_ADCMPANSER_CMPOCA_Msk = 0x2
	// Bit CMPOCA.
	ADC160_ADCMPANSER_CMPOCA = 0x2
	// Excludes the internal reference voltage from the compare window A target range.
	ADC160_ADCMPANSER_CMPOCA_0 = 0x0
	// Includes the internal reference voltage in the compare window A target range.
	ADC160_ADCMPANSER_CMPOCA_1 = 0x1
	// Position of CMPTSA field.
	ADC160_ADCMPANSER_CMPTSA_Pos = 0x0
	// Bit mask of CMPTSA field.
	ADC160_ADCMPANSER_CMPTSA_Msk = 0x1
	// Bit CMPTSA.
	ADC160_ADCMPANSER_CMPTSA = 0x1
	// Excludes the temperature sensor output from the compare window A target range.
	ADC160_ADCMPANSER_CMPTSA_0 = 0x0
	// Includes the temperature sensor output in the compare window A target range.
	ADC160_ADCMPANSER_CMPTSA_1 = 0x1

	// ADCMPLER: A/D Compare Function Window A Extended Input Comparison Condition Setting Register
	// Position of Reserved field.
	ADC160_ADCMPLER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADCMPLER_Reserved_Msk = 0xfc
	// Position of CMPLOCA field.
	ADC160_ADCMPLER_CMPLOCA_Pos = 0x1
	// Bit mask of CMPLOCA field.
	ADC160_ADCMPLER_CMPLOCA_Msk = 0x2
	// Bit CMPLOCA.
	ADC160_ADCMPLER_CMPLOCA = 0x2
	// ADCMPDR0 value > A/D converted value(ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or A/D converted value > ADCMPDR1 value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLER_CMPLOCA_0 = 0x0
	// ADCMPDR0 value < A/D converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 value < A/D converted value < ADCMPDR1 value(ADCMPCR.WCMPE=1)
	ADC160_ADCMPLER_CMPLOCA_1 = 0x1
	// Position of CMPLTSA field.
	ADC160_ADCMPLER_CMPLTSA_Pos = 0x0
	// Bit mask of CMPLTSA field.
	ADC160_ADCMPLER_CMPLTSA_Msk = 0x1
	// Bit CMPLTSA.
	ADC160_ADCMPLER_CMPLTSA = 0x1
	// ADCMPDR0 register value > A/D-converted value(ADCMPCR.WCMPE=0) / AD-converted value < ADCMPDR0 register value or A/D-converted value > ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC160_ADCMPLER_CMPLTSA_0 = 0x0
	// ADCMPDR0 register value < A/D-converted value(ADCMPCR.WCMPE=0) / ADCMPDR0 register value < A/D-converted value < ADCMPDR1 register value(ADCMPCR.WCMPE=1).
	ADC160_ADCMPLER_CMPLTSA_1 = 0x1

	// ADCMPANSR0: A/D Compare Function Window A Channel Select Register 0
	// Position of Reserved field.
	ADC160_ADCMPANSR0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPANSR0_Reserved_Msk = 0xfe00
	// Position of CMPCHA08 field.
	ADC160_ADCMPANSR0_CMPCHA08_Pos = 0x8
	// Bit mask of CMPCHA08 field.
	ADC160_ADCMPANSR0_CMPCHA08_Msk = 0x100
	// Bit CMPCHA08.
	ADC160_ADCMPANSR0_CMPCHA08 = 0x100
	// Compare function disabled for AN008
	ADC160_ADCMPANSR0_CMPCHA08_0 = 0x0
	// Compare function enabled for AN008
	ADC160_ADCMPANSR0_CMPCHA08_1 = 0x1
	// Position of CMPCHA07 field.
	ADC160_ADCMPANSR0_CMPCHA07_Pos = 0x7
	// Bit mask of CMPCHA07 field.
	ADC160_ADCMPANSR0_CMPCHA07_Msk = 0x80
	// Bit CMPCHA07.
	ADC160_ADCMPANSR0_CMPCHA07 = 0x80
	// Compare function disabled for AN007
	ADC160_ADCMPANSR0_CMPCHA07_0 = 0x0
	// Compare function enabled for AN007
	ADC160_ADCMPANSR0_CMPCHA07_1 = 0x1
	// Position of CMPCHA06 field.
	ADC160_ADCMPANSR0_CMPCHA06_Pos = 0x6
	// Bit mask of CMPCHA06 field.
	ADC160_ADCMPANSR0_CMPCHA06_Msk = 0x40
	// Bit CMPCHA06.
	ADC160_ADCMPANSR0_CMPCHA06 = 0x40
	// Compare function disabled for AN006
	ADC160_ADCMPANSR0_CMPCHA06_0 = 0x0
	// Compare function enabled for AN006
	ADC160_ADCMPANSR0_CMPCHA06_1 = 0x1
	// Position of CMPCHA05 field.
	ADC160_ADCMPANSR0_CMPCHA05_Pos = 0x5
	// Bit mask of CMPCHA05 field.
	ADC160_ADCMPANSR0_CMPCHA05_Msk = 0x20
	// Bit CMPCHA05.
	ADC160_ADCMPANSR0_CMPCHA05 = 0x20
	// Compare function disabled for AN005
	ADC160_ADCMPANSR0_CMPCHA05_0 = 0x0
	// Compare function enabled for AN005
	ADC160_ADCMPANSR0_CMPCHA05_1 = 0x1
	// Position of CMPCHA04 field.
	ADC160_ADCMPANSR0_CMPCHA04_Pos = 0x4
	// Bit mask of CMPCHA04 field.
	ADC160_ADCMPANSR0_CMPCHA04_Msk = 0x10
	// Bit CMPCHA04.
	ADC160_ADCMPANSR0_CMPCHA04 = 0x10
	// Compare function disabled for AN004
	ADC160_ADCMPANSR0_CMPCHA04_0 = 0x0
	// Compare function enabled for AN004
	ADC160_ADCMPANSR0_CMPCHA04_1 = 0x1
	// Position of CMPCHA03 field.
	ADC160_ADCMPANSR0_CMPCHA03_Pos = 0x3
	// Bit mask of CMPCHA03 field.
	ADC160_ADCMPANSR0_CMPCHA03_Msk = 0x8
	// Bit CMPCHA03.
	ADC160_ADCMPANSR0_CMPCHA03 = 0x8
	// Compare function disabled for AN003
	ADC160_ADCMPANSR0_CMPCHA03_0 = 0x0
	// Compare function enabled for AN003
	ADC160_ADCMPANSR0_CMPCHA03_1 = 0x1
	// Position of CMPCHA02 field.
	ADC160_ADCMPANSR0_CMPCHA02_Pos = 0x2
	// Bit mask of CMPCHA02 field.
	ADC160_ADCMPANSR0_CMPCHA02_Msk = 0x4
	// Bit CMPCHA02.
	ADC160_ADCMPANSR0_CMPCHA02 = 0x4
	// Compare function disabled for AN002
	ADC160_ADCMPANSR0_CMPCHA02_0 = 0x0
	// Compare function enabled for AN002
	ADC160_ADCMPANSR0_CMPCHA02_1 = 0x1
	// Position of CMPCHA01 field.
	ADC160_ADCMPANSR0_CMPCHA01_Pos = 0x1
	// Bit mask of CMPCHA01 field.
	ADC160_ADCMPANSR0_CMPCHA01_Msk = 0x2
	// Bit CMPCHA01.
	ADC160_ADCMPANSR0_CMPCHA01 = 0x2
	// Compare function disabled for AN001
	ADC160_ADCMPANSR0_CMPCHA01_0 = 0x0
	// Compare function enabled for AN001
	ADC160_ADCMPANSR0_CMPCHA01_1 = 0x1
	// Position of CMPCHA00 field.
	ADC160_ADCMPANSR0_CMPCHA00_Pos = 0x0
	// Bit mask of CMPCHA00 field.
	ADC160_ADCMPANSR0_CMPCHA00_Msk = 0x1
	// Bit CMPCHA00.
	ADC160_ADCMPANSR0_CMPCHA00 = 0x1
	// Compare function disabled for AN000
	ADC160_ADCMPANSR0_CMPCHA00_0 = 0x0
	// Compare function enabled for AN000
	ADC160_ADCMPANSR0_CMPCHA00_1 = 0x1

	// ADCMPANSR1: A/D Compare Function Window A Channel Select Register 1
	// Position of Reserved field.
	ADC160_ADCMPANSR1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPANSR1_Reserved_Msk = 0xfe00
	// Position of CMPCHA24 field.
	ADC160_ADCMPANSR1_CMPCHA24_Pos = 0x8
	// Bit mask of CMPCHA24 field.
	ADC160_ADCMPANSR1_CMPCHA24_Msk = 0x100
	// Bit CMPCHA24.
	ADC160_ADCMPANSR1_CMPCHA24 = 0x100
	// Compare function disabled for AN024
	ADC160_ADCMPANSR1_CMPCHA24_0 = 0x0
	// Compare function enabled for AN024
	ADC160_ADCMPANSR1_CMPCHA24_1 = 0x1
	// Position of CMPCHA23 field.
	ADC160_ADCMPANSR1_CMPCHA23_Pos = 0x7
	// Bit mask of CMPCHA23 field.
	ADC160_ADCMPANSR1_CMPCHA23_Msk = 0x80
	// Bit CMPCHA23.
	ADC160_ADCMPANSR1_CMPCHA23 = 0x80
	// Compare function disabled for AN023
	ADC160_ADCMPANSR1_CMPCHA23_0 = 0x0
	// Compare function enabled for AN023
	ADC160_ADCMPANSR1_CMPCHA23_1 = 0x1
	// Position of CMPCHA22 field.
	ADC160_ADCMPANSR1_CMPCHA22_Pos = 0x6
	// Bit mask of CMPCHA22 field.
	ADC160_ADCMPANSR1_CMPCHA22_Msk = 0x40
	// Bit CMPCHA22.
	ADC160_ADCMPANSR1_CMPCHA22 = 0x40
	// Compare function disabled for AN022
	ADC160_ADCMPANSR1_CMPCHA22_0 = 0x0
	// Compare function enabled for AN022
	ADC160_ADCMPANSR1_CMPCHA22_1 = 0x1
	// Position of CMPCHA21 field.
	ADC160_ADCMPANSR1_CMPCHA21_Pos = 0x5
	// Bit mask of CMPCHA21 field.
	ADC160_ADCMPANSR1_CMPCHA21_Msk = 0x20
	// Bit CMPCHA21.
	ADC160_ADCMPANSR1_CMPCHA21 = 0x20
	// Compare function disabled for AN021
	ADC160_ADCMPANSR1_CMPCHA21_0 = 0x0
	// Compare function enabled for AN021
	ADC160_ADCMPANSR1_CMPCHA21_1 = 0x1
	// Position of CMPCHA20 field.
	ADC160_ADCMPANSR1_CMPCHA20_Pos = 0x4
	// Bit mask of CMPCHA20 field.
	ADC160_ADCMPANSR1_CMPCHA20_Msk = 0x10
	// Bit CMPCHA20.
	ADC160_ADCMPANSR1_CMPCHA20 = 0x10
	// Compare function disabled for AN020
	ADC160_ADCMPANSR1_CMPCHA20_0 = 0x0
	// Compare function enabled for AN020
	ADC160_ADCMPANSR1_CMPCHA20_1 = 0x1
	// Position of CMPCHA19 field.
	ADC160_ADCMPANSR1_CMPCHA19_Pos = 0x3
	// Bit mask of CMPCHA19 field.
	ADC160_ADCMPANSR1_CMPCHA19_Msk = 0x8
	// Bit CMPCHA19.
	ADC160_ADCMPANSR1_CMPCHA19 = 0x8
	// Compare function disabled for AN019
	ADC160_ADCMPANSR1_CMPCHA19_0 = 0x0
	// Compare function enabled for AN019
	ADC160_ADCMPANSR1_CMPCHA19_1 = 0x1
	// Position of CMPCHA18 field.
	ADC160_ADCMPANSR1_CMPCHA18_Pos = 0x2
	// Bit mask of CMPCHA18 field.
	ADC160_ADCMPANSR1_CMPCHA18_Msk = 0x4
	// Bit CMPCHA18.
	ADC160_ADCMPANSR1_CMPCHA18 = 0x4
	// Compare function disabled for AN018
	ADC160_ADCMPANSR1_CMPCHA18_0 = 0x0
	// Compare function enabled for AN018
	ADC160_ADCMPANSR1_CMPCHA18_1 = 0x1
	// Position of CMPCHA17 field.
	ADC160_ADCMPANSR1_CMPCHA17_Pos = 0x1
	// Bit mask of CMPCHA17 field.
	ADC160_ADCMPANSR1_CMPCHA17_Msk = 0x2
	// Bit CMPCHA17.
	ADC160_ADCMPANSR1_CMPCHA17 = 0x2
	// Compare function disabled for AN017
	ADC160_ADCMPANSR1_CMPCHA17_0 = 0x0
	// Compare function enabled for AN017
	ADC160_ADCMPANSR1_CMPCHA17_1 = 0x1
	// Position of CMPCHA16 field.
	ADC160_ADCMPANSR1_CMPCHA16_Pos = 0x0
	// Bit mask of CMPCHA16 field.
	ADC160_ADCMPANSR1_CMPCHA16_Msk = 0x1
	// Bit CMPCHA16.
	ADC160_ADCMPANSR1_CMPCHA16 = 0x1
	// Compare function disabled for AN016
	ADC160_ADCMPANSR1_CMPCHA16_0 = 0x0
	// Compare function enabled for AN016
	ADC160_ADCMPANSR1_CMPCHA16_1 = 0x1

	// ADCMPLR0: A/D Compare Function Window A Comparison Condition Setting Register 0
	// Position of Reserved field.
	ADC160_ADCMPLR0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPLR0_Reserved_Msk = 0xfe00
	// Position of CMPLCHA08 field.
	ADC160_ADCMPLR0_CMPLCHA08_Pos = 0x8
	// Bit mask of CMPLCHA08 field.
	ADC160_ADCMPLR0_CMPLCHA08_Msk = 0x100
	// Bit CMPLCHA08.
	ADC160_ADCMPLR0_CMPLCHA08 = 0x100
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA08_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA08_1 = 0x1
	// Position of CMPLCHA07 field.
	ADC160_ADCMPLR0_CMPLCHA07_Pos = 0x7
	// Bit mask of CMPLCHA07 field.
	ADC160_ADCMPLR0_CMPLCHA07_Msk = 0x80
	// Bit CMPLCHA07.
	ADC160_ADCMPLR0_CMPLCHA07 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA07_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA07_1 = 0x1
	// Position of CMPLCHA06 field.
	ADC160_ADCMPLR0_CMPLCHA06_Pos = 0x6
	// Bit mask of CMPLCHA06 field.
	ADC160_ADCMPLR0_CMPLCHA06_Msk = 0x40
	// Bit CMPLCHA06.
	ADC160_ADCMPLR0_CMPLCHA06 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA06_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA06_1 = 0x1
	// Position of CMPLCHA05 field.
	ADC160_ADCMPLR0_CMPLCHA05_Pos = 0x5
	// Bit mask of CMPLCHA05 field.
	ADC160_ADCMPLR0_CMPLCHA05_Msk = 0x20
	// Bit CMPLCHA05.
	ADC160_ADCMPLR0_CMPLCHA05 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA05_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA05_1 = 0x1
	// Position of CMPLCHA04 field.
	ADC160_ADCMPLR0_CMPLCHA04_Pos = 0x4
	// Bit mask of CMPLCHA04 field.
	ADC160_ADCMPLR0_CMPLCHA04_Msk = 0x10
	// Bit CMPLCHA04.
	ADC160_ADCMPLR0_CMPLCHA04 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA04_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA04_1 = 0x1
	// Position of CMPLCHA03 field.
	ADC160_ADCMPLR0_CMPLCHA03_Pos = 0x3
	// Bit mask of CMPLCHA03 field.
	ADC160_ADCMPLR0_CMPLCHA03_Msk = 0x8
	// Bit CMPLCHA03.
	ADC160_ADCMPLR0_CMPLCHA03 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA03_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA03_1 = 0x1
	// Position of CMPLCHA02 field.
	ADC160_ADCMPLR0_CMPLCHA02_Pos = 0x2
	// Bit mask of CMPLCHA02 field.
	ADC160_ADCMPLR0_CMPLCHA02_Msk = 0x4
	// Bit CMPLCHA02.
	ADC160_ADCMPLR0_CMPLCHA02 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA02_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA02_1 = 0x1
	// Position of CMPLCHA01 field.
	ADC160_ADCMPLR0_CMPLCHA01_Pos = 0x1
	// Bit mask of CMPLCHA01 field.
	ADC160_ADCMPLR0_CMPLCHA01_Msk = 0x2
	// Bit CMPLCHA01.
	ADC160_ADCMPLR0_CMPLCHA01 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA01_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA01_1 = 0x1
	// Position of CMPLCHA00 field.
	ADC160_ADCMPLR0_CMPLCHA00_Pos = 0x0
	// Bit mask of CMPLCHA00 field.
	ADC160_ADCMPLR0_CMPLCHA00_Msk = 0x1
	// Bit CMPLCHA00.
	ADC160_ADCMPLR0_CMPLCHA00 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR0_CMPLCHA00_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR0_CMPLCHA00_1 = 0x1

	// ADCMPLR1: A/D Compare Function Window A Comparison Condition Setting Register 1
	// Position of Reserved field.
	ADC160_ADCMPLR1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPLR1_Reserved_Msk = 0xfe00
	// Position of CMPLCHA24 field.
	ADC160_ADCMPLR1_CMPLCHA24_Pos = 0x8
	// Bit mask of CMPLCHA24 field.
	ADC160_ADCMPLR1_CMPLCHA24_Msk = 0x100
	// Bit CMPLCHA24.
	ADC160_ADCMPLR1_CMPLCHA24 = 0x100
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA24_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA24_1 = 0x1
	// Position of CMPLCHA23 field.
	ADC160_ADCMPLR1_CMPLCHA23_Pos = 0x7
	// Bit mask of CMPLCHA23 field.
	ADC160_ADCMPLR1_CMPLCHA23_Msk = 0x80
	// Bit CMPLCHA23.
	ADC160_ADCMPLR1_CMPLCHA23 = 0x80
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA23_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA23_1 = 0x1
	// Position of CMPLCHA22 field.
	ADC160_ADCMPLR1_CMPLCHA22_Pos = 0x6
	// Bit mask of CMPLCHA22 field.
	ADC160_ADCMPLR1_CMPLCHA22_Msk = 0x40
	// Bit CMPLCHA22.
	ADC160_ADCMPLR1_CMPLCHA22 = 0x40
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA22_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA22_1 = 0x1
	// Position of CMPLCHA21 field.
	ADC160_ADCMPLR1_CMPLCHA21_Pos = 0x5
	// Bit mask of CMPLCHA21 field.
	ADC160_ADCMPLR1_CMPLCHA21_Msk = 0x20
	// Bit CMPLCHA21.
	ADC160_ADCMPLR1_CMPLCHA21 = 0x20
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA21_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA21_1 = 0x1
	// Position of CMPLCHA20 field.
	ADC160_ADCMPLR1_CMPLCHA20_Pos = 0x4
	// Bit mask of CMPLCHA20 field.
	ADC160_ADCMPLR1_CMPLCHA20_Msk = 0x10
	// Bit CMPLCHA20.
	ADC160_ADCMPLR1_CMPLCHA20 = 0x10
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA20_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA20_1 = 0x1
	// Position of CMPLCHA19 field.
	ADC160_ADCMPLR1_CMPLCHA19_Pos = 0x3
	// Bit mask of CMPLCHA19 field.
	ADC160_ADCMPLR1_CMPLCHA19_Msk = 0x8
	// Bit CMPLCHA19.
	ADC160_ADCMPLR1_CMPLCHA19 = 0x8
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA19_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA19_1 = 0x1
	// Position of CMPLCHA18 field.
	ADC160_ADCMPLR1_CMPLCHA18_Pos = 0x2
	// Bit mask of CMPLCHA18 field.
	ADC160_ADCMPLR1_CMPLCHA18_Msk = 0x4
	// Bit CMPLCHA18.
	ADC160_ADCMPLR1_CMPLCHA18 = 0x4
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA18_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA18_1 = 0x1
	// Position of CMPLCHA17 field.
	ADC160_ADCMPLR1_CMPLCHA17_Pos = 0x1
	// Bit mask of CMPLCHA17 field.
	ADC160_ADCMPLR1_CMPLCHA17_Msk = 0x2
	// Bit CMPLCHA17.
	ADC160_ADCMPLR1_CMPLCHA17 = 0x2
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA17_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA17_1 = 0x1
	// Position of CMPLCHA16 field.
	ADC160_ADCMPLR1_CMPLCHA16_Pos = 0x0
	// Bit mask of CMPLCHA16 field.
	ADC160_ADCMPLR1_CMPLCHA16_Msk = 0x1
	// Bit CMPLCHA16.
	ADC160_ADCMPLR1_CMPLCHA16 = 0x1
	// ADCMPDR0 value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < ADCMPDR0 value or, ADCMPDR1 value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPLR1_CMPLCHA16_0 = 0x0
	// ADCMPDR0 value < A/D converted value (ADCMPCR.WCMPE=0) / A/DCMPDR0 value < A/D converted value < ADCMPDR1 value (ADCMPCR.WCMPE=1).
	ADC160_ADCMPLR1_CMPLCHA16_1 = 0x1

	// ADCMPDR0: A/D Compare Function Window A Lower-Side Level Setting Register
	// Position of ADCMPDR0 field.
	ADC160_ADCMPDR0_ADCMPDR0_Pos = 0x0
	// Bit mask of ADCMPDR0 field.
	ADC160_ADCMPDR0_ADCMPDR0_Msk = 0xffff

	// ADCMPDR1: A/D Compare Function Window A Upper-Side Level Setting Register
	// Position of ADCMPDR1 field.
	ADC160_ADCMPDR1_ADCMPDR1_Pos = 0x0
	// Bit mask of ADCMPDR1 field.
	ADC160_ADCMPDR1_ADCMPDR1_Msk = 0xffff

	// ADCMPSR0: A/D Compare Function Window A Channel Status Register 0
	// Position of Reserved field.
	ADC160_ADCMPSR0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPSR0_Reserved_Msk = 0xfe00
	// Position of CMPSTCHA08 field.
	ADC160_ADCMPSR0_CMPSTCHA08_Pos = 0x8
	// Bit mask of CMPSTCHA08 field.
	ADC160_ADCMPSR0_CMPSTCHA08_Msk = 0x100
	// Bit CMPSTCHA08.
	ADC160_ADCMPSR0_CMPSTCHA08 = 0x100
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA08_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA08_1 = 0x1
	// Position of CMPSTCHA07 field.
	ADC160_ADCMPSR0_CMPSTCHA07_Pos = 0x7
	// Bit mask of CMPSTCHA07 field.
	ADC160_ADCMPSR0_CMPSTCHA07_Msk = 0x80
	// Bit CMPSTCHA07.
	ADC160_ADCMPSR0_CMPSTCHA07 = 0x80
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA07_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA07_1 = 0x1
	// Position of CMPSTCHA06 field.
	ADC160_ADCMPSR0_CMPSTCHA06_Pos = 0x6
	// Bit mask of CMPSTCHA06 field.
	ADC160_ADCMPSR0_CMPSTCHA06_Msk = 0x40
	// Bit CMPSTCHA06.
	ADC160_ADCMPSR0_CMPSTCHA06 = 0x40
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA06_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA06_1 = 0x1
	// Position of CMPSTCHA05 field.
	ADC160_ADCMPSR0_CMPSTCHA05_Pos = 0x5
	// Bit mask of CMPSTCHA05 field.
	ADC160_ADCMPSR0_CMPSTCHA05_Msk = 0x20
	// Bit CMPSTCHA05.
	ADC160_ADCMPSR0_CMPSTCHA05 = 0x20
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA05_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA05_1 = 0x1
	// Position of CMPSTCHA04 field.
	ADC160_ADCMPSR0_CMPSTCHA04_Pos = 0x4
	// Bit mask of CMPSTCHA04 field.
	ADC160_ADCMPSR0_CMPSTCHA04_Msk = 0x10
	// Bit CMPSTCHA04.
	ADC160_ADCMPSR0_CMPSTCHA04 = 0x10
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA04_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA04_1 = 0x1
	// Position of CMPSTCHA03 field.
	ADC160_ADCMPSR0_CMPSTCHA03_Pos = 0x3
	// Bit mask of CMPSTCHA03 field.
	ADC160_ADCMPSR0_CMPSTCHA03_Msk = 0x8
	// Bit CMPSTCHA03.
	ADC160_ADCMPSR0_CMPSTCHA03 = 0x8
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA03_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA03_1 = 0x1
	// Position of CMPSTCHA02 field.
	ADC160_ADCMPSR0_CMPSTCHA02_Pos = 0x2
	// Bit mask of CMPSTCHA02 field.
	ADC160_ADCMPSR0_CMPSTCHA02_Msk = 0x4
	// Bit CMPSTCHA02.
	ADC160_ADCMPSR0_CMPSTCHA02 = 0x4
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA02_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA02_1 = 0x1
	// Position of CMPSTCHA01 field.
	ADC160_ADCMPSR0_CMPSTCHA01_Pos = 0x1
	// Bit mask of CMPSTCHA01 field.
	ADC160_ADCMPSR0_CMPSTCHA01_Msk = 0x2
	// Bit CMPSTCHA01.
	ADC160_ADCMPSR0_CMPSTCHA01 = 0x2
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA01_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA01_1 = 0x1
	// Position of CMPSTCHA00 field.
	ADC160_ADCMPSR0_CMPSTCHA00_Pos = 0x0
	// Bit mask of CMPSTCHA00 field.
	ADC160_ADCMPSR0_CMPSTCHA00_Msk = 0x1
	// Bit CMPSTCHA00.
	ADC160_ADCMPSR0_CMPSTCHA00 = 0x1
	// Comparison conditions are not met.
	ADC160_ADCMPSR0_CMPSTCHA00_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR0_CMPSTCHA00_1 = 0x1

	// ADCMPSR1: A/D Compare Function Window A Channel Status Register 1
	// Position of Reserved field.
	ADC160_ADCMPSR1_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	ADC160_ADCMPSR1_Reserved_Msk = 0xfe00
	// Position of CMPSTCHA24 field.
	ADC160_ADCMPSR1_CMPSTCHA24_Pos = 0x8
	// Bit mask of CMPSTCHA24 field.
	ADC160_ADCMPSR1_CMPSTCHA24_Msk = 0x100
	// Bit CMPSTCHA24.
	ADC160_ADCMPSR1_CMPSTCHA24 = 0x100
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA24_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA24_1 = 0x1
	// Position of CMPSTCHA23 field.
	ADC160_ADCMPSR1_CMPSTCHA23_Pos = 0x7
	// Bit mask of CMPSTCHA23 field.
	ADC160_ADCMPSR1_CMPSTCHA23_Msk = 0x80
	// Bit CMPSTCHA23.
	ADC160_ADCMPSR1_CMPSTCHA23 = 0x80
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA23_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA23_1 = 0x1
	// Position of CMPSTCHA22 field.
	ADC160_ADCMPSR1_CMPSTCHA22_Pos = 0x6
	// Bit mask of CMPSTCHA22 field.
	ADC160_ADCMPSR1_CMPSTCHA22_Msk = 0x40
	// Bit CMPSTCHA22.
	ADC160_ADCMPSR1_CMPSTCHA22 = 0x40
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA22_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA22_1 = 0x1
	// Position of CMPSTCHA21 field.
	ADC160_ADCMPSR1_CMPSTCHA21_Pos = 0x5
	// Bit mask of CMPSTCHA21 field.
	ADC160_ADCMPSR1_CMPSTCHA21_Msk = 0x20
	// Bit CMPSTCHA21.
	ADC160_ADCMPSR1_CMPSTCHA21 = 0x20
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA21_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA21_1 = 0x1
	// Position of CMPSTCHA20 field.
	ADC160_ADCMPSR1_CMPSTCHA20_Pos = 0x4
	// Bit mask of CMPSTCHA20 field.
	ADC160_ADCMPSR1_CMPSTCHA20_Msk = 0x10
	// Bit CMPSTCHA20.
	ADC160_ADCMPSR1_CMPSTCHA20 = 0x10
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA20_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA20_1 = 0x1
	// Position of CMPSTCHA19 field.
	ADC160_ADCMPSR1_CMPSTCHA19_Pos = 0x3
	// Bit mask of CMPSTCHA19 field.
	ADC160_ADCMPSR1_CMPSTCHA19_Msk = 0x8
	// Bit CMPSTCHA19.
	ADC160_ADCMPSR1_CMPSTCHA19 = 0x8
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA19_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA19_1 = 0x1
	// Position of CMPSTCHA18 field.
	ADC160_ADCMPSR1_CMPSTCHA18_Pos = 0x2
	// Bit mask of CMPSTCHA18 field.
	ADC160_ADCMPSR1_CMPSTCHA18_Msk = 0x4
	// Bit CMPSTCHA18.
	ADC160_ADCMPSR1_CMPSTCHA18 = 0x4
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA18_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA18_1 = 0x1
	// Position of CMPSTCHA17 field.
	ADC160_ADCMPSR1_CMPSTCHA17_Pos = 0x1
	// Bit mask of CMPSTCHA17 field.
	ADC160_ADCMPSR1_CMPSTCHA17_Msk = 0x2
	// Bit CMPSTCHA17.
	ADC160_ADCMPSR1_CMPSTCHA17 = 0x2
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA17_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA17_1 = 0x1
	// Position of CMPSTCHA16 field.
	ADC160_ADCMPSR1_CMPSTCHA16_Pos = 0x0
	// Bit mask of CMPSTCHA16 field.
	ADC160_ADCMPSR1_CMPSTCHA16_Msk = 0x1
	// Bit CMPSTCHA16.
	ADC160_ADCMPSR1_CMPSTCHA16 = 0x1
	// Comparison conditions are not met.
	ADC160_ADCMPSR1_CMPSTCHA16_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSR1_CMPSTCHA16_1 = 0x1

	// ADCMPSER: A/D Compare Function Window A Extended Input Channel Status Register
	// Position of Reserved field.
	ADC160_ADCMPSER_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADCMPSER_Reserved_Msk = 0xfc
	// Position of CMPSTOCA field.
	ADC160_ADCMPSER_CMPSTOCA_Pos = 0x1
	// Bit mask of CMPSTOCA field.
	ADC160_ADCMPSER_CMPSTOCA_Msk = 0x2
	// Bit CMPSTOCA.
	ADC160_ADCMPSER_CMPSTOCA = 0x2
	// Comparison conditions are not met.
	ADC160_ADCMPSER_CMPSTOCA_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSER_CMPSTOCA_1 = 0x1
	// Position of CMPSTTSA field.
	ADC160_ADCMPSER_CMPSTTSA_Pos = 0x0
	// Bit mask of CMPSTTSA field.
	ADC160_ADCMPSER_CMPSTTSA_Msk = 0x1
	// Bit CMPSTTSA.
	ADC160_ADCMPSER_CMPSTTSA = 0x1
	// Comparison conditions are not met.
	ADC160_ADCMPSER_CMPSTTSA_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPSER_CMPSTTSA_1 = 0x1

	// ADCMPBNSR: A/D Compare Function Window B Channel Selection Register
	// Position of CMPLB field.
	ADC160_ADCMPBNSR_CMPLB_Pos = 0x7
	// Bit mask of CMPLB field.
	ADC160_ADCMPBNSR_CMPLB_Msk = 0x80
	// Bit CMPLB.
	ADC160_ADCMPBNSR_CMPLB = 0x80
	// CMPLLB value > A/D converted value (ADCMPCR.WCMPE=0) / A/D converted value < CMPLLB value or CMPULB value < A/D converted value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPBNSR_CMPLB_0 = 0x0
	// CMPLLB value < A/D converted value(ADCMPCR.WCMPE=0) / CMPLLB value < A/D converted value < CMPULB value (ADCMPCR.WCMPE=1)
	ADC160_ADCMPBNSR_CMPLB_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCMPBNSR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ADC160_ADCMPBNSR_Reserved_Msk = 0x40
	// Bit Reserved.
	ADC160_ADCMPBNSR_Reserved = 0x40
	// Position of CMPCHB field.
	ADC160_ADCMPBNSR_CMPCHB_Pos = 0x0
	// Bit mask of CMPCHB field.
	ADC160_ADCMPBNSR_CMPCHB_Msk = 0x3f
	// AN000
	ADC160_ADCMPBNSR_CMPCHB_0x00 = 0x0
	// AN001
	ADC160_ADCMPBNSR_CMPCHB_0x01 = 0x1
	// AN002
	ADC160_ADCMPBNSR_CMPCHB_0x02 = 0x2
	// AN003
	ADC160_ADCMPBNSR_CMPCHB_0x03 = 0x3
	// AN004
	ADC160_ADCMPBNSR_CMPCHB_0x04 = 0x4
	// AN005
	ADC160_ADCMPBNSR_CMPCHB_0x05 = 0x5
	// AN006
	ADC160_ADCMPBNSR_CMPCHB_0x06 = 0x6
	// AN007
	ADC160_ADCMPBNSR_CMPCHB_0x07 = 0x7
	// AN008
	ADC160_ADCMPBNSR_CMPCHB_0x08 = 0x8
	// AN016
	ADC160_ADCMPBNSR_CMPCHB_0x10 = 0x10
	// AN017
	ADC160_ADCMPBNSR_CMPCHB_0x11 = 0x11
	// AN018
	ADC160_ADCMPBNSR_CMPCHB_0x12 = 0x12
	// AN019
	ADC160_ADCMPBNSR_CMPCHB_0x13 = 0x13
	// AN020
	ADC160_ADCMPBNSR_CMPCHB_0x14 = 0x14
	// AN021
	ADC160_ADCMPBNSR_CMPCHB_0x15 = 0x15
	// AN022
	ADC160_ADCMPBNSR_CMPCHB_0x16 = 0x16
	// AN023
	ADC160_ADCMPBNSR_CMPCHB_0x17 = 0x17
	// Temperature sensor
	ADC160_ADCMPBNSR_CMPCHB_0x20 = 0x20
	// Internal reference voltage
	ADC160_ADCMPBNSR_CMPCHB_0x21 = 0x21
	// No channel is selected
	ADC160_ADCMPBNSR_CMPCHB_0x3F = 0x3f

	// ADWINLLB: A/D Compare Function Window B Lower-Side Level Setting Register
	// Position of ADWINLLB field.
	ADC160_ADWINLLB_ADWINLLB_Pos = 0x0
	// Bit mask of ADWINLLB field.
	ADC160_ADWINLLB_ADWINLLB_Msk = 0xffff

	// ADWINULB: A/D Compare Function Window B Upper-Side Level Setting Register
	// Position of ADWINULB field.
	ADC160_ADWINULB_ADWINULB_Pos = 0x0
	// Bit mask of ADWINULB field.
	ADC160_ADWINULB_ADWINULB_Msk = 0xffff

	// ADCMPBSR: A/D Compare Function Window B Status Register
	// Position of Reserved field.
	ADC160_ADCMPBSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ADC160_ADCMPBSR_Reserved_Msk = 0xfe
	// Position of CMPSTB field.
	ADC160_ADCMPBSR_CMPSTB_Pos = 0x0
	// Bit mask of CMPSTB field.
	ADC160_ADCMPBSR_CMPSTB_Msk = 0x1
	// Bit CMPSTB.
	ADC160_ADCMPBSR_CMPSTB = 0x1
	// Comparison conditions are not met.
	ADC160_ADCMPBSR_CMPSTB_0 = 0x0
	// Comparison conditions are met.
	ADC160_ADCMPBSR_CMPSTB_1 = 0x1

	// ADSSTRL: A/D Sampling State Register L
	// Position of SST field.
	ADC160_ADSSTRL_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC160_ADSSTRL_SST_Msk = 0xff

	// ADSSTRT: A/D Sampling State Register T
	// Position of SST field.
	ADC160_ADSSTRT_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC160_ADSSTRT_SST_Msk = 0xff

	// ADSSTRO: A/D Sampling State Register O
	// Position of SST field.
	ADC160_ADSSTRO_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC160_ADSSTRO_SST_Msk = 0xff

	// ADSSTR00: A/D Sampling State Register %s
	// Position of SST field.
	ADC160_ADSSTR0_SST_Pos = 0x0
	// Bit mask of SST field.
	ADC160_ADSSTR0_SST_Msk = 0xff

	// ADANIM: A/D Channel Input Mode Select Register
	// Position of Reserved field.
	ADC160_ADANIM_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	ADC160_ADANIM_Reserved_Msk = 0xfff0
	// Position of ANIM field.
	ADC160_ADANIM_ANIM_Pos = 0x0
	// Bit mask of ANIM field.
	ADC160_ADANIM_ANIM_Msk = 0xf

	// ADCALEXE: A/D Calibration Execution Register
	// Position of CALEXE field.
	ADC160_ADCALEXE_CALEXE_Pos = 0x7
	// Bit mask of CALEXE field.
	ADC160_ADCALEXE_CALEXE_Msk = 0x80
	// Bit CALEXE.
	ADC160_ADCALEXE_CALEXE = 0x80
	// Calibration does not start
	ADC160_ADCALEXE_CALEXE_0 = 0x0
	// Calibration starts
	ADC160_ADCALEXE_CALEXE_1 = 0x1
	// Position of CALMON field.
	ADC160_ADCALEXE_CALMON_Pos = 0x6
	// Bit mask of CALMON field.
	ADC160_ADCALEXE_CALMON_Msk = 0x40
	// Bit CALMON.
	ADC160_ADCALEXE_CALMON = 0x40
	// Calibration is not in progress
	ADC160_ADCALEXE_CALMON_0 = 0x0
	// Calibration is in progress
	ADC160_ADCALEXE_CALMON_1 = 0x1
	// Position of Reserved field.
	ADC160_ADCALEXE_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ADC160_ADCALEXE_Reserved_Msk = 0x3f

	// VREFAMPCNT: A/D Dedicated Reference Voltage Circuit Control Register
	// Position of ADSLP field.
	ADC160_VREFAMPCNT_ADSLP_Pos = 0x7
	// Bit mask of ADSLP field.
	ADC160_VREFAMPCNT_ADSLP_Msk = 0x80
	// Bit ADSLP.
	ADC160_VREFAMPCNT_ADSLP = 0x80
	// Normal operation
	ADC160_VREFAMPCNT_ADSLP_0 = 0x0
	// Standby state
	ADC160_VREFAMPCNT_ADSLP_1 = 0x1
	// Position of Reserved field.
	ADC160_VREFAMPCNT_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	ADC160_VREFAMPCNT_Reserved_Msk = 0x60
	// Position of BGREN field.
	ADC160_VREFAMPCNT_BGREN_Pos = 0x4
	// Bit mask of BGREN field.
	ADC160_VREFAMPCNT_BGREN_Msk = 0x10
	// Bit BGREN.
	ADC160_VREFAMPCNT_BGREN = 0x10
	// Select AVSS0 as the low-potential reference voltage
	ADC160_VREFAMPCNT_BGREN_0 = 0x0
	// Select VREFL0 as the low-potential reference voltage.
	ADC160_VREFAMPCNT_BGREN_1 = 0x1
	// Position of VREFADCEN field.
	ADC160_VREFAMPCNT_VREFADCEN_Pos = 0x3
	// Bit mask of VREFADCEN field.
	ADC160_VREFAMPCNT_VREFADCEN_Msk = 0x8
	// Bit VREFADCEN.
	ADC160_VREFAMPCNT_VREFADCEN = 0x8
	// Disable the VREFADC output
	ADC160_VREFAMPCNT_VREFADCEN_0 = 0x0
	// Enable the VREFADC output
	ADC160_VREFAMPCNT_VREFADCEN_1 = 0x1
	// Position of VREFADCG field.
	ADC160_VREFAMPCNT_VREFADCG_Pos = 0x1
	// Bit mask of VREFADCG field.
	ADC160_VREFAMPCNT_VREFADCG_Msk = 0x6
	// 1.5 V
	ADC160_VREFAMPCNT_VREFADCG_00 = 0x0
	// 1.5 V
	ADC160_VREFAMPCNT_VREFADCG_01 = 0x1
	// 2.0 V
	ADC160_VREFAMPCNT_VREFADCG_10 = 0x2
	// 2.5 V
	ADC160_VREFAMPCNT_VREFADCG_11 = 0x3
	// Position of OLDETEN field.
	ADC160_VREFAMPCNT_OLDETEN_Pos = 0x0
	// Bit mask of OLDETEN field.
	ADC160_VREFAMPCNT_OLDETEN_Msk = 0x1
	// Bit OLDETEN.
	ADC160_VREFAMPCNT_OLDETEN = 0x1
	// Disable the over current detection
	ADC160_VREFAMPCNT_OLDETEN_0 = 0x0
	// Enable the over current detection
	ADC160_VREFAMPCNT_OLDETEN_1 = 0x1

	// ADRD: A/D Self-Diagnosis Data Register
	// Position of ADRD field.
	ADC160_ADRD_ADRD_Pos = 0x0
	// Bit mask of ADRD field.
	ADC160_ADRD_ADRD_Msk = 0xffff

	// ADRST: A/D Self-Diagnostic Status Register
	// Position of Reserved field.
	ADC160_ADRST_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ADC160_ADRST_Reserved_Msk = 0xfc
	// Position of DIAGST field.
	ADC160_ADRST_DIAGST_Pos = 0x0
	// Bit mask of DIAGST field.
	ADC160_ADRST_DIAGST_Msk = 0x3
	// Self-diagnosis has not been executed since power-on
	ADC160_ADRST_DIAGST_00 = 0x0
	// Self-diagnosis was executed under a condition that an ideal value of the A/D conversion result is 8000h
	ADC160_ADRST_DIAGST_01 = 0x1
	// Self-diagnosis was executed under a condition that an ideal value of the A/D conversion result is 0000h
	ADC160_ADRST_DIAGST_10 = 0x2
	// Self-diagnosis was executed under a condition that an ideal value of the A/D conversion result is 7FFFh.
	ADC160_ADRST_DIAGST_11 = 0x3
)

// Constants for CTSU: Capacitive Touch Sensing Unit
const (
	// CTSUCR0: CTSU Control Register 0
	// Position of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Pos = 0x4
	// Bit mask of CTSUINIT field.
	CTSU_CTSUCR0_CTSUINIT_Msk = 0x10
	// Bit CTSUINIT.
	CTSU_CTSUCR0_CTSUINIT = 0x10
	// Writing a 0 has no effect, this bit is read as 0.
	CTSU_CTSUCR0_CTSUINIT_0 = 0x0
	// initializes the CTSU control block and registers.
	CTSU_CTSUCR0_CTSUINIT_1 = 0x1
	// Position of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Pos = 0x2
	// Bit mask of CTSUSNZ field.
	CTSU_CTSUCR0_CTSUSNZ_Msk = 0x4
	// Bit CTSUSNZ.
	CTSU_CTSUCR0_CTSUSNZ = 0x4
	// Power-saving function during wait state is disabled.
	CTSU_CTSUCR0_CTSUSNZ_0 = 0x0
	// Power-saving function during wait state is enabled.
	CTSU_CTSUCR0_CTSUSNZ_1 = 0x1
	// Position of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Pos = 0x1
	// Bit mask of CTSUCAP field.
	CTSU_CTSUCR0_CTSUCAP_Msk = 0x2
	// Bit CTSUCAP.
	CTSU_CTSUCR0_CTSUCAP = 0x2
	// Software trigger.
	CTSU_CTSUCR0_CTSUCAP_0 = 0x0
	// External trigger.
	CTSU_CTSUCR0_CTSUCAP_1 = 0x1
	// Position of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Pos = 0x0
	// Bit mask of CTSUSTRT field.
	CTSU_CTSUCR0_CTSUSTRT_Msk = 0x1
	// Bit CTSUSTRT.
	CTSU_CTSUCR0_CTSUSTRT = 0x1
	// Measurement operation stops.
	CTSU_CTSUCR0_CTSUSTRT_0 = 0x0
	// Measurement operation starts.
	CTSU_CTSUCR0_CTSUSTRT_1 = 0x1

	// CTSUCR1: CTSU Control Register 1
	// Position of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Pos = 0x6
	// Bit mask of CTSUMD field.
	CTSU_CTSUCR1_CTSUMD_Msk = 0xc0
	// Self-capacitance single scan mode
	CTSU_CTSUCR1_CTSUMD_00 = 0x0
	// Self-capacitance multi-scan mode
	CTSU_CTSUCR1_CTSUMD_01 = 0x1
	// Setting prohibited
	CTSU_CTSUCR1_CTSUMD_10 = 0x2
	// Mutual capacitance full scan mode
	CTSU_CTSUCR1_CTSUMD_11 = 0x3
	// Position of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Pos = 0x4
	// Bit mask of CTSUCLK field.
	CTSU_CTSUCR1_CTSUCLK_Msk = 0x30
	// PCLK
	CTSU_CTSUCR1_CTSUCLK_00 = 0x0
	// PCLK/2 (PCLK divided by 2)
	CTSU_CTSUCR1_CTSUCLK_01 = 0x1
	// PCLK/2 (PCLK divided by 4)
	CTSU_CTSUCR1_CTSUCLK_10 = 0x2
	// Setting prohibited
	CTSU_CTSUCR1_CTSUCLK_11 = 0x3
	// Position of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Pos = 0x3
	// Bit mask of CTSUATUNE1 field.
	CTSU_CTSUCR1_CTSUATUNE1_Msk = 0x8
	// Bit CTSUATUNE1.
	CTSU_CTSUCR1_CTSUATUNE1 = 0x8
	// Normal output
	CTSU_CTSUCR1_CTSUATUNE1_0 = 0x0
	// High-current output
	CTSU_CTSUCR1_CTSUATUNE1_1 = 0x1
	// Position of CTSUATUNE0 field.
	CTSU_CTSUCR1_CTSUATUNE0_Pos = 0x2
	// Bit mask of CTSUATUNE0 field.
	CTSU_CTSUCR1_CTSUATUNE0_Msk = 0x4
	// Bit CTSUATUNE0.
	CTSU_CTSUCR1_CTSUATUNE0 = 0x4
	// Normal operating mode
	CTSU_CTSUCR1_CTSUATUNE0_0 = 0x0
	// Low-voltage operating mode
	CTSU_CTSUCR1_CTSUATUNE0_1 = 0x1
	// Position of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Pos = 0x1
	// Bit mask of CTSUCSW field.
	CTSU_CTSUCR1_CTSUCSW_Msk = 0x2
	// Bit CTSUCSW.
	CTSU_CTSUCR1_CTSUCSW = 0x2
	// Turned off capacitance switch
	CTSU_CTSUCR1_CTSUCSW_0 = 0x0
	// Turned on capacitance switch
	CTSU_CTSUCR1_CTSUCSW_1 = 0x1
	// Position of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Pos = 0x0
	// Bit mask of CTSUPON field.
	CTSU_CTSUCR1_CTSUPON_Msk = 0x1
	// Bit CTSUPON.
	CTSU_CTSUCR1_CTSUPON = 0x1
	// Powered off the CTSU
	CTSU_CTSUCR1_CTSUPON_0 = 0x0
	// Powered on the CTSU
	CTSU_CTSUCR1_CTSUPON_1 = 0x1

	// CTSUSDPRS: CTSU Synchronous Noise Reduction Setting Register
	// Position of Reserved field.
	CTSU_CTSUSDPRS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	CTSU_CTSUSDPRS_Reserved_Msk = 0x80
	// Bit Reserved.
	CTSU_CTSUSDPRS_Reserved = 0x80
	// Position of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Pos = 0x6
	// Bit mask of CTSUSOFF field.
	CTSU_CTSUSDPRS_CTSUSOFF_Msk = 0x40
	// Bit CTSUSOFF.
	CTSU_CTSUSDPRS_CTSUSOFF = 0x40
	// High-pass noise reduction function turned on
	CTSU_CTSUSDPRS_CTSUSOFF_0 = 0x0
	// High-pass noise reduction function turned off
	CTSU_CTSUSDPRS_CTSUSOFF_1 = 0x1
	// Position of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Pos = 0x4
	// Bit mask of CTSUPRMODE field.
	CTSU_CTSUSDPRS_CTSUPRMODE_Msk = 0x30
	// 510 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_00 = 0x0
	// 126 pulses
	CTSU_CTSUSDPRS_CTSUPRMODE_01 = 0x1
	// 62 pulses (recommended setting value)
	CTSU_CTSUSDPRS_CTSUPRMODE_10 = 0x2
	// Setting prohibited
	CTSU_CTSUSDPRS_CTSUPRMODE_11 = 0x3
	// Position of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Pos = 0x0
	// Bit mask of CTSUPRRATIO field.
	CTSU_CTSUSDPRS_CTSUPRRATIO_Msk = 0xf

	// CTSUSST: CTSU Sensor Stabilization Wait Control Register
	// Position of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Pos = 0x0
	// Bit mask of CTSUSST field.
	CTSU_CTSUSST_CTSUSST_Msk = 0xff

	// CTSUMCH0: CTSU Measurement Channel Register 0
	// Position of Reserved field.
	CTSU_CTSUMCH0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUMCH0_Reserved_Msk = 0xc0
	// Position of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Pos = 0x0
	// Bit mask of CTSUMCH0 field.
	CTSU_CTSUMCH0_CTSUMCH0_Msk = 0x3f

	// CTSUMCH1: CTSU Measurement Channel Register 1
	// Position of Reserved field.
	CTSU_CTSUMCH1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUMCH1_Reserved_Msk = 0xc0
	// Position of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Pos = 0x0
	// Bit mask of CTSUMCH1 field.
	CTSU_CTSUMCH1_CTSUMCH1_Msk = 0x3f

	// CTSUCHAC0: CTSU Channel Enable Control Register 0
	// Position of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Pos = 0x0
	// Bit mask of CTSUCHAC0 field.
	CTSU_CTSUCHAC0_CTSUCHAC0_Msk = 0xff

	// CTSUCHAC1: CTSU Channel Enable Control Register 1
	// Position of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Pos = 0x0
	// Bit mask of CTSUCHAC1 field.
	CTSU_CTSUCHAC1_CTSUCHAC1_Msk = 0xff

	// CTSUCHAC2: CTSU Channel Enable Control Register 2
	// Position of CTSUCHAC2 field.
	CTSU_CTSUCHAC2_CTSUCHAC2_Pos = 0x0
	// Bit mask of CTSUCHAC2 field.
	CTSU_CTSUCHAC2_CTSUCHAC2_Msk = 0xff

	// CTSUCHAC3: CTSU Channel Enable Control Register 3
	// Position of CTSUCHAC3 field.
	CTSU_CTSUCHAC3_CTSUCHAC3_Pos = 0x0
	// Bit mask of CTSUCHAC3 field.
	CTSU_CTSUCHAC3_CTSUCHAC3_Msk = 0xff

	// CTSUCHTRC0: CTSU Channel Transmit/Receive Control Register 0
	// Position of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Pos = 0x0
	// Bit mask of CTSUCHTRC0 field.
	CTSU_CTSUCHTRC0_CTSUCHTRC0_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC0_CTSUCHTRC0_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC0_CTSUCHTRC0_1 = 0x1

	// CTSUCHTRC1: CTSU Channel Transmit/Receive Control Register 1
	// Position of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Pos = 0x0
	// Bit mask of CTSUCHTRC1 field.
	CTSU_CTSUCHTRC1_CTSUCHTRC1_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC1_CTSUCHTRC1_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC1_CTSUCHTRC1_1 = 0x1

	// CTSUCHTRC2: CTSU Channel Transmit/Receive Control Register 2
	// Position of CTSUCHRC2 field.
	CTSU_CTSUCHTRC2_CTSUCHRC2_Pos = 0x0
	// Bit mask of CTSUCHRC2 field.
	CTSU_CTSUCHTRC2_CTSUCHRC2_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC2_CTSUCHRC2_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC2_CTSUCHRC2_1 = 0x1

	// CTSUCHTRC3: CTSU Channel Transmit/Receive Control Register 3
	// Position of CTSUCHRC3 field.
	CTSU_CTSUCHTRC3_CTSUCHRC3_Pos = 0x0
	// Bit mask of CTSUCHRC3 field.
	CTSU_CTSUCHTRC3_CTSUCHRC3_Msk = 0xff
	// Reception
	CTSU_CTSUCHTRC3_CTSUCHRC3_0 = 0x0
	// Transmission
	CTSU_CTSUCHTRC3_CTSUCHRC3_1 = 0x1

	// CTSUDCLKC: CTSU High-Pass Noise Reduction Control Register
	// Position of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Msk = 0xc0
	// Position of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Pos = 0x4
	// Bit mask of CTSUSSCNT field.
	CTSU_CTSUDCLKC_CTSUSSCNT_Msk = 0x30
	// Position of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	CTSU_CTSUDCLKC_Reserved_Msk = 0xc
	// Position of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Pos = 0x0
	// Bit mask of CTSUSSMOD field.
	CTSU_CTSUDCLKC_CTSUSSMOD_Msk = 0x3

	// CTSUST: CTSU Status Register
	// Position of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Pos = 0x7
	// Bit mask of CTSUPS field.
	CTSU_CTSUST_CTSUPS_Msk = 0x80
	// Bit CTSUPS.
	CTSU_CTSUST_CTSUPS = 0x80
	// First measurement
	CTSU_CTSUST_CTSUPS_0 = 0x0
	// Second measurement
	CTSU_CTSUST_CTSUPS_1 = 0x1
	// Position of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Pos = 0x6
	// Bit mask of CTSUROVF field.
	CTSU_CTSUST_CTSUROVF_Msk = 0x40
	// Bit CTSUROVF.
	CTSU_CTSUST_CTSUROVF = 0x40
	// No overflow
	CTSU_CTSUST_CTSUROVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUROVF_1 = 0x1
	// Position of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Pos = 0x5
	// Bit mask of CTSUSOVF field.
	CTSU_CTSUST_CTSUSOVF_Msk = 0x20
	// Bit CTSUSOVF.
	CTSU_CTSUST_CTSUSOVF = 0x20
	// No overflow
	CTSU_CTSUST_CTSUSOVF_0 = 0x0
	// An overflow
	CTSU_CTSUST_CTSUSOVF_1 = 0x1
	// Position of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Pos = 0x4
	// Bit mask of CTSUDTSR field.
	CTSU_CTSUST_CTSUDTSR_Msk = 0x10
	// Bit CTSUDTSR.
	CTSU_CTSUST_CTSUDTSR = 0x10
	// Measurement result has been read
	CTSU_CTSUST_CTSUDTSR_0 = 0x0
	// Measurement result has not been read
	CTSU_CTSUST_CTSUDTSR_1 = 0x1
	// Position of Reserved field.
	CTSU_CTSUST_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CTSU_CTSUST_Reserved_Msk = 0x8
	// Bit Reserved.
	CTSU_CTSUST_Reserved = 0x8
	// Position of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Pos = 0x0
	// Bit mask of CTSUSTC field.
	CTSU_CTSUST_CTSUSTC_Msk = 0x7
	// Status 0
	CTSU_CTSUST_CTSUSTC_000 = 0x0
	// Status 1
	CTSU_CTSUST_CTSUSTC_001 = 0x1
	// Status 2
	CTSU_CTSUST_CTSUSTC_010 = 0x2
	// Status 3
	CTSU_CTSUST_CTSUSTC_011 = 0x3
	// Status 4
	CTSU_CTSUST_CTSUSTC_100 = 0x4
	// Status 5
	CTSU_CTSUST_CTSUSTC_101 = 0x5

	// CTSUSSC: CTSU High-Pass Noise Reduction Spectrum Diffusion Control Register
	// Position of Reserved field.
	CTSU_CTSUSSC_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	CTSU_CTSUSSC_Reserved_Msk = 0xf000
	// Position of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Pos = 0x8
	// Bit mask of CTSUSSDIV field.
	CTSU_CTSUSSC_CTSUSSDIV_Msk = 0xf00
	// 4.00 <= fb
	CTSU_CTSUSSC_CTSUSSDIV_0000 = 0x0
	// 2.00 <= fb < 4.00
	CTSU_CTSUSSC_CTSUSSDIV_0001 = 0x1
	// 1.33 <= fb < 2.00
	CTSU_CTSUSSC_CTSUSSDIV_0010 = 0x2
	// 1.00 <= fb < 1.33
	CTSU_CTSUSSC_CTSUSSDIV_0011 = 0x3
	// 0.80 <= fb < 1.00
	CTSU_CTSUSSC_CTSUSSDIV_0100 = 0x4
	// 0.67 <= fb < 0.80
	CTSU_CTSUSSC_CTSUSSDIV_0101 = 0x5
	// 0.57 <= fb < 0.67
	CTSU_CTSUSSC_CTSUSSDIV_0110 = 0x6
	// 0.50 <= fb < 0.57
	CTSU_CTSUSSC_CTSUSSDIV_0111 = 0x7
	// 0.44 <= fb < 0.50
	CTSU_CTSUSSC_CTSUSSDIV_1000 = 0x8
	// 0.40 <= fb < 0.44
	CTSU_CTSUSSC_CTSUSSDIV_1001 = 0x9
	// 0.36 <= fb < 0.40
	CTSU_CTSUSSC_CTSUSSDIV_1010 = 0xa
	// 0.33 <= fb < 0.36
	CTSU_CTSUSSC_CTSUSSDIV_1011 = 0xb
	// 0.31 <= fb < 0.33
	CTSU_CTSUSSC_CTSUSSDIV_1100 = 0xc
	// 0.29 <= fb < 0.31
	CTSU_CTSUSSC_CTSUSSDIV_1101 = 0xd
	// 0.27 <= fb < 0.29
	CTSU_CTSUSSC_CTSUSSDIV_1110 = 0xe
	// fb < 0.27
	CTSU_CTSUSSC_CTSUSSDIV_1111 = 0xf
	// Position of Reserved field.
	CTSU_CTSUSSC_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CTSU_CTSUSSC_Reserved_Msk = 0xff

	// CTSUSO0: CTSU Sensor Offset Register 0
	// Position of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Pos = 0xa
	// Bit mask of CTSUSNUM field.
	CTSU_CTSUSO0_CTSUSNUM_Msk = 0xfc00
	// Position of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Pos = 0x0
	// Bit mask of CTSUSO field.
	CTSU_CTSUSO0_CTSUSO_Msk = 0x3ff

	// CTSUSO1: CTSU Sensor Offset Register 1
	// Position of Reserved field.
	CTSU_CTSUSO1_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	CTSU_CTSUSO1_Reserved_Msk = 0x8000
	// Bit Reserved.
	CTSU_CTSUSO1_Reserved = 0x8000
	// Position of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Pos = 0xd
	// Bit mask of CTSUICOG field.
	CTSU_CTSUSO1_CTSUICOG_Msk = 0x6000
	// 100 percent gain
	CTSU_CTSUSO1_CTSUICOG_00 = 0x0
	// 66 percent gain
	CTSU_CTSUSO1_CTSUICOG_01 = 0x1
	// 50 percent gain
	CTSU_CTSUSO1_CTSUICOG_10 = 0x2
	// 40 percent gain
	CTSU_CTSUSO1_CTSUICOG_11 = 0x3
	// Position of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Pos = 0x8
	// Bit mask of CTSUSDPA field.
	CTSU_CTSUSO1_CTSUSDPA_Msk = 0x1f00
	// Position of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Pos = 0x0
	// Bit mask of CTSURICOA field.
	CTSU_CTSUSO1_CTSURICOA_Msk = 0xff

	// CTSUSC: CTSU Sensor Counter
	// Position of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Pos = 0x0
	// Bit mask of CTSUSC field.
	CTSU_CTSUSC_CTSUSC_Msk = 0xffff

	// CTSURC: CTSU Reference Counter
	// Position of CTSURC field.
	CTSU_CTSURC_CTSURC_Pos = 0x0
	// Bit mask of CTSURC field.
	CTSU_CTSURC_CTSURC_Msk = 0xffff

	// CTSUERRS: CTSU Error Status Register
	// Position of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Pos = 0xf
	// Bit mask of CTSUICOMP field.
	CTSU_CTSUERRS_CTSUICOMP_Msk = 0x8000
	// Bit CTSUICOMP.
	CTSU_CTSUERRS_CTSUICOMP = 0x8000
	// Normal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_0 = 0x0
	// Abnormal TSCAP voltage
	CTSU_CTSUERRS_CTSUICOMP_1 = 0x1
	// Position of Reserved field.
	CTSU_CTSUERRS_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CTSU_CTSUERRS_Reserved_Msk = 0x7fff
)

// Constants for OPAMP: OperationalAmplifier
const (
	// AMPMC: Operational amplifier mode control register
	// Position of AMPSP field.
	OPAMP_AMPMC_AMPSP_Pos = 0x6
	// Bit mask of AMPSP field.
	OPAMP_AMPMC_AMPSP_Msk = 0xc0
	// Low-power mode (Low-speed)
	OPAMP_AMPMC_AMPSP_00 = 0x0
	// Low-power mode (Low-speed)
	OPAMP_AMPMC_AMPSP_10 = 0x2
	// Middle-speed mode
	OPAMP_AMPMC_AMPSP_01 = 0x1
	// High-speed mode
	OPAMP_AMPMC_AMPSP_11 = 0x3
	// Position of Reserved field.
	OPAMP_AMPMC_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	OPAMP_AMPMC_Reserved_Msk = 0x3f

	// AMPTRM: Operational amplifier trigger mode control register
	// Position of Reserved field.
	OPAMP_AMPTRM_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	OPAMP_AMPTRM_Reserved_Msk = 0xc0
	// Position of AMPTRM21 field.
	OPAMP_AMPTRM_AMPTRM21_Pos = 0x5
	// Bit mask of AMPTRM21 field.
	OPAMP_AMPTRM_AMPTRM21_Msk = 0x20
	// Bit AMPTRM21.
	OPAMP_AMPTRM_AMPTRM21 = 0x20
	// Software trigger mode(AMPTRM20=0)/An activation trigger mode(AMPTRM20=1).
	OPAMP_AMPTRM_AMPTRM21_0 = 0x0
	// Setting prohibited(AMPTRM20=0)/An activation and A/D trigger mode(AMPTRM20=1).
	OPAMP_AMPTRM_AMPTRM21_1 = 0x1
	// Position of AMPTRM20 field.
	OPAMP_AMPTRM_AMPTRM20_Pos = 0x4
	// Bit mask of AMPTRM20 field.
	OPAMP_AMPTRM_AMPTRM20_Msk = 0x10
	// Bit AMPTRM20.
	OPAMP_AMPTRM_AMPTRM20 = 0x10
	// Software trigger mode(AMPTRM21=0)/Setting prohibited(AMPTRM21=1).
	OPAMP_AMPTRM_AMPTRM20_0 = 0x0
	// An activation trigger mode(AMPTRM21=0)/An activation and A/D trigger mode(AMPTRM21=1).
	OPAMP_AMPTRM_AMPTRM20_1 = 0x1
	// Position of AMPTRM11 field.
	OPAMP_AMPTRM_AMPTRM11_Pos = 0x3
	// Bit mask of AMPTRM11 field.
	OPAMP_AMPTRM_AMPTRM11_Msk = 0x8
	// Bit AMPTRM11.
	OPAMP_AMPTRM_AMPTRM11 = 0x8
	// Software trigger mode(AMPTRM10=0)/An activation trigger mode(AMPTRM10=1).
	OPAMP_AMPTRM_AMPTRM11_0 = 0x0
	// Setting prohibited(AMPTRM10=0)/An activation and A/D trigger mode(AMPTRM10=1).
	OPAMP_AMPTRM_AMPTRM11_1 = 0x1
	// Position of AMPTRM10 field.
	OPAMP_AMPTRM_AMPTRM10_Pos = 0x2
	// Bit mask of AMPTRM10 field.
	OPAMP_AMPTRM_AMPTRM10_Msk = 0x4
	// Bit AMPTRM10.
	OPAMP_AMPTRM_AMPTRM10 = 0x4
	// Software trigger mode(AMPTRM11=0)/Setting prohibited(AMPTRM11=1).
	OPAMP_AMPTRM_AMPTRM10_0 = 0x0
	// An activation trigger mode(AMPTRM11=0)/An activation and A/D trigger mode(AMPTRM11=1).
	OPAMP_AMPTRM_AMPTRM10_1 = 0x1
	// Position of AMPTRM01 field.
	OPAMP_AMPTRM_AMPTRM01_Pos = 0x1
	// Bit mask of AMPTRM01 field.
	OPAMP_AMPTRM_AMPTRM01_Msk = 0x2
	// Bit AMPTRM01.
	OPAMP_AMPTRM_AMPTRM01 = 0x2
	// Software trigger mode(AMPTRM00=0)/An activation trigger mode(AMPTRM00=1).
	OPAMP_AMPTRM_AMPTRM01_0 = 0x0
	// Setting prohibited(AMPTRM00=0)/An activation and A/D trigger mode(AMPTRM00=1).
	OPAMP_AMPTRM_AMPTRM01_1 = 0x1
	// Position of AMPTRM00 field.
	OPAMP_AMPTRM_AMPTRM00_Pos = 0x0
	// Bit mask of AMPTRM00 field.
	OPAMP_AMPTRM_AMPTRM00_Msk = 0x1
	// Bit AMPTRM00.
	OPAMP_AMPTRM_AMPTRM00 = 0x1
	// Software trigger mode(AMPTRM01=0)/Setting prohibited(AMPTRM01=1).
	OPAMP_AMPTRM_AMPTRM00_0 = 0x0
	// An activation trigger mode(AMPTRM01=0)/An activation and A/D trigger mode(AMPTRM01=1).
	OPAMP_AMPTRM_AMPTRM00_1 = 0x1

	// AMPTRS: Operational Amplifier Activation Trigger Select Register
	// Position of AMPTRS field.
	OPAMP_AMPTRS_AMPTRS_Pos = 0x0
	// Bit mask of AMPTRS field.
	OPAMP_AMPTRS_AMPTRS_Msk = 0x3
	// OPAMPn: OPAMP activation trigger n (n = 0 to 2)
	OPAMP_AMPTRS_AMPTRS_00 = 0x0
	// OPAMPn: OPAMP activation trigger 0 (n = 0, 1), OPAMP2: OPAMP activation trigger 1
	OPAMP_AMPTRS_AMPTRS_01 = 0x1
	// Setting prohibited
	OPAMP_AMPTRS_AMPTRS_10 = 0x2
	// OPAMPn: OPAMP activation trigger 0 (n = 0 to 2).
	OPAMP_AMPTRS_AMPTRS_11 = 0x3

	// AMPC: Operational amplifier control register
	// Position of IREFE field.
	OPAMP_AMPC_IREFE_Pos = 0x7
	// Bit mask of IREFE field.
	OPAMP_AMPC_IREFE_Msk = 0x80
	// Bit IREFE.
	OPAMP_AMPC_IREFE = 0x80
	// Reference current circuit is stopped
	OPAMP_AMPC_IREFE_0 = 0x0
	// Operation of reference current circuit is enabled
	OPAMP_AMPC_IREFE_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMPC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	OPAMP_AMPC_Reserved_Msk = 0x78
	// Position of AMPE2 field.
	OPAMP_AMPC_AMPE2_Pos = 0x2
	// Bit mask of AMPE2 field.
	OPAMP_AMPC_AMPE2_Msk = 0x4
	// Bit AMPE2.
	OPAMP_AMPC_AMPE2 = 0x4
	// OPAMP is stopped
	OPAMP_AMPC_AMPE2_0 = 0x0
	// OPAMP is enabled.
	OPAMP_AMPC_AMPE2_1 = 0x1
	// Position of AMPE1 field.
	OPAMP_AMPC_AMPE1_Pos = 0x1
	// Bit mask of AMPE1 field.
	OPAMP_AMPC_AMPE1_Msk = 0x2
	// Bit AMPE1.
	OPAMP_AMPC_AMPE1 = 0x2
	// OPAMP is stopped
	OPAMP_AMPC_AMPE1_0 = 0x0
	// OPAMP is enabled.
	OPAMP_AMPC_AMPE1_1 = 0x1
	// Position of AMPE0 field.
	OPAMP_AMPC_AMPE0_Pos = 0x0
	// Bit mask of AMPE0 field.
	OPAMP_AMPC_AMPE0_Msk = 0x1
	// Bit AMPE0.
	OPAMP_AMPC_AMPE0 = 0x1
	// OPAMP is stopped
	OPAMP_AMPC_AMPE0_0 = 0x0
	// OPAMP is enabled.
	OPAMP_AMPC_AMPE0_1 = 0x1

	// AMPMON: Operational amplifier monitor register
	// Position of Reserved field.
	OPAMP_AMPMON_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	OPAMP_AMPMON_Reserved_Msk = 0xf8
	// Position of AMPMON2 field.
	OPAMP_AMPMON_AMPMON2_Pos = 0x2
	// Bit mask of AMPMON2 field.
	OPAMP_AMPMON_AMPMON2_Msk = 0x4
	// Bit AMPMON2.
	OPAMP_AMPMON_AMPMON2 = 0x4
	// OPAMP is stopped
	OPAMP_AMPMON_AMPMON2_0 = 0x0
	// OPAMP is operating
	OPAMP_AMPMON_AMPMON2_1 = 0x1
	// Position of AMPMON1 field.
	OPAMP_AMPMON_AMPMON1_Pos = 0x1
	// Bit mask of AMPMON1 field.
	OPAMP_AMPMON_AMPMON1_Msk = 0x2
	// Bit AMPMON1.
	OPAMP_AMPMON_AMPMON1 = 0x2
	// OPAMP is stopped
	OPAMP_AMPMON_AMPMON1_0 = 0x0
	// OPAMP is operating
	OPAMP_AMPMON_AMPMON1_1 = 0x1
	// Position of AMPMON0 field.
	OPAMP_AMPMON_AMPMON0_Pos = 0x0
	// Bit mask of AMPMON0 field.
	OPAMP_AMPMON_AMPMON0_Msk = 0x1
	// Bit AMPMON0.
	OPAMP_AMPMON_AMPMON0 = 0x1
	// OPAMP is stopped
	OPAMP_AMPMON_AMPMON0_0 = 0x0
	// OPAMP is operating
	OPAMP_AMPMON_AMPMON0_1 = 0x1

	// AMP0OS: Operational Amplifier 0 Output Select Register
	// Position of Reserved field.
	OPAMP_AMP0OS_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMP0OS_Reserved_Msk = 0xf0
	// Position of AMPOS3 field.
	OPAMP_AMP0OS_AMPOS3_Pos = 0x3
	// Bit mask of AMPOS3 field.
	OPAMP_AMP0OS_AMPOS3_Msk = 0x8
	// Bit AMPOS3.
	OPAMP_AMP0OS_AMPOS3 = 0x8
	// AMP2+ pin is not connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS3_0 = 0x0
	// AMP2+ pin is connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS3_1 = 0x1
	// Position of AMPOS2 field.
	OPAMP_AMP0OS_AMPOS2_Pos = 0x2
	// Bit mask of AMPOS2 field.
	OPAMP_AMP0OS_AMPOS2_Msk = 0x4
	// Bit AMPOS2.
	OPAMP_AMP0OS_AMPOS2 = 0x4
	// AMP2- pin is not connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS2_0 = 0x0
	// AMP2- pin is connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS2_1 = 0x1
	// Position of AMPOS1 field.
	OPAMP_AMP0OS_AMPOS1_Pos = 0x1
	// Bit mask of AMPOS1 field.
	OPAMP_AMP0OS_AMPOS1_Msk = 0x2
	// Bit AMPOS1.
	OPAMP_AMP0OS_AMPOS1 = 0x2
	// AMP1+ pin is not connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS1_0 = 0x0
	// AMP1+ pin is connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS1_1 = 0x1
	// Position of AMPOS0 field.
	OPAMP_AMP0OS_AMPOS0_Pos = 0x0
	// Bit mask of AMPOS0 field.
	OPAMP_AMP0OS_AMPOS0_Msk = 0x1
	// Bit AMPOS0.
	OPAMP_AMP0OS_AMPOS0 = 0x1
	// AMP1- pin is not connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS0_0 = 0x0
	// AMP1- pin is connected to the OPAMP0 output
	OPAMP_AMP0OS_AMPOS0_1 = 0x1

	// AMP0MS: Operational Amplifier 0 Minus Input Select Register
	// Position of AMPMS7 field.
	OPAMP_AMP0MS_AMPMS7_Pos = 0x7
	// Bit mask of AMPMS7 field.
	OPAMP_AMP0MS_AMPMS7_Msk = 0x80
	// Bit AMPMS7.
	OPAMP_AMP0MS_AMPMS7 = 0x80
	// OPAMP0 output is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS7_0 = 0x0
	// OPAMP0 output is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP0MS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP0MS_Reserved_Msk = 0x60
	// Position of AMPMS4 field.
	OPAMP_AMP0MS_AMPMS4_Pos = 0x4
	// Bit mask of AMPMS4 field.
	OPAMP_AMP0MS_AMPMS4_Msk = 0x10
	// Bit AMPMS4.
	OPAMP_AMP0MS_AMPMS4 = 0x10
	// AMP2- pin is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS4_0 = 0x0
	// AMP2- pin is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS4_1 = 0x1
	// Position of AMPMS3 field.
	OPAMP_AMP0MS_AMPMS3_Pos = 0x3
	// Bit mask of AMPMS3 field.
	OPAMP_AMP0MS_AMPMS3_Msk = 0x8
	// Bit AMPMS3.
	OPAMP_AMP0MS_AMPMS3 = 0x8
	// AMP1+ pin is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS3_0 = 0x0
	// AMP1+ pin is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS3_1 = 0x1
	// Position of AMPMS2 field.
	OPAMP_AMP0MS_AMPMS2_Pos = 0x2
	// Bit mask of AMPMS2 field.
	OPAMP_AMP0MS_AMPMS2_Msk = 0x4
	// Bit AMPMS2.
	OPAMP_AMP0MS_AMPMS2 = 0x4
	// AMP1- pin is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS2_0 = 0x0
	// AMP1- pin is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS2_1 = 0x1
	// Position of AMPMS1 field.
	OPAMP_AMP0MS_AMPMS1_Pos = 0x1
	// Bit mask of AMPMS1 field.
	OPAMP_AMP0MS_AMPMS1_Msk = 0x2
	// Bit AMPMS1.
	OPAMP_AMP0MS_AMPMS1 = 0x2
	// AMP0+ pin is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS1_0 = 0x0
	// AMP0+ pin is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS1_1 = 0x1
	// Position of AMPMS0 field.
	OPAMP_AMP0MS_AMPMS0_Pos = 0x0
	// Bit mask of AMPMS0 field.
	OPAMP_AMP0MS_AMPMS0_Msk = 0x1
	// Bit AMPMS0.
	OPAMP_AMP0MS_AMPMS0 = 0x1
	// AMP0- pin is not connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS0_0 = 0x0
	// AMP0- pin is connected to the AMP0 minus input
	OPAMP_AMP0MS_AMPMS0_1 = 0x1

	// AMP0PS: Operational Amplifier 0 Plus Input Select Register
	// Position of AMPMS7 field.
	OPAMP_AMP0PS_AMPMS7_Pos = 0x7
	// Bit mask of AMPMS7 field.
	OPAMP_AMP0PS_AMPMS7_Msk = 0x80
	// Bit AMPMS7.
	OPAMP_AMP0PS_AMPMS7 = 0x80
	// DAC12 output is not connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPMS7_0 = 0x0
	// DAC12 output is connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPMS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP0PS_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMP0PS_Reserved_Msk = 0x70
	// Position of AMPPS3 field.
	OPAMP_AMP0PS_AMPPS3_Pos = 0x3
	// Bit mask of AMPPS3 field.
	OPAMP_AMP0PS_AMPPS3_Msk = 0x8
	// Bit AMPPS3.
	OPAMP_AMP0PS_AMPPS3 = 0x8
	// AMP2+ pin is not connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS3_0 = 0x0
	// AMP2+ pin is connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS3_1 = 0x1
	// Position of AMPPS2 field.
	OPAMP_AMP0PS_AMPPS2_Pos = 0x2
	// Bit mask of AMPPS2 field.
	OPAMP_AMP0PS_AMPPS2_Msk = 0x4
	// Bit AMPPS2.
	OPAMP_AMP0PS_AMPPS2 = 0x4
	// AMP1+ pin is not connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS2_0 = 0x0
	// AMP1+ pin is connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS2_1 = 0x1
	// Position of AMPPS1 field.
	OPAMP_AMP0PS_AMPPS1_Pos = 0x1
	// Bit mask of AMPPS1 field.
	OPAMP_AMP0PS_AMPPS1_Msk = 0x2
	// Bit AMPPS1.
	OPAMP_AMP0PS_AMPPS1 = 0x2
	// AMP1- pin is not connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS1_0 = 0x0
	// AMP1- pin is connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS1_1 = 0x1
	// Position of AMPPS0 field.
	OPAMP_AMP0PS_AMPPS0_Pos = 0x0
	// Bit mask of AMPPS0 field.
	OPAMP_AMP0PS_AMPPS0_Msk = 0x1
	// Bit AMPPS0.
	OPAMP_AMP0PS_AMPPS0 = 0x1
	// AMP0+ pin is not connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS0_0 = 0x0
	// AMP0+ pin is connected to the AMP0 plus input
	OPAMP_AMP0PS_AMPPS0_1 = 0x1

	// AMP1MS: Operational Amplifier 1 Minus Input Select Register
	// Position of AMPMS7 field.
	OPAMP_AMP1MS_AMPMS7_Pos = 0x7
	// Bit mask of AMPMS7 field.
	OPAMP_AMP1MS_AMPMS7_Msk = 0x80
	// Bit AMPMS7.
	OPAMP_AMP1MS_AMPMS7 = 0x80
	// OPAMP1 output is not connected to the AMP1 minus input
	OPAMP_AMP1MS_AMPMS7_0 = 0x0
	// OPAMP1 output is connected to the AMP1 minus input
	OPAMP_AMP1MS_AMPMS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP1MS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	OPAMP_AMP1MS_Reserved_Msk = 0x7e
	// Position of AMPMS0 field.
	OPAMP_AMP1MS_AMPMS0_Pos = 0x0
	// Bit mask of AMPMS0 field.
	OPAMP_AMP1MS_AMPMS0_Msk = 0x1
	// Bit AMPMS0.
	OPAMP_AMP1MS_AMPMS0 = 0x1
	// AMP1- pin is not connected to the AMP1 minus input
	OPAMP_AMP1MS_AMPMS0_0 = 0x0
	// AMP1- pin is connected to the AMP1 minus input
	OPAMP_AMP1MS_AMPMS0_1 = 0x1

	// AMP1PS: Operational Amplifier 1 Plus Input Select Register
	// Position of AMPMS7 field.
	OPAMP_AMP1PS_AMPMS7_Pos = 0x7
	// Bit mask of AMPMS7 field.
	OPAMP_AMP1PS_AMPMS7_Msk = 0x80
	// Bit AMPMS7.
	OPAMP_AMP1PS_AMPMS7 = 0x80
	// OPAMP2 output is not connected to the AMP2 minus input
	OPAMP_AMP1PS_AMPMS7_0 = 0x0
	// OPAMP2 output is connected to the AMP2 minus input
	OPAMP_AMP1PS_AMPMS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP1PS_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	OPAMP_AMP1PS_Reserved_Msk = 0x70
	// Position of AMPPS3 field.
	OPAMP_AMP1PS_AMPPS3_Pos = 0x3
	// Bit mask of AMPPS3 field.
	OPAMP_AMP1PS_AMPPS3_Msk = 0x8
	// Bit AMPPS3.
	OPAMP_AMP1PS_AMPPS3 = 0x8
	// AMP2+ pin is not connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS3_0 = 0x0
	// AMP2+ pin is connected to the AMP1
	OPAMP_AMP1PS_AMPPS3_1 = 0x1
	// Position of AMPPS2 field.
	OPAMP_AMP1PS_AMPPS2_Pos = 0x2
	// Bit mask of AMPPS2 field.
	OPAMP_AMP1PS_AMPPS2_Msk = 0x4
	// Bit AMPPS2.
	OPAMP_AMP1PS_AMPPS2 = 0x4
	// AMP2- pin is not connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS2_0 = 0x0
	// AMP2- pin is connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS2_1 = 0x1
	// Position of AMPPS1 field.
	OPAMP_AMP1PS_AMPPS1_Pos = 0x1
	// Bit mask of AMPPS1 field.
	OPAMP_AMP1PS_AMPPS1_Msk = 0x2
	// Bit AMPPS1.
	OPAMP_AMP1PS_AMPPS1 = 0x2
	// AMP1+ pin is not connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS1_0 = 0x0
	// AMP1+ pin is connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS1_1 = 0x1
	// Position of AMPPS0 field.
	OPAMP_AMP1PS_AMPPS0_Pos = 0x0
	// Bit mask of AMPPS0 field.
	OPAMP_AMP1PS_AMPPS0_Msk = 0x1
	// Bit AMPPS0.
	OPAMP_AMP1PS_AMPPS0 = 0x1
	// AMP1- pin is not connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS0_0 = 0x0
	// AMP1- pin is connected to the AMP1 plus input
	OPAMP_AMP1PS_AMPPS0_1 = 0x1

	// AMP2MS: Operational Amplifier 2 Minus Input Select Register
	// Position of AMPMS7 field.
	OPAMP_AMP2MS_AMPMS7_Pos = 0x7
	// Bit mask of AMPMS7 field.
	OPAMP_AMP2MS_AMPMS7_Msk = 0x80
	// Bit AMPMS7.
	OPAMP_AMP2MS_AMPMS7 = 0x80
	// OPAMP2 output is not connected to the AMP2 minus input
	OPAMP_AMP2MS_AMPMS7_0 = 0x0
	// OPAMP2 output is connected to the AMP2 minus input
	OPAMP_AMP2MS_AMPMS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP2MS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	OPAMP_AMP2MS_Reserved_Msk = 0x7e
	// Position of AMPMS0 field.
	OPAMP_AMP2MS_AMPMS0_Pos = 0x0
	// Bit mask of AMPMS0 field.
	OPAMP_AMP2MS_AMPMS0_Msk = 0x1
	// Bit AMPMS0.
	OPAMP_AMP2MS_AMPMS0 = 0x1
	// AMP2- pin is not connected to the AMP2 minus input
	OPAMP_AMP2MS_AMPMS0_0 = 0x0
	// AMP2- pin is connected to the AMP2 minus input
	OPAMP_AMP2MS_AMPMS0_1 = 0x1

	// AMP2PS: Operational Amplifier 2 Plus Input Select Register
	// Position of AMPPS7 field.
	OPAMP_AMP2PS_AMPPS7_Pos = 0x7
	// Bit mask of AMPPS7 field.
	OPAMP_AMP2PS_AMPPS7_Msk = 0x80
	// Bit AMPPS7.
	OPAMP_AMP2PS_AMPPS7 = 0x80
	// DAC8 channel 1 output is not connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS7_0 = 0x0
	// DAC8 channel 1 output is connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS7_1 = 0x1
	// Position of Reserved field.
	OPAMP_AMP2PS_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	OPAMP_AMP2PS_Reserved_Msk = 0x7c
	// Position of AMPPS1 field.
	OPAMP_AMP2PS_AMPPS1_Pos = 0x1
	// Bit mask of AMPPS1 field.
	OPAMP_AMP2PS_AMPPS1_Msk = 0x2
	// Bit AMPPS1.
	OPAMP_AMP2PS_AMPPS1 = 0x2
	// AMP2+ pin is not connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS1_0 = 0x0
	// AMP2+ pin is connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS1_1 = 0x1
	// Position of AMPPS0 field.
	OPAMP_AMP2PS_AMPPS0_Pos = 0x0
	// Bit mask of AMPPS0 field.
	OPAMP_AMP2PS_AMPPS0_Msk = 0x1
	// Bit AMPPS0.
	OPAMP_AMP2PS_AMPPS0 = 0x1
	// AMP2- pin is not connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS0_0 = 0x0
	// AMP2- pin is connected to the AMP2 plus input
	OPAMP_AMP2PS_AMPPS0_1 = 0x1

	// AMPCPC: Operational Amplifier Switch Charge Pump Control Register
	// Position of Reserved field.
	OPAMP_AMPCPC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	OPAMP_AMPCPC_Reserved_Msk = 0xf8
	// Position of PUMP2EN field.
	OPAMP_AMPCPC_PUMP2EN_Pos = 0x2
	// Bit mask of PUMP2EN field.
	OPAMP_AMPCPC_PUMP2EN_Msk = 0x4
	// Bit PUMP2EN.
	OPAMP_AMPCPC_PUMP2EN = 0x4
	// Charge Pump for the AMP2 disabled
	OPAMP_AMPCPC_PUMP2EN_0 = 0x0
	// Charge Pump for the AMP2 enable
	OPAMP_AMPCPC_PUMP2EN_1 = 0x1
	// Position of PUMP1EN field.
	OPAMP_AMPCPC_PUMP1EN_Pos = 0x1
	// Bit mask of PUMP1EN field.
	OPAMP_AMPCPC_PUMP1EN_Msk = 0x2
	// Bit PUMP1EN.
	OPAMP_AMPCPC_PUMP1EN = 0x2
	// Charge Pump for the AMP1 disabled
	OPAMP_AMPCPC_PUMP1EN_0 = 0x0
	// Charge Pump for the AMP1 enable
	OPAMP_AMPCPC_PUMP1EN_1 = 0x1
	// Position of PUMP0EN field.
	OPAMP_AMPCPC_PUMP0EN_Pos = 0x0
	// Bit mask of PUMP0EN field.
	OPAMP_AMPCPC_PUMP0EN_Msk = 0x1
	// Bit PUMP0EN.
	OPAMP_AMPCPC_PUMP0EN = 0x1
	// Charge Pump for the AMP0 disabled
	OPAMP_AMPCPC_PUMP0EN_0 = 0x0
	// Charge Pump for the AMP0 enable
	OPAMP_AMPCPC_PUMP0EN_1 = 0x1

	// AMPUOTE: Operational Amplifier User Offset Trimming Enable Register
	// Position of Reserved field.
	OPAMP_AMPUOTE_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	OPAMP_AMPUOTE_Reserved_Msk = 0xf8
	// Position of AMP2TE field.
	OPAMP_AMPUOTE_AMP2TE_Pos = 0x2
	// Bit mask of AMP2TE field.
	OPAMP_AMPUOTE_AMP2TE_Msk = 0x4
	// Bit AMP2TE.
	OPAMP_AMPUOTE_AMP2TE = 0x4
	// Not possible to write to the AMP2OTP and AMP2OTN registers
	OPAMP_AMPUOTE_AMP2TE_0 = 0x0
	// Possible to write to the AMP2OTP and AMP2OTN registers
	OPAMP_AMPUOTE_AMP2TE_1 = 0x1
	// Position of AMP1TE field.
	OPAMP_AMPUOTE_AMP1TE_Pos = 0x1
	// Bit mask of AMP1TE field.
	OPAMP_AMPUOTE_AMP1TE_Msk = 0x2
	// Bit AMP1TE.
	OPAMP_AMPUOTE_AMP1TE = 0x2
	// Not possible to write to the AMP1OTP and AMP1OTN registers
	OPAMP_AMPUOTE_AMP1TE_0 = 0x0
	// Possible to write to the AMP1OTP and AMP1OTN registers
	OPAMP_AMPUOTE_AMP1TE_1 = 0x1
	// Position of AMP0TE field.
	OPAMP_AMPUOTE_AMP0TE_Pos = 0x0
	// Bit mask of AMP0TE field.
	OPAMP_AMPUOTE_AMP0TE_Msk = 0x1
	// Bit AMP0TE.
	OPAMP_AMPUOTE_AMP0TE = 0x1
	// Not possible to write to the AMP0OTP and AMP0OTN registers
	OPAMP_AMPUOTE_AMP0TE_0 = 0x0
	// Possible to write to the AMP0OTP and AMP0OTN registers
	OPAMP_AMPUOTE_AMP0TE_1 = 0x1

	// AMP0OTP: Operational Amplifier 0 Offset Trimming Pch Register
	// Position of Reserved field.
	OPAMP_AMP0OTP_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP0OTP_Reserved_Msk = 0xe0
	// Position of TRMP field.
	OPAMP_AMP0OTP_TRMP_Pos = 0x0
	// Bit mask of TRMP field.
	OPAMP_AMP0OTP_TRMP_Msk = 0x1f

	// AMP0OTN: Operational Amplifier 0 Offset Trimming Nch Register
	// Position of Reserved field.
	OPAMP_AMP0OTN_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP0OTN_Reserved_Msk = 0xe0
	// Position of TRMN field.
	OPAMP_AMP0OTN_TRMN_Pos = 0x0
	// Bit mask of TRMN field.
	OPAMP_AMP0OTN_TRMN_Msk = 0x1f

	// AMP1OTP: Operational Amplifier 1 Offset Trimming Pch Register
	// Position of Reserved field.
	OPAMP_AMP1OTP_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP1OTP_Reserved_Msk = 0xe0
	// Position of TRMP field.
	OPAMP_AMP1OTP_TRMP_Pos = 0x0
	// Bit mask of TRMP field.
	OPAMP_AMP1OTP_TRMP_Msk = 0x1f

	// AMP1OTN: Operational Amplifier 1 Offset Trimming Nch Register
	// Position of Reserved field.
	OPAMP_AMP1OTN_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP1OTN_Reserved_Msk = 0xe0
	// Position of TRMN field.
	OPAMP_AMP1OTN_TRMN_Pos = 0x0
	// Bit mask of TRMN field.
	OPAMP_AMP1OTN_TRMN_Msk = 0x1f

	// AMP2OTP: Operational Amplifier 2 Offset Trimming Pch Register
	// Position of Reserved field.
	OPAMP_AMP2OTP_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP2OTP_Reserved_Msk = 0xe0
	// Position of TRMP field.
	OPAMP_AMP2OTP_TRMP_Pos = 0x0
	// Bit mask of TRMP field.
	OPAMP_AMP2OTP_TRMP_Msk = 0x1f

	// AMP2OTN: Operational Amplifier 2 Offset Trimming Nch Register
	// Position of Reserved field.
	OPAMP_AMP2OTN_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	OPAMP_AMP2OTN_Reserved_Msk = 0xe0
	// Position of TRMN field.
	OPAMP_AMP2OTN_TRMN_Pos = 0x0
	// Bit mask of TRMN field.
	OPAMP_AMP2OTN_TRMN_Msk = 0x1f
)

// Constants for SDADC24: 24-Bit Sigma-Delta A/D Converter
const (
	// STC1: Startup Control Register 1
	// Position of VREFSEL field.
	SDADC24_STC1_VREFSEL_Pos = 0xf
	// Bit mask of VREFSEL field.
	SDADC24_STC1_VREFSEL_Msk = 0x8000
	// Bit VREFSEL.
	SDADC24_STC1_VREFSEL = 0x8000
	// Internal VREF mode
	SDADC24_STC1_VREFSEL_0 = 0x0
	// External VREF mode
	SDADC24_STC1_VREFSEL_1 = 0x1
	// Position of Reserved field.
	SDADC24_STC1_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	SDADC24_STC1_Reserved_Msk = 0x7000
	// Position of VSBIAS field.
	SDADC24_STC1_VSBIAS_Pos = 0x8
	// Bit mask of VSBIAS field.
	SDADC24_STC1_VSBIAS_Msk = 0xf00
	// 0.8 V
	SDADC24_STC1_VSBIAS_0000 = 0x0
	// 1.0 V
	SDADC24_STC1_VSBIAS_0001 = 0x1
	// 1.2 V
	SDADC24_STC1_VSBIAS_0010 = 0x2
	// 1.4 V
	SDADC24_STC1_VSBIAS_0011 = 0x3
	// 1.6 V
	SDADC24_STC1_VSBIAS_0100 = 0x4
	// 1.8 V
	SDADC24_STC1_VSBIAS_0101 = 0x5
	// 2.0 V
	SDADC24_STC1_VSBIAS_0110 = 0x6
	// 2.2 V
	SDADC24_STC1_VSBIAS_0111 = 0x7
	// 2.4 V (This voltage can be set only if VREFSEL = 1. When VREFSEL = 0, 2.2 V is set (rather than 2.4 V))
	SDADC24_STC1_VSBIAS_1111 = 0xf
	// Position of SDADLPM field.
	SDADC24_STC1_SDADLPM_Pos = 0x7
	// Bit mask of SDADLPM field.
	SDADC24_STC1_SDADLPM_Msk = 0x80
	// Bit SDADLPM.
	SDADC24_STC1_SDADLPM = 0x80
	// Normal A/D conversion mode: SDADC24 reference clock:4 MHz, Oversampling clock:1 MHz
	SDADC24_STC1_SDADLPM_0 = 0x0
	// Low-power A/D conversion mode(1/8 of the clock in normal A/D conversion mode): SDADC24 reference clock:500 kHz,Oversampling clock: 125 kHz
	SDADC24_STC1_SDADLPM_1 = 0x1
	// Position of Reserved field.
	SDADC24_STC1_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SDADC24_STC1_Reserved_Msk = 0x70
	// Position of CLKDIV field.
	SDADC24_STC1_CLKDIV_Pos = 0x0
	// Bit mask of CLKDIV field.
	SDADC24_STC1_CLKDIV_Msk = 0xf
	// SDADCCLK (no division)
	SDADC24_STC1_CLKDIV_0000 = 0x0
	// SDADCCLK/2 (1/2)
	SDADC24_STC1_CLKDIV_0001 = 0x1
	// SDADCCLK/3 (1/3)
	SDADC24_STC1_CLKDIV_0010 = 0x2
	// SDADCCLK/4 (1/4)
	SDADC24_STC1_CLKDIV_0011 = 0x3
	// SDADCCLK/5 (1/5)
	SDADC24_STC1_CLKDIV_0100 = 0x4
	// SDADCCLK/6 (1/6)
	SDADC24_STC1_CLKDIV_0101 = 0x5
	// SDADCCLK/8 (1/8)
	SDADC24_STC1_CLKDIV_0110 = 0x6
	// SDADCCLK/12 (1/12)
	SDADC24_STC1_CLKDIV_0111 = 0x7
	// SDADCCLK/16 (1/16).
	SDADC24_STC1_CLKDIV_1000 = 0x8

	// STC2: Startup Control Register 2
	// Position of Reserved field.
	SDADC24_STC2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SDADC24_STC2_Reserved_Msk = 0xf8
	// Position of ADFPWDS field.
	SDADC24_STC2_ADFPWDS_Pos = 0x2
	// Bit mask of ADFPWDS field.
	SDADC24_STC2_ADFPWDS_Msk = 0x4
	// Bit ADFPWDS.
	SDADC24_STC2_ADFPWDS = 0x4
	// Power of ADREG is controlled by the BGRPON setting
	SDADC24_STC2_ADFPWDS_0 = 0x0
	// Power of only ADREG is turned off regardless of the BGRPON setting
	SDADC24_STC2_ADFPWDS_1 = 0x1
	// Position of ADCPON field.
	SDADC24_STC2_ADCPON_Pos = 0x1
	// Bit mask of ADCPON field.
	SDADC24_STC2_ADCPON_Msk = 0x2
	// Bit ADCPON.
	SDADC24_STC2_ADCPON = 0x2
	// Turn off the power of VBIAS, PGA and sigma-delta A/D converter
	SDADC24_STC2_ADCPON_0 = 0x0
	// Turn on the power of VBIAS, PGA and sigma-delta A/D converter
	SDADC24_STC2_ADCPON_1 = 0x1
	// Position of BGRPON field.
	SDADC24_STC2_BGRPON_Pos = 0x0
	// Bit mask of BGRPON field.
	SDADC24_STC2_BGRPON_Msk = 0x1
	// Bit BGRPON.
	SDADC24_STC2_BGRPON = 0x1
	// Turn off the power of ADBGR, SBIAS/VREFI, and ADREG
	SDADC24_STC2_BGRPON_0 = 0x0
	// Turn on the power of ADBGR, SBIAS/VREFI, and ADREG
	SDADC24_STC2_BGRPON_1 = 0x1

	// PGAC0: Input Multiplexer %s Setting Register
	// Position of PGAASN field.
	SDADC24_PGAC_PGAASN_Pos = 0x1f
	// Bit mask of PGAASN field.
	SDADC24_PGAC_PGAASN_Msk = 0x80000000
	// Bit PGAASN.
	SDADC24_PGAC_PGAASN = 0x80000000
	// Specify 1 to 8,032 times by using the value set in the PGACTN[2:0] and PGACTM[4:0] bits
	SDADC24_PGAC_PGAASN_0 = 0x0
	// Specify 1 to 255 times linearly by using the value set in the PGACTN[2:0] and PGACTM[4:0] bits
	SDADC24_PGAC_PGAASN_1 = 0x1
	// Position of PGACVE field.
	SDADC24_PGAC_PGACVE_Pos = 0x1e
	// Bit mask of PGACVE field.
	SDADC24_PGAC_PGACVE_Msk = 0x40000000
	// Bit PGACVE.
	SDADC24_PGAC_PGACVE = 0x40000000
	// Do not calculate the calibration correction factor
	SDADC24_PGAC_PGACVE_0 = 0x0
	// Calculate the calibration correction factor
	SDADC24_PGAC_PGACVE_1 = 0x1
	// Position of Reserved field.
	SDADC24_PGAC_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	SDADC24_PGAC_Reserved_Msk = 0x20000000
	// Bit Reserved.
	SDADC24_PGAC_Reserved = 0x20000000
	// Position of PGAREV field.
	SDADC24_PGAC_PGAREV_Pos = 0x1c
	// Bit mask of PGAREV field.
	SDADC24_PGAC_PGAREV_Msk = 0x10000000
	// Bit PGAREV.
	SDADC24_PGAC_PGAREV = 0x10000000
	// Do not invert the conversion result data
	SDADC24_PGAC_PGAREV_0 = 0x0
	// Invert the conversion result data
	SDADC24_PGAC_PGAREV_1 = 0x1
	// Position of PGAAVE field.
	SDADC24_PGAC_PGAAVE_Pos = 0x1a
	// Bit mask of PGAAVE field.
	SDADC24_PGAC_PGAAVE_Msk = 0xc000000
	// Do not average the A/D conversion results
	SDADC24_PGAC_PGAAVE_00 = 0x0
	// Do not average the A/D conversion results
	SDADC24_PGAC_PGAAVE_01 = 0x1
	// Average the A/D conversion results and generates SDADC_ADI each time an A/D conversion occurs
	SDADC24_PGAC_PGAAVE_10 = 0x2
	// Perform averaging, and generate SDADC_ADI at each time of average value output (A/D conversion is performed N times).
	SDADC24_PGAC_PGAAVE_11 = 0x3
	// Position of PGAAVN field.
	SDADC24_PGAC_PGAAVN_Pos = 0x18
	// Bit mask of PGAAVN field.
	SDADC24_PGAC_PGAAVN_Msk = 0x3000000
	// 8
	SDADC24_PGAC_PGAAVN_00 = 0x0
	// 16
	SDADC24_PGAC_PGAAVN_01 = 0x1
	// 32
	SDADC24_PGAC_PGAAVN_10 = 0x2
	// 64
	SDADC24_PGAC_PGAAVN_11 = 0x3
	// Position of PGACTN field.
	SDADC24_PGAC_PGACTN_Pos = 0x15
	// Bit mask of PGACTN field.
	SDADC24_PGAC_PGACTN_Msk = 0xe00000
	// 0
	SDADC24_PGAC_PGACTN_000 = 0x0
	// 1
	SDADC24_PGAC_PGACTN_001 = 0x1
	// 2
	SDADC24_PGAC_PGACTN_010 = 0x2
	// 3
	SDADC24_PGAC_PGACTN_011 = 0x3
	// 4
	SDADC24_PGAC_PGACTN_100 = 0x4
	// 5
	SDADC24_PGAC_PGACTN_101 = 0x5
	// 6
	SDADC24_PGAC_PGACTN_110 = 0x6
	// 7
	SDADC24_PGAC_PGACTN_111 = 0x7
	// Position of PGACTM field.
	SDADC24_PGAC_PGACTM_Pos = 0x10
	// Bit mask of PGACTM field.
	SDADC24_PGAC_PGACTM_Msk = 0x1f0000
	// Position of PGASEL field.
	SDADC24_PGAC_PGASEL_Pos = 0xf
	// Bit mask of PGASEL field.
	SDADC24_PGAC_PGASEL_Msk = 0x8000
	// Bit PGASEL.
	SDADC24_PGAC_PGASEL = 0x8000
	// Differential input mode
	SDADC24_PGAC_PGASEL_0 = 0x0
	// Single-end input mode
	SDADC24_PGAC_PGASEL_1 = 0x1
	// Position of PGAPOL field.
	SDADC24_PGAC_PGAPOL_Pos = 0xe
	// Bit mask of PGAPOL field.
	SDADC24_PGAC_PGAPOL_Msk = 0x4000
	// Bit PGAPOL.
	SDADC24_PGAC_PGAPOL = 0x4000
	// Positive-side single-end input
	SDADC24_PGAC_PGAPOL_0 = 0x0
	// Negative-side single-end input
	SDADC24_PGAC_PGAPOL_1 = 0x1
	// Position of Reserved field.
	SDADC24_PGAC_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SDADC24_PGAC_Reserved_Msk = 0x2000
	// Bit Reserved.
	SDADC24_PGAC_Reserved = 0x2000
	// Position of PGAOFS field.
	SDADC24_PGAC_PGAOFS_Pos = 0x8
	// Bit mask of PGAOFS field.
	SDADC24_PGAC_PGAOFS_Msk = 0x1f00
	// Position of PGAOSR field.
	SDADC24_PGAC_PGAOSR_Pos = 0x5
	// Bit mask of PGAOSR field.
	SDADC24_PGAC_PGAOSR_Msk = 0xe0
	// 64
	SDADC24_PGAC_PGAOSR_000 = 0x0
	// 128
	SDADC24_PGAC_PGAOSR_001 = 0x1
	// 256
	SDADC24_PGAC_PGAOSR_010 = 0x2
	// 512
	SDADC24_PGAC_PGAOSR_011 = 0x3
	// 1024
	SDADC24_PGAC_PGAOSR_100 = 0x4
	// 2048
	SDADC24_PGAC_PGAOSR_101 = 0x5
	// Position of PGAGC field.
	SDADC24_PGAC_PGAGC_Pos = 0x0
	// Bit mask of PGAGC field.
	SDADC24_PGAC_PGAGC_Msk = 0x1f
	// (1, 1, 1)
	SDADC24_PGAC_PGAGC_00000 = 0x0
	// (2, 1, 2)
	SDADC24_PGAC_PGAGC_00100 = 0x4
	// (3, 1, 3)
	SDADC24_PGAC_PGAGC_01000 = 0x8
	// (4, 1, 4)
	SDADC24_PGAC_PGAGC_01100 = 0xc
	// (8, 1, 8)
	SDADC24_PGAC_PGAGC_10000 = 0x10
	// (1, 2, 2)
	SDADC24_PGAC_PGAGC_00001 = 0x1
	// (2, 2, 4)
	SDADC24_PGAC_PGAGC_00101 = 0x5
	// (3, 2, 6)
	SDADC24_PGAC_PGAGC_01001 = 0x9
	// (4, 2, 8)
	SDADC24_PGAC_PGAGC_01101 = 0xd
	// (8, 2, 16)
	SDADC24_PGAC_PGAGC_10001 = 0x11
	// (1, 4, 4)
	SDADC24_PGAC_PGAGC_00010 = 0x2
	// (2, 4, 8)
	SDADC24_PGAC_PGAGC_00110 = 0x6
	// (3, 4, 12)
	SDADC24_PGAC_PGAGC_01010 = 0xa
	// (4, 4, 16)
	SDADC24_PGAC_PGAGC_01110 = 0xe
	// (8, 4, 32)
	SDADC24_PGAC_PGAGC_10010 = 0x12
	// (1, 8, 8)
	SDADC24_PGAC_PGAGC_00011 = 0x3
	// (2, 8, 16)
	SDADC24_PGAC_PGAGC_00111 = 0x7
	// (3, 8, 24)
	SDADC24_PGAC_PGAGC_01011 = 0xb
	// (4, 8, 32).
	SDADC24_PGAC_PGAGC_01111 = 0xf

	// ADC1: Sigma-delta A/D Converter Control Register 1
	// Position of Reserved field.
	SDADC24_ADC1_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	SDADC24_ADC1_Reserved_Msk = 0xffe00000
	// Position of PGASLFT field.
	SDADC24_ADC1_PGASLFT_Pos = 0x14
	// Bit mask of PGASLFT field.
	SDADC24_ADC1_PGASLFT_Msk = 0x100000
	// Bit PGASLFT.
	SDADC24_ADC1_PGASLFT = 0x100000
	// Disable PGA offset self-diagnosis
	SDADC24_ADC1_PGASLFT_0 = 0x0
	// Enable PGA offset self-diagnosis
	SDADC24_ADC1_PGASLFT_1 = 0x1
	// Position of Reserved field.
	SDADC24_ADC1_Reserved_Pos = 0x12
	// Bit mask of Reserved field.
	SDADC24_ADC1_Reserved_Msk = 0xc0000
	// Position of PGADISC field.
	SDADC24_ADC1_PGADISC_Pos = 0x11
	// Bit mask of PGADISC field.
	SDADC24_ADC1_PGADISC_Msk = 0x20000
	// Bit PGADISC.
	SDADC24_ADC1_PGADISC = 0x20000
	// Discharge
	SDADC24_ADC1_PGADISC_0 = 0x0
	// Pre-charge
	SDADC24_ADC1_PGADISC_1 = 0x1
	// Position of PGADISA field.
	SDADC24_ADC1_PGADISA_Pos = 0x10
	// Bit mask of PGADISA field.
	SDADC24_ADC1_PGADISA_Msk = 0x10000
	// Bit PGADISA.
	SDADC24_ADC1_PGADISA = 0x10000
	// Normal operation
	SDADC24_ADC1_PGADISA_0 = 0x0
	// State of disconnection detection
	SDADC24_ADC1_PGADISA_1 = 0x1
	// Position of Reserved field.
	SDADC24_ADC1_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SDADC24_ADC1_Reserved_Msk = 0xe000
	// Position of SDADBMP field.
	SDADC24_ADC1_SDADBMP_Pos = 0x8
	// Bit mask of SDADBMP field.
	SDADC24_ADC1_SDADBMP_Msk = 0x1f00
	// Position of Reserved field.
	SDADC24_ADC1_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SDADC24_ADC1_Reserved_Msk = 0xe0
	// Position of SDADTMD field.
	SDADC24_ADC1_SDADTMD_Pos = 0x4
	// Bit mask of SDADTMD field.
	SDADC24_ADC1_SDADTMD_Msk = 0x10
	// Bit SDADTMD.
	SDADC24_ADC1_SDADTMD = 0x10
	// Software trigger (conversion is started by a write to SFR)
	SDADC24_ADC1_SDADTMD_0 = 0x0
	// Hardware trigger (conversion is started in synchronization with the event signal selected by ELC_SDADC24).
	SDADC24_ADC1_SDADTMD_1 = 0x1
	// Position of Reserved field.
	SDADC24_ADC1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SDADC24_ADC1_Reserved_Msk = 0xe
	// Position of SDADSCM field.
	SDADC24_ADC1_SDADSCM_Pos = 0x0
	// Bit mask of SDADSCM field.
	SDADC24_ADC1_SDADSCM_Msk = 0x1
	// Bit SDADSCM.
	SDADC24_ADC1_SDADSCM = 0x1
	// Continuous scan mode
	SDADC24_ADC1_SDADSCM_0 = 0x0
	// Single scan mode
	SDADC24_ADC1_SDADSCM_1 = 0x1

	// ADC2: Sigma-delta A/D Converter Control Register 2
	// Position of Reserved field.
	SDADC24_ADC2_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SDADC24_ADC2_Reserved_Msk = 0xfe
	// Position of SDADST field.
	SDADC24_ADC2_SDADST_Pos = 0x0
	// Bit mask of SDADST field.
	SDADC24_ADC2_SDADST_Msk = 0x1
	// Bit SDADST.
	SDADC24_ADC2_SDADST = 0x1
	// Stop A/D conversion
	SDADC24_ADC2_SDADST_0 = 0x0
	// Start A/D conversion
	SDADC24_ADC2_SDADST_1 = 0x1

	// ADCR: Sigma-delta A/D Converter Conversion Result Register
	// Position of Reserved field.
	SDADC24_ADCR_Reserved_Pos = 0x1c
	// Bit mask of Reserved field.
	SDADC24_ADCR_Reserved_Msk = 0xf0000000
	// Position of SDADCRC field.
	SDADC24_ADCR_SDADCRC_Pos = 0x19
	// Bit mask of SDADCRC field.
	SDADC24_ADCR_SDADCRC_Msk = 0xe000000
	// Reset value (Conversion result is invalid)
	SDADC24_ADCR_SDADCRC_000 = 0x0
	// Input multiplexer 0 (ANSD0P / ANSD0N)
	SDADC24_ADCR_SDADCRC_001 = 0x1
	// Input multiplexer 1 (ANSD1P / ANSD1N)
	SDADC24_ADCR_SDADCRC_010 = 0x2
	// Input multiplexer 2 (ANSD2P / ANSD2N)
	SDADC24_ADCR_SDADCRC_011 = 0x3
	// Input multiplexer 3 (ANSD3P / ANSD3N)
	SDADC24_ADCR_SDADCRC_100 = 0x4
	// Input multiplexer 4 (AMP0O / AMP1O)
	SDADC24_ADCR_SDADCRC_101 = 0x5
	// Position of SDADCRS field.
	SDADC24_ADCR_SDADCRS_Pos = 0x18
	// Bit mask of SDADCRS field.
	SDADC24_ADCR_SDADCRS_Msk = 0x1000000
	// Bit SDADCRS.
	SDADC24_ADCR_SDADCRS = 0x1000000
	// Normal status (within the range)
	SDADC24_ADCR_SDADCRS_0 = 0x0
	// Overflow occurred
	SDADC24_ADCR_SDADCRS_1 = 0x1
	// Position of SDADCRD field.
	SDADC24_ADCR_SDADCRD_Pos = 0x0
	// Bit mask of SDADCRD field.
	SDADC24_ADCR_SDADCRD_Msk = 0xffffff
	// Position of Reserved field.
	SDADC24_ADCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SDADC24_ADCR_Reserved_Msk = 0xffff

	// ADAR: Sigma-delta A/D Converter Average Value Register
	// Position of Reserved field.
	SDADC24_ADAR_Reserved_Pos = 0x1c
	// Bit mask of Reserved field.
	SDADC24_ADAR_Reserved_Msk = 0xf0000000
	// Position of SDADMVC field.
	SDADC24_ADAR_SDADMVC_Pos = 0x19
	// Bit mask of SDADMVC field.
	SDADC24_ADAR_SDADMVC_Msk = 0xe000000
	// Reset value (Conversion result is invalid)
	SDADC24_ADAR_SDADMVC_000 = 0x0
	// Input multiplexer 0 (ANSD0P / ANSD0N)
	SDADC24_ADAR_SDADMVC_001 = 0x1
	// Input multiplexer 1 (ANSD1P / ANSD1N)
	SDADC24_ADAR_SDADMVC_010 = 0x2
	// Input multiplexer 2 (ANSD2P / ANSD2N)
	SDADC24_ADAR_SDADMVC_011 = 0x3
	// Input multiplexer 3 (ANSD3P / ANSD3N)
	SDADC24_ADAR_SDADMVC_100 = 0x4
	// Input multiplexer 4 (AMP0O / AMP1O).
	SDADC24_ADAR_SDADMVC_101 = 0x5
	// Position of SDADMVS field.
	SDADC24_ADAR_SDADMVS_Pos = 0x18
	// Bit mask of SDADMVS field.
	SDADC24_ADAR_SDADMVS_Msk = 0x1000000
	// Bit SDADMVS.
	SDADC24_ADAR_SDADMVS = 0x1000000
	// Normal status (within the range)
	SDADC24_ADAR_SDADMVS_0 = 0x0
	// Overflow occurred
	SDADC24_ADAR_SDADMVS_1 = 0x1
	// Position of SDADMVD field.
	SDADC24_ADAR_SDADMVD_Pos = 0x0
	// Bit mask of SDADMVD field.
	SDADC24_ADAR_SDADMVD_Msk = 0xffffff
	// Position of Reserved field.
	SDADC24_ADAR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SDADC24_ADAR_Reserved_Msk = 0xffff

	// CLBC: Calibration Control Register
	// Position of Reserved field.
	SDADC24_CLBC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SDADC24_CLBC_Reserved_Msk = 0xfc
	// Position of CLBMD field.
	SDADC24_CLBC_CLBMD_Pos = 0x0
	// Bit mask of CLBMD field.
	SDADC24_CLBC_CLBMD_Msk = 0x3
	// Internal calibration mode
	SDADC24_CLBC_CLBMD_00 = 0x0
	// External offset calibration mode
	SDADC24_CLBC_CLBMD_01 = 0x1
	// External gain calibration mode
	SDADC24_CLBC_CLBMD_10 = 0x2
	// Settings are prohibited
	SDADC24_CLBC_CLBMD_11 = 0x3

	// CLBSTR: Calibration Start Control Register
	// Position of Reserved field.
	SDADC24_CLBSTR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SDADC24_CLBSTR_Reserved_Msk = 0xfe
	// Position of CLBST field.
	SDADC24_CLBSTR_CLBST_Pos = 0x0
	// Bit mask of CLBST field.
	SDADC24_CLBSTR_CLBST_Msk = 0x1
	// Bit CLBST.
	SDADC24_CLBSTR_CLBST = 0x1
	// Disable writing
	SDADC24_CLBSTR_CLBST_0 = 0x0
	// Start calibration
	SDADC24_CLBSTR_CLBST_1 = 0x1

	// CLBSSR: Calibration Status Register
	// Position of Reserved field.
	SDADC24_CLBSSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SDADC24_CLBSSR_Reserved_Msk = 0xfe
	// Position of CLBSS field.
	SDADC24_CLBSSR_CLBSS_Pos = 0x0
	// Bit mask of CLBSS field.
	SDADC24_CLBSSR_CLBSS_Msk = 0x1
	// Bit CLBSS.
	SDADC24_CLBSSR_CLBSS = 0x1
	// Calibration is not running
	SDADC24_CLBSSR_CLBSS_0 = 0x0
	// Calibration is running
	SDADC24_CLBSSR_CLBSS_1 = 0x1
)

// Constants for TSN: Temperature Sensor
const (
	// TSCDRL: Temperature Sensor Calibration Data Register L
	// Position of TSCDRL field.
	TSN_TSCDRL_TSCDRL_Pos = 0x0
	// Bit mask of TSCDRL field.
	TSN_TSCDRL_TSCDRL_Msk = 0xff

	// TSCDRH: Temperature Sensor Calibration Data Register H
	// Position of TSCDRH field.
	TSN_TSCDRH_TSCDRH_Pos = 0x0
	// Bit mask of TSCDRH field.
	TSN_TSCDRH_TSCDRH_Msk = 0xff
)

// Constants for DAC12: 12-bit D/A converter
const (
	// DADR0: D/A Data Register 0
	// Position of DADR field.
	DAC12_DADR0_DADR_Pos = 0x0
	// Bit mask of DADR field.
	DAC12_DADR0_DADR_Msk = 0xffff

	// DACR: D/A Control Register
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x80
	// Bit Reserved.
	DAC12_DACR_Reserved = 0x80
	// Position of DAOE0 field.
	DAC12_DACR_DAOE0_Pos = 0x6
	// Bit mask of DAOE0 field.
	DAC12_DACR_DAOE0_Msk = 0x40
	// Bit DAOE0.
	DAC12_DACR_DAOE0 = 0x40
	// Analog output of channel 0 (DA0) is disabled.
	DAC12_DACR_DAOE0_0 = 0x0
	// D/A conversion of channel 0 is enabled. Analog output of channel 0 (DA0) is enabled.
	DAC12_DACR_DAOE0_1 = 0x1
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x20
	// Bit Reserved.
	DAC12_DACR_Reserved = 0x20
	// Position of Reserved field.
	DAC12_DACR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC12_DACR_Reserved_Msk = 0x1f

	// DADPR: DADR0 Format Select Register
	// Position of DPSEL field.
	DAC12_DADPR_DPSEL_Pos = 0x7
	// Bit mask of DPSEL field.
	DAC12_DADPR_DPSEL_Msk = 0x80
	// Bit DPSEL.
	DAC12_DADPR_DPSEL = 0x80
	// Right justified format.
	DAC12_DADPR_DPSEL_0 = 0x0
	// Left justified format.
	DAC12_DADPR_DPSEL_1 = 0x1
	// Position of Reserved field.
	DAC12_DADPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC12_DADPR_Reserved_Msk = 0x7f

	// DAADSCR: D/A-A/D Synchronous Start Control Register
	// Position of DAADST field.
	DAC12_DAADSCR_DAADST_Pos = 0x7
	// Bit mask of DAADST field.
	DAC12_DAADSCR_DAADST_Msk = 0x80
	// Bit DAADST.
	DAC12_DAADSCR_DAADST = 0x80
	// D/A converter operation does not synchronize with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is disabled).
	DAC12_DAADSCR_DAADST_0 = 0x0
	// D/A converter operation synchronizes with A/D converter operation (unit 1) (countermeasure against interference between D/A and A/D conversions is enabled).
	DAC12_DAADSCR_DAADST_1 = 0x1
	// Position of Reserved field.
	DAC12_DAADSCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DAC12_DAADSCR_Reserved_Msk = 0x7f

	// DAVREFCR: D/A VREF Control Register
	// Position of Reserved field.
	DAC12_DAVREFCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DAC12_DAVREFCR_Reserved_Msk = 0xf8
	// Position of REF field.
	DAC12_DAVREFCR_REF_Pos = 0x0
	// Bit mask of REF field.
	DAC12_DAVREFCR_REF_Msk = 0x7
	// Not selected
	DAC12_DAVREFCR_REF_000 = 0x0
	// AVCC0/AVSS0
	DAC12_DAVREFCR_REF_001 = 0x1
	// Internal reference voltage/AVSS0
	DAC12_DAVREFCR_REF_011 = 0x3
	// VREFH/VREFL
	DAC12_DAVREFCR_REF_110 = 0x6

	// DAPC: D/A Switch Charge Pump Control Register
	// Position of Reserved field.
	DAC12_DAPC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DAC12_DAPC_Reserved_Msk = 0xfe
	// Position of PUMPEN field.
	DAC12_DAPC_PUMPEN_Pos = 0x0
	// Bit mask of PUMPEN field.
	DAC12_DAPC_PUMPEN_Msk = 0x1
	// Bit PUMPEN.
	DAC12_DAPC_PUMPEN = 0x1
	// Charge pump disabled
	DAC12_DAPC_PUMPEN_0 = 0x0
	// Charge pump enabled
	DAC12_DAPC_PUMPEN_1 = 0x1
)

// Constants for DAC8: 8-bit D/A converter
const (
	// DACS0: D/A Conversion Value Setting Register %s
	// Position of DACS field.
	DAC8_DACS_DACS_Pos = 0x0
	// Bit mask of DACS field.
	DAC8_DACS_DACS_Msk = 0xff

	// DAM: D/A Converter Mode Register
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0x80
	// Bit Reserved.
	DAC8_DAM_Reserved = 0x80
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0x40
	// Bit Reserved.
	DAC8_DAM_Reserved = 0x40
	// Position of DACE1 field.
	DAC8_DAM_DACE1_Pos = 0x5
	// Bit mask of DACE1 field.
	DAC8_DAM_DACE1_Msk = 0x20
	// Bit DACE1.
	DAC8_DAM_DACE1 = 0x20
	// D/A conversion disabled for channel 1
	DAC8_DAM_DACE1_0 = 0x0
	// D/A conversion enabled for channel 1
	DAC8_DAM_DACE1_1 = 0x1
	// Position of DACE0 field.
	DAC8_DAM_DACE0_Pos = 0x4
	// Bit mask of DACE0 field.
	DAC8_DAM_DACE0_Msk = 0x10
	// Bit DACE0.
	DAC8_DAM_DACE0 = 0x10
	// D/A conversion disabled for channel 0
	DAC8_DAM_DACE0_0 = 0x0
	// D/A conversion enabled for channel 0
	DAC8_DAM_DACE0_1 = 0x1
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0x8
	// Bit Reserved.
	DAC8_DAM_Reserved = 0x8
	// Position of Reserved field.
	DAC8_DAM_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	DAC8_DAM_Reserved_Msk = 0x4
	// Bit Reserved.
	DAC8_DAM_Reserved = 0x4
	// Position of DAMD1 field.
	DAC8_DAM_DAMD1_Pos = 0x1
	// Bit mask of DAMD1 field.
	DAC8_DAM_DAMD1_Msk = 0x2
	// Bit DAMD1.
	DAC8_DAM_DAMD1 = 0x2
	// Channel 1 for normal operation mode
	DAC8_DAM_DAMD1_0 = 0x0
	// Channel 1 for real-time output mode(event link)
	DAC8_DAM_DAMD1_1 = 0x1
	// Position of DAMD0 field.
	DAC8_DAM_DAMD0_Pos = 0x0
	// Bit mask of DAMD0 field.
	DAC8_DAM_DAMD0_Msk = 0x1
	// Bit DAMD0.
	DAC8_DAM_DAMD0 = 0x1
	// Channel 0 for normal operation mode
	DAC8_DAM_DAMD0_0 = 0x0
	// Channel 0 for real-time output mode(event link)
	DAC8_DAM_DAMD0_1 = 0x1

	// DACADSCR: D/A A/D Synchronous Start Control Register
	// Position of Reserved field.
	DAC8_DACADSCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DAC8_DACADSCR_Reserved_Msk = 0xfe
	// Position of DACADST field.
	DAC8_DACADSCR_DACADST_Pos = 0x0
	// Bit mask of DACADST field.
	DAC8_DACADSCR_DACADST_Msk = 0x1
	// Bit DACADST.
	DAC8_DACADSCR_DACADST = 0x1
	// Do not synchronize DAC8 with ADC16 operation (disable interference reduction between D/A and A/D conversion)
	DAC8_DACADSCR_DACADST_0 = 0x0
	// Synchronize DAC8 with ADC16 operation (enable interference reduction between D/A and A/D conversion).
	DAC8_DACADSCR_DACADST_1 = 0x1

	// DACPC: D/A SW Charge Pump Control Register
	// Position of Reserved field.
	DAC8_DACPC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DAC8_DACPC_Reserved_Msk = 0xfe
	// Position of PUMPEN field.
	DAC8_DACPC_PUMPEN_Pos = 0x0
	// Bit mask of PUMPEN field.
	DAC8_DACPC_PUMPEN_Msk = 0x1
	// Bit PUMPEN.
	DAC8_DACPC_PUMPEN = 0x1
	// Charge pump disable
	DAC8_DACPC_PUMPEN_0 = 0x0
	// Charge pump enable
	DAC8_DACPC_PUMPEN_1 = 0x1
)

// Constants for ELC: Event Link Controller
const (
	// ELCR: Event Link Controller Register
	// Position of ELCON field.
	ELC_ELCR_ELCON_Pos = 0x7
	// Bit mask of ELCON field.
	ELC_ELCR_ELCON_Msk = 0x80
	// Bit ELCON.
	ELC_ELCR_ELCON = 0x80
	// ELC function is disabled.
	ELC_ELCR_ELCON_0 = 0x0
	// ELC function is enabled.
	ELC_ELCR_ELCON_1 = 0x1
	// Position of Reserved field.
	ELC_ELCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	ELC_ELCR_Reserved_Msk = 0x7f

	// ELSEGR0: Event Link Software Event Generation Register %s
	// Position of WI field.
	ELC_ELSEGR_WI_Pos = 0x7
	// Bit mask of WI field.
	ELC_ELSEGR_WI_Msk = 0x80
	// Bit WI.
	ELC_ELSEGR_WI = 0x80
	// Write to ELSEGR register is enabled.
	ELC_ELSEGR_WI_0 = 0x0
	// Write to ELSEGR register is disabled.
	ELC_ELSEGR_WI_1 = 0x1
	// Position of WE field.
	ELC_ELSEGR_WE_Pos = 0x6
	// Bit mask of WE field.
	ELC_ELSEGR_WE_Msk = 0x40
	// Bit WE.
	ELC_ELSEGR_WE = 0x40
	// Write to SEG bit is disabled.
	ELC_ELSEGR_WE_0 = 0x0
	// Write to SEG bit is enabled.
	ELC_ELSEGR_WE_1 = 0x1
	// Position of Reserved field.
	ELC_ELSEGR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ELC_ELSEGR_Reserved_Msk = 0x3e
	// Position of SEG field.
	ELC_ELSEGR_SEG_Pos = 0x0
	// Bit mask of SEG field.
	ELC_ELSEGR_SEG_Msk = 0x1
	// Bit SEG.
	ELC_ELSEGR_SEG = 0x1
	// Normal operation
	ELC_ELSEGR_SEG_0 = 0x0
	// Software event is generated.
	ELC_ELSEGR_SEG_1 = 0x1

	// ELSR0: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x000 = 0x0

	// ELSR8: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x000 = 0x0

	// ELSR12: Event Link Setting Register 12
	// Position of Reserved field.
	ELC_ELSR12_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR12_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR12_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR12_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR12_ELS_0x000 = 0x0

	// ELSR14: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x000 = 0x0

	// ELSR18: Event Link Setting Register %s
	// Position of Reserved field.
	ELC_ELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR_ELS_0x000 = 0x0

	// ELSR22: Event Link Setting Register 22
	// Position of Reserved field.
	ELC_ELSR22_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ELC_ELSR22_Reserved_Msk = 0xff00
	// Position of ELS field.
	ELC_ELSR22_ELS_Pos = 0x0
	// Bit mask of ELS field.
	ELC_ELSR22_ELS_Msk = 0xff
	// Event output to the corresponding peripheral module is disabled.
	ELC_ELSR22_ELS_0x000 = 0x0
)

// Constants for IWDT: Independent Watchdog Timer
const (
	// IWDTRR: IWDT Refresh Register
	// Position of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Pos = 0x0
	// Bit mask of IWDTRR field.
	IWDT_IWDTRR_IWDTRR_Msk = 0xff

	// IWDTSR: IWDT Status Register
	// Position of REFEF field.
	IWDT_IWDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	IWDT_IWDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	IWDT_IWDTSR_REFEF = 0x8000
	// Refresh error not occurred
	IWDT_IWDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	IWDT_IWDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	IWDT_IWDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	IWDT_IWDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	IWDT_IWDTSR_UNDFF = 0x4000
	// Underflow not occurred
	IWDT_IWDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	IWDT_IWDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	IWDT_IWDTSR_CNTVAL_Msk = 0x3fff
)

// Constants for KINT: Key Interrupt Function
const (
	// KRCTL: KEY Return Control Register
	// Position of KRMD field.
	KINT_KRCTL_KRMD_Pos = 0x7
	// Bit mask of KRMD field.
	KINT_KRCTL_KRMD_Msk = 0x80
	// Bit KRMD.
	KINT_KRCTL_KRMD = 0x80
	// Do not use key interrupt flags
	KINT_KRCTL_KRMD_0 = 0x0
	// Use key interrupt flags.
	KINT_KRCTL_KRMD_1 = 0x1
	// Position of Reserved field.
	KINT_KRCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	KINT_KRCTL_Reserved_Msk = 0x7e
	// Position of KREG field.
	KINT_KRCTL_KREG_Pos = 0x0
	// Bit mask of KREG field.
	KINT_KRCTL_KREG_Msk = 0x1
	// Bit KREG.
	KINT_KRCTL_KREG = 0x1
	// Falling edge
	KINT_KRCTL_KREG_0 = 0x0
	// Rising edge
	KINT_KRCTL_KREG_1 = 0x1

	// KRF: KEY Return Flag Register
	// Position of KRF7 field.
	KINT_KRF_KRF7_Pos = 0x7
	// Bit mask of KRF7 field.
	KINT_KRF_KRF7_Msk = 0x80
	// Bit KRF7.
	KINT_KRF_KRF7 = 0x80
	// No interrupt detected
	KINT_KRF_KRF7_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF7_1 = 0x1
	// Position of KRF6 field.
	KINT_KRF_KRF6_Pos = 0x6
	// Bit mask of KRF6 field.
	KINT_KRF_KRF6_Msk = 0x40
	// Bit KRF6.
	KINT_KRF_KRF6 = 0x40
	// No interrupt detected
	KINT_KRF_KRF6_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF6_1 = 0x1
	// Position of KRF5 field.
	KINT_KRF_KRF5_Pos = 0x5
	// Bit mask of KRF5 field.
	KINT_KRF_KRF5_Msk = 0x20
	// Bit KRF5.
	KINT_KRF_KRF5 = 0x20
	// No interrupt detected
	KINT_KRF_KRF5_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF5_1 = 0x1
	// Position of KRF4 field.
	KINT_KRF_KRF4_Pos = 0x4
	// Bit mask of KRF4 field.
	KINT_KRF_KRF4_Msk = 0x10
	// Bit KRF4.
	KINT_KRF_KRF4 = 0x10
	// No interrupt detected
	KINT_KRF_KRF4_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF4_1 = 0x1
	// Position of KRF3 field.
	KINT_KRF_KRF3_Pos = 0x3
	// Bit mask of KRF3 field.
	KINT_KRF_KRF3_Msk = 0x8
	// Bit KRF3.
	KINT_KRF_KRF3 = 0x8
	// No interrupt detected
	KINT_KRF_KRF3_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF3_1 = 0x1
	// Position of KRF2 field.
	KINT_KRF_KRF2_Pos = 0x2
	// Bit mask of KRF2 field.
	KINT_KRF_KRF2_Msk = 0x4
	// Bit KRF2.
	KINT_KRF_KRF2 = 0x4
	// No interrupt detected
	KINT_KRF_KRF2_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF2_1 = 0x1
	// Position of KRF1 field.
	KINT_KRF_KRF1_Pos = 0x1
	// Bit mask of KRF1 field.
	KINT_KRF_KRF1_Msk = 0x2
	// Bit KRF1.
	KINT_KRF_KRF1 = 0x2
	// No interrupt detected
	KINT_KRF_KRF1_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF1_1 = 0x1
	// Position of KRF0 field.
	KINT_KRF_KRF0_Pos = 0x0
	// Bit mask of KRF0 field.
	KINT_KRF_KRF0_Msk = 0x1
	// Bit KRF0.
	KINT_KRF_KRF0 = 0x1
	// No interrupt detected
	KINT_KRF_KRF0_0 = 0x0
	// Interrupt detected.
	KINT_KRF_KRF0_1 = 0x1

	// KRM: KEY Return Mode Register
	// Position of KRM7 field.
	KINT_KRM_KRM7_Pos = 0x7
	// Bit mask of KRM7 field.
	KINT_KRM_KRM7_Msk = 0x80
	// Bit KRM7.
	KINT_KRM_KRM7 = 0x80
	// Does not detect key interrupt signal
	KINT_KRM_KRM7_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM7_1 = 0x1
	// Position of KRM6 field.
	KINT_KRM_KRM6_Pos = 0x6
	// Bit mask of KRM6 field.
	KINT_KRM_KRM6_Msk = 0x40
	// Bit KRM6.
	KINT_KRM_KRM6 = 0x40
	// Does not detect key interrupt signal
	KINT_KRM_KRM6_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM6_1 = 0x1
	// Position of KRM5 field.
	KINT_KRM_KRM5_Pos = 0x5
	// Bit mask of KRM5 field.
	KINT_KRM_KRM5_Msk = 0x20
	// Bit KRM5.
	KINT_KRM_KRM5 = 0x20
	// Does not detect key interrupt signal
	KINT_KRM_KRM5_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM5_1 = 0x1
	// Position of KRM4 field.
	KINT_KRM_KRM4_Pos = 0x4
	// Bit mask of KRM4 field.
	KINT_KRM_KRM4_Msk = 0x10
	// Bit KRM4.
	KINT_KRM_KRM4 = 0x10
	// Does not detect key interrupt signal
	KINT_KRM_KRM4_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM4_1 = 0x1
	// Position of KRM3 field.
	KINT_KRM_KRM3_Pos = 0x3
	// Bit mask of KRM3 field.
	KINT_KRM_KRM3_Msk = 0x8
	// Bit KRM3.
	KINT_KRM_KRM3 = 0x8
	// Does not detect key interrupt signal
	KINT_KRM_KRM3_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM3_1 = 0x1
	// Position of KRM2 field.
	KINT_KRM_KRM2_Pos = 0x2
	// Bit mask of KRM2 field.
	KINT_KRM_KRM2_Msk = 0x4
	// Bit KRM2.
	KINT_KRM_KRM2 = 0x4
	// Does not detect key interrupt signal
	KINT_KRM_KRM2_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM2_1 = 0x1
	// Position of KRM1 field.
	KINT_KRM_KRM1_Pos = 0x1
	// Bit mask of KRM1 field.
	KINT_KRM_KRM1_Msk = 0x2
	// Bit KRM1.
	KINT_KRM_KRM1 = 0x2
	// Does not detect key interrupt signal
	KINT_KRM_KRM1_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM1_1 = 0x1
	// Position of KRM0 field.
	KINT_KRM_KRM0_Pos = 0x0
	// Bit mask of KRM0 field.
	KINT_KRM_KRM0_Msk = 0x1
	// Bit KRM0.
	KINT_KRM_KRM0 = 0x1
	// Does not detect key interrupt signal
	KINT_KRM_KRM0_0 = 0x0
	// Detect key interrupt signal.
	KINT_KRM_KRM0_1 = 0x1
)

// Constants for USBFS: USB 2.0 FS Module
const (
	// SYSCFG: System Configuration Control Register
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0xf800
	// Position of SCKE field.
	USBFS_SYSCFG_SCKE_Pos = 0xa
	// Bit mask of SCKE field.
	USBFS_SYSCFG_SCKE_Msk = 0x400
	// Bit SCKE.
	USBFS_SYSCFG_SCKE = 0x400
	// Stops supplying the clock signal to the USB.
	USBFS_SYSCFG_SCKE_0 = 0x0
	// Enables supplying the clock signal to the USB.
	USBFS_SYSCFG_SCKE_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_SYSCFG_Reserved = 0x200
	// Position of CNEN field.
	USBFS_SYSCFG_CNEN_Pos = 0x8
	// Bit mask of CNEN field.
	USBFS_SYSCFG_CNEN_Msk = 0x100
	// Bit CNEN.
	USBFS_SYSCFG_CNEN = 0x100
	// Single end receiver operation is disabled.
	USBFS_SYSCFG_CNEN_0 = 0x0
	// Single end receiver operation is enabled.
	USBFS_SYSCFG_CNEN_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0xe0
	// Position of DPRPU field.
	USBFS_SYSCFG_DPRPU_Pos = 0x4
	// Bit mask of DPRPU field.
	USBFS_SYSCFG_DPRPU_Msk = 0x10
	// Bit DPRPU.
	USBFS_SYSCFG_DPRPU = 0x10
	// Pulling up the line is disabled.
	USBFS_SYSCFG_DPRPU_0 = 0x0
	// Pulling up the line is enabled.
	USBFS_SYSCFG_DPRPU_1 = 0x1
	// Position of DMRPU field.
	USBFS_SYSCFG_DMRPU_Pos = 0x3
	// Bit mask of DMRPU field.
	USBFS_SYSCFG_DMRPU_Msk = 0x8
	// Bit DMRPU.
	USBFS_SYSCFG_DMRPU = 0x8
	// Pulling up the line is disabled.
	USBFS_SYSCFG_DMRPU_0 = 0x0
	// Pulling up the line is enabled.
	USBFS_SYSCFG_DMRPU_1 = 0x1
	// Position of Reserved field.
	USBFS_SYSCFG_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_SYSCFG_Reserved_Msk = 0x6
	// Position of USBE field.
	USBFS_SYSCFG_USBE_Pos = 0x0
	// Bit mask of USBE field.
	USBFS_SYSCFG_USBE_Msk = 0x1
	// Bit USBE.
	USBFS_SYSCFG_USBE = 0x1
	// USB operation is disabled.
	USBFS_SYSCFG_USBE_0 = 0x0
	// USB operation is enabled.
	USBFS_SYSCFG_USBE_1 = 0x1

	// SYSSTS0: System Configuration Status Register 0
	// Position of Reserved field.
	USBFS_SYSSTS0_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_SYSSTS0_Reserved_Msk = 0xfffc
	// Position of LNST field.
	USBFS_SYSSTS0_LNST_Pos = 0x0
	// Bit mask of LNST field.
	USBFS_SYSSTS0_LNST_Msk = 0x3
	// SE0
	USBFS_SYSSTS0_LNST_00 = 0x0
	// J-State
	USBFS_SYSSTS0_LNST_01 = 0x1
	// K-State
	USBFS_SYSSTS0_LNST_10 = 0x2
	// SE1
	USBFS_SYSSTS0_LNST_11 = 0x3

	// DVSTCTR0: Device State Control Register 0
	// Position of Reserved field.
	USBFS_DVSTCTR0_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_DVSTCTR0_Reserved_Msk = 0xfe00
	// Position of WKUP field.
	USBFS_DVSTCTR0_WKUP_Pos = 0x8
	// Bit mask of WKUP field.
	USBFS_DVSTCTR0_WKUP_Msk = 0x100
	// Bit WKUP.
	USBFS_DVSTCTR0_WKUP = 0x100
	// Remote wakeup signal is not output.
	USBFS_DVSTCTR0_WKUP_0 = 0x0
	// Remote wakeup signal is output.
	USBFS_DVSTCTR0_WKUP_1 = 0x1
	// Position of Reserved field.
	USBFS_DVSTCTR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_DVSTCTR0_Reserved_Msk = 0xf8
	// Position of RHST field.
	USBFS_DVSTCTR0_RHST_Pos = 0x0
	// Bit mask of RHST field.
	USBFS_DVSTCTR0_RHST_Msk = 0x7
	// Communication speed not determined
	USBFS_DVSTCTR0_RHST_000 = 0x0
	// USB bus reset in progress or low-speed connection
	USBFS_DVSTCTR0_RHST_001 = 0x1
	// USB bus reset in progress or full-speed connection
	USBFS_DVSTCTR0_RHST_010 = 0x2

	// CFIFO: CFIFO Port Register
	// Position of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Pos = 0x0
	// Bit mask of FIFOPORT field.
	USBFS_CFIFO_FIFOPORT_Msk = 0xffff

	// CFIFOSEL: CFIFO Port Select Register
	// Position of RCNT field.
	USBFS_CFIFOSEL_RCNT_Pos = 0xf
	// Bit mask of RCNT field.
	USBFS_CFIFOSEL_RCNT_Msk = 0x8000
	// Bit RCNT.
	USBFS_CFIFOSEL_RCNT = 0x8000
	// The DTLN[8:0] bits (CFIFOCRT.DTLN[8:0], D0FIFOCRT.DTLN[8:0], D1FIFOCRT.DTLN[8:0]) are cleared when all of the receive data has been read from the CFIFO.(In double buffer mode, the DTLN[8:0] bit value is cleared when all the data has been read from only a single plane.)
	USBFS_CFIFOSEL_RCNT_0 = 0x0
	// The DTLN[8:0] bits are decremented each time the receive data is read from the CFIFO.
	USBFS_CFIFOSEL_RCNT_1 = 0x1
	// Position of REW field.
	USBFS_CFIFOSEL_REW_Pos = 0xe
	// Bit mask of REW field.
	USBFS_CFIFOSEL_REW_Msk = 0x4000
	// Bit REW.
	USBFS_CFIFOSEL_REW = 0x4000
	// The buffer pointer is not rewound.
	USBFS_CFIFOSEL_REW_0 = 0x0
	// The buffer pointer is rewound.
	USBFS_CFIFOSEL_REW_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x3800
	// Position of MBW field.
	USBFS_CFIFOSEL_MBW_Pos = 0xa
	// Bit mask of MBW field.
	USBFS_CFIFOSEL_MBW_Msk = 0x400
	// Bit MBW.
	USBFS_CFIFOSEL_MBW = 0x400
	// 8-bit width
	USBFS_CFIFOSEL_MBW_0 = 0x0
	// 16-bit width
	USBFS_CFIFOSEL_MBW_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x200
	// Bit Reserved.
	USBFS_CFIFOSEL_Reserved = 0x200
	// Position of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Pos = 0x8
	// Bit mask of BIGEND field.
	USBFS_CFIFOSEL_BIGEND_Msk = 0x100
	// Bit BIGEND.
	USBFS_CFIFOSEL_BIGEND = 0x100
	// Little endian
	USBFS_CFIFOSEL_BIGEND_0 = 0x0
	// Big endian
	USBFS_CFIFOSEL_BIGEND_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0xc0
	// Position of ISEL field.
	USBFS_CFIFOSEL_ISEL_Pos = 0x5
	// Bit mask of ISEL field.
	USBFS_CFIFOSEL_ISEL_Msk = 0x20
	// Bit ISEL.
	USBFS_CFIFOSEL_ISEL = 0x20
	// Reading from the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_0 = 0x0
	// Writing to the buffer memory is selected
	USBFS_CFIFOSEL_ISEL_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOSEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_CFIFOSEL_Reserved_Msk = 0x10
	// Bit Reserved.
	USBFS_CFIFOSEL_Reserved = 0x10
	// Position of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Pos = 0x0
	// Bit mask of CURPIPE field.
	USBFS_CFIFOSEL_CURPIPE_Msk = 0xf
	// DCP(Defaultcontrolpipe)
	USBFS_CFIFOSEL_CURPIPE_0000 = 0x0
	// Pipe1
	USBFS_CFIFOSEL_CURPIPE_0001 = 0x1
	// Pipe2
	USBFS_CFIFOSEL_CURPIPE_0010 = 0x2
	// Pipe3
	USBFS_CFIFOSEL_CURPIPE_0011 = 0x3
	// Pipe4
	USBFS_CFIFOSEL_CURPIPE_0100 = 0x4
	// Pipe5
	USBFS_CFIFOSEL_CURPIPE_0101 = 0x5
	// Pipe6
	USBFS_CFIFOSEL_CURPIPE_0110 = 0x6
	// Pipe7
	USBFS_CFIFOSEL_CURPIPE_0111 = 0x7
	// Pipe8
	USBFS_CFIFOSEL_CURPIPE_1000 = 0x8
	// Pipe9
	USBFS_CFIFOSEL_CURPIPE_1001 = 0x9

	// CFIFOCTR: CFIFO Port Control Register
	// Position of BVAL field.
	USBFS_CFIFOCTR_BVAL_Pos = 0xf
	// Bit mask of BVAL field.
	USBFS_CFIFOCTR_BVAL_Msk = 0x8000
	// Bit BVAL.
	USBFS_CFIFOCTR_BVAL = 0x8000
	// Invalid
	USBFS_CFIFOCTR_BVAL_0 = 0x0
	// Writing ended
	USBFS_CFIFOCTR_BVAL_1 = 0x1
	// Position of BCLR field.
	USBFS_CFIFOCTR_BCLR_Pos = 0xe
	// Bit mask of BCLR field.
	USBFS_CFIFOCTR_BCLR_Msk = 0x4000
	// Bit BCLR.
	USBFS_CFIFOCTR_BCLR = 0x4000
	// Invalid
	USBFS_CFIFOCTR_BCLR_0 = 0x0
	// Clears the buffer memory on the CPU side
	USBFS_CFIFOCTR_BCLR_1 = 0x1
	// Position of FRDY field.
	USBFS_CFIFOCTR_FRDY_Pos = 0xd
	// Bit mask of FRDY field.
	USBFS_CFIFOCTR_FRDY_Msk = 0x2000
	// Bit FRDY.
	USBFS_CFIFOCTR_FRDY = 0x2000
	// FIFO port access is disabled.
	USBFS_CFIFOCTR_FRDY_0 = 0x0
	// FIFO port access is enabled.
	USBFS_CFIFOCTR_FRDY_1 = 0x1
	// Position of Reserved field.
	USBFS_CFIFOCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_CFIFOCTR_Reserved_Msk = 0x1e00
	// Position of DTLN field.
	USBFS_CFIFOCTR_DTLN_Pos = 0x0
	// Bit mask of DTLN field.
	USBFS_CFIFOCTR_DTLN_Msk = 0x1ff

	// INTENB0: Interrupt Enable Register 0
	// Position of VBSE field.
	USBFS_INTENB0_VBSE_Pos = 0xf
	// Bit mask of VBSE field.
	USBFS_INTENB0_VBSE_Msk = 0x8000
	// Bit VBSE.
	USBFS_INTENB0_VBSE = 0x8000
	// Interrupt output disabled
	USBFS_INTENB0_VBSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_VBSE_1 = 0x1
	// Position of RSME field.
	USBFS_INTENB0_RSME_Pos = 0xe
	// Bit mask of RSME field.
	USBFS_INTENB0_RSME_Msk = 0x4000
	// Bit RSME.
	USBFS_INTENB0_RSME = 0x4000
	// Interrupt output disabled
	USBFS_INTENB0_RSME_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_RSME_1 = 0x1
	// Position of SOFE field.
	USBFS_INTENB0_SOFE_Pos = 0xd
	// Bit mask of SOFE field.
	USBFS_INTENB0_SOFE_Msk = 0x2000
	// Bit SOFE.
	USBFS_INTENB0_SOFE = 0x2000
	// Interrupt output disabled
	USBFS_INTENB0_SOFE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_SOFE_1 = 0x1
	// Position of DVSE field.
	USBFS_INTENB0_DVSE_Pos = 0xc
	// Bit mask of DVSE field.
	USBFS_INTENB0_DVSE_Msk = 0x1000
	// Bit DVSE.
	USBFS_INTENB0_DVSE = 0x1000
	// Interrupt output disabled
	USBFS_INTENB0_DVSE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_DVSE_1 = 0x1
	// Position of CTRE field.
	USBFS_INTENB0_CTRE_Pos = 0xb
	// Bit mask of CTRE field.
	USBFS_INTENB0_CTRE_Msk = 0x800
	// Bit CTRE.
	USBFS_INTENB0_CTRE = 0x800
	// Interrupt output disabled
	USBFS_INTENB0_CTRE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_CTRE_1 = 0x1
	// Position of BEMPE field.
	USBFS_INTENB0_BEMPE_Pos = 0xa
	// Bit mask of BEMPE field.
	USBFS_INTENB0_BEMPE_Msk = 0x400
	// Bit BEMPE.
	USBFS_INTENB0_BEMPE = 0x400
	// Interrupt output disabled
	USBFS_INTENB0_BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BEMPE_1 = 0x1
	// Position of NRDYE field.
	USBFS_INTENB0_NRDYE_Pos = 0x9
	// Bit mask of NRDYE field.
	USBFS_INTENB0_NRDYE_Msk = 0x200
	// Bit NRDYE.
	USBFS_INTENB0_NRDYE = 0x200
	// Interrupt output disabled
	USBFS_INTENB0_NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_NRDYE_1 = 0x1
	// Position of BRDYE field.
	USBFS_INTENB0_BRDYE_Pos = 0x8
	// Bit mask of BRDYE field.
	USBFS_INTENB0_BRDYE_Msk = 0x100
	// Bit BRDYE.
	USBFS_INTENB0_BRDYE = 0x100
	// Interrupt output disabled
	USBFS_INTENB0_BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_INTENB0_BRDYE_1 = 0x1
	// Position of Reserved field.
	USBFS_INTENB0_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_INTENB0_Reserved_Msk = 0xff

	// BRDYENB: BRDY Interrupt Enable Register
	// Position of Reserved field.
	USBFS_BRDYENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BRDYENB_Reserved_Msk = 0xfc00
	// Position of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Pos = 0x9
	// Bit mask of PIPE9BRDYE field.
	USBFS_BRDYENB_PIPE9BRDYE_Msk = 0x200
	// Bit PIPE9BRDYE.
	USBFS_BRDYENB_PIPE9BRDYE = 0x200
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE9BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE9BRDYE_1 = 0x1
	// Position of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Pos = 0x8
	// Bit mask of PIPE8BRDYE field.
	USBFS_BRDYENB_PIPE8BRDYE_Msk = 0x100
	// Bit PIPE8BRDYE.
	USBFS_BRDYENB_PIPE8BRDYE = 0x100
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE8BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE8BRDYE_1 = 0x1
	// Position of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Pos = 0x7
	// Bit mask of PIPE7BRDYE field.
	USBFS_BRDYENB_PIPE7BRDYE_Msk = 0x80
	// Bit PIPE7BRDYE.
	USBFS_BRDYENB_PIPE7BRDYE = 0x80
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE7BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE7BRDYE_1 = 0x1
	// Position of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Pos = 0x6
	// Bit mask of PIPE6BRDYE field.
	USBFS_BRDYENB_PIPE6BRDYE_Msk = 0x40
	// Bit PIPE6BRDYE.
	USBFS_BRDYENB_PIPE6BRDYE = 0x40
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE6BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE6BRDYE_1 = 0x1
	// Position of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Pos = 0x5
	// Bit mask of PIPE5BRDYE field.
	USBFS_BRDYENB_PIPE5BRDYE_Msk = 0x20
	// Bit PIPE5BRDYE.
	USBFS_BRDYENB_PIPE5BRDYE = 0x20
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE5BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE5BRDYE_1 = 0x1
	// Position of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Pos = 0x4
	// Bit mask of PIPE4BRDYE field.
	USBFS_BRDYENB_PIPE4BRDYE_Msk = 0x10
	// Bit PIPE4BRDYE.
	USBFS_BRDYENB_PIPE4BRDYE = 0x10
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE4BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE4BRDYE_1 = 0x1
	// Position of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Pos = 0x3
	// Bit mask of PIPE3BRDYE field.
	USBFS_BRDYENB_PIPE3BRDYE_Msk = 0x8
	// Bit PIPE3BRDYE.
	USBFS_BRDYENB_PIPE3BRDYE = 0x8
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE3BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE3BRDYE_1 = 0x1
	// Position of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Pos = 0x2
	// Bit mask of PIPE2BRDYE field.
	USBFS_BRDYENB_PIPE2BRDYE_Msk = 0x4
	// Bit PIPE2BRDYE.
	USBFS_BRDYENB_PIPE2BRDYE = 0x4
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE2BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE2BRDYE_1 = 0x1
	// Position of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Pos = 0x1
	// Bit mask of PIPE1BRDYE field.
	USBFS_BRDYENB_PIPE1BRDYE_Msk = 0x2
	// Bit PIPE1BRDYE.
	USBFS_BRDYENB_PIPE1BRDYE = 0x2
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE1BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE1BRDYE_1 = 0x1
	// Position of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Pos = 0x0
	// Bit mask of PIPE0BRDYE field.
	USBFS_BRDYENB_PIPE0BRDYE_Msk = 0x1
	// Bit PIPE0BRDYE.
	USBFS_BRDYENB_PIPE0BRDYE = 0x1
	// Interrupt output disabled
	USBFS_BRDYENB_PIPE0BRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_BRDYENB_PIPE0BRDYE_1 = 0x1

	// NRDYENB: NRDY Interrupt Enable Register
	// Position of Reserved field.
	USBFS_NRDYENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_NRDYENB_Reserved_Msk = 0xfc00
	// Position of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Pos = 0x9
	// Bit mask of PIPE9NRDYE field.
	USBFS_NRDYENB_PIPE9NRDYE_Msk = 0x200
	// Bit PIPE9NRDYE.
	USBFS_NRDYENB_PIPE9NRDYE = 0x200
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE9NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE9NRDYE_1 = 0x1
	// Position of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Pos = 0x8
	// Bit mask of PIPE8NRDYE field.
	USBFS_NRDYENB_PIPE8NRDYE_Msk = 0x100
	// Bit PIPE8NRDYE.
	USBFS_NRDYENB_PIPE8NRDYE = 0x100
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE8NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE8NRDYE_1 = 0x1
	// Position of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Pos = 0x7
	// Bit mask of PIPE7NRDYE field.
	USBFS_NRDYENB_PIPE7NRDYE_Msk = 0x80
	// Bit PIPE7NRDYE.
	USBFS_NRDYENB_PIPE7NRDYE = 0x80
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE7NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE7NRDYE_1 = 0x1
	// Position of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Pos = 0x6
	// Bit mask of PIPE6NRDYE field.
	USBFS_NRDYENB_PIPE6NRDYE_Msk = 0x40
	// Bit PIPE6NRDYE.
	USBFS_NRDYENB_PIPE6NRDYE = 0x40
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE6NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE6NRDYE_1 = 0x1
	// Position of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Pos = 0x5
	// Bit mask of PIPE5NRDYE field.
	USBFS_NRDYENB_PIPE5NRDYE_Msk = 0x20
	// Bit PIPE5NRDYE.
	USBFS_NRDYENB_PIPE5NRDYE = 0x20
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE5NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE5NRDYE_1 = 0x1
	// Position of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Pos = 0x4
	// Bit mask of PIPE4NRDYE field.
	USBFS_NRDYENB_PIPE4NRDYE_Msk = 0x10
	// Bit PIPE4NRDYE.
	USBFS_NRDYENB_PIPE4NRDYE = 0x10
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE4NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE4NRDYE_1 = 0x1
	// Position of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Pos = 0x3
	// Bit mask of PIPE3NRDYE field.
	USBFS_NRDYENB_PIPE3NRDYE_Msk = 0x8
	// Bit PIPE3NRDYE.
	USBFS_NRDYENB_PIPE3NRDYE = 0x8
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE3NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE3NRDYE_1 = 0x1
	// Position of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Pos = 0x2
	// Bit mask of PIPE2NRDYE field.
	USBFS_NRDYENB_PIPE2NRDYE_Msk = 0x4
	// Bit PIPE2NRDYE.
	USBFS_NRDYENB_PIPE2NRDYE = 0x4
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE2NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE2NRDYE_1 = 0x1
	// Position of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Pos = 0x1
	// Bit mask of PIPE1NRDYE field.
	USBFS_NRDYENB_PIPE1NRDYE_Msk = 0x2
	// Bit PIPE1NRDYE.
	USBFS_NRDYENB_PIPE1NRDYE = 0x2
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE1NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE1NRDYE_1 = 0x1
	// Position of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Pos = 0x0
	// Bit mask of PIPE0NRDYE field.
	USBFS_NRDYENB_PIPE0NRDYE_Msk = 0x1
	// Bit PIPE0NRDYE.
	USBFS_NRDYENB_PIPE0NRDYE = 0x1
	// Interrupt output disabled
	USBFS_NRDYENB_PIPE0NRDYE_0 = 0x0
	// Interrupt output enabled
	USBFS_NRDYENB_PIPE0NRDYE_1 = 0x1

	// BEMPENB: BEMP Interrupt Enable Register
	// Position of Reserved field.
	USBFS_BEMPENB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BEMPENB_Reserved_Msk = 0xfc00
	// Position of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Pos = 0x9
	// Bit mask of PIPE9BEMPE field.
	USBFS_BEMPENB_PIPE9BEMPE_Msk = 0x200
	// Bit PIPE9BEMPE.
	USBFS_BEMPENB_PIPE9BEMPE = 0x200
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE9BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE9BEMPE_1 = 0x1
	// Position of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Pos = 0x8
	// Bit mask of PIPE8BEMPE field.
	USBFS_BEMPENB_PIPE8BEMPE_Msk = 0x100
	// Bit PIPE8BEMPE.
	USBFS_BEMPENB_PIPE8BEMPE = 0x100
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE8BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE8BEMPE_1 = 0x1
	// Position of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Pos = 0x7
	// Bit mask of PIPE7BEMPE field.
	USBFS_BEMPENB_PIPE7BEMPE_Msk = 0x80
	// Bit PIPE7BEMPE.
	USBFS_BEMPENB_PIPE7BEMPE = 0x80
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE7BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE7BEMPE_1 = 0x1
	// Position of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Pos = 0x6
	// Bit mask of PIPE6BEMPE field.
	USBFS_BEMPENB_PIPE6BEMPE_Msk = 0x40
	// Bit PIPE6BEMPE.
	USBFS_BEMPENB_PIPE6BEMPE = 0x40
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE6BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE6BEMPE_1 = 0x1
	// Position of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Pos = 0x5
	// Bit mask of PIPE5BEMPE field.
	USBFS_BEMPENB_PIPE5BEMPE_Msk = 0x20
	// Bit PIPE5BEMPE.
	USBFS_BEMPENB_PIPE5BEMPE = 0x20
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE5BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE5BEMPE_1 = 0x1
	// Position of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Pos = 0x4
	// Bit mask of PIPE4BEMPE field.
	USBFS_BEMPENB_PIPE4BEMPE_Msk = 0x10
	// Bit PIPE4BEMPE.
	USBFS_BEMPENB_PIPE4BEMPE = 0x10
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE4BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE4BEMPE_1 = 0x1
	// Position of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Pos = 0x3
	// Bit mask of PIPE3BEMPE field.
	USBFS_BEMPENB_PIPE3BEMPE_Msk = 0x8
	// Bit PIPE3BEMPE.
	USBFS_BEMPENB_PIPE3BEMPE = 0x8
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE3BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE3BEMPE_1 = 0x1
	// Position of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Pos = 0x2
	// Bit mask of PIPE2BEMPE field.
	USBFS_BEMPENB_PIPE2BEMPE_Msk = 0x4
	// Bit PIPE2BEMPE.
	USBFS_BEMPENB_PIPE2BEMPE = 0x4
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE2BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE2BEMPE_1 = 0x1
	// Position of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Pos = 0x1
	// Bit mask of PIPE1BEMPE field.
	USBFS_BEMPENB_PIPE1BEMPE_Msk = 0x2
	// Bit PIPE1BEMPE.
	USBFS_BEMPENB_PIPE1BEMPE = 0x2
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE1BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE1BEMPE_1 = 0x1
	// Position of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Pos = 0x0
	// Bit mask of PIPE0BEMPE field.
	USBFS_BEMPENB_PIPE0BEMPE_Msk = 0x1
	// Bit PIPE0BEMPE.
	USBFS_BEMPENB_PIPE0BEMPE = 0x1
	// Interrupt output disabled
	USBFS_BEMPENB_PIPE0BEMPE_0 = 0x0
	// Interrupt output enabled
	USBFS_BEMPENB_PIPE0BEMPE_1 = 0x1

	// SOFCFG: SOF Output Configuration Register
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0xfe00
	// Position of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Pos = 0x8
	// Bit mask of TRNENSEL field.
	USBFS_SOFCFG_TRNENSEL_Msk = 0x100
	// Bit TRNENSEL.
	USBFS_SOFCFG_TRNENSEL = 0x100
	// For non-low-speed communication
	USBFS_SOFCFG_TRNENSEL_0 = 0x0
	// For low-speed communication
	USBFS_SOFCFG_TRNENSEL_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0x80
	// Bit Reserved.
	USBFS_SOFCFG_Reserved = 0x80
	// Position of BRDYM field.
	USBFS_SOFCFG_BRDYM_Pos = 0x6
	// Bit mask of BRDYM field.
	USBFS_SOFCFG_BRDYM_Msk = 0x40
	// Bit BRDYM.
	USBFS_SOFCFG_BRDYM = 0x40
	// Software clears the status.
	USBFS_SOFCFG_BRDYM_0 = 0x0
	// The USB clears the status when data has been read from the FIFO buffer or data has been written to the FIFO buffer.
	USBFS_SOFCFG_BRDYM_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0x20
	// Bit Reserved.
	USBFS_SOFCFG_Reserved = 0x20
	// Position of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Pos = 0x4
	// Bit mask of EDGESTS field.
	USBFS_SOFCFG_EDGESTS_Msk = 0x10
	// Bit EDGESTS.
	USBFS_SOFCFG_EDGESTS = 0x10
	// before stopping the clock supply to the USB module
	USBFS_SOFCFG_EDGESTS_0 = 0x0
	// the edge interrupt output signal is in the middle of the edge processing
	USBFS_SOFCFG_EDGESTS_1 = 0x1
	// Position of Reserved field.
	USBFS_SOFCFG_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_SOFCFG_Reserved_Msk = 0xf

	// INTSTS0: Interrupt Status Register 0
	// Position of VBINT field.
	USBFS_INTSTS0_VBINT_Pos = 0xf
	// Bit mask of VBINT field.
	USBFS_INTSTS0_VBINT_Msk = 0x8000
	// Bit VBINT.
	USBFS_INTSTS0_VBINT = 0x8000
	// VBUS interrupts are not generated.
	USBFS_INTSTS0_VBINT_0 = 0x0
	// VBUS interrupts are generated.
	USBFS_INTSTS0_VBINT_1 = 0x1
	// Position of RESM field.
	USBFS_INTSTS0_RESM_Pos = 0xe
	// Bit mask of RESM field.
	USBFS_INTSTS0_RESM_Msk = 0x4000
	// Bit RESM.
	USBFS_INTSTS0_RESM = 0x4000
	// Resume interrupts are not generated.
	USBFS_INTSTS0_RESM_0 = 0x0
	// Resume interrupts are generated.
	USBFS_INTSTS0_RESM_1 = 0x1
	// Position of SOFR field.
	USBFS_INTSTS0_SOFR_Pos = 0xd
	// Bit mask of SOFR field.
	USBFS_INTSTS0_SOFR_Msk = 0x2000
	// Bit SOFR.
	USBFS_INTSTS0_SOFR = 0x2000
	// SOF interrupts are not generated.
	USBFS_INTSTS0_SOFR_0 = 0x0
	// SOF interrupts are generated.
	USBFS_INTSTS0_SOFR_1 = 0x1
	// Position of DVST field.
	USBFS_INTSTS0_DVST_Pos = 0xc
	// Bit mask of DVST field.
	USBFS_INTSTS0_DVST_Msk = 0x1000
	// Bit DVST.
	USBFS_INTSTS0_DVST = 0x1000
	// Device state transition interrupts are not generated.
	USBFS_INTSTS0_DVST_0 = 0x0
	// Device state transition interrupts are generated.
	USBFS_INTSTS0_DVST_1 = 0x1
	// Position of CTRT field.
	USBFS_INTSTS0_CTRT_Pos = 0xb
	// Bit mask of CTRT field.
	USBFS_INTSTS0_CTRT_Msk = 0x800
	// Bit CTRT.
	USBFS_INTSTS0_CTRT = 0x800
	// Control transfer stage transition interrupts are not generated.
	USBFS_INTSTS0_CTRT_0 = 0x0
	// Control transfer stage transition interrupts are generated.
	USBFS_INTSTS0_CTRT_1 = 0x1
	// Position of BEMP field.
	USBFS_INTSTS0_BEMP_Pos = 0xa
	// Bit mask of BEMP field.
	USBFS_INTSTS0_BEMP_Msk = 0x400
	// Bit BEMP.
	USBFS_INTSTS0_BEMP = 0x400
	// BEMP interrupts are not generated.
	USBFS_INTSTS0_BEMP_0 = 0x0
	// BEMP interrupts are generated.
	USBFS_INTSTS0_BEMP_1 = 0x1
	// Position of NRDY field.
	USBFS_INTSTS0_NRDY_Pos = 0x9
	// Bit mask of NRDY field.
	USBFS_INTSTS0_NRDY_Msk = 0x200
	// Bit NRDY.
	USBFS_INTSTS0_NRDY = 0x200
	// NRDY interrupts are not generated.
	USBFS_INTSTS0_NRDY_0 = 0x0
	// NRDY interrupts are generated.
	USBFS_INTSTS0_NRDY_1 = 0x1
	// Position of BRDY field.
	USBFS_INTSTS0_BRDY_Pos = 0x8
	// Bit mask of BRDY field.
	USBFS_INTSTS0_BRDY_Msk = 0x100
	// Bit BRDY.
	USBFS_INTSTS0_BRDY = 0x100
	// BRDY interrupts are not generated.
	USBFS_INTSTS0_BRDY_0 = 0x0
	// BRDY interrupts are generated.
	USBFS_INTSTS0_BRDY_1 = 0x1
	// Position of VBSTS field.
	USBFS_INTSTS0_VBSTS_Pos = 0x7
	// Bit mask of VBSTS field.
	USBFS_INTSTS0_VBSTS_Msk = 0x80
	// Bit VBSTS.
	USBFS_INTSTS0_VBSTS = 0x80
	// USB0_VBUS pin is low.
	USBFS_INTSTS0_VBSTS_0 = 0x0
	// USB0_VBUS pin is high.
	USBFS_INTSTS0_VBSTS_1 = 0x1
	// Position of DVSQ field.
	USBFS_INTSTS0_DVSQ_Pos = 0x4
	// Bit mask of DVSQ field.
	USBFS_INTSTS0_DVSQ_Msk = 0x70
	// Powered state
	USBFS_INTSTS0_DVSQ_000 = 0x0
	// Default state
	USBFS_INTSTS0_DVSQ_001 = 0x1
	// Address state
	USBFS_INTSTS0_DVSQ_010 = 0x2
	// Configured state
	USBFS_INTSTS0_DVSQ_011 = 0x3
	// Position of VALID field.
	USBFS_INTSTS0_VALID_Pos = 0x3
	// Bit mask of VALID field.
	USBFS_INTSTS0_VALID_Msk = 0x8
	// Bit VALID.
	USBFS_INTSTS0_VALID = 0x8
	// Setup packet is not received
	USBFS_INTSTS0_VALID_0 = 0x0
	// Setup packet is received
	USBFS_INTSTS0_VALID_1 = 0x1
	// Position of CTSQ field.
	USBFS_INTSTS0_CTSQ_Pos = 0x0
	// Bit mask of CTSQ field.
	USBFS_INTSTS0_CTSQ_Msk = 0x7
	// Idle or setup stage
	USBFS_INTSTS0_CTSQ_000 = 0x0
	// Control read data stage
	USBFS_INTSTS0_CTSQ_001 = 0x1
	// Control read status stage
	USBFS_INTSTS0_CTSQ_010 = 0x2
	// Control write data stage
	USBFS_INTSTS0_CTSQ_011 = 0x3
	// Control write status stage
	USBFS_INTSTS0_CTSQ_100 = 0x4
	// Control write(nodata) status stage
	USBFS_INTSTS0_CTSQ_101 = 0x5
	// Control transfer sequence error
	USBFS_INTSTS0_CTSQ_110 = 0x6

	// BRDYSTS: BRDY Interrupt Status Register
	// Position of Reserved field.
	USBFS_BRDYSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BRDYSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Pos = 0x9
	// Bit mask of PIPE9BRDY field.
	USBFS_BRDYSTS_PIPE9BRDY_Msk = 0x200
	// Bit PIPE9BRDY.
	USBFS_BRDYSTS_PIPE9BRDY = 0x200
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE9BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE9BRDY_1 = 0x1
	// Position of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Pos = 0x8
	// Bit mask of PIPE8BRDY field.
	USBFS_BRDYSTS_PIPE8BRDY_Msk = 0x100
	// Bit PIPE8BRDY.
	USBFS_BRDYSTS_PIPE8BRDY = 0x100
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE8BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE8BRDY_1 = 0x1
	// Position of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Pos = 0x7
	// Bit mask of PIPE7BRDY field.
	USBFS_BRDYSTS_PIPE7BRDY_Msk = 0x80
	// Bit PIPE7BRDY.
	USBFS_BRDYSTS_PIPE7BRDY = 0x80
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE7BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE7BRDY_1 = 0x1
	// Position of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Pos = 0x6
	// Bit mask of PIPE6BRDY field.
	USBFS_BRDYSTS_PIPE6BRDY_Msk = 0x40
	// Bit PIPE6BRDY.
	USBFS_BRDYSTS_PIPE6BRDY = 0x40
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE6BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE6BRDY_1 = 0x1
	// Position of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Pos = 0x5
	// Bit mask of PIPE5BRDY field.
	USBFS_BRDYSTS_PIPE5BRDY_Msk = 0x20
	// Bit PIPE5BRDY.
	USBFS_BRDYSTS_PIPE5BRDY = 0x20
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE5BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE5BRDY_1 = 0x1
	// Position of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Pos = 0x4
	// Bit mask of PIPE4BRDY field.
	USBFS_BRDYSTS_PIPE4BRDY_Msk = 0x10
	// Bit PIPE4BRDY.
	USBFS_BRDYSTS_PIPE4BRDY = 0x10
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE4BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE4BRDY_1 = 0x1
	// Position of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Pos = 0x3
	// Bit mask of PIPE3BRDY field.
	USBFS_BRDYSTS_PIPE3BRDY_Msk = 0x8
	// Bit PIPE3BRDY.
	USBFS_BRDYSTS_PIPE3BRDY = 0x8
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE3BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE3BRDY_1 = 0x1
	// Position of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Pos = 0x2
	// Bit mask of PIPE2BRDY field.
	USBFS_BRDYSTS_PIPE2BRDY_Msk = 0x4
	// Bit PIPE2BRDY.
	USBFS_BRDYSTS_PIPE2BRDY = 0x4
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE2BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE2BRDY_1 = 0x1
	// Position of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Pos = 0x1
	// Bit mask of PIPE1BRDY field.
	USBFS_BRDYSTS_PIPE1BRDY_Msk = 0x2
	// Bit PIPE1BRDY.
	USBFS_BRDYSTS_PIPE1BRDY = 0x2
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE1BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE1BRDY_1 = 0x1
	// Position of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Pos = 0x0
	// Bit mask of PIPE0BRDY field.
	USBFS_BRDYSTS_PIPE0BRDY_Msk = 0x1
	// Bit PIPE0BRDY.
	USBFS_BRDYSTS_PIPE0BRDY = 0x1
	// Interrupts are not generated.
	USBFS_BRDYSTS_PIPE0BRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_BRDYSTS_PIPE0BRDY_1 = 0x1

	// NRDYSTS: NRDY Interrupt Status Register
	// Position of Reserved field.
	USBFS_NRDYSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_NRDYSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Pos = 0x9
	// Bit mask of PIPE9NRDY field.
	USBFS_NRDYSTS_PIPE9NRDY_Msk = 0x200
	// Bit PIPE9NRDY.
	USBFS_NRDYSTS_PIPE9NRDY = 0x200
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE9NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE9NRDY_1 = 0x1
	// Position of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Pos = 0x8
	// Bit mask of PIPE8NRDY field.
	USBFS_NRDYSTS_PIPE8NRDY_Msk = 0x100
	// Bit PIPE8NRDY.
	USBFS_NRDYSTS_PIPE8NRDY = 0x100
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE8NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE8NRDY_1 = 0x1
	// Position of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Pos = 0x7
	// Bit mask of PIPE7NRDY field.
	USBFS_NRDYSTS_PIPE7NRDY_Msk = 0x80
	// Bit PIPE7NRDY.
	USBFS_NRDYSTS_PIPE7NRDY = 0x80
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE7NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE7NRDY_1 = 0x1
	// Position of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Pos = 0x6
	// Bit mask of PIPE6NRDY field.
	USBFS_NRDYSTS_PIPE6NRDY_Msk = 0x40
	// Bit PIPE6NRDY.
	USBFS_NRDYSTS_PIPE6NRDY = 0x40
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE6NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE6NRDY_1 = 0x1
	// Position of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Pos = 0x5
	// Bit mask of PIPE5NRDY field.
	USBFS_NRDYSTS_PIPE5NRDY_Msk = 0x20
	// Bit PIPE5NRDY.
	USBFS_NRDYSTS_PIPE5NRDY = 0x20
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE5NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE5NRDY_1 = 0x1
	// Position of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Pos = 0x4
	// Bit mask of PIPE4NRDY field.
	USBFS_NRDYSTS_PIPE4NRDY_Msk = 0x10
	// Bit PIPE4NRDY.
	USBFS_NRDYSTS_PIPE4NRDY = 0x10
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE4NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE4NRDY_1 = 0x1
	// Position of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Pos = 0x3
	// Bit mask of PIPE3NRDY field.
	USBFS_NRDYSTS_PIPE3NRDY_Msk = 0x8
	// Bit PIPE3NRDY.
	USBFS_NRDYSTS_PIPE3NRDY = 0x8
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE3NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE3NRDY_1 = 0x1
	// Position of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Pos = 0x2
	// Bit mask of PIPE2NRDY field.
	USBFS_NRDYSTS_PIPE2NRDY_Msk = 0x4
	// Bit PIPE2NRDY.
	USBFS_NRDYSTS_PIPE2NRDY = 0x4
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE2NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE2NRDY_1 = 0x1
	// Position of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Pos = 0x1
	// Bit mask of PIPE1NRDY field.
	USBFS_NRDYSTS_PIPE1NRDY_Msk = 0x2
	// Bit PIPE1NRDY.
	USBFS_NRDYSTS_PIPE1NRDY = 0x2
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE1NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE1NRDY_1 = 0x1
	// Position of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Pos = 0x0
	// Bit mask of PIPE0NRDY field.
	USBFS_NRDYSTS_PIPE0NRDY_Msk = 0x1
	// Bit PIPE0NRDY.
	USBFS_NRDYSTS_PIPE0NRDY = 0x1
	// Interrupts are not generated.
	USBFS_NRDYSTS_PIPE0NRDY_0 = 0x0
	// Interrupts are generated.
	USBFS_NRDYSTS_PIPE0NRDY_1 = 0x1

	// BEMPSTS: BEMP Interrupt Status Register
	// Position of Reserved field.
	USBFS_BEMPSTS_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_BEMPSTS_Reserved_Msk = 0xfc00
	// Position of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Pos = 0x9
	// Bit mask of PIPE9BEMP field.
	USBFS_BEMPSTS_PIPE9BEMP_Msk = 0x200
	// Bit PIPE9BEMP.
	USBFS_BEMPSTS_PIPE9BEMP = 0x200
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE9BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE9BEMP_1 = 0x1
	// Position of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Pos = 0x8
	// Bit mask of PIPE8BEMP field.
	USBFS_BEMPSTS_PIPE8BEMP_Msk = 0x100
	// Bit PIPE8BEMP.
	USBFS_BEMPSTS_PIPE8BEMP = 0x100
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE8BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE8BEMP_1 = 0x1
	// Position of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Pos = 0x7
	// Bit mask of PIPE7BEMP field.
	USBFS_BEMPSTS_PIPE7BEMP_Msk = 0x80
	// Bit PIPE7BEMP.
	USBFS_BEMPSTS_PIPE7BEMP = 0x80
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE7BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE7BEMP_1 = 0x1
	// Position of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Pos = 0x6
	// Bit mask of PIPE6BEMP field.
	USBFS_BEMPSTS_PIPE6BEMP_Msk = 0x40
	// Bit PIPE6BEMP.
	USBFS_BEMPSTS_PIPE6BEMP = 0x40
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE6BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE6BEMP_1 = 0x1
	// Position of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Pos = 0x5
	// Bit mask of PIPE5BEMP field.
	USBFS_BEMPSTS_PIPE5BEMP_Msk = 0x20
	// Bit PIPE5BEMP.
	USBFS_BEMPSTS_PIPE5BEMP = 0x20
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE5BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE5BEMP_1 = 0x1
	// Position of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Pos = 0x4
	// Bit mask of PIPE4BEMP field.
	USBFS_BEMPSTS_PIPE4BEMP_Msk = 0x10
	// Bit PIPE4BEMP.
	USBFS_BEMPSTS_PIPE4BEMP = 0x10
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE4BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE4BEMP_1 = 0x1
	// Position of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Pos = 0x3
	// Bit mask of PIPE3BEMP field.
	USBFS_BEMPSTS_PIPE3BEMP_Msk = 0x8
	// Bit PIPE3BEMP.
	USBFS_BEMPSTS_PIPE3BEMP = 0x8
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE3BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE3BEMP_1 = 0x1
	// Position of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Pos = 0x2
	// Bit mask of PIPE2BEMP field.
	USBFS_BEMPSTS_PIPE2BEMP_Msk = 0x4
	// Bit PIPE2BEMP.
	USBFS_BEMPSTS_PIPE2BEMP = 0x4
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE2BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE2BEMP_1 = 0x1
	// Position of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Pos = 0x1
	// Bit mask of PIPE1BEMP field.
	USBFS_BEMPSTS_PIPE1BEMP_Msk = 0x2
	// Bit PIPE1BEMP.
	USBFS_BEMPSTS_PIPE1BEMP = 0x2
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE1BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE1BEMP_1 = 0x1
	// Position of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Pos = 0x0
	// Bit mask of PIPE0BEMP field.
	USBFS_BEMPSTS_PIPE0BEMP_Msk = 0x1
	// Bit PIPE0BEMP.
	USBFS_BEMPSTS_PIPE0BEMP = 0x1
	// Interrupts are not generated.
	USBFS_BEMPSTS_PIPE0BEMP_0 = 0x0
	// Interrupts are generated.
	USBFS_BEMPSTS_PIPE0BEMP_1 = 0x1

	// FRMNUM: Frame Number Register
	// Position of OVRN field.
	USBFS_FRMNUM_OVRN_Pos = 0xf
	// Bit mask of OVRN field.
	USBFS_FRMNUM_OVRN_Msk = 0x8000
	// Bit OVRN.
	USBFS_FRMNUM_OVRN = 0x8000
	// No error
	USBFS_FRMNUM_OVRN_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_OVRN_1 = 0x1
	// Position of CRCE field.
	USBFS_FRMNUM_CRCE_Pos = 0xe
	// Bit mask of CRCE field.
	USBFS_FRMNUM_CRCE_Msk = 0x4000
	// Bit CRCE.
	USBFS_FRMNUM_CRCE = 0x4000
	// No error
	USBFS_FRMNUM_CRCE_0 = 0x0
	// An error occurred
	USBFS_FRMNUM_CRCE_1 = 0x1
	// Position of Reserved field.
	USBFS_FRMNUM_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_FRMNUM_Reserved_Msk = 0x3800
	// Position of FRNM field.
	USBFS_FRMNUM_FRNM_Pos = 0x0
	// Bit mask of FRNM field.
	USBFS_FRMNUM_FRNM_Msk = 0x7ff

	// USBREQ: USB Request Type Register
	// Position of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Pos = 0x8
	// Bit mask of BREQUEST field.
	USBFS_USBREQ_BREQUEST_Msk = 0xff00
	// Position of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Pos = 0x0
	// Bit mask of BMREQUESTTYPE field.
	USBFS_USBREQ_BMREQUESTTYPE_Msk = 0xff

	// USBVAL: USB Request Value Register
	// Position of WVALUE field.
	USBFS_USBVAL_WVALUE_Pos = 0x0
	// Bit mask of WVALUE field.
	USBFS_USBVAL_WVALUE_Msk = 0xffff

	// USBINDX: USB Request Index Register
	// Position of WINDEX field.
	USBFS_USBINDX_WINDEX_Pos = 0x0
	// Bit mask of WINDEX field.
	USBFS_USBINDX_WINDEX_Msk = 0xffff

	// USBLENG: USB Request Length Register
	// Position of WLENGTUH field.
	USBFS_USBLENG_WLENGTUH_Pos = 0x0
	// Bit mask of WLENGTUH field.
	USBFS_USBLENG_WLENGTUH_Msk = 0xffff

	// DCPCFG: DCP Configuration Register
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0xff00
	// Position of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_DCPCFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_DCPCFG_SHTNAK = 0x80
	// Pipe continued at the end of transfer
	USBFS_DCPCFG_SHTNAK_0 = 0x0
	// Pipe disabled at the end of transfer
	USBFS_DCPCFG_SHTNAK_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0x60
	// Position of DIR field.
	USBFS_DCPCFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_DCPCFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_DCPCFG_DIR = 0x10
	// Data receiving direction
	USBFS_DCPCFG_DIR_0 = 0x0
	// Data transmitting direction
	USBFS_DCPCFG_DIR_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCFG_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_DCPCFG_Reserved_Msk = 0xf

	// DCPMAXP: DCP Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_DCPMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_DCPMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_DCPMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_DCPMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_DCPMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_DCPMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_DCPMAXP_DEVSEL_0101 = 0x5
	// Position of Reserved field.
	USBFS_DCPMAXP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	USBFS_DCPMAXP_Reserved_Msk = 0xf80
	// Position of MXPS field.
	USBFS_DCPMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_DCPMAXP_MXPS_Msk = 0x7f
	// 8bytes
	USBFS_DCPMAXP_MXPS_0001000 = 0x8
	// 16bytes
	USBFS_DCPMAXP_MXPS_0010000 = 0x10
	// 24bytes
	USBFS_DCPMAXP_MXPS_0011000 = 0x18
	// 32bytes
	USBFS_DCPMAXP_MXPS_0100000 = 0x20
	// 40bytes
	USBFS_DCPMAXP_MXPS_0101000 = 0x28
	// 48bytes
	USBFS_DCPMAXP_MXPS_0110000 = 0x30
	// 56bytes
	USBFS_DCPMAXP_MXPS_0111000 = 0x38
	// 64bytes
	USBFS_DCPMAXP_MXPS_1000000 = 0x40
	// 72bytes
	USBFS_DCPMAXP_MXPS_1001000 = 0x48
	// 80bytes
	USBFS_DCPMAXP_MXPS_1010000 = 0x50
	// 88bytes
	USBFS_DCPMAXP_MXPS_1011000 = 0x58
	// 96bytes
	USBFS_DCPMAXP_MXPS_1100000 = 0x60
	// 104bytes
	USBFS_DCPMAXP_MXPS_1101000 = 0x68
	// 112bytes
	USBFS_DCPMAXP_MXPS_1110000 = 0x70
	// 120bytes
	USBFS_DCPMAXP_MXPS_1111000 = 0x78

	// DCPCTR: DCP Control Register
	// Position of BSTS field.
	USBFS_DCPCTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_DCPCTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_DCPCTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_DCPCTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_DCPCTR_BSTS_1 = 0x1
	// Position of SUREQ field.
	USBFS_DCPCTR_SUREQ_Pos = 0xe
	// Bit mask of SUREQ field.
	USBFS_DCPCTR_SUREQ_Msk = 0x4000
	// Bit SUREQ.
	USBFS_DCPCTR_SUREQ = 0x4000
	// Invalid
	USBFS_DCPCTR_SUREQ_0 = 0x0
	// Transmits the setup packet.
	USBFS_DCPCTR_SUREQ_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x3000
	// Position of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Pos = 0xb
	// Bit mask of SUREQCLR field.
	USBFS_DCPCTR_SUREQCLR_Msk = 0x800
	// Bit SUREQCLR.
	USBFS_DCPCTR_SUREQCLR = 0x800
	// Invalid
	USBFS_DCPCTR_SUREQCLR_0 = 0x0
	// Clears the SUREQ bit to 0.
	USBFS_DCPCTR_SUREQCLR_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x600
	// Position of SQCLR field.
	USBFS_DCPCTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_DCPCTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_DCPCTR_SQCLR = 0x100
	// Invalid
	USBFS_DCPCTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_DCPCTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_DCPCTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_DCPCTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_DCPCTR_SQSET = 0x80
	// Invalid
	USBFS_DCPCTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_DCPCTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_DCPCTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_DCPCTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_DCPCTR_SQMON = 0x40
	// DATA0
	USBFS_DCPCTR_SQMON_0 = 0x0
	// DATA1
	USBFS_DCPCTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_DCPCTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_DCPCTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_DCPCTR_PBUSY = 0x20
	// DCP is not used for the transaction.
	USBFS_DCPCTR_PBUSY_0 = 0x0
	// DCP is used for the transaction.
	USBFS_DCPCTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_DCPCTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	USBFS_DCPCTR_Reserved_Msk = 0x18
	// Position of CCPL field.
	USBFS_DCPCTR_CCPL_Pos = 0x2
	// Bit mask of CCPL field.
	USBFS_DCPCTR_CCPL_Msk = 0x4
	// Bit CCPL.
	USBFS_DCPCTR_CCPL = 0x4
	// Invalid
	USBFS_DCPCTR_CCPL_0 = 0x0
	// Completion of control transfer is enabled.
	USBFS_DCPCTR_CCPL_1 = 0x1
	// Position of PID field.
	USBFS_DCPCTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_DCPCTR_PID_Msk = 0x3
	// NAK response
	USBFS_DCPCTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_DCPCTR_PID_01 = 0x1
	// STALL response
	USBFS_DCPCTR_PID_10 = 0x2
	// STALL response
	USBFS_DCPCTR_PID_11 = 0x3

	// PIPESEL: Pipe Window Select Register
	// Position of Reserved field.
	USBFS_PIPESEL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	USBFS_PIPESEL_Reserved_Msk = 0xfff0
	// Position of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Pos = 0x0
	// Bit mask of PIPESEL field.
	USBFS_PIPESEL_PIPESEL_Msk = 0xf
	// No pipe selected
	USBFS_PIPESEL_PIPESEL_0000 = 0x0
	// PIPE4
	USBFS_PIPESEL_PIPESEL_0100 = 0x4
	// PIPE5
	USBFS_PIPESEL_PIPESEL_0101 = 0x5
	// PIPE6
	USBFS_PIPESEL_PIPESEL_0110 = 0x6
	// PIPE7
	USBFS_PIPESEL_PIPESEL_0111 = 0x7

	// PIPECFG: Pipe Configuration Register
	// Position of TYPE field.
	USBFS_PIPECFG_TYPE_Pos = 0xe
	// Bit mask of TYPE field.
	USBFS_PIPECFG_TYPE_Msk = 0xc000
	// Pipe not used
	USBFS_PIPECFG_TYPE_00 = 0x0
	// Bulk transfer(PIPE1 and PIPE5) /Setting prohibited(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_01 = 0x1
	// Setting prohibited(PIPE1 and PIPE5) /Interrupt transfer(PIPE6 to PIPE9)
	USBFS_PIPECFG_TYPE_10 = 0x2
	// Isochronous transfer(PIPE1 and PIPE2) /Setting prohibited(PIPE3 to PIPE9)
	USBFS_PIPECFG_TYPE_11 = 0x3
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x3800
	// Position of BFRE field.
	USBFS_PIPECFG_BFRE_Pos = 0xa
	// Bit mask of BFRE field.
	USBFS_PIPECFG_BFRE_Msk = 0x400
	// Bit BFRE.
	USBFS_PIPECFG_BFRE = 0x400
	// BRDY interrupt upon transmitting or receiving data
	USBFS_PIPECFG_BFRE_0 = 0x0
	// BRDY interrupt upon completion of reading data
	USBFS_PIPECFG_BFRE_1 = 0x1
	// Position of DBLB field.
	USBFS_PIPECFG_DBLB_Pos = 0x9
	// Bit mask of DBLB field.
	USBFS_PIPECFG_DBLB_Msk = 0x200
	// Bit DBLB.
	USBFS_PIPECFG_DBLB = 0x200
	// Single buffer
	USBFS_PIPECFG_DBLB_0 = 0x0
	// Double buffer
	USBFS_PIPECFG_DBLB_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x100
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x100
	// Position of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Pos = 0x7
	// Bit mask of SHTNAK field.
	USBFS_PIPECFG_SHTNAK_Msk = 0x80
	// Bit SHTNAK.
	USBFS_PIPECFG_SHTNAK = 0x80
	// Pipe assignment continued at the end of transfer
	USBFS_PIPECFG_SHTNAK_0 = 0x0
	// Pipe assignment disabled at the end of transfer
	USBFS_PIPECFG_SHTNAK_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x40
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x40
	// Position of Reserved field.
	USBFS_PIPECFG_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	USBFS_PIPECFG_Reserved_Msk = 0x20
	// Bit Reserved.
	USBFS_PIPECFG_Reserved = 0x20
	// Position of DIR field.
	USBFS_PIPECFG_DIR_Pos = 0x4
	// Bit mask of DIR field.
	USBFS_PIPECFG_DIR_Msk = 0x10
	// Bit DIR.
	USBFS_PIPECFG_DIR = 0x10
	// Receiving direction
	USBFS_PIPECFG_DIR_0 = 0x0
	// Transmitting direction
	USBFS_PIPECFG_DIR_1 = 0x1
	// Position of EPNUM field.
	USBFS_PIPECFG_EPNUM_Pos = 0x0
	// Bit mask of EPNUM field.
	USBFS_PIPECFG_EPNUM_Msk = 0xf

	// PIPEMAXP: Pipe Maximum Packet Size Register
	// Position of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Pos = 0xc
	// Bit mask of DEVSEL field.
	USBFS_PIPEMAXP_DEVSEL_Msk = 0xf000
	// Address 0000
	USBFS_PIPEMAXP_DEVSEL_0000 = 0x0
	// Address 0001
	USBFS_PIPEMAXP_DEVSEL_0001 = 0x1
	// Address 0010
	USBFS_PIPEMAXP_DEVSEL_0010 = 0x2
	// Address 0011
	USBFS_PIPEMAXP_DEVSEL_0011 = 0x3
	// Address 0100
	USBFS_PIPEMAXP_DEVSEL_0100 = 0x4
	// Address 0101
	USBFS_PIPEMAXP_DEVSEL_0101 = 0x5
	// Position of Reserved field.
	USBFS_PIPEMAXP_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	USBFS_PIPEMAXP_Reserved_Msk = 0xe00
	// Position of MXPS field.
	USBFS_PIPEMAXP_MXPS_Pos = 0x0
	// Bit mask of MXPS field.
	USBFS_PIPEMAXP_MXPS_Msk = 0x1ff

	// PIPE4CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access by the CPU is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access by the CPU is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of INBUFM field.
	USBFS_PIPECTR_INBUFM_Pos = 0xe
	// Bit mask of INBUFM field.
	USBFS_PIPECTR_INBUFM_Msk = 0x4000
	// Bit INBUFM.
	USBFS_PIPECTR_INBUFM = 0x4000
	// No data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_0 = 0x0
	// Data to be transmitted is in the FIFO buffer
	USBFS_PIPECTR_INBUFM_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x3800
	// Position of ATREPM field.
	USBFS_PIPECTR_ATREPM_Pos = 0xa
	// Bit mask of ATREPM field.
	USBFS_PIPECTR_ATREPM_Msk = 0x400
	// Bit ATREPM.
	USBFS_PIPECTR_ATREPM = 0x400
	// Auto response is disabled.
	USBFS_PIPECTR_ATREPM_0 = 0x0
	// Auto response is enabled.
	USBFS_PIPECTR_ATREPM_1 = 0x1
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Disabled
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Write disabled
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Write disabled
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// The relevant pipe is not used for the transaction.
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// The relevant pipe is used for the transaction.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x1c
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response (depending on the buffer state)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE6CTR: Pipe %s Control Register
	// Position of BSTS field.
	USBFS_PIPECTR_BSTS_Pos = 0xf
	// Bit mask of BSTS field.
	USBFS_PIPECTR_BSTS_Msk = 0x8000
	// Bit BSTS.
	USBFS_PIPECTR_BSTS = 0x8000
	// Buffer access is disabled.
	USBFS_PIPECTR_BSTS_0 = 0x0
	// Buffer access is enabled.
	USBFS_PIPECTR_BSTS_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x7c00
	// Position of ACLRM field.
	USBFS_PIPECTR_ACLRM_Pos = 0x9
	// Bit mask of ACLRM field.
	USBFS_PIPECTR_ACLRM_Msk = 0x200
	// Bit ACLRM.
	USBFS_PIPECTR_ACLRM = 0x200
	// Auto buffer clear mode is disabled.
	USBFS_PIPECTR_ACLRM_0 = 0x0
	// Auto buffer clear mode is enabled (all buffers are initialized)
	USBFS_PIPECTR_ACLRM_1 = 0x1
	// Position of SQCLR field.
	USBFS_PIPECTR_SQCLR_Pos = 0x8
	// Bit mask of SQCLR field.
	USBFS_PIPECTR_SQCLR_Msk = 0x100
	// Bit SQCLR.
	USBFS_PIPECTR_SQCLR = 0x100
	// Invalid
	USBFS_PIPECTR_SQCLR_0 = 0x0
	// Specifies DATA0.
	USBFS_PIPECTR_SQCLR_1 = 0x1
	// Position of SQSET field.
	USBFS_PIPECTR_SQSET_Pos = 0x7
	// Bit mask of SQSET field.
	USBFS_PIPECTR_SQSET_Msk = 0x80
	// Bit SQSET.
	USBFS_PIPECTR_SQSET = 0x80
	// Invalid
	USBFS_PIPECTR_SQSET_0 = 0x0
	// Specifies DATA1.
	USBFS_PIPECTR_SQSET_1 = 0x1
	// Position of SQMON field.
	USBFS_PIPECTR_SQMON_Pos = 0x6
	// Bit mask of SQMON field.
	USBFS_PIPECTR_SQMON_Msk = 0x40
	// Bit SQMON.
	USBFS_PIPECTR_SQMON = 0x40
	// DATA0
	USBFS_PIPECTR_SQMON_0 = 0x0
	// DATA1
	USBFS_PIPECTR_SQMON_1 = 0x1
	// Position of PBUSY field.
	USBFS_PIPECTR_PBUSY_Pos = 0x5
	// Bit mask of PBUSY field.
	USBFS_PIPECTR_PBUSY_Msk = 0x20
	// Bit PBUSY.
	USBFS_PIPECTR_PBUSY = 0x20
	// The relevant pipe is not used at the USB bus.
	USBFS_PIPECTR_PBUSY_0 = 0x0
	// The relevant pipe is used at the USB bus.
	USBFS_PIPECTR_PBUSY_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPECTR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_PIPECTR_Reserved_Msk = 0x1c
	// Position of PID field.
	USBFS_PIPECTR_PID_Pos = 0x0
	// Bit mask of PID field.
	USBFS_PIPECTR_PID_Msk = 0x3
	// NAK response
	USBFS_PIPECTR_PID_00 = 0x0
	// BUF response(dependingonthebufferstate)
	USBFS_PIPECTR_PID_01 = 0x1
	// STALL response
	USBFS_PIPECTR_PID_10 = 0x2
	// STALL response
	USBFS_PIPECTR_PID_11 = 0x3

	// PIPE4TRE: Pipe %s Transaction Counter Enable Register
	// Position of Reserved field.
	USBFS_PIPETRE_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_PIPETRE_Reserved_Msk = 0xfc00
	// Position of TRENB field.
	USBFS_PIPETRE_TRENB_Pos = 0x9
	// Bit mask of TRENB field.
	USBFS_PIPETRE_TRENB_Msk = 0x200
	// Bit TRENB.
	USBFS_PIPETRE_TRENB = 0x200
	// Transaction counter is disabled.
	USBFS_PIPETRE_TRENB_0 = 0x0
	// Transaction counter is enabled.
	USBFS_PIPETRE_TRENB_1 = 0x1
	// Position of TRCLR field.
	USBFS_PIPETRE_TRCLR_Pos = 0x8
	// Bit mask of TRCLR field.
	USBFS_PIPETRE_TRCLR_Msk = 0x100
	// Bit TRCLR.
	USBFS_PIPETRE_TRCLR = 0x100
	// Invalid
	USBFS_PIPETRE_TRCLR_0 = 0x0
	// The current counter value is cleared.
	USBFS_PIPETRE_TRCLR_1 = 0x1
	// Position of Reserved field.
	USBFS_PIPETRE_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	USBFS_PIPETRE_Reserved_Msk = 0xff

	// PIPE4TRN: Pipe %s Transaction Counter Register
	// Position of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Pos = 0x0
	// Bit mask of TRNCNT field.
	USBFS_PIPETRN_TRNCNT_Msk = 0xffff

	// USBBCCTRL0: BC Control Register 0
	// Position of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Msk = 0xfc00
	// Position of PDDETSTS0 field.
	USBFS_USBBCCTRL0_PDDETSTS0_Pos = 0x9
	// Bit mask of PDDETSTS0 field.
	USBFS_USBBCCTRL0_PDDETSTS0_Msk = 0x200
	// Bit PDDETSTS0.
	USBFS_USBBCCTRL0_PDDETSTS0 = 0x200
	// Not detected
	USBFS_USBBCCTRL0_PDDETSTS0_0 = 0x0
	// Detected
	USBFS_USBBCCTRL0_PDDETSTS0_1 = 0x1
	// Position of CHGDETSTS0 field.
	USBFS_USBBCCTRL0_CHGDETSTS0_Pos = 0x8
	// Bit mask of CHGDETSTS0 field.
	USBFS_USBBCCTRL0_CHGDETSTS0_Msk = 0x100
	// Bit CHGDETSTS0.
	USBFS_USBBCCTRL0_CHGDETSTS0 = 0x100
	// Not detected
	USBFS_USBBCCTRL0_CHGDETSTS0_0 = 0x0
	// Detected
	USBFS_USBBCCTRL0_CHGDETSTS0_1 = 0x1
	// Position of BATCHGE0 field.
	USBFS_USBBCCTRL0_BATCHGE0_Pos = 0x7
	// Bit mask of BATCHGE0 field.
	USBFS_USBBCCTRL0_BATCHGE0_Msk = 0x80
	// Bit BATCHGE0.
	USBFS_USBBCCTRL0_BATCHGE0 = 0x80
	// Disabled
	USBFS_USBBCCTRL0_BATCHGE0_0 = 0x0
	// Enabled
	USBFS_USBBCCTRL0_BATCHGE0_1 = 0x1
	// Position of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	USBFS_USBBCCTRL0_Reserved_Msk = 0x40
	// Bit Reserved.
	USBFS_USBBCCTRL0_Reserved = 0x40
	// Position of VDMSRCE0 field.
	USBFS_USBBCCTRL0_VDMSRCE0_Pos = 0x5
	// Bit mask of VDMSRCE0 field.
	USBFS_USBBCCTRL0_VDMSRCE0_Msk = 0x20
	// Bit VDMSRCE0.
	USBFS_USBBCCTRL0_VDMSRCE0 = 0x20
	// Stop
	USBFS_USBBCCTRL0_VDMSRCE0_0 = 0x0
	// 0.6 V output
	USBFS_USBBCCTRL0_VDMSRCE0_1 = 0x1
	// Position of IDPSINKE0 field.
	USBFS_USBBCCTRL0_IDPSINKE0_Pos = 0x4
	// Bit mask of IDPSINKE0 field.
	USBFS_USBBCCTRL0_IDPSINKE0_Msk = 0x10
	// Bit IDPSINKE0.
	USBFS_USBBCCTRL0_IDPSINKE0 = 0x10
	// Detection off
	USBFS_USBBCCTRL0_IDPSINKE0_0 = 0x0
	// Detection on (comparator and sink current on)
	USBFS_USBBCCTRL0_IDPSINKE0_1 = 0x1
	// Position of VDPSRCE0 field.
	USBFS_USBBCCTRL0_VDPSRCE0_Pos = 0x3
	// Bit mask of VDPSRCE0 field.
	USBFS_USBBCCTRL0_VDPSRCE0_Msk = 0x8
	// Bit VDPSRCE0.
	USBFS_USBBCCTRL0_VDPSRCE0 = 0x8
	// Stop
	USBFS_USBBCCTRL0_VDPSRCE0_0 = 0x0
	// 0.6 V output
	USBFS_USBBCCTRL0_VDPSRCE0_1 = 0x1
	// Position of IDMSINKE0 field.
	USBFS_USBBCCTRL0_IDMSINKE0_Pos = 0x2
	// Bit mask of IDMSINKE0 field.
	USBFS_USBBCCTRL0_IDMSINKE0_Msk = 0x4
	// Bit IDMSINKE0.
	USBFS_USBBCCTRL0_IDMSINKE0 = 0x4
	// Detection off
	USBFS_USBBCCTRL0_IDMSINKE0_0 = 0x0
	// Detection on (comparator and sink current on)
	USBFS_USBBCCTRL0_IDMSINKE0_1 = 0x1
	// Position of IDPSRCE0 field.
	USBFS_USBBCCTRL0_IDPSRCE0_Pos = 0x1
	// Bit mask of IDPSRCE0 field.
	USBFS_USBBCCTRL0_IDPSRCE0_Msk = 0x2
	// Bit IDPSRCE0.
	USBFS_USBBCCTRL0_IDPSRCE0 = 0x2
	// Stop
	USBFS_USBBCCTRL0_IDPSRCE0_0 = 0x0
	// 10 uA output
	USBFS_USBBCCTRL0_IDPSRCE0_1 = 0x1
	// Position of RPDME0 field.
	USBFS_USBBCCTRL0_RPDME0_Pos = 0x0
	// Bit mask of RPDME0 field.
	USBFS_USBBCCTRL0_RPDME0_Msk = 0x1
	// Bit RPDME0.
	USBFS_USBBCCTRL0_RPDME0 = 0x1
	// Pull-down off
	USBFS_USBBCCTRL0_RPDME0_0 = 0x0
	// Pull-down on
	USBFS_USBBCCTRL0_RPDME0_1 = 0x1

	// UCKSEL: USB Clock Selection Register
	// Position of Reserved field.
	USBFS_UCKSEL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_UCKSEL_Reserved_Msk = 0xfffe
	// Position of UCKSELC field.
	USBFS_UCKSEL_UCKSELC_Pos = 0x0
	// Bit mask of UCKSELC field.
	USBFS_UCKSEL_UCKSELC_Msk = 0x1
	// Bit UCKSELC.
	USBFS_UCKSEL_UCKSELC = 0x1
	// High-speed on-chip oscillator clock (HOCO) is not selected as USB clock
	USBFS_UCKSEL_UCKSELC_0 = 0x0
	// High-speed on-chip oscillator clock (HOCO) is selected as USB clock
	USBFS_UCKSEL_UCKSELC_1 = 0x1

	// USBMC: USB Module Control Register
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0xff00
	// Position of VDCEN field.
	USBFS_USBMC_VDCEN_Pos = 0x7
	// Bit mask of VDCEN field.
	USBFS_USBMC_VDCEN_Msk = 0x80
	// Bit VDCEN.
	USBFS_USBMC_VDCEN = 0x80
	// USB regulator off
	USBFS_USBMC_VDCEN_0 = 0x0
	// USB regulator on
	USBFS_USBMC_VDCEN_1 = 0x1
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0x7c
	// Position of Reserved field.
	USBFS_USBMC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	USBFS_USBMC_Reserved_Msk = 0x2
	// Bit Reserved.
	USBFS_USBMC_Reserved = 0x2
	// Position of VDDUSBE field.
	USBFS_USBMC_VDDUSBE_Pos = 0x0
	// Bit mask of VDDUSBE field.
	USBFS_USBMC_VDDUSBE_Msk = 0x1
	// Bit VDDUSBE.
	USBFS_USBMC_VDDUSBE = 0x1
	// USB reference power supply circuit off
	USBFS_USBMC_VDDUSBE_0 = 0x0
	// USB reference power supply circuit on
	USBFS_USBMC_VDDUSBE_1 = 0x1
)

// Constants for WDT: Watchdog Timer
const (
	// WDTRR: WDT Refresh Register
	// Position of WDTRR field.
	WDT_WDTRR_WDTRR_Pos = 0x0
	// Bit mask of WDTRR field.
	WDT_WDTRR_WDTRR_Msk = 0xff

	// WDTCR: WDT Control Register
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc000
	// Position of RPSS field.
	WDT_WDTCR_RPSS_Pos = 0xc
	// Bit mask of RPSS field.
	WDT_WDTCR_RPSS_Msk = 0x3000
	// 25 percent
	WDT_WDTCR_RPSS_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPSS_01 = 0x1
	// 75 percent
	WDT_WDTCR_RPSS_10 = 0x2
	// 100 percent (window start position is not specified)
	WDT_WDTCR_RPSS_11 = 0x3
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc00
	// Position of RPES field.
	WDT_WDTCR_RPES_Pos = 0x8
	// Bit mask of RPES field.
	WDT_WDTCR_RPES_Msk = 0x300
	// 75 percent
	WDT_WDTCR_RPES_00 = 0x0
	// 50 percent
	WDT_WDTCR_RPES_01 = 0x1
	// 25 percent
	WDT_WDTCR_RPES_10 = 0x2
	// 0 percent (window end position is not specified)
	WDT_WDTCR_RPES_11 = 0x3
	// Position of CKS field.
	WDT_WDTCR_CKS_Pos = 0x4
	// Bit mask of CKS field.
	WDT_WDTCR_CKS_Msk = 0xf0
	// PCLK/4
	WDT_WDTCR_CKS_0001 = 0x1
	// PCLK/64
	WDT_WDTCR_CKS_0100 = 0x4
	// PCLK/128
	WDT_WDTCR_CKS_1111 = 0xf
	// PCLK/512
	WDT_WDTCR_CKS_0110 = 0x6
	// PCLK/2048
	WDT_WDTCR_CKS_0111 = 0x7
	// PCLK/8192
	WDT_WDTCR_CKS_1000 = 0x8
	// Position of Reserved field.
	WDT_WDTCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	WDT_WDTCR_Reserved_Msk = 0xc
	// Position of TOPS field.
	WDT_WDTCR_TOPS_Pos = 0x0
	// Bit mask of TOPS field.
	WDT_WDTCR_TOPS_Msk = 0x3
	// 1,024 cycles (03FFh)
	WDT_WDTCR_TOPS_00 = 0x0
	// 4,096 cycles (0FFFh)
	WDT_WDTCR_TOPS_01 = 0x1
	// 8,192 cycles (1FFFh)
	WDT_WDTCR_TOPS_10 = 0x2
	// 16,384 cycles (3FFFh)
	WDT_WDTCR_TOPS_11 = 0x3

	// WDTSR: WDT Status Register
	// Position of REFEF field.
	WDT_WDTSR_REFEF_Pos = 0xf
	// Bit mask of REFEF field.
	WDT_WDTSR_REFEF_Msk = 0x8000
	// Bit REFEF.
	WDT_WDTSR_REFEF = 0x8000
	// No refresh error occurred
	WDT_WDTSR_REFEF_0 = 0x0
	// Refresh error occurred
	WDT_WDTSR_REFEF_1 = 0x1
	// Position of UNDFF field.
	WDT_WDTSR_UNDFF_Pos = 0xe
	// Bit mask of UNDFF field.
	WDT_WDTSR_UNDFF_Msk = 0x4000
	// Bit UNDFF.
	WDT_WDTSR_UNDFF = 0x4000
	// No underflow occurred
	WDT_WDTSR_UNDFF_0 = 0x0
	// Underflow occurred
	WDT_WDTSR_UNDFF_1 = 0x1
	// Position of CNTVAL field.
	WDT_WDTSR_CNTVAL_Pos = 0x0
	// Bit mask of CNTVAL field.
	WDT_WDTSR_CNTVAL_Msk = 0x3fff

	// WDTRCR: WDT Reset Control Register
	// Position of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Pos = 0x7
	// Bit mask of RSTIRQS field.
	WDT_WDTRCR_RSTIRQS_Msk = 0x80
	// Bit RSTIRQS.
	WDT_WDTRCR_RSTIRQS = 0x80
	// Non-maskable interrupt request or interrupt request output is enabled
	WDT_WDTRCR_RSTIRQS_0 = 0x0
	// Reset output is enabled.
	WDT_WDTRCR_RSTIRQS_1 = 0x1

	// WDTCSTPR: WDT Count Stop Control Register
	// Position of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Pos = 0x7
	// Bit mask of SLCSTP field.
	WDT_WDTCSTPR_SLCSTP_Msk = 0x80
	// Bit SLCSTP.
	WDT_WDTCSTPR_SLCSTP = 0x80
	// Count stop is disabled.
	WDT_WDTCSTPR_SLCSTP_0 = 0x0
	// Count is stopped at a transition to sleep mode.
	WDT_WDTCSTPR_SLCSTP_1 = 0x1
	// Position of Reserved field.
	WDT_WDTCSTPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	WDT_WDTCSTPR_Reserved_Msk = 0x7f
)

// Constants for CAC: Clock Frequency Accuracy Measurement Circuit
const (
	// CACR0: CAC Control Register 0
	// Position of Reserved field.
	CAC_CACR0_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	CAC_CACR0_Reserved_Msk = 0xfe
	// Position of CFME field.
	CAC_CACR0_CFME_Pos = 0x0
	// Bit mask of CFME field.
	CAC_CACR0_CFME_Msk = 0x1
	// Bit CFME.
	CAC_CACR0_CFME = 0x1
	// Disable
	CAC_CACR0_CFME_0 = 0x0
	// Enable
	CAC_CACR0_CFME_1 = 0x1

	// CACR1: CAC Control Register 1
	// Position of EDGES field.
	CAC_CACR1_EDGES_Pos = 0x6
	// Bit mask of EDGES field.
	CAC_CACR1_EDGES_Msk = 0xc0
	// Rising edge
	CAC_CACR1_EDGES_00 = 0x0
	// Falling edge
	CAC_CACR1_EDGES_01 = 0x1
	// Both rising and falling edges
	CAC_CACR1_EDGES_10 = 0x2
	// Setting prohibited
	CAC_CACR1_EDGES_11 = 0x3
	// Position of TCSS field.
	CAC_CACR1_TCSS_Pos = 0x4
	// Bit mask of TCSS field.
	CAC_CACR1_TCSS_Msk = 0x30
	// No division
	CAC_CACR1_TCSS_00 = 0x0
	// x 1/4 clock
	CAC_CACR1_TCSS_01 = 0x1
	// x 1/8 clock
	CAC_CACR1_TCSS_10 = 0x2
	// x 1/32 clock
	CAC_CACR1_TCSS_11 = 0x3
	// Position of FMCS field.
	CAC_CACR1_FMCS_Pos = 0x1
	// Bit mask of FMCS field.
	CAC_CACR1_FMCS_Msk = 0xe
	// Main clock
	CAC_CACR1_FMCS_000 = 0x0
	// Sub-clock
	CAC_CACR1_FMCS_001 = 0x1
	// HOCO clock
	CAC_CACR1_FMCS_010 = 0x2
	// MOCO clock
	CAC_CACR1_FMCS_011 = 0x3
	// LOCO clock
	CAC_CACR1_FMCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR1_FMCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR1_FMCS_110 = 0x6
	// Setting prohibited
	CAC_CACR1_FMCS_111 = 0x7
	// Position of CACREFE field.
	CAC_CACR1_CACREFE_Pos = 0x0
	// Bit mask of CACREFE field.
	CAC_CACR1_CACREFE_Msk = 0x1
	// Bit CACREFE.
	CAC_CACR1_CACREFE = 0x1
	// Disable
	CAC_CACR1_CACREFE_0 = 0x0
	// Enable
	CAC_CACR1_CACREFE_1 = 0x1

	// CACR2: CAC Control Register 2
	// Position of DFS field.
	CAC_CACR2_DFS_Pos = 0x6
	// Bit mask of DFS field.
	CAC_CACR2_DFS_Msk = 0xc0
	// Digital filtering is disabled.
	CAC_CACR2_DFS_00 = 0x0
	// The sampling clock for the digital filter is the frequency measuring clock.
	CAC_CACR2_DFS_01 = 0x1
	// The sampling clock for the digital filter is the frequency measuring clock divided by 4.
	CAC_CACR2_DFS_10 = 0x2
	// The sampling clock for the digital filter is the frequency measuring clock divided by 16.
	CAC_CACR2_DFS_11 = 0x3
	// Position of RCDS field.
	CAC_CACR2_RCDS_Pos = 0x4
	// Bit mask of RCDS field.
	CAC_CACR2_RCDS_Msk = 0x30
	// 1/32 clock
	CAC_CACR2_RCDS_00 = 0x0
	// 1/128 clock
	CAC_CACR2_RCDS_01 = 0x1
	// 1/1024 clock
	CAC_CACR2_RCDS_10 = 0x2
	// 1/8192 clock
	CAC_CACR2_RCDS_11 = 0x3
	// Position of RSCS field.
	CAC_CACR2_RSCS_Pos = 0x1
	// Bit mask of RSCS field.
	CAC_CACR2_RSCS_Msk = 0xe
	// Main clock
	CAC_CACR2_RSCS_000 = 0x0
	// Sub-clock
	CAC_CACR2_RSCS_001 = 0x1
	// HOCO clock
	CAC_CACR2_RSCS_010 = 0x2
	// MOCO clock
	CAC_CACR2_RSCS_011 = 0x3
	// LOCO clock
	CAC_CACR2_RSCS_100 = 0x4
	// Peripheral module clock(PCLKB)
	CAC_CACR2_RSCS_101 = 0x5
	// IWDTCLK clock
	CAC_CACR2_RSCS_110 = 0x6
	// Setting prohibited
	CAC_CACR2_RSCS_111 = 0x7
	// Position of RPS field.
	CAC_CACR2_RPS_Pos = 0x0
	// Bit mask of RPS field.
	CAC_CACR2_RPS_Msk = 0x1
	// Bit RPS.
	CAC_CACR2_RPS = 0x1
	// CACREF pin input
	CAC_CACR2_RPS_0 = 0x0
	// Internal clock (internally generated signal)
	CAC_CACR2_RPS_1 = 0x1

	// CAICR: CAC Interrupt Control Register
	// Position of Reserved field.
	CAC_CAICR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	CAC_CAICR_Reserved_Msk = 0x80
	// Bit Reserved.
	CAC_CAICR_Reserved = 0x80
	// Position of OVFFCL field.
	CAC_CAICR_OVFFCL_Pos = 0x6
	// Bit mask of OVFFCL field.
	CAC_CAICR_OVFFCL_Msk = 0x40
	// Bit OVFFCL.
	CAC_CAICR_OVFFCL = 0x40
	// No effect on operations
	CAC_CAICR_OVFFCL_0 = 0x0
	// Clears the OVFF flag
	CAC_CAICR_OVFFCL_1 = 0x1
	// Position of MENDFCL field.
	CAC_CAICR_MENDFCL_Pos = 0x5
	// Bit mask of MENDFCL field.
	CAC_CAICR_MENDFCL_Msk = 0x20
	// Bit MENDFCL.
	CAC_CAICR_MENDFCL = 0x20
	// No effect on operations
	CAC_CAICR_MENDFCL_0 = 0x0
	// Clears the MENDF flag
	CAC_CAICR_MENDFCL_1 = 0x1
	// Position of FERRFCL field.
	CAC_CAICR_FERRFCL_Pos = 0x4
	// Bit mask of FERRFCL field.
	CAC_CAICR_FERRFCL_Msk = 0x10
	// Bit FERRFCL.
	CAC_CAICR_FERRFCL = 0x10
	// No effect on operations
	CAC_CAICR_FERRFCL_0 = 0x0
	// Clears the FERRF flag
	CAC_CAICR_FERRFCL_1 = 0x1
	// Position of Reserved field.
	CAC_CAICR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAC_CAICR_Reserved_Msk = 0x8
	// Bit Reserved.
	CAC_CAICR_Reserved = 0x8
	// Position of OVFIE field.
	CAC_CAICR_OVFIE_Pos = 0x2
	// Bit mask of OVFIE field.
	CAC_CAICR_OVFIE_Msk = 0x4
	// Bit OVFIE.
	CAC_CAICR_OVFIE = 0x4
	// Disable
	CAC_CAICR_OVFIE_0 = 0x0
	// Enable
	CAC_CAICR_OVFIE_1 = 0x1
	// Position of MENDIE field.
	CAC_CAICR_MENDIE_Pos = 0x1
	// Bit mask of MENDIE field.
	CAC_CAICR_MENDIE_Msk = 0x2
	// Bit MENDIE.
	CAC_CAICR_MENDIE = 0x2
	// Disable
	CAC_CAICR_MENDIE_0 = 0x0
	// Enable
	CAC_CAICR_MENDIE_1 = 0x1
	// Position of FERRIE field.
	CAC_CAICR_FERRIE_Pos = 0x0
	// Bit mask of FERRIE field.
	CAC_CAICR_FERRIE_Msk = 0x1
	// Bit FERRIE.
	CAC_CAICR_FERRIE = 0x1
	// Disable
	CAC_CAICR_FERRIE_0 = 0x0
	// Enable
	CAC_CAICR_FERRIE_1 = 0x1

	// CASTR: CAC Status Register
	// Position of OVFF field.
	CAC_CASTR_OVFF_Pos = 0x2
	// Bit mask of OVFF field.
	CAC_CASTR_OVFF_Msk = 0x4
	// Bit OVFF.
	CAC_CASTR_OVFF = 0x4
	// The counter has not overflowed.
	CAC_CASTR_OVFF_0 = 0x0
	// The counter has overflowed.
	CAC_CASTR_OVFF_1 = 0x1
	// Position of MENDF field.
	CAC_CASTR_MENDF_Pos = 0x1
	// Bit mask of MENDF field.
	CAC_CASTR_MENDF_Msk = 0x2
	// Bit MENDF.
	CAC_CASTR_MENDF = 0x2
	// Measurement is in progress.
	CAC_CASTR_MENDF_0 = 0x0
	// Measurement has ended.
	CAC_CASTR_MENDF_1 = 0x1
	// Position of FERRF field.
	CAC_CASTR_FERRF_Pos = 0x0
	// Bit mask of FERRF field.
	CAC_CASTR_FERRF_Msk = 0x1
	// Bit FERRF.
	CAC_CASTR_FERRF = 0x1
	// The clock frequency is within the range corresponding to the settings.
	CAC_CASTR_FERRF_0 = 0x0
	// The clock frequency has deviated beyond the range corresponding to the settings (frequency error).
	CAC_CASTR_FERRF_1 = 0x1

	// CAULVR: CAC Upper-Limit Value Setting Register
	// Position of CAULVR field.
	CAC_CAULVR_CAULVR_Pos = 0x0
	// Bit mask of CAULVR field.
	CAC_CAULVR_CAULVR_Msk = 0xffff

	// CALLVR: CAC Lower-Limit Value Setting Register
	// Position of CALLVR field.
	CAC_CALLVR_CALLVR_Pos = 0x0
	// Bit mask of CALLVR field.
	CAC_CALLVR_CALLVR_Msk = 0xffff

	// CACNTBR: CAC Counter Buffer Register
	// Position of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Pos = 0x0
	// Bit mask of CACNTBR field.
	CAC_CACNTBR_CACNTBR_Msk = 0xffff
)

// Constants for CRC: CRC Calculator
const (
	// CRCCR0: CRC Control Register0
	// Position of DORCLR field.
	CRC_CRCCR0_DORCLR_Pos = 0x7
	// Bit mask of DORCLR field.
	CRC_CRCCR0_DORCLR_Msk = 0x80
	// Bit DORCLR.
	CRC_CRCCR0_DORCLR = 0x80
	// No effect.
	CRC_CRCCR0_DORCLR_0 = 0x0
	// Clears the CRCDOR register.
	CRC_CRCCR0_DORCLR_1 = 0x1
	// Position of LMS field.
	CRC_CRCCR0_LMS_Pos = 0x6
	// Bit mask of LMS field.
	CRC_CRCCR0_LMS_Msk = 0x40
	// Bit LMS.
	CRC_CRCCR0_LMS = 0x40
	// Generates CRC for LSB first communication.
	CRC_CRCCR0_LMS_0 = 0x0
	// Generates CRC for MSB first communication.
	CRC_CRCCR0_LMS_1 = 0x1
	// Position of Reserved field.
	CRC_CRCCR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CRC_CRCCR0_Reserved_Msk = 0x38
	// Position of GPS field.
	CRC_CRCCR0_GPS_Pos = 0x0
	// Bit mask of GPS field.
	CRC_CRCCR0_GPS_Msk = 0x7
	// No calculation is executed.
	CRC_CRCCR0_GPS_000 = 0x0
	// 8-bit CRC-8 (X8 + X2 + X + 1)
	CRC_CRCCR0_GPS_001 = 0x1
	// 16-bit CRC-16 (X16 + X15 + X2 + 1)
	CRC_CRCCR0_GPS_010 = 0x2
	// 16-bit CRC-CCITT (X16 + X12 + X5 + 1)
	CRC_CRCCR0_GPS_011 = 0x3
	// 32-bit CRC-32(X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1)
	CRC_CRCCR0_GPS_100 = 0x4
	// 32-bit CRC-32C (X32+X28+X27+X26+X25+X23+X22+X20+X19+X18+X14+X13+X11+X10+X9+X8+X6+1)
	CRC_CRCCR0_GPS_101 = 0x5

	// CRCCR1: CRC Control Register1
	// Position of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Pos = 0x7
	// Bit mask of CRCSEN field.
	CRC_CRCCR1_CRCSEN_Msk = 0x80
	// Bit CRCSEN.
	CRC_CRCCR1_CRCSEN = 0x80
	// Disabled
	CRC_CRCCR1_CRCSEN_0 = 0x0
	// Enabled
	CRC_CRCCR1_CRCSEN_1 = 0x1
	// Position of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Pos = 0x6
	// Bit mask of CRCSWR field.
	CRC_CRCCR1_CRCSWR_Msk = 0x40
	// Bit CRCSWR.
	CRC_CRCCR1_CRCSWR = 0x40
	// Snoop-on-read
	CRC_CRCCR1_CRCSWR_0 = 0x0
	// Snoop-on-write
	CRC_CRCCR1_CRCSWR_1 = 0x1
	// Position of Reserved field.
	CRC_CRCCR1_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	CRC_CRCCR1_Reserved_Msk = 0x3f

	// CRCDIR: CRC Data Input Register
	// Position of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Pos = 0x0
	// Bit mask of CRCDIR field.
	CRC_CRCDIR_CRCDIR_Msk = 0xffffffff

	// CRCDIR_BY: CRC Data Input Register (byte access)
	// Position of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Pos = 0x0
	// Bit mask of CRCDIR_BY field.
	CRC_CRCDIR_BY_CRCDIR_BY_Msk = 0xff

	// CRCDOR: CRC Data Output Register
	// Position of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Pos = 0x0
	// Bit mask of CRCDOR field.
	CRC_CRCDOR_CRCDOR_Msk = 0xffffffff

	// CRCDOR_HA: CRC Data Output Register (halfword access)
	// Position of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Pos = 0x0
	// Bit mask of CRCDOR_HA field.
	CRC_CRCDOR_HA_CRCDOR_HA_Msk = 0xffff

	// CRCDOR_BY: CRC Data Output Register(byte access)
	// Position of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Pos = 0x0
	// Bit mask of CRCDOR_BY field.
	CRC_CRCDOR_BY_CRCDOR_BY_Msk = 0xff

	// CRCSAR: Snoop Address Register
	// Position of Reserved field.
	CRC_CRCSAR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CRC_CRCSAR_Reserved_Msk = 0xc000
	// Position of CRCSA field.
	CRC_CRCSAR_CRCSA_Pos = 0x0
	// Bit mask of CRCSA field.
	CRC_CRCSAR_CRCSA_Msk = 0x3fff
	// SCI0.TDR
	CRC_CRCSAR_CRCSA_0x0003 = 0x3
	// SCI0.RDR
	CRC_CRCSAR_CRCSA_0x0005 = 0x5
	// SCI1.TDR
	CRC_CRCSAR_CRCSA_0x0023 = 0x23
	// SCI1.RDR
	CRC_CRCSAR_CRCSA_0x0025 = 0x25
	// SCI9.TDR
	CRC_CRCSAR_CRCSA_0x0123 = 0x123
	// SCI9.RDR
	CRC_CRCSAR_CRCSA_0x0125 = 0x125
)

// Constants for DOC: Data Operation Circuit
const (
	// DOCR: DOC Control Register
	// Position of Reserved field.
	DOC_DOCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	DOC_DOCR_Reserved_Msk = 0x80
	// Bit Reserved.
	DOC_DOCR_Reserved = 0x80
	// Position of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Pos = 0x6
	// Bit mask of DOPCFCL field.
	DOC_DOCR_DOPCFCL_Msk = 0x40
	// Bit DOPCFCL.
	DOC_DOCR_DOPCFCL = 0x40
	// Maintains the DOPCF flag state.
	DOC_DOCR_DOPCFCL_0 = 0x0
	// Clears the DOPCF flag.
	DOC_DOCR_DOPCFCL_1 = 0x1
	// Position of DOPCF field.
	DOC_DOCR_DOPCF_Pos = 0x5
	// Bit mask of DOPCF field.
	DOC_DOCR_DOPCF_Msk = 0x20
	// Bit DOPCF.
	DOC_DOCR_DOPCF = 0x20
	// Position of Reserved field.
	DOC_DOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DOC_DOCR_Reserved_Msk = 0x18
	// Position of DCSEL field.
	DOC_DOCR_DCSEL_Pos = 0x2
	// Bit mask of DCSEL field.
	DOC_DOCR_DCSEL_Msk = 0x4
	// Bit DCSEL.
	DOC_DOCR_DCSEL = 0x4
	// DOPCF is set when data mismatch is detected.
	DOC_DOCR_DCSEL_0 = 0x0
	// DOPCF is set when data match is detected.
	DOC_DOCR_DCSEL_1 = 0x1
	// Position of OMS field.
	DOC_DOCR_OMS_Pos = 0x0
	// Bit mask of OMS field.
	DOC_DOCR_OMS_Msk = 0x3
	// Data comparison mode
	DOC_DOCR_OMS_00 = 0x0
	// Data addition mode
	DOC_DOCR_OMS_01 = 0x1
	// Data subtraction mode
	DOC_DOCR_OMS_10 = 0x2
	// Setting prohibited
	DOC_DOCR_OMS_11 = 0x3

	// DODIR: DOC Data Input Register
	// Position of DODIR field.
	DOC_DODIR_DODIR_Pos = 0x0
	// Bit mask of DODIR field.
	DOC_DODIR_DODIR_Msk = 0xffff

	// DODSR: DOC Data Setting Register
	// Position of DODSR field.
	DOC_DODSR_DODSR_Pos = 0x0
	// Bit mask of DODSR field.
	DOC_DODSR_DODSR_Msk = 0xffff
)

// Constants for SCI0: Serial Communication Interface 0
const (
	// SMR: Serial Mode Register (SCMR.SMIF = 0)
	// Position of CM field.
	SCI0_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI0_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI0_SMR_CM = 0x80
	// Asynchronous mode or simple I2C mode
	SCI0_SMR_CM_0 = 0x0
	// Clock synchronous mode
	SCI0_SMR_CM_1 = 0x1
	// Position of CHR field.
	SCI0_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI0_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI0_SMR_CHR = 0x40
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 8bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_0 = 0x0
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 7bit data length(SCMR.CHR1=1)
	SCI0_SMR_CHR_1 = 0x1
	// Position of PE field.
	SCI0_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_PE = 0x20
	// Parity bit addition is not performed (transmitting) / Parity bit checking is not performed ( receiving )
	SCI0_SMR_PE_0 = 0x0
	// The parity bit is added (transmitting) / The parity bit is checked (receiving)
	SCI0_SMR_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_PM = 0x10
	// Selects even parity
	SCI0_SMR_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_PM_1 = 0x1
	// Position of STOP field.
	SCI0_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI0_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI0_SMR_STOP = 0x8
	// 1 stop bit
	SCI0_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI0_SMR_STOP_1 = 0x1
	// Position of MP field.
	SCI0_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI0_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI0_SMR_MP = 0x4
	// Multi-processor communications function is disabled
	SCI0_SMR_MP_0 = 0x0
	// Multi-processor communications function is enabled
	SCI0_SMR_MP_1 = 0x1
	// Position of CKS field.
	SCI0_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_CKS_11 = 0x3

	// SMR_SMCI: Serial mode register (SCMR.SMIF = 1)
	// Position of GM field.
	SCI0_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI0_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI0_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI0_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI0_SMR_SMCI_GM_1 = 0x1
	// Position of BLK field.
	SCI0_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI0_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI0_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI0_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI0_SMR_SMCI_BLK_1 = 0x1
	// Position of PE field.
	SCI0_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI0_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI0_SMR_SMCI_PE = 0x20
	// Setting Prohibited
	SCI0_SMR_SMCI_PE_0 = 0x0
	// Set this bit to 1 in smart card interface mode.
	SCI0_SMR_SMCI_PE_1 = 0x1
	// Position of PM field.
	SCI0_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI0_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI0_SMR_SMCI_PM = 0x10
	// Selects even parity
	SCI0_SMR_SMCI_PM_0 = 0x0
	// Selects odd parity
	SCI0_SMR_SMCI_PM_1 = 0x1
	// Position of BCP field.
	SCI0_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI0_SMR_SMCI_BCP_Msk = 0xc
	// 93 clock cycles(S=93) (SCMR.BCP2=0) / 32 clock cycles(S=32) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_00 = 0x0
	// 128 clock cycles(S=128) (SCMR.BCP2=0) / 64 clock cycles(S=64) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_01 = 0x1
	// 186 clock cycles(S=186) (SCMR.BCP2=0) / 372 clock cycles(S=372) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_10 = 0x2
	// 512 clock cycles(S=512) (SCMR.BCP2=0) / 256 clock cycles(S=256) (SCMR.BCP2=1)
	SCI0_SMR_SMCI_BCP_11 = 0x3
	// Position of CKS field.
	SCI0_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI0_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock
	SCI0_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock
	SCI0_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock
	SCI0_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock
	SCI0_SMR_SMCI_CKS_11 = 0x3

	// BRR: Bit Rate Register
	// Position of BRR field.
	SCI0_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	SCI0_BRR_BRR_Msk = 0xff

	// SCR: Serial Control Register (SCMR.SMIF = 0)
	// Position of TIE field.
	SCI0_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_TIE = 0x80
	// TXI interrupt request is disabled
	SCI0_SCR_TIE_0 = 0x0
	// TXI interrupt request is enabled
	SCI0_SCR_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI0_SCR_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI0_SCR_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_MPIE = 0x8
	// Normal reception
	SCI0_SCR_MPIE_0 = 0x0
	// When the data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF,ORER and FER in SSR to 1 is disabled. When the data with the multiprocessor bit set to 1 is received, the MPIE bit is automatically cleared to 0, and normal reception is resumed.
	SCI0_SCR_MPIE_1 = 0x1
	// Position of TEIE field.
	SCI0_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_TEIE = 0x4
	// TEI interrupt request is disabled
	SCI0_SCR_TEIE_0 = 0x0
	// TEI interrupt request is enabled
	SCI0_SCR_TEIE_1 = 0x1
	// Position of CKE field.
	SCI0_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_CKE_Msk = 0x3
	// The SCKn pin is available for use as an I/O port in accord with the I/O port settings.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_00 = 0x0
	// The clock with the same frequency as the bit rate is output from the SCKn pin.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI0_SCR_CKE_01 = 0x1

	// SCR_SMCI: Serial Control Register (SCMR.SMIF =1)
	// Position of TIE field.
	SCI0_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI0_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI0_SCR_SMCI_TIE = 0x80
	// A TXI interrupt request is disabled
	SCI0_SCR_SMCI_TIE_0 = 0x0
	// A TXI interrupt request is enabled
	SCI0_SCR_SMCI_TIE_1 = 0x1
	// Position of RIE field.
	SCI0_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI0_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI0_SCR_SMCI_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI0_SCR_SMCI_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI0_SCR_SMCI_RIE_1 = 0x1
	// Position of TE field.
	SCI0_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI0_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI0_SCR_SMCI_TE = 0x20
	// Serial transmission is disabled
	SCI0_SCR_SMCI_TE_0 = 0x0
	// Serial transmission is enabled
	SCI0_SCR_SMCI_TE_1 = 0x1
	// Position of RE field.
	SCI0_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI0_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI0_SCR_SMCI_RE = 0x10
	// Serial reception is disabled
	SCI0_SCR_SMCI_RE_0 = 0x0
	// Serial reception is enabled
	SCI0_SCR_SMCI_RE_1 = 0x1
	// Position of MPIE field.
	SCI0_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI0_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI0_SCR_SMCI_MPIE = 0x8
	// Position of TEIE field.
	SCI0_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI0_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI0_SCR_SMCI_TEIE = 0x4
	// Position of CKE field.
	SCI0_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI0_SCR_SMCI_CKE_Msk = 0x3
	// Output disabled(SMR_SMCI.GM=0) / Output fixed low(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_00 = 0x0
	// Clock Output
	SCI0_SCR_SMCI_CKE_01 = 0x1
	// Setting prohibited(SMR_SMCI.GM=0) / Output fixed High(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_10 = 0x2
	// Setting prohibited(SMR_SMCI.GM=0) / Clock Output(SMR_SMCI.GM=1)
	SCI0_SCR_SMCI_CKE_11 = 0x3

	// TDR: Transmit Data Register
	// Position of TDR field.
	SCI0_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	SCI0_TDR_TDR_Msk = 0xff

	// SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
	// Position of TDRE field.
	SCI0_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FER = 0x10
	// No framing error occurred
	SCI0_SSR_FER_0 = 0x0
	// A framing error has occurred
	SCI0_SSR_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_PER = 0x8
	// No parity error occurred
	SCI0_SSR_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_MPB = 0x2
	// Data transmission cycles
	SCI0_SSR_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPB_1 = 0x1
	// Position of MPBT field.
	SCI0_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_MPBT = 0x1
	// Data transmission cycles
	SCI0_SSR_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_SSR_MPBT_1 = 0x1

	// SSR_FIFO: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=1)
	// Position of TDFE field.
	SCI0_SSR_FIFO_TDFE_Pos = 0x7
	// Bit mask of TDFE field.
	SCI0_SSR_FIFO_TDFE_Msk = 0x80
	// Bit TDFE.
	SCI0_SSR_FIFO_TDFE = 0x80
	// The quantity of transmit data written in FTDR exceeds the specified transmit triggering number.
	SCI0_SSR_FIFO_TDFE_0 = 0x0
	// The quantity of transmit data written in FTDR is equal to or less than the specified transmit triggering number
	SCI0_SSR_FIFO_TDFE_1 = 0x1
	// Position of RDF field.
	SCI0_SSR_FIFO_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_SSR_FIFO_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_SSR_FIFO_RDF = 0x40
	// The quantity of receive data written in FRDR falls below the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_0 = 0x0
	// The quantity of receive data written in FRDR is equal to or greater than the specified receive triggering number.
	SCI0_SSR_FIFO_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_FIFO_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_FIFO_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_FIFO_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_FIFO_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_FIFO_ORER_1 = 0x1
	// Position of FER field.
	SCI0_SSR_FIFO_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_SSR_FIFO_FER_Msk = 0x10
	// Bit FER.
	SCI0_SSR_FIFO_FER = 0x10
	// No framing error occurred.
	SCI0_SSR_FIFO_FER_0 = 0x0
	// A framing error has occurred.
	SCI0_SSR_FIFO_FER_1 = 0x1
	// Position of PER field.
	SCI0_SSR_FIFO_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_FIFO_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_FIFO_PER = 0x8
	// No parity error occurred.
	SCI0_SSR_FIFO_PER_0 = 0x0
	// A parity error has occurred.
	SCI0_SSR_FIFO_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_FIFO_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_FIFO_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_FIFO_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_FIFO_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_FIFO_TEND_1 = 0x1
	// Position of Reserved field.
	SCI0_SSR_FIFO_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SSR_FIFO_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SSR_FIFO_Reserved = 0x2
	// Position of DR field.
	SCI0_SSR_FIFO_DR_Pos = 0x0
	// Bit mask of DR field.
	SCI0_SSR_FIFO_DR_Msk = 0x1
	// Bit DR.
	SCI0_SSR_FIFO_DR = 0x1
	// Receiving is in progress, or no received data has remained in FRDR after normally completed receiving.(receive FIFO is empty)
	SCI0_SSR_FIFO_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving, , when data is stored in FIFO to equal or less than receive triggering number.
	SCI0_SSR_FIFO_DR_1 = 0x1

	// SSR_SMCI: Serial Status Register(SCMR.SMIF = 1)
	// Position of TDRE field.
	SCI0_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI0_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI0_SSR_SMCI_TDRE = 0x80
	// Transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI0_SSR_SMCI_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI0_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI0_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI0_SSR_SMCI_RDRF = 0x40
	// No received data is in RDR register
	SCI0_SSR_SMCI_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI0_SSR_SMCI_RDRF_1 = 0x1
	// Position of ORER field.
	SCI0_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI0_SSR_SMCI_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_SSR_SMCI_ORER_1 = 0x1
	// Position of ERS field.
	SCI0_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI0_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI0_SSR_SMCI_ERS = 0x10
	// Low error signal not responded
	SCI0_SSR_SMCI_ERS_0 = 0x0
	// Low error signal responded
	SCI0_SSR_SMCI_ERS_1 = 0x1
	// Position of PER field.
	SCI0_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI0_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI0_SSR_SMCI_PER_0 = 0x0
	// A parity error has occurred
	SCI0_SSR_SMCI_PER_1 = 0x1
	// Position of TEND field.
	SCI0_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI0_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI0_SSR_SMCI_TEND = 0x4
	// A character is being transmitted.
	SCI0_SSR_SMCI_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI0_SSR_SMCI_TEND_1 = 0x1
	// Position of MPB field.
	SCI0_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_SSR_SMCI_MPB = 0x2
	// Position of MPBT field.
	SCI0_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI0_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI0_SSR_SMCI_MPBT = 0x1

	// RDR: Receive Data Register
	// Position of RDR field.
	SCI0_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	SCI0_RDR_RDR_Msk = 0xff

	// SCMR: Smart Card Mode Register
	// Position of BCP2 field.
	SCI0_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI0_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI0_SCMR_BCP2 = 0x80
	// S=93(SMR.BCP[1:0]=00), 128(SMR.BCP[1:0]=01), 186(SMR.BCP[1:0]=10), 512(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_0 = 0x0
	// S=32(SMR.BCP[1:0]=00), 64(SMR.BCP[1:0]=01), 372(SMR.BCP[1:0]=10), 256(SMR.BCP[1:0]=11)
	SCI0_SCMR_BCP2_1 = 0x1
	// Position of Reserved field.
	SCI0_SCMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_SCMR_Reserved_Msk = 0x60
	// Position of CHR1 field.
	SCI0_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI0_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI0_SCMR_CHR1 = 0x10
	// Transmit/receive in 9-bit data length
	SCI0_SCMR_CHR1_0 = 0x0
	// Transmit/receive in 8-bit data length(SMR.CHR=0) / in 7bit data length(SMR.CHR=1)
	SCI0_SCMR_CHR1_1 = 0x1
	// Position of SDIR field.
	SCI0_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI0_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI0_SCMR_SDIR = 0x8
	// Transfer with LSB first
	SCI0_SCMR_SDIR_0 = 0x0
	// Transfer with MSB first
	SCI0_SCMR_SDIR_1 = 0x1
	// Position of SINV field.
	SCI0_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI0_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI0_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Receive data is stored as it is in RDR.
	SCI0_SCMR_SINV_0 = 0x0
	// TDR contents are inverted before being transmitted. Receive data is stored in inverted form in RDR.
	SCI0_SCMR_SINV_1 = 0x1
	// Position of Reserved field.
	SCI0_SCMR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SCMR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SCMR_Reserved = 0x2
	// Position of SMIF field.
	SCI0_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI0_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI0_SCMR_SMIF = 0x1
	// Non-smart card interface mode(Asynchronous mode, clock synchronous mode, simple SPI mode, or simple I2C mode)
	SCI0_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI0_SCMR_SMIF_1 = 0x1

	// SEMR: Serial Extended Mode Register
	// Position of RXDESEL field.
	SCI0_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI0_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI0_SEMR_RXDESEL = 0x80
	// The low level on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_0 = 0x0
	// A falling edge on the RXDn pin is detected as the start bit.
	SCI0_SEMR_RXDESEL_1 = 0x1
	// Position of BGDM field.
	SCI0_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI0_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI0_SEMR_BGDM = 0x40
	// Baud rate generator outputs the clock with normal frequency.
	SCI0_SEMR_BGDM_0 = 0x0
	// Baud rate generator outputs the clock with doubled frequency.
	SCI0_SEMR_BGDM_1 = 0x1
	// Position of NFEN field.
	SCI0_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI0_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI0_SEMR_NFEN = 0x20
	// Noise cancellation function for the RXDn/TXDn input signal is disabled.
	SCI0_SEMR_NFEN_0 = 0x0
	// Noise cancellation function for the RXDn/TXDn input signal is enabled.
	SCI0_SEMR_NFEN_1 = 0x1
	// Position of ABCS field.
	SCI0_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI0_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI0_SEMR_ABCS = 0x10
	// Selects 16 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_0 = 0x0
	// Selects 8 base clock cycles for 1-bit period.
	SCI0_SEMR_ABCS_1 = 0x1
	// Position of ABCSE field.
	SCI0_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI0_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI0_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period is decided with combination between BGDM and ABCS in SEMR.
	SCI0_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period and the clock of a double frequency is output from the baud rate generator.
	SCI0_SEMR_ABCSE_1 = 0x1
	// Position of BRME field.
	SCI0_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI0_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI0_SEMR_BRME = 0x4
	// Bit rate modulation function is disabled.
	SCI0_SEMR_BRME_0 = 0x0
	// Bit rate modulation function is enabled.
	SCI0_SEMR_BRME_1 = 0x1
	// Position of Reserved field.
	SCI0_SEMR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SCI0_SEMR_Reserved_Msk = 0x3

	// SNFR: Noise Filter Setting Register
	// Position of Reserved field.
	SCI0_SNFR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SNFR_Reserved_Msk = 0xf8
	// Position of NFCS field.
	SCI0_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI0_SNFR_NFCS_Msk = 0x7
	// The clock signal divided by 1 is used with the noise filter.(In asynchronous mode)
	SCI0_SNFR_NFCS_000 = 0x0
	// The clock signal divided by 1 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_001 = 0x1
	// The clock signal divided by 2 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_010 = 0x2
	// The clock signal divided by 4 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_011 = 0x3
	// The clock signal divided by 8 is used with the noise filter.(In simple I2C mode)
	SCI0_SNFR_NFCS_100 = 0x4

	// SIMR1: I2C Mode Register 1
	// Position of IICDL field.
	SCI0_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI0_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI0_SIMR1_IICDL_00000 = 0x0
	// Position of Reserved field.
	SCI0_SIMR1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SIMR1_Reserved_Msk = 0x6
	// Position of IICM field.
	SCI0_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI0_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI0_SIMR1_IICM = 0x1
	// Asynchronous mode, Multi-processor mode, Clock synchronous mode(SCMR.SMIF=0) /Smart card interface mode(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_0 = 0x0
	// Simple I2C mode(SCMR.SMIF=0) / Setting prohibited.(SCMR.SMIF=1)
	SCI0_SIMR1_IICM_1 = 0x1

	// SIMR2: I2C Mode Register 2
	// Position of Reserved field.
	SCI0_SIMR2_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI0_SIMR2_Reserved_Msk = 0xc0
	// Position of IICACKT field.
	SCI0_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI0_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI0_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI0_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and reception of ACK/NACK
	SCI0_SIMR2_IICACKT_1 = 0x1
	// Position of Reserved field.
	SCI0_SIMR2_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_SIMR2_Reserved_Msk = 0x1c
	// Position of IICCSC field.
	SCI0_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI0_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI0_SIMR2_IICCSC = 0x2
	// No synchronization with the clock signal
	SCI0_SIMR2_IICCSC_0 = 0x0
	// Synchronization with the clock signal
	SCI0_SIMR2_IICCSC_1 = 0x1
	// Position of IICINTM field.
	SCI0_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI0_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI0_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts.
	SCI0_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI0_SIMR2_IICINTM_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI0_SIMR3_IICSCLS_Msk = 0xc0
	// Serial clock output
	SCI0_SIMR3_IICSCLS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSCLS_01 = 0x1
	// Output the low level on the SSCLn pin.
	SCI0_SIMR3_IICSCLS_10 = 0x2
	// Place the SSCLn pin in the high-impedance state.
	SCI0_SIMR3_IICSCLS_11 = 0x3
	// Position of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI0_SIMR3_IICSDAS_Msk = 0x30
	// Serial data output
	SCI0_SIMR3_IICSDAS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI0_SIMR3_IICSDAS_01 = 0x1
	// Output the low level on the SSDAn pin.
	SCI0_SIMR3_IICSDAS_10 = 0x2
	// Place the SSDAn pin in the high-impedance state.
	SCI0_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI0_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI0_SIMR3_IICSTIF = 0x8
	// There are no requests for generating conditions or a condition is being generated.
	SCI0_SIMR3_IICSTIF_0 = 0x0
	// A start, restart, or stop condition is completely generated.
	SCI0_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI0_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI0_SIMR3_IICSTPREQ = 0x4
	// A stop condition is not generated.
	SCI0_SIMR3_IICSTPREQ_0 = 0x0
	// A stop condition is generated.
	SCI0_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI0_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI0_SIMR3_IICRSTAREQ = 0x2
	// A restart condition is not generated.
	SCI0_SIMR3_IICRSTAREQ_0 = 0x0
	// A restart condition is generated.
	SCI0_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI0_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI0_SIMR3_IICSTAREQ = 0x1
	// A start condition is not generated.
	SCI0_SIMR3_IICSTAREQ_0 = 0x0
	// A start condition is generated.
	SCI0_SIMR3_IICSTAREQ_1 = 0x1

	// SISR: IIC Status Register
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x30
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x8
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x4
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x4
	// Position of Reserved field.
	SCI0_SISR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_SISR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_SISR_Reserved = 0x2
	// Position of IICACKR field.
	SCI0_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI0_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI0_SISR_IICACKR = 0x1
	// ACK received
	SCI0_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI0_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of CKPH field.
	SCI0_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI0_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI0_SPMR_CKPH = 0x80
	// Clock is not delayed.
	SCI0_SPMR_CKPH_0 = 0x0
	// Clock is delayed.
	SCI0_SPMR_CKPH_1 = 0x1
	// Position of CKPOL field.
	SCI0_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI0_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI0_SPMR_CKPOL = 0x40
	// Clock polarity is not inverted.
	SCI0_SPMR_CKPOL_0 = 0x0
	// Clock polarity is inverted
	SCI0_SPMR_CKPOL_1 = 0x1
	// Position of Reserved field.
	SCI0_SPMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_SPMR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI0_SPMR_Reserved = 0x20
	// Position of MFF field.
	SCI0_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI0_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI0_SPMR_MFF = 0x10
	// No mode fault error
	SCI0_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI0_SPMR_MFF_1 = 0x1
	// Position of Reserved field.
	SCI0_SPMR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SPMR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI0_SPMR_Reserved = 0x8
	// Position of MSS field.
	SCI0_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI0_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI0_SPMR_MSS = 0x4
	// Transmission is through the TXDn pin and reception is through the RXDn pin (master mode).
	SCI0_SPMR_MSS_0 = 0x0
	// Reception is through the TXDn pin and transmission is through the RXDn pin (slave mode).
	SCI0_SPMR_MSS_1 = 0x1
	// Position of CTSE field.
	SCI0_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI0_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI0_SPMR_CTSE = 0x2
	// CTS function is disabled (RTS output function is enabled).
	SCI0_SPMR_CTSE_0 = 0x0
	// CTS function is enabled.
	SCI0_SPMR_CTSE_1 = 0x1
	// Position of SSE field.
	SCI0_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI0_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI0_SPMR_SSE = 0x1
	// SSn# pin function is disabled.
	SCI0_SPMR_SSE_0 = 0x0
	// SSn# pin function is enabled.
	SCI0_SPMR_SSE_1 = 0x1

	// TDRHL: Transmit 9-bit Data Register
	// Position of TDRHL field.
	SCI0_TDRHL_TDRHL_Pos = 0x0
	// Bit mask of TDRHL field.
	SCI0_TDRHL_TDRHL_Msk = 0xffff

	// FTDRHL: Transmit FIFO Data Register HL
	// Position of Reserved field.
	SCI0_FTDRHL_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	SCI0_FTDRHL_Reserved_Msk = 0xfc00
	// Position of MPBT field.
	SCI0_FTDRHL_MPBT_Pos = 0x9
	// Bit mask of MPBT field.
	SCI0_FTDRHL_MPBT_Msk = 0x200
	// Bit MPBT.
	SCI0_FTDRHL_MPBT = 0x200
	// Data transmission cycles
	SCI0_FTDRHL_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRHL_MPBT_1 = 0x1
	// Position of TDAT field.
	SCI0_FTDRHL_TDAT_Pos = 0x0
	// Bit mask of TDAT field.
	SCI0_FTDRHL_TDAT_Msk = 0x1ff

	// FTDRH: Transmit FIFO Data Register H
	// Position of Reserved field.
	SCI0_FTDRH_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI0_FTDRH_Reserved_Msk = 0xfc
	// Position of MPBT field.
	SCI0_FTDRH_MPBT_Pos = 0x1
	// Bit mask of MPBT field.
	SCI0_FTDRH_MPBT_Msk = 0x2
	// Bit MPBT.
	SCI0_FTDRH_MPBT = 0x2
	// Data transmission cycles
	SCI0_FTDRH_MPBT_0 = 0x0
	// ID transmission cycles
	SCI0_FTDRH_MPBT_1 = 0x1
	// Position of TDATH field.
	SCI0_FTDRH_TDATH_Pos = 0x0
	// Bit mask of TDATH field.
	SCI0_FTDRH_TDATH_Msk = 0x1
	// Bit TDATH.
	SCI0_FTDRH_TDATH = 0x1

	// FTDRL: Transmit FIFO Data Register L
	// Position of TDATL field.
	SCI0_FTDRL_TDATL_Pos = 0x0
	// Bit mask of TDATL field.
	SCI0_FTDRL_TDATL_Msk = 0xff

	// RDRHL: Receive 9-bit Data Register
	// Position of RDRHL field.
	SCI0_RDRHL_RDRHL_Pos = 0x0
	// Bit mask of RDRHL field.
	SCI0_RDRHL_RDRHL_Msk = 0xffff

	// FRDRHL: Receive FIFO Data Register HL
	// Position of Reserved field.
	SCI0_FRDRHL_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	SCI0_FRDRHL_Reserved_Msk = 0x8000
	// Bit Reserved.
	SCI0_FRDRHL_Reserved = 0x8000
	// Position of RDF field.
	SCI0_FRDRHL_RDF_Pos = 0xe
	// Bit mask of RDF field.
	SCI0_FRDRHL_RDF_Msk = 0x4000
	// Bit RDF.
	SCI0_FRDRHL_RDF = 0x4000
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRHL_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRHL_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRHL_ORER_Pos = 0xd
	// Bit mask of ORER field.
	SCI0_FRDRHL_ORER_Msk = 0x2000
	// Bit ORER.
	SCI0_FRDRHL_ORER = 0x2000
	// No overrun error occurred.
	SCI0_FRDRHL_ORER_0 = 0x0
	// An overrun error has occurred.
	SCI0_FRDRHL_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRHL_FER_Pos = 0xc
	// Bit mask of FER field.
	SCI0_FRDRHL_FER_Msk = 0x1000
	// Bit FER.
	SCI0_FRDRHL_FER = 0x1000
	// No framing error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRHL_PER_Pos = 0xb
	// Bit mask of PER field.
	SCI0_FRDRHL_PER_Msk = 0x800
	// Bit PER.
	SCI0_FRDRHL_PER = 0x800
	// No parity error occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL.
	SCI0_FRDRHL_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRHL_DR_Pos = 0xa
	// Bit mask of DR field.
	SCI0_FRDRHL_DR_Msk = 0x400
	// Bit DR.
	SCI0_FRDRHL_DR = 0x400
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRHL_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRHL_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRHL_MPB_Pos = 0x9
	// Bit mask of MPB field.
	SCI0_FRDRHL_MPB_Msk = 0x200
	// Bit MPB.
	SCI0_FRDRHL_MPB = 0x200
	// Data transmission cycles
	SCI0_FRDRHL_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRHL_MPB_1 = 0x1
	// Position of RDAT field.
	SCI0_FRDRHL_RDAT_Pos = 0x0
	// Bit mask of RDAT field.
	SCI0_FRDRHL_RDAT_Msk = 0x1ff

	// FRDRH: Receive FIFO Data Register H
	// Position of Reserved field.
	SCI0_FRDRH_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SCI0_FRDRH_Reserved_Msk = 0x80
	// Bit Reserved.
	SCI0_FRDRH_Reserved = 0x80
	// Position of RDF field.
	SCI0_FRDRH_RDF_Pos = 0x6
	// Bit mask of RDF field.
	SCI0_FRDRH_RDF_Msk = 0x40
	// Bit RDF.
	SCI0_FRDRH_RDF = 0x40
	// The quantity of receive data written in FRDRH and FRDRL falls below the specified receive triggering number.
	SCI0_FRDRH_RDF_0 = 0x0
	// The quantity of receive data written in FRDRH and FRDRL is equal to or greater than the specified receive triggering number.
	SCI0_FRDRH_RDF_1 = 0x1
	// Position of ORER field.
	SCI0_FRDRH_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI0_FRDRH_ORER_Msk = 0x20
	// Bit ORER.
	SCI0_FRDRH_ORER = 0x20
	// No overrun error occurred
	SCI0_FRDRH_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_FRDRH_ORER_1 = 0x1
	// Position of FER field.
	SCI0_FRDRH_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI0_FRDRH_FER_Msk = 0x10
	// Bit FER.
	SCI0_FRDRH_FER = 0x10
	// No framing error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_0 = 0x0
	// A framing error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_FER_1 = 0x1
	// Position of PER field.
	SCI0_FRDRH_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI0_FRDRH_PER_Msk = 0x8
	// Bit PER.
	SCI0_FRDRH_PER = 0x8
	// No parity error occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_0 = 0x0
	// A parity error has occurred at the first data of FRDRH and FRDRL
	SCI0_FRDRH_PER_1 = 0x1
	// Position of DR field.
	SCI0_FRDRH_DR_Pos = 0x2
	// Bit mask of DR field.
	SCI0_FRDRH_DR_Msk = 0x4
	// Bit DR.
	SCI0_FRDRH_DR = 0x4
	// Receiving is in progress, or no received data has remained in FRDRH and FRDRL after normally completed receiving.
	SCI0_FRDRH_DR_0 = 0x0
	// Next receive data has not been received for a period after normal completed receiving.
	SCI0_FRDRH_DR_1 = 0x1
	// Position of MPB field.
	SCI0_FRDRH_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI0_FRDRH_MPB_Msk = 0x2
	// Bit MPB.
	SCI0_FRDRH_MPB = 0x2
	// Data transmission cycles
	SCI0_FRDRH_MPB_0 = 0x0
	// ID transmission cycles
	SCI0_FRDRH_MPB_1 = 0x1
	// Position of RDATH field.
	SCI0_FRDRH_RDATH_Pos = 0x0
	// Bit mask of RDATH field.
	SCI0_FRDRH_RDATH_Msk = 0x1
	// Bit RDATH.
	SCI0_FRDRH_RDATH = 0x1

	// FRDRL: Receive FIFO Data Register L
	// Position of RDATL field.
	SCI0_FRDRL_RDATL_Pos = 0x0
	// Bit mask of RDATL field.
	SCI0_FRDRL_RDATL_Msk = 0xff

	// MDDR: Modulation Duty Register
	// Position of MDDR field.
	SCI0_MDDR_MDDR_Pos = 0x0
	// Bit mask of MDDR field.
	SCI0_MDDR_MDDR_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCME field.
	SCI0_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI0_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI0_DCCR_DCME = 0x80
	// Address match function is disabled.
	SCI0_DCCR_DCME_0 = 0x0
	// Address match function is enabled
	SCI0_DCCR_DCME_1 = 0x1
	// Position of IDSEL field.
	SCI0_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI0_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI0_DCCR_IDSEL = 0x40
	// Always compare data regardless of the value of the MPB bit.
	SCI0_DCCR_IDSEL_0 = 0x0
	// Compare data when the MPB bit is 1 (ID frame) only.
	SCI0_DCCR_IDSEL_1 = 0x1
	// Position of Reserved field.
	SCI0_DCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_DCCR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI0_DCCR_Reserved = 0x20
	// Position of DFER field.
	SCI0_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI0_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI0_DCCR_DFER = 0x10
	// No framing error occurred
	SCI0_DCCR_DFER_0 = 0x0
	// A framing error has occurred
	SCI0_DCCR_DFER_1 = 0x1
	// Position of DPER field.
	SCI0_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI0_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI0_DCCR_DPER = 0x8
	// No parity error occurred
	SCI0_DCCR_DPER_0 = 0x0
	// A parity error has occurred
	SCI0_DCCR_DPER_1 = 0x1
	// Position of Reserved field.
	SCI0_DCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_DCCR_Reserved_Msk = 0x6
	// Position of DCMF field.
	SCI0_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI0_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI0_DCCR_DCMF = 0x1
	// No matched
	SCI0_DCCR_DCMF_0 = 0x0
	// Matched
	SCI0_DCCR_DCMF_1 = 0x1

	// FCR: FIFO Control Register
	// Position of RSTRG field.
	SCI0_FCR_RSTRG_Pos = 0xc
	// Bit mask of RSTRG field.
	SCI0_FCR_RSTRG_Msk = 0xf000
	// Position of RTRG field.
	SCI0_FCR_RTRG_Pos = 0x8
	// Bit mask of RTRG field.
	SCI0_FCR_RTRG_Msk = 0xf00
	// Position of TTRG field.
	SCI0_FCR_TTRG_Pos = 0x4
	// Bit mask of TTRG field.
	SCI0_FCR_TTRG_Msk = 0xf0
	// Position of DRES field.
	SCI0_FCR_DRES_Pos = 0x3
	// Bit mask of DRES field.
	SCI0_FCR_DRES_Msk = 0x8
	// Bit DRES.
	SCI0_FCR_DRES = 0x8
	// Reception data full interrupt (RXIn)
	SCI0_FCR_DRES_0 = 0x0
	// Receive error interrupt (ERIn)
	SCI0_FCR_DRES_1 = 0x1
	// Position of TFRST field.
	SCI0_FCR_TFRST_Pos = 0x2
	// Bit mask of TFRST field.
	SCI0_FCR_TFRST_Msk = 0x4
	// Bit TFRST.
	SCI0_FCR_TFRST = 0x4
	// Not reset to FTDRHL
	SCI0_FCR_TFRST_0 = 0x0
	// Reset to FTDRHL
	SCI0_FCR_TFRST_1 = 0x1
	// Position of RFRST field.
	SCI0_FCR_RFRST_Pos = 0x1
	// Bit mask of RFRST field.
	SCI0_FCR_RFRST_Msk = 0x2
	// Bit RFRST.
	SCI0_FCR_RFRST = 0x2
	// Not reset to FRDRHL
	SCI0_FCR_RFRST_0 = 0x0
	// Reset to FRDRHL
	SCI0_FCR_RFRST_1 = 0x1
	// Position of FM field.
	SCI0_FCR_FM_Pos = 0x0
	// Bit mask of FM field.
	SCI0_FCR_FM_Msk = 0x1
	// Bit FM.
	SCI0_FCR_FM = 0x1
	// Non-FIFO mode
	SCI0_FCR_FM_0 = 0x0
	// FIFO mode
	SCI0_FCR_FM_1 = 0x1

	// FDR: FIFO Data Count Register
	// Position of Reserved field.
	SCI0_FDR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SCI0_FDR_Reserved_Msk = 0xe000
	// Position of T field.
	SCI0_FDR_T_Pos = 0x8
	// Bit mask of T field.
	SCI0_FDR_T_Msk = 0x1f00
	// Position of Reserved field.
	SCI0_FDR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI0_FDR_Reserved_Msk = 0xe0
	// Position of R field.
	SCI0_FDR_R_Pos = 0x0
	// Bit mask of R field.
	SCI0_FDR_R_Msk = 0x1f

	// LSR: Line Status Register
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0xe000
	// Position of PNUM field.
	SCI0_LSR_PNUM_Pos = 0x8
	// Bit mask of PNUM field.
	SCI0_LSR_PNUM_Msk = 0x1f00
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0x80
	// Bit Reserved.
	SCI0_LSR_Reserved = 0x80
	// Position of FNUM field.
	SCI0_LSR_FNUM_Pos = 0x2
	// Bit mask of FNUM field.
	SCI0_LSR_FNUM_Msk = 0x7c
	// Position of Reserved field.
	SCI0_LSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI0_LSR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI0_LSR_Reserved = 0x2
	// Position of ORER field.
	SCI0_LSR_ORER_Pos = 0x0
	// Bit mask of ORER field.
	SCI0_LSR_ORER_Msk = 0x1
	// Bit ORER.
	SCI0_LSR_ORER = 0x1
	// No overrun error occurred
	SCI0_LSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI0_LSR_ORER_1 = 0x1

	// CDR: Compare Match Data Register
	// Position of Reserved field.
	SCI0_CDR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SCI0_CDR_Reserved_Msk = 0xfe00
	// Position of CMPD field.
	SCI0_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI0_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of Reserved field.
	SCI0_SPTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI0_SPTR_Reserved_Msk = 0xf8
	// Position of SPB2IO field.
	SCI0_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI0_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI0_SPTR_SPB2IO = 0x4
	// The value of SPB2DT bit isn't output in TxD terminal.
	SCI0_SPTR_SPB2IO_0 = 0x0
	// The value of SPB2DT bit is output in TxD terminal.
	SCI0_SPTR_SPB2IO_1 = 0x1
	// Position of SPB2DT field.
	SCI0_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI0_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI0_SPTR_SPB2DT = 0x2
	// Low level is output in TxD terminal.
	SCI0_SPTR_SPB2DT_0 = 0x0
	// High level is output in TxD terminal.
	SCI0_SPTR_SPB2DT_1 = 0x1
	// Position of RXDMON field.
	SCI0_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI0_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI0_SPTR_RXDMON = 0x1
	// RXD terminal is the Low level.
	SCI0_SPTR_RXDMON_0 = 0x0
	// RXD terminal is the High level.
	SCI0_SPTR_RXDMON_1 = 0x1
)

// Constants for SCI1: Serial Communication Interface 1
const (
	// SMR: Serial Mode Register (SCMR.SMIF = 0)
	// Position of CM field.
	SCI1_SMR_CM_Pos = 0x7
	// Bit mask of CM field.
	SCI1_SMR_CM_Msk = 0x80
	// Bit CM.
	SCI1_SMR_CM = 0x80
	// Asynchronous mode or simple I2C mode
	SCI1_SMR_CM_0 = 0x0
	// Clock synchronous mode
	SCI1_SMR_CM_1 = 0x1
	// Position of CHR field.
	SCI1_SMR_CHR_Pos = 0x6
	// Bit mask of CHR field.
	SCI1_SMR_CHR_Msk = 0x40
	// Bit CHR.
	SCI1_SMR_CHR = 0x40
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 8bit data length(SCMR.CHR1=1)
	SCI1_SMR_CHR_0 = 0x0
	// Transmit/receive in 9-bit data length(SCMR.CHR1=0) / in 7bit data length(SCMR.CHR1=1)
	SCI1_SMR_CHR_1 = 0x1
	// Position of PE field.
	SCI1_SMR_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_PE = 0x20
	// Parity bit addition is not performed (transmitting) / Parity bit checking is not performed ( receiving )
	SCI1_SMR_PE_0 = 0x0
	// The parity bit is added (transmitting) / The parity bit is checked (receiving)
	SCI1_SMR_PE_1 = 0x1
	// Position of PM field.
	SCI1_SMR_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_PM = 0x10
	// Selects even parity
	SCI1_SMR_PM_0 = 0x0
	// Selects odd parity
	SCI1_SMR_PM_1 = 0x1
	// Position of STOP field.
	SCI1_SMR_STOP_Pos = 0x3
	// Bit mask of STOP field.
	SCI1_SMR_STOP_Msk = 0x8
	// Bit STOP.
	SCI1_SMR_STOP = 0x8
	// 1 stop bit
	SCI1_SMR_STOP_0 = 0x0
	// 2 stop bits
	SCI1_SMR_STOP_1 = 0x1
	// Position of MP field.
	SCI1_SMR_MP_Pos = 0x2
	// Bit mask of MP field.
	SCI1_SMR_MP_Msk = 0x4
	// Bit MP.
	SCI1_SMR_MP = 0x4
	// Multi-processor communications function is disabled
	SCI1_SMR_MP_0 = 0x0
	// Multi-processor communications function is enabled
	SCI1_SMR_MP_1 = 0x1
	// Position of CKS field.
	SCI1_SMR_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_CKS_Msk = 0x3
	// PCLK clock
	SCI1_SMR_CKS_00 = 0x0
	// PCLK/4 clock
	SCI1_SMR_CKS_01 = 0x1
	// PCLK/16 clock
	SCI1_SMR_CKS_10 = 0x2
	// PCLK/64 clock
	SCI1_SMR_CKS_11 = 0x3

	// SMR_SMCI: Serial mode register (SCMR.SMIF = 1)
	// Position of GM field.
	SCI1_SMR_SMCI_GM_Pos = 0x7
	// Bit mask of GM field.
	SCI1_SMR_SMCI_GM_Msk = 0x80
	// Bit GM.
	SCI1_SMR_SMCI_GM = 0x80
	// Normal mode operation
	SCI1_SMR_SMCI_GM_0 = 0x0
	// GSM mode operation
	SCI1_SMR_SMCI_GM_1 = 0x1
	// Position of BLK field.
	SCI1_SMR_SMCI_BLK_Pos = 0x6
	// Bit mask of BLK field.
	SCI1_SMR_SMCI_BLK_Msk = 0x40
	// Bit BLK.
	SCI1_SMR_SMCI_BLK = 0x40
	// Normal mode operation
	SCI1_SMR_SMCI_BLK_0 = 0x0
	// Block transfer mode operation
	SCI1_SMR_SMCI_BLK_1 = 0x1
	// Position of PE field.
	SCI1_SMR_SMCI_PE_Pos = 0x5
	// Bit mask of PE field.
	SCI1_SMR_SMCI_PE_Msk = 0x20
	// Bit PE.
	SCI1_SMR_SMCI_PE = 0x20
	// Setting Prohibited
	SCI1_SMR_SMCI_PE_0 = 0x0
	// Set this bit to 1 in smart card interface mode.
	SCI1_SMR_SMCI_PE_1 = 0x1
	// Position of PM field.
	SCI1_SMR_SMCI_PM_Pos = 0x4
	// Bit mask of PM field.
	SCI1_SMR_SMCI_PM_Msk = 0x10
	// Bit PM.
	SCI1_SMR_SMCI_PM = 0x10
	// Selects even parity
	SCI1_SMR_SMCI_PM_0 = 0x0
	// Selects odd parity
	SCI1_SMR_SMCI_PM_1 = 0x1
	// Position of BCP field.
	SCI1_SMR_SMCI_BCP_Pos = 0x2
	// Bit mask of BCP field.
	SCI1_SMR_SMCI_BCP_Msk = 0xc
	// 93 clock cycles(S=93) (SCMR.BCP2=0) / 32 clock cycles(S=32) (SCMR.BCP2=1)
	SCI1_SMR_SMCI_BCP_00 = 0x0
	// 128 clock cycles(S=128) (SCMR.BCP2=0) / 64 clock cycles(S=64) (SCMR.BCP2=1)
	SCI1_SMR_SMCI_BCP_01 = 0x1
	// 186 clock cycles(S=186) (SCMR.BCP2=0) / 372 clock cycles(S=372) (SCMR.BCP2=1)
	SCI1_SMR_SMCI_BCP_10 = 0x2
	// 512 clock cycles(S=512) (SCMR.BCP2=0) / 256 clock cycles(S=256) (SCMR.BCP2=1)
	SCI1_SMR_SMCI_BCP_11 = 0x3
	// Position of CKS field.
	SCI1_SMR_SMCI_CKS_Pos = 0x0
	// Bit mask of CKS field.
	SCI1_SMR_SMCI_CKS_Msk = 0x3
	// PCLK clock
	SCI1_SMR_SMCI_CKS_00 = 0x0
	// PCLK/4 clock
	SCI1_SMR_SMCI_CKS_01 = 0x1
	// PCLK/16 clock
	SCI1_SMR_SMCI_CKS_10 = 0x2
	// PCLK/64 clock
	SCI1_SMR_SMCI_CKS_11 = 0x3

	// BRR: Bit Rate Register
	// Position of BRR field.
	SCI1_BRR_BRR_Pos = 0x0
	// Bit mask of BRR field.
	SCI1_BRR_BRR_Msk = 0xff

	// SCR: Serial Control Register (SCMR.SMIF = 0)
	// Position of TIE field.
	SCI1_SCR_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_TIE = 0x80
	// TXI interrupt request is disabled
	SCI1_SCR_TIE_0 = 0x0
	// TXI interrupt request is enabled
	SCI1_SCR_TIE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI1_SCR_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI1_SCR_RIE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_TE = 0x20
	// Serial transmission is disabled
	SCI1_SCR_TE_0 = 0x0
	// Serial transmission is enabled
	SCI1_SCR_TE_1 = 0x1
	// Position of RE field.
	SCI1_SCR_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_RE = 0x10
	// Serial reception is disabled
	SCI1_SCR_RE_0 = 0x0
	// Serial reception is enabled
	SCI1_SCR_RE_1 = 0x1
	// Position of MPIE field.
	SCI1_SCR_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_MPIE = 0x8
	// Normal reception
	SCI1_SCR_MPIE_0 = 0x0
	// When the data with the multi-processor bit set to 0 is received, the data is not read, and setting the status flags RDRF,ORER and FER in SSR to 1 is disabled. When the data with the multiprocessor bit set to 1 is received, the MPIE bit is automatically cleared to 0, and normal reception is resumed.
	SCI1_SCR_MPIE_1 = 0x1
	// Position of TEIE field.
	SCI1_SCR_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_TEIE = 0x4
	// TEI interrupt request is disabled
	SCI1_SCR_TEIE_0 = 0x0
	// TEI interrupt request is enabled
	SCI1_SCR_TEIE_1 = 0x1
	// Position of CKE field.
	SCI1_SCR_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_CKE_Msk = 0x3
	// The SCKn pin is available for use as an I/O port in accord with the I/O port settings.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI1_SCR_CKE_00 = 0x0
	// The clock with the same frequency as the bit rate is output from the SCKn pin.(Asynchronous mode) / The SCKn pin functions as the clock output pin(Clock synchronous mode)
	SCI1_SCR_CKE_01 = 0x1

	// SCR_SMCI: Serial Control Register (SCMR.SMIF =1)
	// Position of TIE field.
	SCI1_SCR_SMCI_TIE_Pos = 0x7
	// Bit mask of TIE field.
	SCI1_SCR_SMCI_TIE_Msk = 0x80
	// Bit TIE.
	SCI1_SCR_SMCI_TIE = 0x80
	// A TXI interrupt request is disabled
	SCI1_SCR_SMCI_TIE_0 = 0x0
	// A TXI interrupt request is enabled
	SCI1_SCR_SMCI_TIE_1 = 0x1
	// Position of RIE field.
	SCI1_SCR_SMCI_RIE_Pos = 0x6
	// Bit mask of RIE field.
	SCI1_SCR_SMCI_RIE_Msk = 0x40
	// Bit RIE.
	SCI1_SCR_SMCI_RIE = 0x40
	// RXI and ERI interrupt requests are disabled
	SCI1_SCR_SMCI_RIE_0 = 0x0
	// RXI and ERI interrupt requests are enabled
	SCI1_SCR_SMCI_RIE_1 = 0x1
	// Position of TE field.
	SCI1_SCR_SMCI_TE_Pos = 0x5
	// Bit mask of TE field.
	SCI1_SCR_SMCI_TE_Msk = 0x20
	// Bit TE.
	SCI1_SCR_SMCI_TE = 0x20
	// Serial transmission is disabled
	SCI1_SCR_SMCI_TE_0 = 0x0
	// Serial transmission is enabled
	SCI1_SCR_SMCI_TE_1 = 0x1
	// Position of RE field.
	SCI1_SCR_SMCI_RE_Pos = 0x4
	// Bit mask of RE field.
	SCI1_SCR_SMCI_RE_Msk = 0x10
	// Bit RE.
	SCI1_SCR_SMCI_RE = 0x10
	// Serial reception is disabled
	SCI1_SCR_SMCI_RE_0 = 0x0
	// Serial reception is enabled
	SCI1_SCR_SMCI_RE_1 = 0x1
	// Position of MPIE field.
	SCI1_SCR_SMCI_MPIE_Pos = 0x3
	// Bit mask of MPIE field.
	SCI1_SCR_SMCI_MPIE_Msk = 0x8
	// Bit MPIE.
	SCI1_SCR_SMCI_MPIE = 0x8
	// Position of TEIE field.
	SCI1_SCR_SMCI_TEIE_Pos = 0x2
	// Bit mask of TEIE field.
	SCI1_SCR_SMCI_TEIE_Msk = 0x4
	// Bit TEIE.
	SCI1_SCR_SMCI_TEIE = 0x4
	// Position of CKE field.
	SCI1_SCR_SMCI_CKE_Pos = 0x0
	// Bit mask of CKE field.
	SCI1_SCR_SMCI_CKE_Msk = 0x3
	// Output disabled(SMR_SMCI.GM=0) / Output fixed low(SMR_SMCI.GM=1)
	SCI1_SCR_SMCI_CKE_00 = 0x0
	// Clock Output
	SCI1_SCR_SMCI_CKE_01 = 0x1
	// Setting prohibited(SMR_SMCI.GM=0) / Output fixed High(SMR_SMCI.GM=1)
	SCI1_SCR_SMCI_CKE_10 = 0x2
	// Setting prohibited(SMR_SMCI.GM=0) / Clock Output(SMR_SMCI.GM=1)
	SCI1_SCR_SMCI_CKE_11 = 0x3

	// TDR: Transmit Data Register
	// Position of TDR field.
	SCI1_TDR_TDR_Pos = 0x0
	// Bit mask of TDR field.
	SCI1_TDR_TDR_Msk = 0xff

	// SSR: Serial Status Register(SCMR.SMIF = 0 and FCR.FM=0)
	// Position of TDRE field.
	SCI1_SSR_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_TDRE = 0x80
	// Transmit data is in TDR register
	SCI1_SSR_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI1_SSR_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_RDRF = 0x40
	// No received data is in RDR register
	SCI1_SSR_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI1_SSR_RDRF_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_ORER_0 = 0x0
	// An overrun error has occurred
	SCI1_SSR_ORER_1 = 0x1
	// Position of FER field.
	SCI1_SSR_FER_Pos = 0x4
	// Bit mask of FER field.
	SCI1_SSR_FER_Msk = 0x10
	// Bit FER.
	SCI1_SSR_FER = 0x10
	// No framing error occurred
	SCI1_SSR_FER_0 = 0x0
	// A framing error has occurred
	SCI1_SSR_FER_1 = 0x1
	// Position of PER field.
	SCI1_SSR_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_PER = 0x8
	// No parity error occurred
	SCI1_SSR_PER_0 = 0x0
	// A parity error has occurred
	SCI1_SSR_PER_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_TEND = 0x4
	// A character is being transmitted.
	SCI1_SSR_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI1_SSR_TEND_1 = 0x1
	// Position of MPB field.
	SCI1_SSR_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_MPB = 0x2
	// Data transmission cycles
	SCI1_SSR_MPB_0 = 0x0
	// ID transmission cycles
	SCI1_SSR_MPB_1 = 0x1
	// Position of MPBT field.
	SCI1_SSR_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_MPBT = 0x1
	// Data transmission cycles
	SCI1_SSR_MPBT_0 = 0x0
	// ID transmission cycles
	SCI1_SSR_MPBT_1 = 0x1

	// SSR_SMCI: Serial Status Register(SCMR.SMIF = 1)
	// Position of TDRE field.
	SCI1_SSR_SMCI_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	SCI1_SSR_SMCI_TDRE_Msk = 0x80
	// Bit TDRE.
	SCI1_SSR_SMCI_TDRE = 0x80
	// Transmit data is in TDR register
	SCI1_SSR_SMCI_TDRE_0 = 0x0
	// No transmit data is in TDR register
	SCI1_SSR_SMCI_TDRE_1 = 0x1
	// Position of RDRF field.
	SCI1_SSR_SMCI_RDRF_Pos = 0x6
	// Bit mask of RDRF field.
	SCI1_SSR_SMCI_RDRF_Msk = 0x40
	// Bit RDRF.
	SCI1_SSR_SMCI_RDRF = 0x40
	// No received data is in RDR register
	SCI1_SSR_SMCI_RDRF_0 = 0x0
	// Received data is in RDR register
	SCI1_SSR_SMCI_RDRF_1 = 0x1
	// Position of ORER field.
	SCI1_SSR_SMCI_ORER_Pos = 0x5
	// Bit mask of ORER field.
	SCI1_SSR_SMCI_ORER_Msk = 0x20
	// Bit ORER.
	SCI1_SSR_SMCI_ORER = 0x20
	// No overrun error occurred
	SCI1_SSR_SMCI_ORER_0 = 0x0
	// An overrun error has occurred
	SCI1_SSR_SMCI_ORER_1 = 0x1
	// Position of ERS field.
	SCI1_SSR_SMCI_ERS_Pos = 0x4
	// Bit mask of ERS field.
	SCI1_SSR_SMCI_ERS_Msk = 0x10
	// Bit ERS.
	SCI1_SSR_SMCI_ERS = 0x10
	// Low error signal not responded
	SCI1_SSR_SMCI_ERS_0 = 0x0
	// Low error signal responded
	SCI1_SSR_SMCI_ERS_1 = 0x1
	// Position of PER field.
	SCI1_SSR_SMCI_PER_Pos = 0x3
	// Bit mask of PER field.
	SCI1_SSR_SMCI_PER_Msk = 0x8
	// Bit PER.
	SCI1_SSR_SMCI_PER = 0x8
	// No parity error occurred
	SCI1_SSR_SMCI_PER_0 = 0x0
	// A parity error has occurred
	SCI1_SSR_SMCI_PER_1 = 0x1
	// Position of TEND field.
	SCI1_SSR_SMCI_TEND_Pos = 0x2
	// Bit mask of TEND field.
	SCI1_SSR_SMCI_TEND_Msk = 0x4
	// Bit TEND.
	SCI1_SSR_SMCI_TEND = 0x4
	// A character is being transmitted.
	SCI1_SSR_SMCI_TEND_0 = 0x0
	// Character transfer has been completed.
	SCI1_SSR_SMCI_TEND_1 = 0x1
	// Position of MPB field.
	SCI1_SSR_SMCI_MPB_Pos = 0x1
	// Bit mask of MPB field.
	SCI1_SSR_SMCI_MPB_Msk = 0x2
	// Bit MPB.
	SCI1_SSR_SMCI_MPB = 0x2
	// Position of MPBT field.
	SCI1_SSR_SMCI_MPBT_Pos = 0x0
	// Bit mask of MPBT field.
	SCI1_SSR_SMCI_MPBT_Msk = 0x1
	// Bit MPBT.
	SCI1_SSR_SMCI_MPBT = 0x1

	// RDR: Receive Data Register
	// Position of RDR field.
	SCI1_RDR_RDR_Pos = 0x0
	// Bit mask of RDR field.
	SCI1_RDR_RDR_Msk = 0xff

	// SCMR: Smart Card Mode Register
	// Position of BCP2 field.
	SCI1_SCMR_BCP2_Pos = 0x7
	// Bit mask of BCP2 field.
	SCI1_SCMR_BCP2_Msk = 0x80
	// Bit BCP2.
	SCI1_SCMR_BCP2 = 0x80
	// S=93(SMR.BCP[1:0]=00), 128(SMR.BCP[1:0]=01), 186(SMR.BCP[1:0]=10), 512(SMR.BCP[1:0]=11)
	SCI1_SCMR_BCP2_0 = 0x0
	// S=32(SMR.BCP[1:0]=00), 64(SMR.BCP[1:0]=01), 372(SMR.BCP[1:0]=10), 256(SMR.BCP[1:0]=11)
	SCI1_SCMR_BCP2_1 = 0x1
	// Position of Reserved field.
	SCI1_SCMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI1_SCMR_Reserved_Msk = 0x60
	// Position of CHR1 field.
	SCI1_SCMR_CHR1_Pos = 0x4
	// Bit mask of CHR1 field.
	SCI1_SCMR_CHR1_Msk = 0x10
	// Bit CHR1.
	SCI1_SCMR_CHR1 = 0x10
	// Transmit/receive in 9-bit data length
	SCI1_SCMR_CHR1_0 = 0x0
	// Transmit/receive in 8-bit data length(SMR.CHR=0) / in 7bit data length(SMR.CHR=1)
	SCI1_SCMR_CHR1_1 = 0x1
	// Position of SDIR field.
	SCI1_SCMR_SDIR_Pos = 0x3
	// Bit mask of SDIR field.
	SCI1_SCMR_SDIR_Msk = 0x8
	// Bit SDIR.
	SCI1_SCMR_SDIR = 0x8
	// Transfer with LSB first
	SCI1_SCMR_SDIR_0 = 0x0
	// Transfer with MSB first
	SCI1_SCMR_SDIR_1 = 0x1
	// Position of SINV field.
	SCI1_SCMR_SINV_Pos = 0x2
	// Bit mask of SINV field.
	SCI1_SCMR_SINV_Msk = 0x4
	// Bit SINV.
	SCI1_SCMR_SINV = 0x4
	// TDR contents are transmitted as they are. Receive data is stored as it is in RDR.
	SCI1_SCMR_SINV_0 = 0x0
	// TDR contents are inverted before being transmitted. Receive data is stored in inverted form in RDR.
	SCI1_SCMR_SINV_1 = 0x1
	// Position of Reserved field.
	SCI1_SCMR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI1_SCMR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI1_SCMR_Reserved = 0x2
	// Position of SMIF field.
	SCI1_SCMR_SMIF_Pos = 0x0
	// Bit mask of SMIF field.
	SCI1_SCMR_SMIF_Msk = 0x1
	// Bit SMIF.
	SCI1_SCMR_SMIF = 0x1
	// Non-smart card interface mode(Asynchronous mode, clock synchronous mode, simple SPI mode, or simple I2C mode)
	SCI1_SCMR_SMIF_0 = 0x0
	// Smart card interface mode
	SCI1_SCMR_SMIF_1 = 0x1

	// SEMR: Serial Extended Mode Register
	// Position of RXDESEL field.
	SCI1_SEMR_RXDESEL_Pos = 0x7
	// Bit mask of RXDESEL field.
	SCI1_SEMR_RXDESEL_Msk = 0x80
	// Bit RXDESEL.
	SCI1_SEMR_RXDESEL = 0x80
	// The low level on the RXDn pin is detected as the start bit.
	SCI1_SEMR_RXDESEL_0 = 0x0
	// A falling edge on the RXDn pin is detected as the start bit.
	SCI1_SEMR_RXDESEL_1 = 0x1
	// Position of BGDM field.
	SCI1_SEMR_BGDM_Pos = 0x6
	// Bit mask of BGDM field.
	SCI1_SEMR_BGDM_Msk = 0x40
	// Bit BGDM.
	SCI1_SEMR_BGDM = 0x40
	// Baud rate generator outputs the clock with normal frequency.
	SCI1_SEMR_BGDM_0 = 0x0
	// Baud rate generator outputs the clock with doubled frequency.
	SCI1_SEMR_BGDM_1 = 0x1
	// Position of NFEN field.
	SCI1_SEMR_NFEN_Pos = 0x5
	// Bit mask of NFEN field.
	SCI1_SEMR_NFEN_Msk = 0x20
	// Bit NFEN.
	SCI1_SEMR_NFEN = 0x20
	// Noise cancellation function for the RXDn/TXDn input signal is disabled.
	SCI1_SEMR_NFEN_0 = 0x0
	// Noise cancellation function for the RXDn/TXDn input signal is enabled.
	SCI1_SEMR_NFEN_1 = 0x1
	// Position of ABCS field.
	SCI1_SEMR_ABCS_Pos = 0x4
	// Bit mask of ABCS field.
	SCI1_SEMR_ABCS_Msk = 0x10
	// Bit ABCS.
	SCI1_SEMR_ABCS = 0x10
	// Selects 16 base clock cycles for 1-bit period.
	SCI1_SEMR_ABCS_0 = 0x0
	// Selects 8 base clock cycles for 1-bit period.
	SCI1_SEMR_ABCS_1 = 0x1
	// Position of ABCSE field.
	SCI1_SEMR_ABCSE_Pos = 0x3
	// Bit mask of ABCSE field.
	SCI1_SEMR_ABCSE_Msk = 0x8
	// Bit ABCSE.
	SCI1_SEMR_ABCSE = 0x8
	// Clock cycles for 1-bit period is decided with combination between BGDM and ABCS in SEMR.
	SCI1_SEMR_ABCSE_0 = 0x0
	// Baud rate is 6 base clock cycles for 1-bit period and the clock of a double frequency is output from the baud rate generator.
	SCI1_SEMR_ABCSE_1 = 0x1
	// Position of BRME field.
	SCI1_SEMR_BRME_Pos = 0x2
	// Bit mask of BRME field.
	SCI1_SEMR_BRME_Msk = 0x4
	// Bit BRME.
	SCI1_SEMR_BRME = 0x4
	// Bit rate modulation function is disabled.
	SCI1_SEMR_BRME_0 = 0x0
	// Bit rate modulation function is enabled.
	SCI1_SEMR_BRME_1 = 0x1
	// Position of Reserved field.
	SCI1_SEMR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SCI1_SEMR_Reserved_Msk = 0x3

	// SNFR: Noise Filter Setting Register
	// Position of Reserved field.
	SCI1_SNFR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI1_SNFR_Reserved_Msk = 0xf8
	// Position of NFCS field.
	SCI1_SNFR_NFCS_Pos = 0x0
	// Bit mask of NFCS field.
	SCI1_SNFR_NFCS_Msk = 0x7
	// The clock signal divided by 1 is used with the noise filter.(In asynchronous mode)
	SCI1_SNFR_NFCS_000 = 0x0
	// The clock signal divided by 1 is used with the noise filter.(In simple I2C mode)
	SCI1_SNFR_NFCS_001 = 0x1
	// The clock signal divided by 2 is used with the noise filter.(In simple I2C mode)
	SCI1_SNFR_NFCS_010 = 0x2
	// The clock signal divided by 4 is used with the noise filter.(In simple I2C mode)
	SCI1_SNFR_NFCS_011 = 0x3
	// The clock signal divided by 8 is used with the noise filter.(In simple I2C mode)
	SCI1_SNFR_NFCS_100 = 0x4

	// SIMR1: I2C Mode Register 1
	// Position of IICDL field.
	SCI1_SIMR1_IICDL_Pos = 0x3
	// Bit mask of IICDL field.
	SCI1_SIMR1_IICDL_Msk = 0xf8
	// No output delay
	SCI1_SIMR1_IICDL_00000 = 0x0
	// Position of Reserved field.
	SCI1_SIMR1_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI1_SIMR1_Reserved_Msk = 0x6
	// Position of IICM field.
	SCI1_SIMR1_IICM_Pos = 0x0
	// Bit mask of IICM field.
	SCI1_SIMR1_IICM_Msk = 0x1
	// Bit IICM.
	SCI1_SIMR1_IICM = 0x1
	// Asynchronous mode, Multi-processor mode, Clock synchronous mode(SCMR.SMIF=0) /Smart card interface mode(SCMR.SMIF=1)
	SCI1_SIMR1_IICM_0 = 0x0
	// Simple I2C mode(SCMR.SMIF=0) / Setting prohibited.(SCMR.SMIF=1)
	SCI1_SIMR1_IICM_1 = 0x1

	// SIMR2: I2C Mode Register 2
	// Position of Reserved field.
	SCI1_SIMR2_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI1_SIMR2_Reserved_Msk = 0xc0
	// Position of IICACKT field.
	SCI1_SIMR2_IICACKT_Pos = 0x5
	// Bit mask of IICACKT field.
	SCI1_SIMR2_IICACKT_Msk = 0x20
	// Bit IICACKT.
	SCI1_SIMR2_IICACKT = 0x20
	// ACK transmission
	SCI1_SIMR2_IICACKT_0 = 0x0
	// NACK transmission and reception of ACK/NACK
	SCI1_SIMR2_IICACKT_1 = 0x1
	// Position of Reserved field.
	SCI1_SIMR2_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI1_SIMR2_Reserved_Msk = 0x1c
	// Position of IICCSC field.
	SCI1_SIMR2_IICCSC_Pos = 0x1
	// Bit mask of IICCSC field.
	SCI1_SIMR2_IICCSC_Msk = 0x2
	// Bit IICCSC.
	SCI1_SIMR2_IICCSC = 0x2
	// No synchronization with the clock signal
	SCI1_SIMR2_IICCSC_0 = 0x0
	// Synchronization with the clock signal
	SCI1_SIMR2_IICCSC_1 = 0x1
	// Position of IICINTM field.
	SCI1_SIMR2_IICINTM_Pos = 0x0
	// Bit mask of IICINTM field.
	SCI1_SIMR2_IICINTM_Msk = 0x1
	// Bit IICINTM.
	SCI1_SIMR2_IICINTM = 0x1
	// Use ACK/NACK interrupts.
	SCI1_SIMR2_IICINTM_0 = 0x0
	// Use reception and transmission interrupts
	SCI1_SIMR2_IICINTM_1 = 0x1

	// SIMR3: IIC Mode Register 3
	// Position of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Pos = 0x6
	// Bit mask of IICSCLS field.
	SCI1_SIMR3_IICSCLS_Msk = 0xc0
	// Serial clock output
	SCI1_SIMR3_IICSCLS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI1_SIMR3_IICSCLS_01 = 0x1
	// Output the low level on the SSCLn pin.
	SCI1_SIMR3_IICSCLS_10 = 0x2
	// Place the SSCLn pin in the high-impedance state.
	SCI1_SIMR3_IICSCLS_11 = 0x3
	// Position of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Pos = 0x4
	// Bit mask of IICSDAS field.
	SCI1_SIMR3_IICSDAS_Msk = 0x30
	// Serial data output
	SCI1_SIMR3_IICSDAS_00 = 0x0
	// Generate a start, restart, or stop condition.
	SCI1_SIMR3_IICSDAS_01 = 0x1
	// Output the low level on the SSDAn pin.
	SCI1_SIMR3_IICSDAS_10 = 0x2
	// Place the SSDAn pin in the high-impedance state.
	SCI1_SIMR3_IICSDAS_11 = 0x3
	// Position of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Pos = 0x3
	// Bit mask of IICSTIF field.
	SCI1_SIMR3_IICSTIF_Msk = 0x8
	// Bit IICSTIF.
	SCI1_SIMR3_IICSTIF = 0x8
	// There are no requests for generating conditions or a condition is being generated.
	SCI1_SIMR3_IICSTIF_0 = 0x0
	// A start, restart, or stop condition is completely generated.
	SCI1_SIMR3_IICSTIF_1 = 0x1
	// Position of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Pos = 0x2
	// Bit mask of IICSTPREQ field.
	SCI1_SIMR3_IICSTPREQ_Msk = 0x4
	// Bit IICSTPREQ.
	SCI1_SIMR3_IICSTPREQ = 0x4
	// A stop condition is not generated.
	SCI1_SIMR3_IICSTPREQ_0 = 0x0
	// A stop condition is generated.
	SCI1_SIMR3_IICSTPREQ_1 = 0x1
	// Position of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Pos = 0x1
	// Bit mask of IICRSTAREQ field.
	SCI1_SIMR3_IICRSTAREQ_Msk = 0x2
	// Bit IICRSTAREQ.
	SCI1_SIMR3_IICRSTAREQ = 0x2
	// A restart condition is not generated.
	SCI1_SIMR3_IICRSTAREQ_0 = 0x0
	// A restart condition is generated.
	SCI1_SIMR3_IICRSTAREQ_1 = 0x1
	// Position of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Pos = 0x0
	// Bit mask of IICSTAREQ field.
	SCI1_SIMR3_IICSTAREQ_Msk = 0x1
	// Bit IICSTAREQ.
	SCI1_SIMR3_IICSTAREQ = 0x1
	// A start condition is not generated.
	SCI1_SIMR3_IICSTAREQ_0 = 0x0
	// A start condition is generated.
	SCI1_SIMR3_IICSTAREQ_1 = 0x1

	// SISR: IIC Status Register
	// Position of Reserved field.
	SCI1_SISR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SCI1_SISR_Reserved_Msk = 0xc0
	// Position of Reserved field.
	SCI1_SISR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SCI1_SISR_Reserved_Msk = 0x30
	// Position of Reserved field.
	SCI1_SISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI1_SISR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI1_SISR_Reserved = 0x8
	// Position of Reserved field.
	SCI1_SISR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SCI1_SISR_Reserved_Msk = 0x4
	// Bit Reserved.
	SCI1_SISR_Reserved = 0x4
	// Position of Reserved field.
	SCI1_SISR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI1_SISR_Reserved_Msk = 0x2
	// Bit Reserved.
	SCI1_SISR_Reserved = 0x2
	// Position of IICACKR field.
	SCI1_SISR_IICACKR_Pos = 0x0
	// Bit mask of IICACKR field.
	SCI1_SISR_IICACKR_Msk = 0x1
	// Bit IICACKR.
	SCI1_SISR_IICACKR = 0x1
	// ACK received
	SCI1_SISR_IICACKR_0 = 0x0
	// NACK received
	SCI1_SISR_IICACKR_1 = 0x1

	// SPMR: SPI Mode Register
	// Position of CKPH field.
	SCI1_SPMR_CKPH_Pos = 0x7
	// Bit mask of CKPH field.
	SCI1_SPMR_CKPH_Msk = 0x80
	// Bit CKPH.
	SCI1_SPMR_CKPH = 0x80
	// Clock is not delayed.
	SCI1_SPMR_CKPH_0 = 0x0
	// Clock is delayed.
	SCI1_SPMR_CKPH_1 = 0x1
	// Position of CKPOL field.
	SCI1_SPMR_CKPOL_Pos = 0x6
	// Bit mask of CKPOL field.
	SCI1_SPMR_CKPOL_Msk = 0x40
	// Bit CKPOL.
	SCI1_SPMR_CKPOL = 0x40
	// Clock polarity is not inverted.
	SCI1_SPMR_CKPOL_0 = 0x0
	// Clock polarity is inverted
	SCI1_SPMR_CKPOL_1 = 0x1
	// Position of Reserved field.
	SCI1_SPMR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI1_SPMR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI1_SPMR_Reserved = 0x20
	// Position of MFF field.
	SCI1_SPMR_MFF_Pos = 0x4
	// Bit mask of MFF field.
	SCI1_SPMR_MFF_Msk = 0x10
	// Bit MFF.
	SCI1_SPMR_MFF = 0x10
	// No mode fault error
	SCI1_SPMR_MFF_0 = 0x0
	// Mode fault error
	SCI1_SPMR_MFF_1 = 0x1
	// Position of Reserved field.
	SCI1_SPMR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI1_SPMR_Reserved_Msk = 0x8
	// Bit Reserved.
	SCI1_SPMR_Reserved = 0x8
	// Position of MSS field.
	SCI1_SPMR_MSS_Pos = 0x2
	// Bit mask of MSS field.
	SCI1_SPMR_MSS_Msk = 0x4
	// Bit MSS.
	SCI1_SPMR_MSS = 0x4
	// Transmission is through the TXDn pin and reception is through the RXDn pin (master mode).
	SCI1_SPMR_MSS_0 = 0x0
	// Reception is through the TXDn pin and transmission is through the RXDn pin (slave mode).
	SCI1_SPMR_MSS_1 = 0x1
	// Position of CTSE field.
	SCI1_SPMR_CTSE_Pos = 0x1
	// Bit mask of CTSE field.
	SCI1_SPMR_CTSE_Msk = 0x2
	// Bit CTSE.
	SCI1_SPMR_CTSE = 0x2
	// CTS function is disabled (RTS output function is enabled).
	SCI1_SPMR_CTSE_0 = 0x0
	// CTS function is enabled.
	SCI1_SPMR_CTSE_1 = 0x1
	// Position of SSE field.
	SCI1_SPMR_SSE_Pos = 0x0
	// Bit mask of SSE field.
	SCI1_SPMR_SSE_Msk = 0x1
	// Bit SSE.
	SCI1_SPMR_SSE = 0x1
	// SSn# pin function is disabled.
	SCI1_SPMR_SSE_0 = 0x0
	// SSn# pin function is enabled.
	SCI1_SPMR_SSE_1 = 0x1

	// TDRHL: Transmit 9-bit Data Register
	// Position of TDRHL field.
	SCI1_TDRHL_TDRHL_Pos = 0x0
	// Bit mask of TDRHL field.
	SCI1_TDRHL_TDRHL_Msk = 0xffff

	// RDRHL: Receive 9-bit Data Register
	// Position of RDRHL field.
	SCI1_RDRHL_RDRHL_Pos = 0x0
	// Bit mask of RDRHL field.
	SCI1_RDRHL_RDRHL_Msk = 0xffff

	// MDDR: Modulation Duty Register
	// Position of MDDR field.
	SCI1_MDDR_MDDR_Pos = 0x0
	// Bit mask of MDDR field.
	SCI1_MDDR_MDDR_Msk = 0xff

	// DCCR: Data Compare Match Control Register
	// Position of DCME field.
	SCI1_DCCR_DCME_Pos = 0x7
	// Bit mask of DCME field.
	SCI1_DCCR_DCME_Msk = 0x80
	// Bit DCME.
	SCI1_DCCR_DCME = 0x80
	// Address match function is disabled.
	SCI1_DCCR_DCME_0 = 0x0
	// Address match function is enabled
	SCI1_DCCR_DCME_1 = 0x1
	// Position of IDSEL field.
	SCI1_DCCR_IDSEL_Pos = 0x6
	// Bit mask of IDSEL field.
	SCI1_DCCR_IDSEL_Msk = 0x40
	// Bit IDSEL.
	SCI1_DCCR_IDSEL = 0x40
	// Always compare data regardless of the value of the MPB bit.
	SCI1_DCCR_IDSEL_0 = 0x0
	// Compare data when the MPB bit is 1 (ID frame) only.
	SCI1_DCCR_IDSEL_1 = 0x1
	// Position of Reserved field.
	SCI1_DCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SCI1_DCCR_Reserved_Msk = 0x20
	// Bit Reserved.
	SCI1_DCCR_Reserved = 0x20
	// Position of DFER field.
	SCI1_DCCR_DFER_Pos = 0x4
	// Bit mask of DFER field.
	SCI1_DCCR_DFER_Msk = 0x10
	// Bit DFER.
	SCI1_DCCR_DFER = 0x10
	// No framing error occurred
	SCI1_DCCR_DFER_0 = 0x0
	// A framing error has occurred
	SCI1_DCCR_DFER_1 = 0x1
	// Position of DPER field.
	SCI1_DCCR_DPER_Pos = 0x3
	// Bit mask of DPER field.
	SCI1_DCCR_DPER_Msk = 0x8
	// Bit DPER.
	SCI1_DCCR_DPER = 0x8
	// No parity error occurred
	SCI1_DCCR_DPER_0 = 0x0
	// A parity error has occurred
	SCI1_DCCR_DPER_1 = 0x1
	// Position of Reserved field.
	SCI1_DCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SCI1_DCCR_Reserved_Msk = 0x6
	// Position of DCMF field.
	SCI1_DCCR_DCMF_Pos = 0x0
	// Bit mask of DCMF field.
	SCI1_DCCR_DCMF_Msk = 0x1
	// Bit DCMF.
	SCI1_DCCR_DCMF = 0x1
	// No matched
	SCI1_DCCR_DCMF_0 = 0x0
	// Matched
	SCI1_DCCR_DCMF_1 = 0x1

	// CDR: Compare Match Data Register
	// Position of Reserved field.
	SCI1_CDR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SCI1_CDR_Reserved_Msk = 0xfe00
	// Position of CMPD field.
	SCI1_CDR_CMPD_Pos = 0x0
	// Bit mask of CMPD field.
	SCI1_CDR_CMPD_Msk = 0x1ff

	// SPTR: Serial Port Register
	// Position of Reserved field.
	SCI1_SPTR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SCI1_SPTR_Reserved_Msk = 0xf8
	// Position of SPB2IO field.
	SCI1_SPTR_SPB2IO_Pos = 0x2
	// Bit mask of SPB2IO field.
	SCI1_SPTR_SPB2IO_Msk = 0x4
	// Bit SPB2IO.
	SCI1_SPTR_SPB2IO = 0x4
	// The value of SPB2DT bit isn't output in TxD terminal.
	SCI1_SPTR_SPB2IO_0 = 0x0
	// The value of SPB2DT bit is output in TxD terminal.
	SCI1_SPTR_SPB2IO_1 = 0x1
	// Position of SPB2DT field.
	SCI1_SPTR_SPB2DT_Pos = 0x1
	// Bit mask of SPB2DT field.
	SCI1_SPTR_SPB2DT_Msk = 0x2
	// Bit SPB2DT.
	SCI1_SPTR_SPB2DT = 0x2
	// Low level is output in TxD terminal.
	SCI1_SPTR_SPB2DT_0 = 0x0
	// High level is output in TxD terminal.
	SCI1_SPTR_SPB2DT_1 = 0x1
	// Position of RXDMON field.
	SCI1_SPTR_RXDMON_Pos = 0x0
	// Bit mask of RXDMON field.
	SCI1_SPTR_RXDMON_Msk = 0x1
	// Bit RXDMON.
	SCI1_SPTR_RXDMON = 0x1
	// RXD terminal is the Low level.
	SCI1_SPTR_RXDMON_0 = 0x0
	// RXD terminal is the High level.
	SCI1_SPTR_RXDMON_1 = 0x1
)

// Constants for SPI0: Serial Peripheral Interface 0
const (
	// SPCR: SPI Control Register
	// Position of SPRIE field.
	SPI0_SPCR_SPRIE_Pos = 0x7
	// Bit mask of SPRIE field.
	SPI0_SPCR_SPRIE_Msk = 0x80
	// Bit SPRIE.
	SPI0_SPCR_SPRIE = 0x80
	// Disables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_0 = 0x0
	// Enables the generation of SPI receive buffer full interrupt requests
	SPI0_SPCR_SPRIE_1 = 0x1
	// Position of SPE field.
	SPI0_SPCR_SPE_Pos = 0x6
	// Bit mask of SPE field.
	SPI0_SPCR_SPE_Msk = 0x40
	// Bit SPE.
	SPI0_SPCR_SPE = 0x40
	// Disables the SPI function
	SPI0_SPCR_SPE_0 = 0x0
	// Enables the SPI function
	SPI0_SPCR_SPE_1 = 0x1
	// Position of SPTIE field.
	SPI0_SPCR_SPTIE_Pos = 0x5
	// Bit mask of SPTIE field.
	SPI0_SPCR_SPTIE_Msk = 0x20
	// Bit SPTIE.
	SPI0_SPCR_SPTIE = 0x20
	// Disables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_0 = 0x0
	// Enables the generation of transmit buffer empty interrupt requests
	SPI0_SPCR_SPTIE_1 = 0x1
	// Position of SPEIE field.
	SPI0_SPCR_SPEIE_Pos = 0x4
	// Bit mask of SPEIE field.
	SPI0_SPCR_SPEIE_Msk = 0x10
	// Bit SPEIE.
	SPI0_SPCR_SPEIE = 0x10
	// Disables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_0 = 0x0
	// Enables the generation of SPI error interrupt requests
	SPI0_SPCR_SPEIE_1 = 0x1
	// Position of MSTR field.
	SPI0_SPCR_MSTR_Pos = 0x3
	// Bit mask of MSTR field.
	SPI0_SPCR_MSTR_Msk = 0x8
	// Bit MSTR.
	SPI0_SPCR_MSTR = 0x8
	// Slave mode
	SPI0_SPCR_MSTR_0 = 0x0
	// Master mode
	SPI0_SPCR_MSTR_1 = 0x1
	// Position of MODFEN field.
	SPI0_SPCR_MODFEN_Pos = 0x2
	// Bit mask of MODFEN field.
	SPI0_SPCR_MODFEN_Msk = 0x4
	// Bit MODFEN.
	SPI0_SPCR_MODFEN = 0x4
	// Disables the detection of mode fault error
	SPI0_SPCR_MODFEN_0 = 0x0
	// Enables the detection of mode fault error
	SPI0_SPCR_MODFEN_1 = 0x1
	// Position of TXMD field.
	SPI0_SPCR_TXMD_Pos = 0x1
	// Bit mask of TXMD field.
	SPI0_SPCR_TXMD_Msk = 0x2
	// Bit TXMD.
	SPI0_SPCR_TXMD = 0x2
	// Full-duplex synchronous serial communications
	SPI0_SPCR_TXMD_0 = 0x0
	// Serial communications consisting of only transmit operations
	SPI0_SPCR_TXMD_1 = 0x1
	// Position of SPMS field.
	SPI0_SPCR_SPMS_Pos = 0x0
	// Bit mask of SPMS field.
	SPI0_SPCR_SPMS_Msk = 0x1
	// Bit SPMS.
	SPI0_SPCR_SPMS = 0x1
	// SPI operation (4-wire method)
	SPI0_SPCR_SPMS_0 = 0x0
	// Clock synchronous operation (3-wire method)
	SPI0_SPCR_SPMS_1 = 0x1

	// SSLP: SPI Slave Select Polarity Register
	// Position of Reserved field.
	SPI0_SSLP_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SPI0_SSLP_Reserved_Msk = 0xf0
	// Position of SSL3P field.
	SPI0_SSLP_SSL3P_Pos = 0x3
	// Bit mask of SSL3P field.
	SPI0_SSLP_SSL3P_Msk = 0x8
	// Bit SSL3P.
	SPI0_SSLP_SSL3P = 0x8
	// SSL3 signal is active low
	SPI0_SSLP_SSL3P_0 = 0x0
	// SSL3 signal is active high
	SPI0_SSLP_SSL3P_1 = 0x1
	// Position of SSL2P field.
	SPI0_SSLP_SSL2P_Pos = 0x2
	// Bit mask of SSL2P field.
	SPI0_SSLP_SSL2P_Msk = 0x4
	// Bit SSL2P.
	SPI0_SSLP_SSL2P = 0x4
	// SSL2 signal is active low
	SPI0_SSLP_SSL2P_0 = 0x0
	// SSL2 signal is active high
	SPI0_SSLP_SSL2P_1 = 0x1
	// Position of SSL1P field.
	SPI0_SSLP_SSL1P_Pos = 0x1
	// Bit mask of SSL1P field.
	SPI0_SSLP_SSL1P_Msk = 0x2
	// Bit SSL1P.
	SPI0_SSLP_SSL1P = 0x2
	// SSL1 signal is active low
	SPI0_SSLP_SSL1P_0 = 0x0
	// SSL1 signal is active high
	SPI0_SSLP_SSL1P_1 = 0x1
	// Position of SSL0P field.
	SPI0_SSLP_SSL0P_Pos = 0x0
	// Bit mask of SSL0P field.
	SPI0_SSLP_SSL0P_Msk = 0x1
	// Bit SSL0P.
	SPI0_SSLP_SSL0P = 0x1
	// SSL0 signal is active low
	SPI0_SSLP_SSL0P_0 = 0x0
	// SSL0 signal is active high
	SPI0_SSLP_SSL0P_1 = 0x1

	// SPPCR: SPI Pin Control Register
	// Position of Reserved field.
	SPI0_SPPCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPPCR_Reserved_Msk = 0xc0
	// Position of MOIFE field.
	SPI0_SPPCR_MOIFE_Pos = 0x5
	// Bit mask of MOIFE field.
	SPI0_SPPCR_MOIFE_Msk = 0x20
	// Bit MOIFE.
	SPI0_SPPCR_MOIFE = 0x20
	// MOSI output value equals final data from previous transfer
	SPI0_SPPCR_MOIFE_0 = 0x0
	// MOSI output value equals the value set in the MOIFV bit
	SPI0_SPPCR_MOIFE_1 = 0x1
	// Position of MOIFV field.
	SPI0_SPPCR_MOIFV_Pos = 0x4
	// Bit mask of MOIFV field.
	SPI0_SPPCR_MOIFV_Msk = 0x10
	// Bit MOIFV.
	SPI0_SPPCR_MOIFV = 0x10
	// The level output on the MOSIn pin during MOSI idling corresponds to low.
	SPI0_SPPCR_MOIFV_0 = 0x0
	// The level output on the MOSIn pin during MOSI idling corresponds to high.
	SPI0_SPPCR_MOIFV_1 = 0x1
	// Position of Reserved field.
	SPI0_SPPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SPI0_SPPCR_Reserved_Msk = 0xc
	// Position of SPLP2 field.
	SPI0_SPPCR_SPLP2_Pos = 0x1
	// Bit mask of SPLP2 field.
	SPI0_SPPCR_SPLP2_Msk = 0x2
	// Bit SPLP2.
	SPI0_SPPCR_SPLP2 = 0x2
	// Normal mode
	SPI0_SPPCR_SPLP2_0 = 0x0
	// Loopback mode (data is not inverted for transmission)
	SPI0_SPPCR_SPLP2_1 = 0x1
	// Position of SPLP field.
	SPI0_SPPCR_SPLP_Pos = 0x0
	// Bit mask of SPLP field.
	SPI0_SPPCR_SPLP_Msk = 0x1
	// Bit SPLP.
	SPI0_SPPCR_SPLP = 0x1
	// Normal mode
	SPI0_SPPCR_SPLP_0 = 0x0
	// Loopback mode (data is inverted for transmission)
	SPI0_SPPCR_SPLP_1 = 0x1

	// SPSR: SPI Status Register
	// Position of SPRF field.
	SPI0_SPSR_SPRF_Pos = 0x7
	// Bit mask of SPRF field.
	SPI0_SPSR_SPRF_Msk = 0x80
	// Bit SPRF.
	SPI0_SPSR_SPRF = 0x80
	// No valid data in SPDR
	SPI0_SPSR_SPRF_0 = 0x0
	// Valid data found in SPDR
	SPI0_SPSR_SPRF_1 = 0x1
	// Position of Reserved field.
	SPI0_SPSR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPSR_Reserved_Msk = 0x40
	// Bit Reserved.
	SPI0_SPSR_Reserved = 0x40
	// Position of SPTEF field.
	SPI0_SPSR_SPTEF_Pos = 0x5
	// Bit mask of SPTEF field.
	SPI0_SPSR_SPTEF_Msk = 0x20
	// Bit SPTEF.
	SPI0_SPSR_SPTEF = 0x20
	// Data found in the transmit buffer
	SPI0_SPSR_SPTEF_0 = 0x0
	// No data in the transmit buffer
	SPI0_SPSR_SPTEF_1 = 0x1
	// Position of UDRF field.
	SPI0_SPSR_UDRF_Pos = 0x4
	// Bit mask of UDRF field.
	SPI0_SPSR_UDRF_Msk = 0x10
	// Bit UDRF.
	SPI0_SPSR_UDRF = 0x10
	// A mode fault error occurs (MODF=1)
	SPI0_SPSR_UDRF_0 = 0x0
	// An underrun error occurs (MODF=1)
	SPI0_SPSR_UDRF_1 = 0x1
	// Position of PERF field.
	SPI0_SPSR_PERF_Pos = 0x3
	// Bit mask of PERF field.
	SPI0_SPSR_PERF_Msk = 0x8
	// Bit PERF.
	SPI0_SPSR_PERF = 0x8
	// No parity error occurs
	SPI0_SPSR_PERF_0 = 0x0
	// A parity error occurs
	SPI0_SPSR_PERF_1 = 0x1
	// Position of MODF field.
	SPI0_SPSR_MODF_Pos = 0x2
	// Bit mask of MODF field.
	SPI0_SPSR_MODF_Msk = 0x4
	// Bit MODF.
	SPI0_SPSR_MODF = 0x4
	// Neither mode fault error nor underrun error occurs
	SPI0_SPSR_MODF_0 = 0x0
	// A mode fault error or an underrun error occurs.
	SPI0_SPSR_MODF_1 = 0x1
	// Position of IDLNF field.
	SPI0_SPSR_IDLNF_Pos = 0x1
	// Bit mask of IDLNF field.
	SPI0_SPSR_IDLNF_Msk = 0x2
	// Bit IDLNF.
	SPI0_SPSR_IDLNF = 0x2
	// SPI is in the idle state
	SPI0_SPSR_IDLNF_0 = 0x0
	// SPI is in the transfer state
	SPI0_SPSR_IDLNF_1 = 0x1
	// Position of OVRF field.
	SPI0_SPSR_OVRF_Pos = 0x0
	// Bit mask of OVRF field.
	SPI0_SPSR_OVRF_Msk = 0x1
	// Bit OVRF.
	SPI0_SPSR_OVRF = 0x1
	// No overrun error occurs
	SPI0_SPSR_OVRF_0 = 0x0
	// An overrun error occurs
	SPI0_SPSR_OVRF_1 = 0x1

	// SPDR: SPI Data Register
	// Position of SPDR field.
	SPI0_SPDR_SPDR_Pos = 0x0
	// Bit mask of SPDR field.
	SPI0_SPDR_SPDR_Msk = 0xffffffff

	// SPDR_HA: SPI Data Register ( halfword access )
	// Position of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Pos = 0x0
	// Bit mask of SPDR_HA field.
	SPI0_SPDR_HA_SPDR_HA_Msk = 0xffff

	// SPBR: SPI Bit Rate Register
	// Position of SPR field.
	SPI0_SPBR_SPR_Pos = 0x0
	// Bit mask of SPR field.
	SPI0_SPBR_SPR_Msk = 0xff

	// SPDCR: SPI Data Control Register
	// Position of Reserved field.
	SPI0_SPDCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	SPI0_SPDCR_Reserved_Msk = 0xc0
	// Position of SPLW field.
	SPI0_SPDCR_SPLW_Pos = 0x5
	// Bit mask of SPLW field.
	SPI0_SPDCR_SPLW_Msk = 0x20
	// Bit SPLW.
	SPI0_SPDCR_SPLW = 0x20
	// Set SPDR_HA to valid for halfword access
	SPI0_SPDCR_SPLW_0 = 0x0
	// Set SPDR to valid for word access.
	SPI0_SPDCR_SPLW_1 = 0x1
	// Position of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Pos = 0x4
	// Bit mask of SPRDTD field.
	SPI0_SPDCR_SPRDTD_Msk = 0x10
	// Bit SPRDTD.
	SPI0_SPDCR_SPRDTD = 0x10
	// SPDR values are read from the receive buffer
	SPI0_SPDCR_SPRDTD_0 = 0x0
	// SPDR values are read from the transmit buffer (but only if the transmit buffer is empty)
	SPI0_SPDCR_SPRDTD_1 = 0x1
	// Position of Reserved field.
	SPI0_SPDCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SPI0_SPDCR_Reserved_Msk = 0xf

	// SPCKD: SPI Clock Delay Register
	// Position of Reserved field.
	SPI0_SPCKD_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPCKD_Reserved_Msk = 0xf8
	// Position of SCKDL field.
	SPI0_SPCKD_SCKDL_Pos = 0x0
	// Bit mask of SCKDL field.
	SPI0_SPCKD_SCKDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SPCKD_SCKDL_000 = 0x0
	// 2 RSPCK
	SPI0_SPCKD_SCKDL_001 = 0x1
	// 3 RSPCK
	SPI0_SPCKD_SCKDL_010 = 0x2
	// 4 RSPCK
	SPI0_SPCKD_SCKDL_011 = 0x3
	// 5 RSPCK
	SPI0_SPCKD_SCKDL_100 = 0x4
	// 6 RSPCK
	SPI0_SPCKD_SCKDL_101 = 0x5
	// 7 RSPCK
	SPI0_SPCKD_SCKDL_110 = 0x6
	// 8 RSPCK
	SPI0_SPCKD_SCKDL_111 = 0x7

	// SSLND: SPI Slave Select Negation Delay Register
	// Position of Reserved field.
	SPI0_SSLND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SSLND_Reserved_Msk = 0xf8
	// Position of SLNDL field.
	SPI0_SSLND_SLNDL_Pos = 0x0
	// Bit mask of SLNDL field.
	SPI0_SSLND_SLNDL_Msk = 0x7
	// 1 RSPCK
	SPI0_SSLND_SLNDL_000 = 0x0
	// 2 RSPCK
	SPI0_SSLND_SLNDL_001 = 0x1
	// 3 RSPCK
	SPI0_SSLND_SLNDL_010 = 0x2
	// 4 RSPCK
	SPI0_SSLND_SLNDL_011 = 0x3
	// 5 RSPCK
	SPI0_SSLND_SLNDL_100 = 0x4
	// 6 RSPCK
	SPI0_SSLND_SLNDL_101 = 0x5
	// 7 RSPCK
	SPI0_SSLND_SLNDL_110 = 0x6
	// 8 RSPCK
	SPI0_SSLND_SLNDL_111 = 0x7

	// SPND: SPI Next-Access Delay Register
	// Position of Reserved field.
	SPI0_SPND_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SPI0_SPND_Reserved_Msk = 0xf8
	// Position of SPNDL field.
	SPI0_SPND_SPNDL_Pos = 0x0
	// Bit mask of SPNDL field.
	SPI0_SPND_SPNDL_Msk = 0x7
	// 1 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_000 = 0x0
	// 2 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_001 = 0x1
	// 3 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_010 = 0x2
	// 4 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_011 = 0x3
	// 5 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_100 = 0x4
	// 6 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_101 = 0x5
	// 7 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_110 = 0x6
	// 8 RSPCK + 2 PCLK
	SPI0_SPND_SPNDL_111 = 0x7

	// SPCR2: SPI Control Register 2
	// Position of Reserved field.
	SPI0_SPCR2_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SPI0_SPCR2_Reserved_Msk = 0xe0
	// Position of SCKASE field.
	SPI0_SPCR2_SCKASE_Pos = 0x4
	// Bit mask of SCKASE field.
	SPI0_SPCR2_SCKASE_Msk = 0x10
	// Bit SCKASE.
	SPI0_SPCR2_SCKASE = 0x10
	// Disables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_0 = 0x0
	// Enables the RSPCK auto-stop function
	SPI0_SPCR2_SCKASE_1 = 0x1
	// Position of PTE field.
	SPI0_SPCR2_PTE_Pos = 0x3
	// Bit mask of PTE field.
	SPI0_SPCR2_PTE_Msk = 0x8
	// Bit PTE.
	SPI0_SPCR2_PTE = 0x8
	// Disables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_0 = 0x0
	// Enables the self-diagnosis function of the parity circuit
	SPI0_SPCR2_PTE_1 = 0x1
	// Position of SPIIE field.
	SPI0_SPCR2_SPIIE_Pos = 0x2
	// Bit mask of SPIIE field.
	SPI0_SPCR2_SPIIE_Msk = 0x4
	// Bit SPIIE.
	SPI0_SPCR2_SPIIE = 0x4
	// Disables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_0 = 0x0
	// Enables the generation of idle interrupt requests
	SPI0_SPCR2_SPIIE_1 = 0x1
	// Position of SPOE field.
	SPI0_SPCR2_SPOE_Pos = 0x1
	// Bit mask of SPOE field.
	SPI0_SPCR2_SPOE_Msk = 0x2
	// Bit SPOE.
	SPI0_SPCR2_SPOE = 0x2
	// Selects even parity for use in transmission and reception
	SPI0_SPCR2_SPOE_0 = 0x0
	// Selects odd parity for use in transmission and reception
	SPI0_SPCR2_SPOE_1 = 0x1
	// Position of SPPE field.
	SPI0_SPCR2_SPPE_Pos = 0x0
	// Bit mask of SPPE field.
	SPI0_SPCR2_SPPE_Msk = 0x1
	// Bit SPPE.
	SPI0_SPCR2_SPPE = 0x1
	// Does not add the parity bit to transmit data and does not check the parity bit of receive data
	SPI0_SPCR2_SPPE_0 = 0x0
	// Adds the parity bit to transmit data and checks the parity bit of receive data (when SPCR.TXMD = 0) / Adds the parity bit to transmit data but does not check the parity bit of receive data (when SPCR.TXMD = 1)
	SPI0_SPCR2_SPPE_1 = 0x1

	// SPCMD0: SPI Command Register 0
	// Position of SCKDEN field.
	SPI0_SPCMD0_SCKDEN_Pos = 0xf
	// Bit mask of SCKDEN field.
	SPI0_SPCMD0_SCKDEN_Msk = 0x8000
	// Bit SCKDEN.
	SPI0_SPCMD0_SCKDEN = 0x8000
	// An RSPCK delay of 1 RSPCK
	SPI0_SPCMD0_SCKDEN_0 = 0x0
	// An RSPCK delay is equal to the setting of the SPI clock delay register (SPCKD)
	SPI0_SPCMD0_SCKDEN_1 = 0x1
	// Position of SLNDEN field.
	SPI0_SPCMD0_SLNDEN_Pos = 0xe
	// Bit mask of SLNDEN field.
	SPI0_SPCMD0_SLNDEN_Msk = 0x4000
	// Bit SLNDEN.
	SPI0_SPCMD0_SLNDEN = 0x4000
	// An SSL negation delay of 1 RSPCK
	SPI0_SPCMD0_SLNDEN_0 = 0x0
	// An SSL negation delay is equal to the setting of the SPI slave select negation delay register (SSLND)
	SPI0_SPCMD0_SLNDEN_1 = 0x1
	// Position of SPNDEN field.
	SPI0_SPCMD0_SPNDEN_Pos = 0xd
	// Bit mask of SPNDEN field.
	SPI0_SPCMD0_SPNDEN_Msk = 0x2000
	// Bit SPNDEN.
	SPI0_SPCMD0_SPNDEN = 0x2000
	// A next-access delay of 1 RSPCK + 2 PCLK
	SPI0_SPCMD0_SPNDEN_0 = 0x0
	// A next-access delay is equal to the setting of the SPI next-access delay register (SPND)
	SPI0_SPCMD0_SPNDEN_1 = 0x1
	// Position of LSBF field.
	SPI0_SPCMD0_LSBF_Pos = 0xc
	// Bit mask of LSBF field.
	SPI0_SPCMD0_LSBF_Msk = 0x1000
	// Bit LSBF.
	SPI0_SPCMD0_LSBF = 0x1000
	// MSB first
	SPI0_SPCMD0_LSBF_0 = 0x0
	// LSB first
	SPI0_SPCMD0_LSBF_1 = 0x1
	// Position of SPB field.
	SPI0_SPCMD0_SPB_Pos = 0x8
	// Bit mask of SPB field.
	SPI0_SPCMD0_SPB_Msk = 0xf00
	// 8 bits
	SPI0_SPCMD0_SPB_0100 = 0x4
	// 8 bits
	SPI0_SPCMD0_SPB_0101 = 0x5
	// 8 bits
	SPI0_SPCMD0_SPB_0110 = 0x6
	// 8 bits
	SPI0_SPCMD0_SPB_0111 = 0x7
	// 9 bits
	SPI0_SPCMD0_SPB_1000 = 0x8
	// 10 bits
	SPI0_SPCMD0_SPB_1001 = 0x9
	// 11 bits
	SPI0_SPCMD0_SPB_1010 = 0xa
	// 12 bits
	SPI0_SPCMD0_SPB_1011 = 0xb
	// 13 bits
	SPI0_SPCMD0_SPB_1100 = 0xc
	// 14 bits
	SPI0_SPCMD0_SPB_1101 = 0xd
	// 15 bits
	SPI0_SPCMD0_SPB_1110 = 0xe
	// 16 bits
	SPI0_SPCMD0_SPB_1111 = 0xf
	// Position of Reserved field.
	SPI0_SPCMD0_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SPI0_SPCMD0_Reserved_Msk = 0x80
	// Bit Reserved.
	SPI0_SPCMD0_Reserved = 0x80
	// Position of SSLA field.
	SPI0_SPCMD0_SSLA_Pos = 0x4
	// Bit mask of SSLA field.
	SPI0_SPCMD0_SSLA_Msk = 0x70
	// SSL0
	SPI0_SPCMD0_SSLA_000 = 0x0
	// SSL1
	SPI0_SPCMD0_SSLA_001 = 0x1
	// SSL2
	SPI0_SPCMD0_SSLA_010 = 0x2
	// SSL3
	SPI0_SPCMD0_SSLA_011 = 0x3
	// Position of BRDV field.
	SPI0_SPCMD0_BRDV_Pos = 0x2
	// Bit mask of BRDV field.
	SPI0_SPCMD0_BRDV_Msk = 0xc
	// These bits select the base bit rate
	SPI0_SPCMD0_BRDV_00 = 0x0
	// These bits select the base bit rate divided by 2
	SPI0_SPCMD0_BRDV_01 = 0x1
	// These bits select the base bit rate divided by 4
	SPI0_SPCMD0_BRDV_10 = 0x2
	// These bits select the base bit rate divided by 8
	SPI0_SPCMD0_BRDV_11 = 0x3
	// Position of CPOL field.
	SPI0_SPCMD0_CPOL_Pos = 0x1
	// Bit mask of CPOL field.
	SPI0_SPCMD0_CPOL_Msk = 0x2
	// Bit CPOL.
	SPI0_SPCMD0_CPOL = 0x2
	// RSPCK is low when idle
	SPI0_SPCMD0_CPOL_0 = 0x0
	// RSPCK is high when idle
	SPI0_SPCMD0_CPOL_1 = 0x1
	// Position of CPHA field.
	SPI0_SPCMD0_CPHA_Pos = 0x0
	// Bit mask of CPHA field.
	SPI0_SPCMD0_CPHA_Msk = 0x1
	// Bit CPHA.
	SPI0_SPCMD0_CPHA = 0x1
	// Data sampling on odd edge, data variation on even edge
	SPI0_SPCMD0_CPHA_0 = 0x0
	// Data variation on odd edge, data sampling on even edge
	SPI0_SPCMD0_CPHA_1 = 0x1
)

// Constants for CAN0: CAN0 Module
const (
	// MB0_ID: Mailbox Register
	// Position of IDE field.
	CAN0_MB_ID_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_MB_ID_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_MB_ID_IDE = 0x80000000
	// Standard ID
	CAN0_MB_ID_IDE_0 = 0x0
	// Extended ID
	CAN0_MB_ID_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_MB_ID_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_MB_ID_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_MB_ID_RTR = 0x40000000
	// Data frame
	CAN0_MB_ID_RTR_0 = 0x0
	// Remote frame
	CAN0_MB_ID_RTR_1 = 0x1
	// Position of Reserved field.
	CAN0_MB_ID_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_MB_ID_Reserved_Msk = 0x20000000
	// Bit Reserved.
	CAN0_MB_ID_Reserved = 0x20000000
	// Position of SID field.
	CAN0_MB_ID_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MB_ID_SID_Msk = 0x1ffc0000
	// Corresponding SID[10:0] bits are 0
	CAN0_MB_ID_SID_0 = 0x0
	// Corresponding SID[10:0] bits are 1
	CAN0_MB_ID_SID_1 = 0x1
	// Position of EID field.
	CAN0_MB_ID_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MB_ID_EID_Msk = 0x3ffff
	// Corresponding EID[17:0] bits are 0
	CAN0_MB_ID_EID_0 = 0x0
	// Corresponding EID[17:0] bits are 1
	CAN0_MB_ID_EID_1 = 0x1

	// MB0_DL: Mailbox Register
	// Position of Reserved field.
	CAN0_MB_DL_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CAN0_MB_DL_Reserved_Msk = 0xfff0
	// Position of DLC field.
	CAN0_MB_DL_DLC_Pos = 0x0
	// Bit mask of DLC field.
	CAN0_MB_DL_DLC_Msk = 0xf
	// Data length = 0 byte
	CAN0_MB_DL_DLC_0000 = 0x0
	// Data length = 1 byte
	CAN0_MB_DL_DLC_0001 = 0x1
	// Data length = 2 bytes
	CAN0_MB_DL_DLC_0010 = 0x2
	// Data length = 3 bytes
	CAN0_MB_DL_DLC_0011 = 0x3
	// Data length = 4 bytes
	CAN0_MB_DL_DLC_0100 = 0x4
	// Data length = 5 bytes
	CAN0_MB_DL_DLC_0101 = 0x5
	// Data length = 6 bytes
	CAN0_MB_DL_DLC_0110 = 0x6
	// Data length = 7 bytes
	CAN0_MB_DL_DLC_0111 = 0x7

	// MB0_D0: Mailbox Register
	// Position of DATA0 field.
	CAN0_MB_D0_DATA0_Pos = 0x0
	// Bit mask of DATA0 field.
	CAN0_MB_D0_DATA0_Msk = 0xff

	// MB0_D1: Mailbox Register
	// Position of DATA1 field.
	CAN0_MB_D1_DATA1_Pos = 0x0
	// Bit mask of DATA1 field.
	CAN0_MB_D1_DATA1_Msk = 0xff

	// MB0_D2: Mailbox Register
	// Position of DATA2 field.
	CAN0_MB_D2_DATA2_Pos = 0x0
	// Bit mask of DATA2 field.
	CAN0_MB_D2_DATA2_Msk = 0xff

	// MB0_D3: Mailbox Register
	// Position of DATA3 field.
	CAN0_MB_D3_DATA3_Pos = 0x0
	// Bit mask of DATA3 field.
	CAN0_MB_D3_DATA3_Msk = 0xff

	// MB0_D4: Mailbox Register
	// Position of DATA4 field.
	CAN0_MB_D4_DATA4_Pos = 0x0
	// Bit mask of DATA4 field.
	CAN0_MB_D4_DATA4_Msk = 0xff

	// MB0_D5: Mailbox Register
	// Position of DATA5 field.
	CAN0_MB_D5_DATA5_Pos = 0x0
	// Bit mask of DATA5 field.
	CAN0_MB_D5_DATA5_Msk = 0xff

	// MB0_D6: Mailbox Register
	// Position of DATA6 field.
	CAN0_MB_D6_DATA6_Pos = 0x0
	// Bit mask of DATA6 field.
	CAN0_MB_D6_DATA6_Msk = 0xff

	// MB0_D7: Mailbox Register
	// Position of DATA7 field.
	CAN0_MB_D7_DATA7_Pos = 0x0
	// Bit mask of DATA7 field.
	CAN0_MB_D7_DATA7_Msk = 0xff

	// MB0_TS: Mailbox Register
	// Position of TSH field.
	CAN0_MB_TS_TSH_Pos = 0x8
	// Bit mask of TSH field.
	CAN0_MB_TS_TSH_Msk = 0xff00
	// Position of TSL field.
	CAN0_MB_TS_TSL_Pos = 0x0
	// Bit mask of TSL field.
	CAN0_MB_TS_TSL_Msk = 0xff

	// MKR: Mask Register
	// Position of Reserved field.
	CAN0_MKR_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_MKR_Reserved_Msk = 0xe0000000
	// Position of SID field.
	CAN0_MKR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_MKR_SID_Msk = 0x1ffc0000
	// Corresponding SID[10:0] bit is not compared
	CAN0_MKR_SID_0 = 0x0
	// Corresponding SID[10:0] bit is compared
	CAN0_MKR_SID_1 = 0x1
	// Position of EID field.
	CAN0_MKR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_MKR_EID_Msk = 0x3ffff
	// Corresponding EID[17:0] bit is not compared
	CAN0_MKR_EID_0 = 0x0
	// Corresponding EID[17:0] bit is compared
	CAN0_MKR_EID_1 = 0x1

	// FIDCR0: FIFO Received ID Compare Registers
	// Position of IDE field.
	CAN0_FIDCR_IDE_Pos = 0x1f
	// Bit mask of IDE field.
	CAN0_FIDCR_IDE_Msk = 0x80000000
	// Bit IDE.
	CAN0_FIDCR_IDE = 0x80000000
	// Standard ID
	CAN0_FIDCR_IDE_0 = 0x0
	// Extended ID
	CAN0_FIDCR_IDE_1 = 0x1
	// Position of RTR field.
	CAN0_FIDCR_RTR_Pos = 0x1e
	// Bit mask of RTR field.
	CAN0_FIDCR_RTR_Msk = 0x40000000
	// Bit RTR.
	CAN0_FIDCR_RTR = 0x40000000
	// Data frame
	CAN0_FIDCR_RTR_0 = 0x0
	// Remote frame
	CAN0_FIDCR_RTR_1 = 0x1
	// Position of Reserved field.
	CAN0_FIDCR_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	CAN0_FIDCR_Reserved_Msk = 0x20000000
	// Bit Reserved.
	CAN0_FIDCR_Reserved = 0x20000000
	// Position of SID field.
	CAN0_FIDCR_SID_Pos = 0x12
	// Bit mask of SID field.
	CAN0_FIDCR_SID_Msk = 0x1ffc0000
	// Corresponding SID[10:0] bits are 0
	CAN0_FIDCR_SID_0 = 0x0
	// Corresponding SID[10:0] bits are 1
	CAN0_FIDCR_SID_1 = 0x1
	// Position of EID field.
	CAN0_FIDCR_EID_Pos = 0x0
	// Bit mask of EID field.
	CAN0_FIDCR_EID_Msk = 0x3ffff
	// Corresponding EID[17:0] bits are 0
	CAN0_FIDCR_EID_0 = 0x0
	// Corresponding EID[17:0] bits are 1
	CAN0_FIDCR_EID_1 = 0x1

	// MKIVLR: Mask Invalid Register
	// Position of MB31 field.
	CAN0_MKIVLR_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MKIVLR_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MKIVLR_MB31 = 0x80000000
	// Mask valid
	CAN0_MKIVLR_MB31_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MKIVLR_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MKIVLR_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MKIVLR_MB30 = 0x40000000
	// Mask valid
	CAN0_MKIVLR_MB30_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MKIVLR_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MKIVLR_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MKIVLR_MB29 = 0x20000000
	// Mask valid
	CAN0_MKIVLR_MB29_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MKIVLR_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MKIVLR_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MKIVLR_MB28 = 0x10000000
	// Mask valid
	CAN0_MKIVLR_MB28_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MKIVLR_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MKIVLR_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MKIVLR_MB27 = 0x8000000
	// Mask valid
	CAN0_MKIVLR_MB27_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MKIVLR_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MKIVLR_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MKIVLR_MB26 = 0x4000000
	// Mask valid
	CAN0_MKIVLR_MB26_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MKIVLR_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MKIVLR_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MKIVLR_MB25 = 0x2000000
	// Mask valid
	CAN0_MKIVLR_MB25_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MKIVLR_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MKIVLR_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MKIVLR_MB24 = 0x1000000
	// Mask valid
	CAN0_MKIVLR_MB24_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MKIVLR_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MKIVLR_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MKIVLR_MB23 = 0x800000
	// Mask valid
	CAN0_MKIVLR_MB23_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MKIVLR_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MKIVLR_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MKIVLR_MB22 = 0x400000
	// Mask valid
	CAN0_MKIVLR_MB22_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MKIVLR_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MKIVLR_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MKIVLR_MB21 = 0x200000
	// Mask valid
	CAN0_MKIVLR_MB21_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MKIVLR_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MKIVLR_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MKIVLR_MB20 = 0x100000
	// Mask valid
	CAN0_MKIVLR_MB20_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MKIVLR_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MKIVLR_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MKIVLR_MB19 = 0x80000
	// Mask valid
	CAN0_MKIVLR_MB19_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MKIVLR_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MKIVLR_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MKIVLR_MB18 = 0x40000
	// Mask valid
	CAN0_MKIVLR_MB18_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MKIVLR_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MKIVLR_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MKIVLR_MB17 = 0x20000
	// Mask valid
	CAN0_MKIVLR_MB17_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MKIVLR_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MKIVLR_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MKIVLR_MB16 = 0x10000
	// Mask valid
	CAN0_MKIVLR_MB16_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MKIVLR_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MKIVLR_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MKIVLR_MB15 = 0x8000
	// Mask valid
	CAN0_MKIVLR_MB15_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MKIVLR_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MKIVLR_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MKIVLR_MB14 = 0x4000
	// Mask valid
	CAN0_MKIVLR_MB14_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MKIVLR_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MKIVLR_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MKIVLR_MB13 = 0x2000
	// Mask valid
	CAN0_MKIVLR_MB13_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MKIVLR_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MKIVLR_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MKIVLR_MB12 = 0x1000
	// Mask valid
	CAN0_MKIVLR_MB12_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MKIVLR_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MKIVLR_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MKIVLR_MB11 = 0x800
	// Mask valid
	CAN0_MKIVLR_MB11_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MKIVLR_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MKIVLR_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MKIVLR_MB10 = 0x400
	// Mask valid
	CAN0_MKIVLR_MB10_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MKIVLR_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MKIVLR_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MKIVLR_MB9 = 0x200
	// Mask valid
	CAN0_MKIVLR_MB9_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MKIVLR_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MKIVLR_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MKIVLR_MB8 = 0x100
	// Mask valid
	CAN0_MKIVLR_MB8_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MKIVLR_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MKIVLR_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MKIVLR_MB7 = 0x80
	// Mask valid
	CAN0_MKIVLR_MB7_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MKIVLR_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MKIVLR_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MKIVLR_MB6 = 0x40
	// Mask valid
	CAN0_MKIVLR_MB6_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MKIVLR_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MKIVLR_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MKIVLR_MB5 = 0x20
	// Mask valid
	CAN0_MKIVLR_MB5_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MKIVLR_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MKIVLR_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MKIVLR_MB4 = 0x10
	// Mask valid
	CAN0_MKIVLR_MB4_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MKIVLR_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MKIVLR_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MKIVLR_MB3 = 0x8
	// Mask valid
	CAN0_MKIVLR_MB3_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MKIVLR_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MKIVLR_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MKIVLR_MB2 = 0x4
	// Mask valid
	CAN0_MKIVLR_MB2_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MKIVLR_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MKIVLR_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MKIVLR_MB1 = 0x2
	// Mask valid
	CAN0_MKIVLR_MB1_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MKIVLR_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MKIVLR_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MKIVLR_MB0 = 0x1
	// Mask valid
	CAN0_MKIVLR_MB0_0 = 0x0
	// Mask invalid
	CAN0_MKIVLR_MB0_1 = 0x1

	// MIER: Mailbox Interrupt Enable Register (Normal mailbox mode)
	// Position of MB31 field.
	CAN0_MIER_MB31_Pos = 0x1f
	// Bit mask of MB31 field.
	CAN0_MIER_MB31_Msk = 0x80000000
	// Bit MB31.
	CAN0_MIER_MB31 = 0x80000000
	// Interrupt disabled
	CAN0_MIER_MB31_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB31_1 = 0x1
	// Position of MB30 field.
	CAN0_MIER_MB30_Pos = 0x1e
	// Bit mask of MB30 field.
	CAN0_MIER_MB30_Msk = 0x40000000
	// Bit MB30.
	CAN0_MIER_MB30 = 0x40000000
	// Interrupt disabled
	CAN0_MIER_MB30_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB30_1 = 0x1
	// Position of MB29 field.
	CAN0_MIER_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_MB29 = 0x20000000
	// Interrupt disabled
	CAN0_MIER_MB29_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB28_1 = 0x1
	// Position of MB27 field.
	CAN0_MIER_MB27_Pos = 0x1b
	// Bit mask of MB27 field.
	CAN0_MIER_MB27_Msk = 0x8000000
	// Bit MB27.
	CAN0_MIER_MB27 = 0x8000000
	// Interrupt disabled
	CAN0_MIER_MB27_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB27_1 = 0x1
	// Position of MB26 field.
	CAN0_MIER_MB26_Pos = 0x1a
	// Bit mask of MB26 field.
	CAN0_MIER_MB26_Msk = 0x4000000
	// Bit MB26.
	CAN0_MIER_MB26 = 0x4000000
	// Interrupt disabled
	CAN0_MIER_MB26_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB26_1 = 0x1
	// Position of MB25 field.
	CAN0_MIER_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_MB25 = 0x2000000
	// Interrupt disabled
	CAN0_MIER_MB25_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_MB0_1 = 0x1

	// MIER_FIFO: Mailbox Interrupt Enable Register(FIFO mailbox mode)
	// Position of MB29 field.
	CAN0_MIER_FIFO_MB29_Pos = 0x1d
	// Bit mask of MB29 field.
	CAN0_MIER_FIFO_MB29_Msk = 0x20000000
	// Bit MB29.
	CAN0_MIER_FIFO_MB29 = 0x20000000
	// Every time reception is completed
	CAN0_MIER_FIFO_MB29_0 = 0x0
	// When the receive FIFO becomes buffer warning by completion of reception
	CAN0_MIER_FIFO_MB29_1 = 0x1
	// Position of MB28 field.
	CAN0_MIER_FIFO_MB28_Pos = 0x1c
	// Bit mask of MB28 field.
	CAN0_MIER_FIFO_MB28_Msk = 0x10000000
	// Bit MB28.
	CAN0_MIER_FIFO_MB28 = 0x10000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB28_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB28_1 = 0x1
	// Position of Reserved field.
	CAN0_MIER_FIFO_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	CAN0_MIER_FIFO_Reserved_Msk = 0xc000000
	// Position of MB25 field.
	CAN0_MIER_FIFO_MB25_Pos = 0x19
	// Bit mask of MB25 field.
	CAN0_MIER_FIFO_MB25_Msk = 0x2000000
	// Bit MB25.
	CAN0_MIER_FIFO_MB25 = 0x2000000
	// Every time transmission is completed
	CAN0_MIER_FIFO_MB25_0 = 0x0
	// When the transmit FIFO becomes empty due to completion of transmission
	CAN0_MIER_FIFO_MB25_1 = 0x1
	// Position of MB24 field.
	CAN0_MIER_FIFO_MB24_Pos = 0x18
	// Bit mask of MB24 field.
	CAN0_MIER_FIFO_MB24_Msk = 0x1000000
	// Bit MB24.
	CAN0_MIER_FIFO_MB24 = 0x1000000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB24_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB24_1 = 0x1
	// Position of MB23 field.
	CAN0_MIER_FIFO_MB23_Pos = 0x17
	// Bit mask of MB23 field.
	CAN0_MIER_FIFO_MB23_Msk = 0x800000
	// Bit MB23.
	CAN0_MIER_FIFO_MB23 = 0x800000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB23_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB23_1 = 0x1
	// Position of MB22 field.
	CAN0_MIER_FIFO_MB22_Pos = 0x16
	// Bit mask of MB22 field.
	CAN0_MIER_FIFO_MB22_Msk = 0x400000
	// Bit MB22.
	CAN0_MIER_FIFO_MB22 = 0x400000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB22_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB22_1 = 0x1
	// Position of MB21 field.
	CAN0_MIER_FIFO_MB21_Pos = 0x15
	// Bit mask of MB21 field.
	CAN0_MIER_FIFO_MB21_Msk = 0x200000
	// Bit MB21.
	CAN0_MIER_FIFO_MB21 = 0x200000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB21_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB21_1 = 0x1
	// Position of MB20 field.
	CAN0_MIER_FIFO_MB20_Pos = 0x14
	// Bit mask of MB20 field.
	CAN0_MIER_FIFO_MB20_Msk = 0x100000
	// Bit MB20.
	CAN0_MIER_FIFO_MB20 = 0x100000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB20_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB20_1 = 0x1
	// Position of MB19 field.
	CAN0_MIER_FIFO_MB19_Pos = 0x13
	// Bit mask of MB19 field.
	CAN0_MIER_FIFO_MB19_Msk = 0x80000
	// Bit MB19.
	CAN0_MIER_FIFO_MB19 = 0x80000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB19_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB19_1 = 0x1
	// Position of MB18 field.
	CAN0_MIER_FIFO_MB18_Pos = 0x12
	// Bit mask of MB18 field.
	CAN0_MIER_FIFO_MB18_Msk = 0x40000
	// Bit MB18.
	CAN0_MIER_FIFO_MB18 = 0x40000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB18_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB18_1 = 0x1
	// Position of MB17 field.
	CAN0_MIER_FIFO_MB17_Pos = 0x11
	// Bit mask of MB17 field.
	CAN0_MIER_FIFO_MB17_Msk = 0x20000
	// Bit MB17.
	CAN0_MIER_FIFO_MB17 = 0x20000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB17_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB17_1 = 0x1
	// Position of MB16 field.
	CAN0_MIER_FIFO_MB16_Pos = 0x10
	// Bit mask of MB16 field.
	CAN0_MIER_FIFO_MB16_Msk = 0x10000
	// Bit MB16.
	CAN0_MIER_FIFO_MB16 = 0x10000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB16_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB16_1 = 0x1
	// Position of MB15 field.
	CAN0_MIER_FIFO_MB15_Pos = 0xf
	// Bit mask of MB15 field.
	CAN0_MIER_FIFO_MB15_Msk = 0x8000
	// Bit MB15.
	CAN0_MIER_FIFO_MB15 = 0x8000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB15_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB15_1 = 0x1
	// Position of MB14 field.
	CAN0_MIER_FIFO_MB14_Pos = 0xe
	// Bit mask of MB14 field.
	CAN0_MIER_FIFO_MB14_Msk = 0x4000
	// Bit MB14.
	CAN0_MIER_FIFO_MB14 = 0x4000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB14_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB14_1 = 0x1
	// Position of MB13 field.
	CAN0_MIER_FIFO_MB13_Pos = 0xd
	// Bit mask of MB13 field.
	CAN0_MIER_FIFO_MB13_Msk = 0x2000
	// Bit MB13.
	CAN0_MIER_FIFO_MB13 = 0x2000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB13_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB13_1 = 0x1
	// Position of MB12 field.
	CAN0_MIER_FIFO_MB12_Pos = 0xc
	// Bit mask of MB12 field.
	CAN0_MIER_FIFO_MB12_Msk = 0x1000
	// Bit MB12.
	CAN0_MIER_FIFO_MB12 = 0x1000
	// Interrupt disabled
	CAN0_MIER_FIFO_MB12_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB12_1 = 0x1
	// Position of MB11 field.
	CAN0_MIER_FIFO_MB11_Pos = 0xb
	// Bit mask of MB11 field.
	CAN0_MIER_FIFO_MB11_Msk = 0x800
	// Bit MB11.
	CAN0_MIER_FIFO_MB11 = 0x800
	// Interrupt disabled
	CAN0_MIER_FIFO_MB11_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB11_1 = 0x1
	// Position of MB10 field.
	CAN0_MIER_FIFO_MB10_Pos = 0xa
	// Bit mask of MB10 field.
	CAN0_MIER_FIFO_MB10_Msk = 0x400
	// Bit MB10.
	CAN0_MIER_FIFO_MB10 = 0x400
	// Interrupt disabled
	CAN0_MIER_FIFO_MB10_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB10_1 = 0x1
	// Position of MB9 field.
	CAN0_MIER_FIFO_MB9_Pos = 0x9
	// Bit mask of MB9 field.
	CAN0_MIER_FIFO_MB9_Msk = 0x200
	// Bit MB9.
	CAN0_MIER_FIFO_MB9 = 0x200
	// Interrupt disabled
	CAN0_MIER_FIFO_MB9_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB9_1 = 0x1
	// Position of MB8 field.
	CAN0_MIER_FIFO_MB8_Pos = 0x8
	// Bit mask of MB8 field.
	CAN0_MIER_FIFO_MB8_Msk = 0x100
	// Bit MB8.
	CAN0_MIER_FIFO_MB8 = 0x100
	// Interrupt disabled
	CAN0_MIER_FIFO_MB8_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB8_1 = 0x1
	// Position of MB7 field.
	CAN0_MIER_FIFO_MB7_Pos = 0x7
	// Bit mask of MB7 field.
	CAN0_MIER_FIFO_MB7_Msk = 0x80
	// Bit MB7.
	CAN0_MIER_FIFO_MB7 = 0x80
	// Interrupt disabled
	CAN0_MIER_FIFO_MB7_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB7_1 = 0x1
	// Position of MB6 field.
	CAN0_MIER_FIFO_MB6_Pos = 0x6
	// Bit mask of MB6 field.
	CAN0_MIER_FIFO_MB6_Msk = 0x40
	// Bit MB6.
	CAN0_MIER_FIFO_MB6 = 0x40
	// Interrupt disabled
	CAN0_MIER_FIFO_MB6_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB6_1 = 0x1
	// Position of MB5 field.
	CAN0_MIER_FIFO_MB5_Pos = 0x5
	// Bit mask of MB5 field.
	CAN0_MIER_FIFO_MB5_Msk = 0x20
	// Bit MB5.
	CAN0_MIER_FIFO_MB5 = 0x20
	// Interrupt disabled
	CAN0_MIER_FIFO_MB5_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB5_1 = 0x1
	// Position of MB4 field.
	CAN0_MIER_FIFO_MB4_Pos = 0x4
	// Bit mask of MB4 field.
	CAN0_MIER_FIFO_MB4_Msk = 0x10
	// Bit MB4.
	CAN0_MIER_FIFO_MB4 = 0x10
	// Interrupt disabled
	CAN0_MIER_FIFO_MB4_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB4_1 = 0x1
	// Position of MB3 field.
	CAN0_MIER_FIFO_MB3_Pos = 0x3
	// Bit mask of MB3 field.
	CAN0_MIER_FIFO_MB3_Msk = 0x8
	// Bit MB3.
	CAN0_MIER_FIFO_MB3 = 0x8
	// Interrupt disabled
	CAN0_MIER_FIFO_MB3_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB3_1 = 0x1
	// Position of MB2 field.
	CAN0_MIER_FIFO_MB2_Pos = 0x2
	// Bit mask of MB2 field.
	CAN0_MIER_FIFO_MB2_Msk = 0x4
	// Bit MB2.
	CAN0_MIER_FIFO_MB2 = 0x4
	// Interrupt disabled
	CAN0_MIER_FIFO_MB2_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB2_1 = 0x1
	// Position of MB1 field.
	CAN0_MIER_FIFO_MB1_Pos = 0x1
	// Bit mask of MB1 field.
	CAN0_MIER_FIFO_MB1_Msk = 0x2
	// Bit MB1.
	CAN0_MIER_FIFO_MB1 = 0x2
	// Interrupt disabled
	CAN0_MIER_FIFO_MB1_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB1_1 = 0x1
	// Position of MB0 field.
	CAN0_MIER_FIFO_MB0_Pos = 0x0
	// Bit mask of MB0 field.
	CAN0_MIER_FIFO_MB0_Msk = 0x1
	// Bit MB0.
	CAN0_MIER_FIFO_MB0 = 0x1
	// Interrupt disabled
	CAN0_MIER_FIFO_MB0_0 = 0x0
	// Interrupt enabled
	CAN0_MIER_FIFO_MB0_1 = 0x1

	// MCTL_TX: Message Control Register(Transmit mode (when the TRMREQ bit is 1 and the RECREQ bit is 0))
	// Position of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_TX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_TX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_TX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_TX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_TX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_TX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_TX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_TX_RECREQ_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_TX_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MCTL_TX_Reserved_Msk = 0x20
	// Bit Reserved.
	CAN0_MCTL_TX_Reserved = 0x20
	// Position of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_TX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_TX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_TX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_TX_ONESHOT_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_TX_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_MCTL_TX_Reserved_Msk = 0x8
	// Bit Reserved.
	CAN0_MCTL_TX_Reserved = 0x8
	// Position of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Pos = 0x2
	// Bit mask of TRMABT field.
	CAN0_MCTL_TX_TRMABT_Msk = 0x4
	// Bit TRMABT.
	CAN0_MCTL_TX_TRMABT = 0x4
	// Transmission has started, transmission abort failed because transmission is completed, or transmission abort is not requested
	CAN0_MCTL_TX_TRMABT_0 = 0x0
	// Transmission abort is completed
	CAN0_MCTL_TX_TRMABT_1 = 0x1
	// Position of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Pos = 0x1
	// Bit mask of TRMACTIVE field.
	CAN0_MCTL_TX_TRMACTIVE_Msk = 0x2
	// Bit TRMACTIVE.
	CAN0_MCTL_TX_TRMACTIVE = 0x2
	// Transmission is pending or transmission is not requested
	CAN0_MCTL_TX_TRMACTIVE_0 = 0x0
	// From acceptance of transmission request to completion of transmission, or error/arbitration-lost
	CAN0_MCTL_TX_TRMACTIVE_1 = 0x1
	// Position of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Pos = 0x0
	// Bit mask of SENTDATA field.
	CAN0_MCTL_TX_SENTDATA_Msk = 0x1
	// Bit SENTDATA.
	CAN0_MCTL_TX_SENTDATA = 0x1
	// Transmission is not completed
	CAN0_MCTL_TX_SENTDATA_0 = 0x0
	// Transmission is completed
	CAN0_MCTL_TX_SENTDATA_1 = 0x1

	// MCTL_RX: Message Control Register( Receive mode (when the TRMREQ bit is 0 and the RECREQ bit is 1))
	// Position of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Pos = 0x7
	// Bit mask of TRMREQ field.
	CAN0_MCTL_RX_TRMREQ_Msk = 0x80
	// Bit TRMREQ.
	CAN0_MCTL_RX_TRMREQ = 0x80
	// Not configured for transmission
	CAN0_MCTL_RX_TRMREQ_0 = 0x0
	// Configured for transmission
	CAN0_MCTL_RX_TRMREQ_1 = 0x1
	// Position of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Pos = 0x6
	// Bit mask of RECREQ field.
	CAN0_MCTL_RX_RECREQ_Msk = 0x40
	// Bit RECREQ.
	CAN0_MCTL_RX_RECREQ = 0x40
	// Not configured for reception
	CAN0_MCTL_RX_RECREQ_0 = 0x0
	// Configured for reception
	CAN0_MCTL_RX_RECREQ_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_RX_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MCTL_RX_Reserved_Msk = 0x20
	// Bit Reserved.
	CAN0_MCTL_RX_Reserved = 0x20
	// Position of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Pos = 0x4
	// Bit mask of ONESHOT field.
	CAN0_MCTL_RX_ONESHOT_Msk = 0x10
	// Bit ONESHOT.
	CAN0_MCTL_RX_ONESHOT = 0x10
	// One-shot reception or one-shot transmission disabled
	CAN0_MCTL_RX_ONESHOT_0 = 0x0
	// One-shot reception or one-shot transmission enabled
	CAN0_MCTL_RX_ONESHOT_1 = 0x1
	// Position of Reserved field.
	CAN0_MCTL_RX_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_MCTL_RX_Reserved_Msk = 0x8
	// Bit Reserved.
	CAN0_MCTL_RX_Reserved = 0x8
	// Position of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Pos = 0x2
	// Bit mask of MSGLOST field.
	CAN0_MCTL_RX_MSGLOST_Msk = 0x4
	// Bit MSGLOST.
	CAN0_MCTL_RX_MSGLOST = 0x4
	// Message is not overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_0 = 0x0
	// Message is overwritten or overrun
	CAN0_MCTL_RX_MSGLOST_1 = 0x1
	// Position of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Pos = 0x1
	// Bit mask of INVALDATA field.
	CAN0_MCTL_RX_INVALDATA_Msk = 0x2
	// Bit INVALDATA.
	CAN0_MCTL_RX_INVALDATA = 0x2
	// Message valid
	CAN0_MCTL_RX_INVALDATA_0 = 0x0
	// Message being updated
	CAN0_MCTL_RX_INVALDATA_1 = 0x1
	// Position of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Pos = 0x0
	// Bit mask of NEWDATA field.
	CAN0_MCTL_RX_NEWDATA_Msk = 0x1
	// Bit NEWDATA.
	CAN0_MCTL_RX_NEWDATA = 0x1
	// No data has been received or 0 is written to the NEWDATA bit
	CAN0_MCTL_RX_NEWDATA_0 = 0x0
	// A new message is being stored or has been stored to the mailbox
	CAN0_MCTL_RX_NEWDATA_1 = 0x1

	// CTLR: Control Register
	// Position of Reserved field.
	CAN0_CTLR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CAN0_CTLR_Reserved_Msk = 0xc000
	// Position of RBOC field.
	CAN0_CTLR_RBOC_Pos = 0xd
	// Bit mask of RBOC field.
	CAN0_CTLR_RBOC_Msk = 0x2000
	// Bit RBOC.
	CAN0_CTLR_RBOC = 0x2000
	// Nothing occurred
	CAN0_CTLR_RBOC_0 = 0x0
	// Forcible return from bus-off
	CAN0_CTLR_RBOC_1 = 0x1
	// Position of BOM field.
	CAN0_CTLR_BOM_Pos = 0xb
	// Bit mask of BOM field.
	CAN0_CTLR_BOM_Msk = 0x1800
	// Normal mode (ISO11898-1 compliant)
	CAN0_CTLR_BOM_00 = 0x0
	// Entry to CAN halt mode automatically at bus-off entry
	CAN0_CTLR_BOM_01 = 0x1
	// Entry to CAN halt mode automatically at bus-off end
	CAN0_CTLR_BOM_10 = 0x2
	// Entry to CAN halt mode (during bus-off recovery period) by a program request
	CAN0_CTLR_BOM_11 = 0x3
	// Position of SLPM field.
	CAN0_CTLR_SLPM_Pos = 0xa
	// Bit mask of SLPM field.
	CAN0_CTLR_SLPM_Msk = 0x400
	// Bit SLPM.
	CAN0_CTLR_SLPM = 0x400
	// Other than CAN sleep mode
	CAN0_CTLR_SLPM_0 = 0x0
	// CAN sleep mode
	CAN0_CTLR_SLPM_1 = 0x1
	// Position of CANM field.
	CAN0_CTLR_CANM_Pos = 0x8
	// Bit mask of CANM field.
	CAN0_CTLR_CANM_Msk = 0x300
	// CAN operation mode
	CAN0_CTLR_CANM_00 = 0x0
	// CAN reset mode
	CAN0_CTLR_CANM_01 = 0x1
	// CAN halt mode
	CAN0_CTLR_CANM_10 = 0x2
	// CAN reset mode (forcible transition)
	CAN0_CTLR_CANM_11 = 0x3
	// Position of TSPS field.
	CAN0_CTLR_TSPS_Pos = 0x6
	// Bit mask of TSPS field.
	CAN0_CTLR_TSPS_Msk = 0xc0
	// Every bit time
	CAN0_CTLR_TSPS_00 = 0x0
	// Every 2-bit time
	CAN0_CTLR_TSPS_01 = 0x1
	// Every 4-bit time
	CAN0_CTLR_TSPS_10 = 0x2
	// Every 8-bit time
	CAN0_CTLR_TSPS_11 = 0x3
	// Position of TSRC field.
	CAN0_CTLR_TSRC_Pos = 0x5
	// Bit mask of TSRC field.
	CAN0_CTLR_TSRC_Msk = 0x20
	// Bit TSRC.
	CAN0_CTLR_TSRC = 0x20
	// Nothing occurred
	CAN0_CTLR_TSRC_0 = 0x0
	// Reset
	CAN0_CTLR_TSRC_1 = 0x1
	// Position of TPM field.
	CAN0_CTLR_TPM_Pos = 0x4
	// Bit mask of TPM field.
	CAN0_CTLR_TPM_Msk = 0x10
	// Bit TPM.
	CAN0_CTLR_TPM = 0x10
	// ID priority transmit mode
	CAN0_CTLR_TPM_0 = 0x0
	// Mailbox number priority transmit mode
	CAN0_CTLR_TPM_1 = 0x1
	// Position of MLM field.
	CAN0_CTLR_MLM_Pos = 0x3
	// Bit mask of MLM field.
	CAN0_CTLR_MLM_Msk = 0x8
	// Bit MLM.
	CAN0_CTLR_MLM = 0x8
	// Overwrite mode
	CAN0_CTLR_MLM_0 = 0x0
	// Overrun mode
	CAN0_CTLR_MLM_1 = 0x1
	// Position of IDFM field.
	CAN0_CTLR_IDFM_Pos = 0x1
	// Bit mask of IDFM field.
	CAN0_CTLR_IDFM_Msk = 0x6
	// Standard ID mode.All mailboxes (including FIFO mailboxes) handle only standard Ids.
	CAN0_CTLR_IDFM_00 = 0x0
	// Extended ID mode.All mailboxes (including FIFO mailboxes) handle only extended IDs.
	CAN0_CTLR_IDFM_01 = 0x1
	// Mixed ID mode.All mailboxes (including FIFO mailboxes) handle both standard IDs and extended IDs. Standard IDs or extended IDs are specified by using the IDE bit in the corresponding mailbox in normal mailbox mode. In FIFO mailbox mode, the IDE bit in the corresponding mailbox is used for mailboxes [0] to [23], the IDE bits in FIDCR0 and FIDCR1 are used for the receive FIFO, and the IDE bit in mailbox [24] is used for the transmit FIFO.
	CAN0_CTLR_IDFM_10 = 0x2
	// Do not use this combination
	CAN0_CTLR_IDFM_11 = 0x3
	// Position of MBM field.
	CAN0_CTLR_MBM_Pos = 0x0
	// Bit mask of MBM field.
	CAN0_CTLR_MBM_Msk = 0x1
	// Bit MBM.
	CAN0_CTLR_MBM = 0x1
	// Normal mailbox mode
	CAN0_CTLR_MBM_0 = 0x0
	// FIFO mailbox mode
	CAN0_CTLR_MBM_1 = 0x1

	// STR: Status Register
	// Position of Reserved field.
	CAN0_STR_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	CAN0_STR_Reserved_Msk = 0x8000
	// Bit Reserved.
	CAN0_STR_Reserved = 0x8000
	// Position of RECST field.
	CAN0_STR_RECST_Pos = 0xe
	// Bit mask of RECST field.
	CAN0_STR_RECST_Msk = 0x4000
	// Bit RECST.
	CAN0_STR_RECST = 0x4000
	// Bus idle or transmission in progress
	CAN0_STR_RECST_0 = 0x0
	// Reception in progress
	CAN0_STR_RECST_1 = 0x1
	// Position of TRMST field.
	CAN0_STR_TRMST_Pos = 0xd
	// Bit mask of TRMST field.
	CAN0_STR_TRMST_Msk = 0x2000
	// Bit TRMST.
	CAN0_STR_TRMST = 0x2000
	// Bus idle or reception in progress
	CAN0_STR_TRMST_0 = 0x0
	// Transmission in progress or in bus-off state
	CAN0_STR_TRMST_1 = 0x1
	// Position of BOST field.
	CAN0_STR_BOST_Pos = 0xc
	// Bit mask of BOST field.
	CAN0_STR_BOST_Msk = 0x1000
	// Bit BOST.
	CAN0_STR_BOST = 0x1000
	// Not in bus-off state
	CAN0_STR_BOST_0 = 0x0
	// In bus-off state
	CAN0_STR_BOST_1 = 0x1
	// Position of EPST field.
	CAN0_STR_EPST_Pos = 0xb
	// Bit mask of EPST field.
	CAN0_STR_EPST_Msk = 0x800
	// Bit EPST.
	CAN0_STR_EPST = 0x800
	// Not in error-passive state
	CAN0_STR_EPST_0 = 0x0
	// In error-passive state
	CAN0_STR_EPST_1 = 0x1
	// Position of SLPST field.
	CAN0_STR_SLPST_Pos = 0xa
	// Bit mask of SLPST field.
	CAN0_STR_SLPST_Msk = 0x400
	// Bit SLPST.
	CAN0_STR_SLPST = 0x400
	// Not in CAN sleep mode
	CAN0_STR_SLPST_0 = 0x0
	// In CAN sleep mode
	CAN0_STR_SLPST_1 = 0x1
	// Position of HLTST field.
	CAN0_STR_HLTST_Pos = 0x9
	// Bit mask of HLTST field.
	CAN0_STR_HLTST_Msk = 0x200
	// Bit HLTST.
	CAN0_STR_HLTST = 0x200
	// Not in CAN halt mode
	CAN0_STR_HLTST_0 = 0x0
	// In CAN halt mode
	CAN0_STR_HLTST_1 = 0x1
	// Position of RSTST field.
	CAN0_STR_RSTST_Pos = 0x8
	// Bit mask of RSTST field.
	CAN0_STR_RSTST_Msk = 0x100
	// Bit RSTST.
	CAN0_STR_RSTST = 0x100
	// Not in CAN reset mode
	CAN0_STR_RSTST_0 = 0x0
	// In CAN reset mode
	CAN0_STR_RSTST_1 = 0x1
	// Position of EST field.
	CAN0_STR_EST_Pos = 0x7
	// Bit mask of EST field.
	CAN0_STR_EST_Msk = 0x80
	// Bit EST.
	CAN0_STR_EST = 0x80
	// No error occurred
	CAN0_STR_EST_0 = 0x0
	// Error occurred
	CAN0_STR_EST_1 = 0x1
	// Position of TABST field.
	CAN0_STR_TABST_Pos = 0x6
	// Bit mask of TABST field.
	CAN0_STR_TABST_Msk = 0x40
	// Bit TABST.
	CAN0_STR_TABST = 0x40
	// No mailbox with TRMABT bit = 1
	CAN0_STR_TABST_0 = 0x0
	// Mailbox(es) with TRMABT bit = 1
	CAN0_STR_TABST_1 = 0x1
	// Position of FMLST field.
	CAN0_STR_FMLST_Pos = 0x5
	// Bit mask of FMLST field.
	CAN0_STR_FMLST_Msk = 0x20
	// Bit FMLST.
	CAN0_STR_FMLST = 0x20
	// RFMLF bit = 0
	CAN0_STR_FMLST_0 = 0x0
	// RFMLF bit = 1
	CAN0_STR_FMLST_1 = 0x1
	// Position of NMLST field.
	CAN0_STR_NMLST_Pos = 0x4
	// Bit mask of NMLST field.
	CAN0_STR_NMLST_Msk = 0x10
	// Bit NMLST.
	CAN0_STR_NMLST = 0x10
	// No mailbox with MSGLOST bit = 1
	CAN0_STR_NMLST_0 = 0x0
	// Mailbox(es) with MSGLOST bit = 1
	CAN0_STR_NMLST_1 = 0x1
	// Position of TFST field.
	CAN0_STR_TFST_Pos = 0x3
	// Bit mask of TFST field.
	CAN0_STR_TFST_Msk = 0x8
	// Bit TFST.
	CAN0_STR_TFST = 0x8
	// Transmit FIFO is full
	CAN0_STR_TFST_0 = 0x0
	// Transmit FIFO is not full
	CAN0_STR_TFST_1 = 0x1
	// Position of RFST field.
	CAN0_STR_RFST_Pos = 0x2
	// Bit mask of RFST field.
	CAN0_STR_RFST_Msk = 0x4
	// Bit RFST.
	CAN0_STR_RFST = 0x4
	// No message in receive FIFO (empty)
	CAN0_STR_RFST_0 = 0x0
	// Message in receive FIFO
	CAN0_STR_RFST_1 = 0x1
	// Position of SDST field.
	CAN0_STR_SDST_Pos = 0x1
	// Bit mask of SDST field.
	CAN0_STR_SDST_Msk = 0x2
	// Bit SDST.
	CAN0_STR_SDST = 0x2
	// No mailbox with SENTDATA bit = 1
	CAN0_STR_SDST_0 = 0x0
	// Mailbox(es) with SENTDATA bit = 1
	CAN0_STR_SDST_1 = 0x1
	// Position of NDST field.
	CAN0_STR_NDST_Pos = 0x0
	// Bit mask of NDST field.
	CAN0_STR_NDST_Msk = 0x1
	// Bit NDST.
	CAN0_STR_NDST = 0x1
	// No mailbox with NEWDATA bit = 1
	CAN0_STR_NDST_0 = 0x0
	// Mailbox(es) with NEWDATA bit = 1
	CAN0_STR_NDST_1 = 0x1

	// BCR: Bit Configuration Register
	// Position of TSEG1 field.
	CAN0_BCR_TSEG1_Pos = 0x1c
	// Bit mask of TSEG1 field.
	CAN0_BCR_TSEG1_Msk = 0xf0000000
	// 4 Tq
	CAN0_BCR_TSEG1_0011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG1_0100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG1_0101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG1_0110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG1_0111 = 0x7
	// 9 Tq
	CAN0_BCR_TSEG1_1000 = 0x8
	// 10 Tq
	CAN0_BCR_TSEG1_1001 = 0x9
	// 11 Tq
	CAN0_BCR_TSEG1_1010 = 0xa
	// 12 Tq
	CAN0_BCR_TSEG1_1011 = 0xb
	// 13 Tq
	CAN0_BCR_TSEG1_1100 = 0xc
	// 14 Tq
	CAN0_BCR_TSEG1_1101 = 0xd
	// 15 Tq
	CAN0_BCR_TSEG1_1110 = 0xe
	// 16 Tq
	CAN0_BCR_TSEG1_1111 = 0xf
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xc000000
	// Position of BRP field.
	CAN0_BCR_BRP_Pos = 0x10
	// Bit mask of BRP field.
	CAN0_BCR_BRP_Msk = 0x3ff0000
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xc000
	// Position of SJW field.
	CAN0_BCR_SJW_Pos = 0xc
	// Bit mask of SJW field.
	CAN0_BCR_SJW_Msk = 0x3000
	// 1 Tq
	CAN0_BCR_SJW_00 = 0x0
	// 2 Tq
	CAN0_BCR_SJW_01 = 0x1
	// 3 Tq
	CAN0_BCR_SJW_10 = 0x2
	// 4 Tq
	CAN0_BCR_SJW_11 = 0x3
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0x800
	// Bit Reserved.
	CAN0_BCR_Reserved = 0x800
	// Position of TSEG2 field.
	CAN0_BCR_TSEG2_Pos = 0x8
	// Bit mask of TSEG2 field.
	CAN0_BCR_TSEG2_Msk = 0x700
	// Setting prohibited
	CAN0_BCR_TSEG2_000 = 0x0
	// 2 Tq
	CAN0_BCR_TSEG2_001 = 0x1
	// 3 Tq
	CAN0_BCR_TSEG2_010 = 0x2
	// 4 Tq
	CAN0_BCR_TSEG2_011 = 0x3
	// 5 Tq
	CAN0_BCR_TSEG2_100 = 0x4
	// 6 Tq
	CAN0_BCR_TSEG2_101 = 0x5
	// 7 Tq
	CAN0_BCR_TSEG2_110 = 0x6
	// 8 Tq
	CAN0_BCR_TSEG2_111 = 0x7
	// Position of Reserved field.
	CAN0_BCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	CAN0_BCR_Reserved_Msk = 0xfe
	// Position of CCLKS field.
	CAN0_BCR_CCLKS_Pos = 0x0
	// Bit mask of CCLKS field.
	CAN0_BCR_CCLKS_Msk = 0x1
	// Bit CCLKS.
	CAN0_BCR_CCLKS = 0x1
	// PCLK (generated by the PLL clock)
	CAN0_BCR_CCLKS_0 = 0x0
	// CANMCLK (generated by the main clock)
	CAN0_BCR_CCLKS_1 = 0x1

	// RFCR: Receive FIFO Control Register
	// Position of RFEST field.
	CAN0_RFCR_RFEST_Pos = 0x7
	// Bit mask of RFEST field.
	CAN0_RFCR_RFEST_Msk = 0x80
	// Bit RFEST.
	CAN0_RFCR_RFEST = 0x80
	// Unread message in receive FIFO
	CAN0_RFCR_RFEST_0 = 0x0
	// No unread message in receive FIFO
	CAN0_RFCR_RFEST_1 = 0x1
	// Position of RFWST field.
	CAN0_RFCR_RFWST_Pos = 0x6
	// Bit mask of RFWST field.
	CAN0_RFCR_RFWST_Msk = 0x40
	// Bit RFWST.
	CAN0_RFCR_RFWST = 0x40
	// Receive FIFO is not buffer warning
	CAN0_RFCR_RFWST_0 = 0x0
	// Receive FIFO is buffer warning (3 unread messages)
	CAN0_RFCR_RFWST_1 = 0x1
	// Position of RFFST field.
	CAN0_RFCR_RFFST_Pos = 0x5
	// Bit mask of RFFST field.
	CAN0_RFCR_RFFST_Msk = 0x20
	// Bit RFFST.
	CAN0_RFCR_RFFST = 0x20
	// Receive FIFO is not full
	CAN0_RFCR_RFFST_0 = 0x0
	// Receive FIFO is full (4 unread messages)
	CAN0_RFCR_RFFST_1 = 0x1
	// Position of RFMLF field.
	CAN0_RFCR_RFMLF_Pos = 0x4
	// Bit mask of RFMLF field.
	CAN0_RFCR_RFMLF_Msk = 0x10
	// Bit RFMLF.
	CAN0_RFCR_RFMLF = 0x10
	// No receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_0 = 0x0
	// Receive FIFO message lost has occurred
	CAN0_RFCR_RFMLF_1 = 0x1
	// Position of RFUST field.
	CAN0_RFCR_RFUST_Pos = 0x1
	// Bit mask of RFUST field.
	CAN0_RFCR_RFUST_Msk = 0xe
	// No unread message
	CAN0_RFCR_RFUST_000 = 0x0
	// 1 unread message
	CAN0_RFCR_RFUST_001 = 0x1
	// 2 unread messages
	CAN0_RFCR_RFUST_010 = 0x2
	// 3 unread messages
	CAN0_RFCR_RFUST_011 = 0x3
	// 4 unread messages
	CAN0_RFCR_RFUST_100 = 0x4
	// Position of RFE field.
	CAN0_RFCR_RFE_Pos = 0x0
	// Bit mask of RFE field.
	CAN0_RFCR_RFE_Msk = 0x1
	// Bit RFE.
	CAN0_RFCR_RFE = 0x1
	// Receive FIFO disabled
	CAN0_RFCR_RFE_0 = 0x0
	// Receive FIFO enabled
	CAN0_RFCR_RFE_1 = 0x1

	// RFPCR: Receive FIFO Pointer Control Register
	// Position of RFPCR field.
	CAN0_RFPCR_RFPCR_Pos = 0x0
	// Bit mask of RFPCR field.
	CAN0_RFPCR_RFPCR_Msk = 0xff

	// TFCR: Transmit FIFO Control Register
	// Position of TFEST field.
	CAN0_TFCR_TFEST_Pos = 0x7
	// Bit mask of TFEST field.
	CAN0_TFCR_TFEST_Msk = 0x80
	// Bit TFEST.
	CAN0_TFCR_TFEST = 0x80
	// Unsent message in transmit FIFO
	CAN0_TFCR_TFEST_0 = 0x0
	// No unsent message in transmit FIFO
	CAN0_TFCR_TFEST_1 = 0x1
	// Position of TFFST field.
	CAN0_TFCR_TFFST_Pos = 0x6
	// Bit mask of TFFST field.
	CAN0_TFCR_TFFST_Msk = 0x40
	// Bit TFFST.
	CAN0_TFCR_TFFST = 0x40
	// Transmit FIFO is not full
	CAN0_TFCR_TFFST_0 = 0x0
	// Transmit FIFO is full (4 unsent messages)
	CAN0_TFCR_TFFST_1 = 0x1
	// Position of Reserved field.
	CAN0_TFCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	CAN0_TFCR_Reserved_Msk = 0x30
	// Position of TFUST field.
	CAN0_TFCR_TFUST_Pos = 0x1
	// Bit mask of TFUST field.
	CAN0_TFCR_TFUST_Msk = 0xe
	// No unsent message
	CAN0_TFCR_TFUST_000 = 0x0
	// 1 unsent message
	CAN0_TFCR_TFUST_001 = 0x1
	// 2 unsent messages
	CAN0_TFCR_TFUST_010 = 0x2
	// 3 unsent messages
	CAN0_TFCR_TFUST_011 = 0x3
	// 4 unsent messages
	CAN0_TFCR_TFUST_100 = 0x4
	// Position of TFE field.
	CAN0_TFCR_TFE_Pos = 0x0
	// Bit mask of TFE field.
	CAN0_TFCR_TFE_Msk = 0x1
	// Bit TFE.
	CAN0_TFCR_TFE = 0x1
	// Transmit FIFO disabled
	CAN0_TFCR_TFE_0 = 0x0
	// Transmit FIFO enabled
	CAN0_TFCR_TFE_1 = 0x1

	// TFPCR: Transmit FIFO Pointer Control Register
	// Position of TFPCR field.
	CAN0_TFPCR_TFPCR_Pos = 0x0
	// Bit mask of TFPCR field.
	CAN0_TFPCR_TFPCR_Msk = 0xff

	// EIER: Error Interrupt Enable Register
	// Position of BLIE field.
	CAN0_EIER_BLIE_Pos = 0x7
	// Bit mask of BLIE field.
	CAN0_EIER_BLIE_Msk = 0x80
	// Bit BLIE.
	CAN0_EIER_BLIE = 0x80
	// Bus lock interrupt disabled
	CAN0_EIER_BLIE_0 = 0x0
	// Bus lock interrupt enabled
	CAN0_EIER_BLIE_1 = 0x1
	// Position of OLIE field.
	CAN0_EIER_OLIE_Pos = 0x6
	// Bit mask of OLIE field.
	CAN0_EIER_OLIE_Msk = 0x40
	// Bit OLIE.
	CAN0_EIER_OLIE = 0x40
	// Overload frame transmit interrupt disabled
	CAN0_EIER_OLIE_0 = 0x0
	// Overload frame transmit interrupt enabled
	CAN0_EIER_OLIE_1 = 0x1
	// Position of ORIE field.
	CAN0_EIER_ORIE_Pos = 0x5
	// Bit mask of ORIE field.
	CAN0_EIER_ORIE_Msk = 0x20
	// Bit ORIE.
	CAN0_EIER_ORIE = 0x20
	// Receive overrun interrupt disabled
	CAN0_EIER_ORIE_0 = 0x0
	// Receive overrun interrupt enabled
	CAN0_EIER_ORIE_1 = 0x1
	// Position of BORIE field.
	CAN0_EIER_BORIE_Pos = 0x4
	// Bit mask of BORIE field.
	CAN0_EIER_BORIE_Msk = 0x10
	// Bit BORIE.
	CAN0_EIER_BORIE = 0x10
	// Bus-off recovery interrupt disabled
	CAN0_EIER_BORIE_0 = 0x0
	// Bus-off recovery interrupt enabled
	CAN0_EIER_BORIE_1 = 0x1
	// Position of BOEIE field.
	CAN0_EIER_BOEIE_Pos = 0x3
	// Bit mask of BOEIE field.
	CAN0_EIER_BOEIE_Msk = 0x8
	// Bit BOEIE.
	CAN0_EIER_BOEIE = 0x8
	// Bus-off entry interrupt disabled
	CAN0_EIER_BOEIE_0 = 0x0
	// Bus-off entry interrupt enabled
	CAN0_EIER_BOEIE_1 = 0x1
	// Position of EPIE field.
	CAN0_EIER_EPIE_Pos = 0x2
	// Bit mask of EPIE field.
	CAN0_EIER_EPIE_Msk = 0x4
	// Bit EPIE.
	CAN0_EIER_EPIE = 0x4
	// Error-passive interrupt disabled
	CAN0_EIER_EPIE_0 = 0x0
	// Error-passive interrupt enabled
	CAN0_EIER_EPIE_1 = 0x1
	// Position of EWIE field.
	CAN0_EIER_EWIE_Pos = 0x1
	// Bit mask of EWIE field.
	CAN0_EIER_EWIE_Msk = 0x2
	// Bit EWIE.
	CAN0_EIER_EWIE = 0x2
	// Error-warning interrupt disabled
	CAN0_EIER_EWIE_0 = 0x0
	// Error-warning interrupt enabled
	CAN0_EIER_EWIE_1 = 0x1
	// Position of BEIE field.
	CAN0_EIER_BEIE_Pos = 0x0
	// Bit mask of BEIE field.
	CAN0_EIER_BEIE_Msk = 0x1
	// Bit BEIE.
	CAN0_EIER_BEIE = 0x1
	// Bus error interrupt disabled
	CAN0_EIER_BEIE_0 = 0x0
	// Bus error interrupt enabled
	CAN0_EIER_BEIE_1 = 0x1

	// EIFR: Error Interrupt Factor Judge Register
	// Position of BLIF field.
	CAN0_EIFR_BLIF_Pos = 0x7
	// Bit mask of BLIF field.
	CAN0_EIFR_BLIF_Msk = 0x80
	// Bit BLIF.
	CAN0_EIFR_BLIF = 0x80
	// No bus lock detected
	CAN0_EIFR_BLIF_0 = 0x0
	// Bus lock detected
	CAN0_EIFR_BLIF_1 = 0x1
	// Position of OLIF field.
	CAN0_EIFR_OLIF_Pos = 0x6
	// Bit mask of OLIF field.
	CAN0_EIFR_OLIF_Msk = 0x40
	// Bit OLIF.
	CAN0_EIFR_OLIF = 0x40
	// No overload frame transmission detected
	CAN0_EIFR_OLIF_0 = 0x0
	// Overload frame transmission detected
	CAN0_EIFR_OLIF_1 = 0x1
	// Position of ORIF field.
	CAN0_EIFR_ORIF_Pos = 0x5
	// Bit mask of ORIF field.
	CAN0_EIFR_ORIF_Msk = 0x20
	// Bit ORIF.
	CAN0_EIFR_ORIF = 0x20
	// No receive overrun detected
	CAN0_EIFR_ORIF_0 = 0x0
	// Receive overrun detected
	CAN0_EIFR_ORIF_1 = 0x1
	// Position of BORIF field.
	CAN0_EIFR_BORIF_Pos = 0x4
	// Bit mask of BORIF field.
	CAN0_EIFR_BORIF_Msk = 0x10
	// Bit BORIF.
	CAN0_EIFR_BORIF = 0x10
	// No bus-off recovery detected
	CAN0_EIFR_BORIF_0 = 0x0
	// Bus-off recovery detected
	CAN0_EIFR_BORIF_1 = 0x1
	// Position of BOEIF field.
	CAN0_EIFR_BOEIF_Pos = 0x3
	// Bit mask of BOEIF field.
	CAN0_EIFR_BOEIF_Msk = 0x8
	// Bit BOEIF.
	CAN0_EIFR_BOEIF = 0x8
	// No bus-off entry detected
	CAN0_EIFR_BOEIF_0 = 0x0
	// Bus-off entry detected
	CAN0_EIFR_BOEIF_1 = 0x1
	// Position of EPIF field.
	CAN0_EIFR_EPIF_Pos = 0x2
	// Bit mask of EPIF field.
	CAN0_EIFR_EPIF_Msk = 0x4
	// Bit EPIF.
	CAN0_EIFR_EPIF = 0x4
	// No error-passive detected
	CAN0_EIFR_EPIF_0 = 0x0
	// Error-passive detected
	CAN0_EIFR_EPIF_1 = 0x1
	// Position of EWIF field.
	CAN0_EIFR_EWIF_Pos = 0x1
	// Bit mask of EWIF field.
	CAN0_EIFR_EWIF_Msk = 0x2
	// Bit EWIF.
	CAN0_EIFR_EWIF = 0x2
	// No error-warning detected
	CAN0_EIFR_EWIF_0 = 0x0
	// Error-warning detected
	CAN0_EIFR_EWIF_1 = 0x1
	// Position of BEIF field.
	CAN0_EIFR_BEIF_Pos = 0x0
	// Bit mask of BEIF field.
	CAN0_EIFR_BEIF_Msk = 0x1
	// Bit BEIF.
	CAN0_EIFR_BEIF = 0x1
	// No bus error detected
	CAN0_EIFR_BEIF_0 = 0x0
	// Bus error detected
	CAN0_EIFR_BEIF_1 = 0x1

	// RECR: Receive Error Count Register
	// Position of RECR field.
	CAN0_RECR_RECR_Pos = 0x0
	// Bit mask of RECR field.
	CAN0_RECR_RECR_Msk = 0xff

	// TECR: Transmit Error Count Register
	// Position of TECR field.
	CAN0_TECR_TECR_Pos = 0x0
	// Bit mask of TECR field.
	CAN0_TECR_TECR_Msk = 0xff

	// ECSR: Error Code Store Register
	// Position of EDPM field.
	CAN0_ECSR_EDPM_Pos = 0x7
	// Bit mask of EDPM field.
	CAN0_ECSR_EDPM_Msk = 0x80
	// Bit EDPM.
	CAN0_ECSR_EDPM = 0x80
	// Output of first detected error code
	CAN0_ECSR_EDPM_0 = 0x0
	// Output of accumulated error code
	CAN0_ECSR_EDPM_1 = 0x1
	// Position of ADEF field.
	CAN0_ECSR_ADEF_Pos = 0x6
	// Bit mask of ADEF field.
	CAN0_ECSR_ADEF_Msk = 0x40
	// Bit ADEF.
	CAN0_ECSR_ADEF = 0x40
	// No ACK delimiter error detected
	CAN0_ECSR_ADEF_0 = 0x0
	// ACK delimiter error detected
	CAN0_ECSR_ADEF_1 = 0x1
	// Position of BE0F field.
	CAN0_ECSR_BE0F_Pos = 0x5
	// Bit mask of BE0F field.
	CAN0_ECSR_BE0F_Msk = 0x20
	// Bit BE0F.
	CAN0_ECSR_BE0F = 0x20
	// No bit error (dominant) detected
	CAN0_ECSR_BE0F_0 = 0x0
	// Bit error (dominant) detected
	CAN0_ECSR_BE0F_1 = 0x1
	// Position of BE1F field.
	CAN0_ECSR_BE1F_Pos = 0x4
	// Bit mask of BE1F field.
	CAN0_ECSR_BE1F_Msk = 0x10
	// Bit BE1F.
	CAN0_ECSR_BE1F = 0x10
	// No bit error (recessive) detected
	CAN0_ECSR_BE1F_0 = 0x0
	// Bit error (recessive) detected
	CAN0_ECSR_BE1F_1 = 0x1
	// Position of CEF field.
	CAN0_ECSR_CEF_Pos = 0x3
	// Bit mask of CEF field.
	CAN0_ECSR_CEF_Msk = 0x8
	// Bit CEF.
	CAN0_ECSR_CEF = 0x8
	// No CRC error detected
	CAN0_ECSR_CEF_0 = 0x0
	// CRC error detected
	CAN0_ECSR_CEF_1 = 0x1
	// Position of AEF field.
	CAN0_ECSR_AEF_Pos = 0x2
	// Bit mask of AEF field.
	CAN0_ECSR_AEF_Msk = 0x4
	// Bit AEF.
	CAN0_ECSR_AEF = 0x4
	// No ACK error detected
	CAN0_ECSR_AEF_0 = 0x0
	// ACK error detected
	CAN0_ECSR_AEF_1 = 0x1
	// Position of FEF field.
	CAN0_ECSR_FEF_Pos = 0x1
	// Bit mask of FEF field.
	CAN0_ECSR_FEF_Msk = 0x2
	// Bit FEF.
	CAN0_ECSR_FEF = 0x2
	// No form error detected
	CAN0_ECSR_FEF_0 = 0x0
	// Form error detected
	CAN0_ECSR_FEF_1 = 0x1
	// Position of SEF field.
	CAN0_ECSR_SEF_Pos = 0x0
	// Bit mask of SEF field.
	CAN0_ECSR_SEF_Msk = 0x1
	// Bit SEF.
	CAN0_ECSR_SEF = 0x1
	// No stuff error detected
	CAN0_ECSR_SEF_0 = 0x0
	// Stuff error detected
	CAN0_ECSR_SEF_1 = 0x1

	// CSSR: Channel Search Support Register
	// Position of CSSR field.
	CAN0_CSSR_CSSR_Pos = 0x0
	// Bit mask of CSSR field.
	CAN0_CSSR_CSSR_Msk = 0xff

	// MSSR: Mailbox Search Status Register
	// Position of SEST field.
	CAN0_MSSR_SEST_Pos = 0x7
	// Bit mask of SEST field.
	CAN0_MSSR_SEST_Msk = 0x80
	// Bit SEST.
	CAN0_MSSR_SEST = 0x80
	// Search result found
	CAN0_MSSR_SEST_0 = 0x0
	// No search result
	CAN0_MSSR_SEST_1 = 0x1
	// Position of Reserved field.
	CAN0_MSSR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	CAN0_MSSR_Reserved_Msk = 0x60
	// Position of MBNST field.
	CAN0_MSSR_MBNST_Pos = 0x0
	// Bit mask of MBNST field.
	CAN0_MSSR_MBNST_Msk = 0x1f

	// MSMR: Mailbox Search Mode Register
	// Position of Reserved field.
	CAN0_MSMR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	CAN0_MSMR_Reserved_Msk = 0xfc
	// Position of MBSM field.
	CAN0_MSMR_MBSM_Pos = 0x0
	// Bit mask of MBSM field.
	CAN0_MSMR_MBSM_Msk = 0x3
	// Receive mailbox search mode
	CAN0_MSMR_MBSM_00 = 0x0
	// Transmit mailbox search mode
	CAN0_MSMR_MBSM_01 = 0x1
	// Message lost search mode
	CAN0_MSMR_MBSM_10 = 0x2
	// Channel search mode
	CAN0_MSMR_MBSM_11 = 0x3

	// TSR: Time Stamp Register
	// Position of TSR field.
	CAN0_TSR_TSR_Pos = 0x0
	// Bit mask of TSR field.
	CAN0_TSR_TSR_Msk = 0xffff

	// AFSR: Acceptance Filter Support Register
	// Position of AFSR field.
	CAN0_AFSR_AFSR_Pos = 0x0
	// Bit mask of AFSR field.
	CAN0_AFSR_AFSR_Msk = 0xffff

	// TCR: Test Control Register
	// Position of Reserved field.
	CAN0_TCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	CAN0_TCR_Reserved_Msk = 0xf8
	// Position of TSTM field.
	CAN0_TCR_TSTM_Pos = 0x1
	// Bit mask of TSTM field.
	CAN0_TCR_TSTM_Msk = 0x6
	// Other than CAN test mode
	CAN0_TCR_TSTM_00 = 0x0
	// Listen-only mode
	CAN0_TCR_TSTM_01 = 0x1
	// Self-test mode 0 (external loopback)
	CAN0_TCR_TSTM_10 = 0x2
	// Self-test mode 1 (internal loopback)
	CAN0_TCR_TSTM_11 = 0x3
	// Position of TSTE field.
	CAN0_TCR_TSTE_Pos = 0x0
	// Bit mask of TSTE field.
	CAN0_TCR_TSTE_Msk = 0x1
	// Bit TSTE.
	CAN0_TCR_TSTE = 0x1
	// CAN test mode disabled
	CAN0_TCR_TSTE_0 = 0x0
	// CAN test mode enabled
	CAN0_TCR_TSTE_1 = 0x1
)

// Constants for IIC0: Inter-Integrated Circuit 0
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC0_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC0_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC0_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC0_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC0_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC0_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC0_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC0_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC0_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC0_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC0_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC0_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC0_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC0_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC0_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC0_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC0_ICCR1_SOWP = 0x10
	// Bits SCLO and SDAO can be written.
	IIC0_ICCR1_SOWP_0 = 0x0
	// Bits SCLO and SDAO are protected.
	IIC0_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC0_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC0_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC0_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC0_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC0_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC0_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC0_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC0_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC0_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC0_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC0_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC0_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC0_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC0_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC0_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC0_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC0_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC0_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC0_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC0_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC0_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC0_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC0_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC0_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC0_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC0_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC0_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC0_ICCR2_MST = 0x40
	// Slave mode
	IIC0_ICCR2_MST_0 = 0x0
	// Master mode
	IIC0_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC0_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC0_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC0_ICCR2_TRS = 0x20
	// Receive mode
	IIC0_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC0_ICCR2_TRS_1 = 0x1
	// Position of Reserved field.
	IIC0_ICCR2_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICCR2_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICCR2_Reserved = 0x10
	// Position of SP field.
	IIC0_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC0_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC0_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC0_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC0_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC0_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC0_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC0_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC0_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC0_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC0_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC0_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC0_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC0_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC0_ICCR2_ST_1 = 0x1
	// Position of Reserved field.
	IIC0_ICCR2_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	IIC0_ICCR2_Reserved_Msk = 0x1
	// Bit Reserved.
	IIC0_ICCR2_Reserved = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC0_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC0_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC0_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC0_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC0_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC0_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC0_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC0_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC0_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC0_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC0_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC0_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC0_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC0_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC0_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC0_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC0_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC0_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC0_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC0_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC0_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC0_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC0_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC0_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC0_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC0_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC0_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC0_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC0_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC0_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC0_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC0_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC0_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC0_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC0_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC0_ICMR2_SDDL_111 = 0x7
	// Position of Reserved field.
	IIC0_ICMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_ICMR2_Reserved_Msk = 0x8
	// Bit Reserved.
	IIC0_ICMR2_Reserved = 0x8
	// Position of TMOH field.
	IIC0_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC0_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC0_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC0_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC0_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC0_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC0_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC0_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC0_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC0_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC0_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC0_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC0_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBS field.
	IIC0_ICMR3_SMBS_Pos = 0x7
	// Bit mask of SMBS field.
	IIC0_ICMR3_SMBS_Msk = 0x80
	// Bit SMBS.
	IIC0_ICMR3_SMBS = 0x80
	// The I2C bus is selected.
	IIC0_ICMR3_SMBS_0 = 0x0
	// The SMBus is selected.
	IIC0_ICMR3_SMBS_1 = 0x1
	// Position of WAIT field.
	IIC0_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC0_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC0_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC0_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC0_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC0_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC0_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC0_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC0_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC0_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC0_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC0_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC0_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC0_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC0_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC0_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC0_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC0_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC0_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC0_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC0_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC0_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC0_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC0_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC0_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC0_ICMR3_NF_Msk = 0x3
	// Noise of up to one IIC cycle is filtered out (single-stage filter).
	IIC0_ICMR3_NF_00 = 0x0
	// Noise of up to two IIC cycles is filtered out (2-stage filter).
	IIC0_ICMR3_NF_01 = 0x1
	// Noise of up to three IIC cycles is filtered out (3-stage filter).
	IIC0_ICMR3_NF_10 = 0x2
	// Noise of up to four IIC cycles is filtered out (4-stage filter)
	IIC0_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of Reserved field.
	IIC0_ICFER_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	IIC0_ICFER_Reserved_Msk = 0x80
	// Bit Reserved.
	IIC0_ICFER_Reserved = 0x80
	// Position of SCLE field.
	IIC0_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC0_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC0_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC0_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC0_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC0_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC0_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC0_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC0_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC0_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC0_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC0_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC0_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC0_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC0_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC0_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC0_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC0_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC0_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC0_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC0_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC0_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC0_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC0_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC0_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC0_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC0_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC0_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC0_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC0_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC0_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC0_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC0_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC0_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC0_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC0_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC0_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC0_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC0_ICSER_HOAE_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC0_ICSER_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC0_ICSER_Reserved = 0x40
	// Position of DIDE field.
	IIC0_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC0_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC0_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC0_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC0_ICSER_DIDE_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICSER_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICSER_Reserved = 0x10
	// Position of GCAE field.
	IIC0_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC0_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC0_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC0_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC0_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC0_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC0_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC0_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC0_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC0_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC0_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC0_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC0_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC0_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC0_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC0_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC0_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC0_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC0_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC0_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC0_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC0_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC0_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (IICn_TXI) is disabled.
	IIC0_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (IICn_TXI) is enabled.
	IIC0_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC0_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC0_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC0_ICIER_TEIE = 0x40
	// Transmit end interrupt request (IICn_TEI) is disabled.
	IIC0_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (IICn_TEI) is enabled.
	IIC0_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC0_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC0_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC0_ICIER_RIE = 0x20
	// Receive data full interrupt request (IICn_RXI) is disabled.
	IIC0_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (IICn_RXI) is enabled.
	IIC0_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC0_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC0_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC0_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC0_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC0_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC0_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC0_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC0_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC0_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC0_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC0_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC0_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC0_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC0_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC0_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC0_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC0_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC0_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC0_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC0_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC0_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC0_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC0_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC0_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC0_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC0_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC0_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC0_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC0_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC0_ICSR1_HOA_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSR1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC0_ICSR1_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC0_ICSR1_Reserved = 0x40
	// Position of DID field.
	IIC0_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC0_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC0_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC0_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC0_ICSR1_DID_1 = 0x1
	// Position of Reserved field.
	IIC0_ICSR1_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC0_ICSR1_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC0_ICSR1_Reserved = 0x10
	// Position of GCA field.
	IIC0_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC0_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC0_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC0_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC0_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC0_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC0_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC0_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC0_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC0_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC0_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC0_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC0_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC0_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC0_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC0_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC0_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC0_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC0_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC0_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC0_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC0_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC0_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC0_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC0_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC0_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC0_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC0_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC0_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC0_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC0_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC0_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC0_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC0_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC0_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC0_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC0_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC0_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC0_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC0_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC0_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC0_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC0_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC0_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC0_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC0_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC0_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC0_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC0_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC0_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC0_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC0_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC0_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC0_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC0_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC0_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC0_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC0_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC0_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC0_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC0_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC0_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of Reserved field.
	IIC0_SARU_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_SARU_Reserved_Msk = 0xf8
	// Position of SVA9 field.
	IIC0_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC0_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC0_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC0_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC0_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC0_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC0_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC0_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC0_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC0_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC0_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of Reserved field.
	IIC0_ICBRL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC0_ICBRL_Reserved_Msk = 0xe0
	// Position of BRL field.
	IIC0_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC0_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of Reserved field.
	IIC0_ICBRH_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC0_ICBRH_Reserved_Msk = 0xe0
	// Position of BRH field.
	IIC0_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC0_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC0_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC0_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC0_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC0_ICDRR_ICDRR_Msk = 0xff

	// ICWUR: I2C Bus Wake Up Unit Register
	// Position of WUE field.
	IIC0_ICWUR_WUE_Pos = 0x7
	// Bit mask of WUE field.
	IIC0_ICWUR_WUE_Msk = 0x80
	// Bit WUE.
	IIC0_ICWUR_WUE = 0x80
	// Wake-up function is disabled
	IIC0_ICWUR_WUE_0 = 0x0
	// Wake-up function is enabled.
	IIC0_ICWUR_WUE_1 = 0x1
	// Position of WUIE field.
	IIC0_ICWUR_WUIE_Pos = 0x6
	// Bit mask of WUIE field.
	IIC0_ICWUR_WUIE_Msk = 0x40
	// Bit WUIE.
	IIC0_ICWUR_WUIE = 0x40
	// Wake Up Interrupt Request (WUI) is disabled.
	IIC0_ICWUR_WUIE_0 = 0x0
	// Wake Up Interrupt Request (WUI) is enabled.
	IIC0_ICWUR_WUIE_1 = 0x1
	// Position of WUF field.
	IIC0_ICWUR_WUF_Pos = 0x5
	// Bit mask of WUF field.
	IIC0_ICWUR_WUF_Msk = 0x20
	// Bit WUF.
	IIC0_ICWUR_WUF = 0x20
	// Wake-Up event does not occur
	IIC0_ICWUR_WUF_0 = 0x0
	// Wake-Up event occur.
	IIC0_ICWUR_WUF_1 = 0x1
	// Position of WUACK field.
	IIC0_ICWUR_WUACK_Pos = 0x4
	// Bit mask of WUACK field.
	IIC0_ICWUR_WUACK_Msk = 0x10
	// Bit WUACK.
	IIC0_ICWUR_WUACK = 0x10
	// State of synchronous operation
	IIC0_ICWUR_WUACK_0 = 0x0
	// State of asynchronous operation
	IIC0_ICWUR_WUACK_1 = 0x1
	// Position of Reserved field.
	IIC0_ICWUR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	IIC0_ICWUR_Reserved_Msk = 0xe
	// Position of WUAFA field.
	IIC0_ICWUR_WUAFA_Pos = 0x0
	// Bit mask of WUAFA field.
	IIC0_ICWUR_WUAFA_Msk = 0x1
	// Bit WUAFA.
	IIC0_ICWUR_WUAFA = 0x1
	// Do not add the Wake Up analog filter.
	IIC0_ICWUR_WUAFA_0 = 0x0
	// Add the Wake Up analog filter.
	IIC0_ICWUR_WUAFA_1 = 0x1

	// ICWUR2: Reserved
	// Position of Reserved field.
	IIC0_ICWUR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC0_ICWUR2_Reserved_Msk = 0xf8
	// Position of WUSYF field.
	IIC0_ICWUR2_WUSYF_Pos = 0x2
	// Bit mask of WUSYF field.
	IIC0_ICWUR2_WUSYF_Msk = 0x4
	// Bit WUSYF.
	IIC0_ICWUR2_WUSYF = 0x4
	// RIIC asynchronous circuit enable condition
	IIC0_ICWUR2_WUSYF_0 = 0x0
	// RIIC synchronous circuit enable condition
	IIC0_ICWUR2_WUSYF_1 = 0x1
	// Position of WUASYF field.
	IIC0_ICWUR2_WUASYF_Pos = 0x1
	// Bit mask of WUASYF field.
	IIC0_ICWUR2_WUASYF_Msk = 0x2
	// Bit WUASYF.
	IIC0_ICWUR2_WUASYF = 0x2
	// RIIC synchronous circuit enable condition
	IIC0_ICWUR2_WUASYF_0 = 0x0
	// RIIC asynchronous circuit enable condition
	IIC0_ICWUR2_WUASYF_1 = 0x1
	// Position of WUSEN field.
	IIC0_ICWUR2_WUSEN_Pos = 0x0
	// Bit mask of WUSEN field.
	IIC0_ICWUR2_WUSEN_Msk = 0x1
	// Bit WUSEN.
	IIC0_ICWUR2_WUSEN = 0x1
	// RIIC asynchronous circuit enable
	IIC0_ICWUR2_WUSEN_0 = 0x0
	// RIIC synchronous circuit enable
	IIC0_ICWUR2_WUSEN_1 = 0x1
)

// Constants for IIC1: Inter-Integrated Circuit 1
const (
	// ICCR1: I2C Bus Control Register 1
	// Position of ICE field.
	IIC1_ICCR1_ICE_Pos = 0x7
	// Bit mask of ICE field.
	IIC1_ICCR1_ICE_Msk = 0x80
	// Bit ICE.
	IIC1_ICCR1_ICE = 0x80
	// Disable (SCLn and SDAn pins in inactive state)
	IIC1_ICCR1_ICE_0 = 0x0
	// Enable (SCLn and SDAn pins in active state)
	IIC1_ICCR1_ICE_1 = 0x1
	// Position of IICRST field.
	IIC1_ICCR1_IICRST_Pos = 0x6
	// Bit mask of IICRST field.
	IIC1_ICCR1_IICRST_Msk = 0x40
	// Bit IICRST.
	IIC1_ICCR1_IICRST = 0x40
	// Releases the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_0 = 0x0
	// Initiates the RIIC reset or internal reset.
	IIC1_ICCR1_IICRST_1 = 0x1
	// Position of CLO field.
	IIC1_ICCR1_CLO_Pos = 0x5
	// Bit mask of CLO field.
	IIC1_ICCR1_CLO_Msk = 0x20
	// Bit CLO.
	IIC1_ICCR1_CLO = 0x20
	// Does not output an extra SCL clock cycle.
	IIC1_ICCR1_CLO_0 = 0x0
	// Outputs an extra SCL clock cycle.
	IIC1_ICCR1_CLO_1 = 0x1
	// Position of SOWP field.
	IIC1_ICCR1_SOWP_Pos = 0x4
	// Bit mask of SOWP field.
	IIC1_ICCR1_SOWP_Msk = 0x10
	// Bit SOWP.
	IIC1_ICCR1_SOWP = 0x10
	// Bits SCLO and SDAO can be written.
	IIC1_ICCR1_SOWP_0 = 0x0
	// Bits SCLO and SDAO are protected.
	IIC1_ICCR1_SOWP_1 = 0x1
	// Position of SCLO field.
	IIC1_ICCR1_SCLO_Pos = 0x3
	// Bit mask of SCLO field.
	IIC1_ICCR1_SCLO_Msk = 0x8
	// Bit SCLO.
	IIC1_ICCR1_SCLO = 0x8
	// (Read)The RIIC has driven the SCLn pin low. / (Write)The RIIC drives the SCLn pin low.
	IIC1_ICCR1_SCLO_0 = 0x0
	// (Read)The RIIC has released the SCLn pin. / (Write)The RIIC releases the SCLn pin.
	IIC1_ICCR1_SCLO_1 = 0x1
	// Position of SDAO field.
	IIC1_ICCR1_SDAO_Pos = 0x2
	// Bit mask of SDAO field.
	IIC1_ICCR1_SDAO_Msk = 0x4
	// Bit SDAO.
	IIC1_ICCR1_SDAO = 0x4
	// (Read)The RIIC has driven the SDAn pin low. / (Write)The RIIC drives the SDAn pin low.
	IIC1_ICCR1_SDAO_0 = 0x0
	// (Read)The RIIC has released the SDAn pin./ (Write)The RIIC releases the SDAn pin.
	IIC1_ICCR1_SDAO_1 = 0x1
	// Position of SCLI field.
	IIC1_ICCR1_SCLI_Pos = 0x1
	// Bit mask of SCLI field.
	IIC1_ICCR1_SCLI_Msk = 0x2
	// Bit SCLI.
	IIC1_ICCR1_SCLI = 0x2
	// SCLn line is low.
	IIC1_ICCR1_SCLI_0 = 0x0
	// SCLn line is high.
	IIC1_ICCR1_SCLI_1 = 0x1
	// Position of SDAI field.
	IIC1_ICCR1_SDAI_Pos = 0x0
	// Bit mask of SDAI field.
	IIC1_ICCR1_SDAI_Msk = 0x1
	// Bit SDAI.
	IIC1_ICCR1_SDAI = 0x1
	// SDAn line is low.
	IIC1_ICCR1_SDAI_0 = 0x0
	// SDAn line is high.
	IIC1_ICCR1_SDAI_1 = 0x1

	// ICCR2: I2C Bus Control Register 2
	// Position of BBSY field.
	IIC1_ICCR2_BBSY_Pos = 0x7
	// Bit mask of BBSY field.
	IIC1_ICCR2_BBSY_Msk = 0x80
	// Bit BBSY.
	IIC1_ICCR2_BBSY = 0x80
	// The I2C bus is released (bus free state).
	IIC1_ICCR2_BBSY_0 = 0x0
	// The I2C bus is occupied (bus busy state).
	IIC1_ICCR2_BBSY_1 = 0x1
	// Position of MST field.
	IIC1_ICCR2_MST_Pos = 0x6
	// Bit mask of MST field.
	IIC1_ICCR2_MST_Msk = 0x40
	// Bit MST.
	IIC1_ICCR2_MST = 0x40
	// Slave mode
	IIC1_ICCR2_MST_0 = 0x0
	// Master mode
	IIC1_ICCR2_MST_1 = 0x1
	// Position of TRS field.
	IIC1_ICCR2_TRS_Pos = 0x5
	// Bit mask of TRS field.
	IIC1_ICCR2_TRS_Msk = 0x20
	// Bit TRS.
	IIC1_ICCR2_TRS = 0x20
	// Receive mode
	IIC1_ICCR2_TRS_0 = 0x0
	// Transmit mode
	IIC1_ICCR2_TRS_1 = 0x1
	// Position of Reserved field.
	IIC1_ICCR2_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICCR2_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICCR2_Reserved = 0x10
	// Position of SP field.
	IIC1_ICCR2_SP_Pos = 0x3
	// Bit mask of SP field.
	IIC1_ICCR2_SP_Msk = 0x8
	// Bit SP.
	IIC1_ICCR2_SP = 0x8
	// Does not request to issue a stop condition.
	IIC1_ICCR2_SP_0 = 0x0
	// Requests to issue a stop condition.
	IIC1_ICCR2_SP_1 = 0x1
	// Position of RS field.
	IIC1_ICCR2_RS_Pos = 0x2
	// Bit mask of RS field.
	IIC1_ICCR2_RS_Msk = 0x4
	// Bit RS.
	IIC1_ICCR2_RS = 0x4
	// Does not request to issue a restart condition.
	IIC1_ICCR2_RS_0 = 0x0
	// Requests to issue a restart condition.
	IIC1_ICCR2_RS_1 = 0x1
	// Position of ST field.
	IIC1_ICCR2_ST_Pos = 0x1
	// Bit mask of ST field.
	IIC1_ICCR2_ST_Msk = 0x2
	// Bit ST.
	IIC1_ICCR2_ST = 0x2
	// Does not request to issue a start condition.
	IIC1_ICCR2_ST_0 = 0x0
	// Requests to issue a start condition.
	IIC1_ICCR2_ST_1 = 0x1
	// Position of Reserved field.
	IIC1_ICCR2_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	IIC1_ICCR2_Reserved_Msk = 0x1
	// Bit Reserved.
	IIC1_ICCR2_Reserved = 0x1

	// ICMR1: I2C Bus Mode Register 1
	// Position of MTWP field.
	IIC1_ICMR1_MTWP_Pos = 0x7
	// Bit mask of MTWP field.
	IIC1_ICMR1_MTWP_Msk = 0x80
	// Bit MTWP.
	IIC1_ICMR1_MTWP = 0x80
	// Disables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_0 = 0x0
	// Enables writing to the MST and TRS bits in ICCR2.
	IIC1_ICMR1_MTWP_1 = 0x1
	// Position of CKS field.
	IIC1_ICMR1_CKS_Pos = 0x4
	// Bit mask of CKS field.
	IIC1_ICMR1_CKS_Msk = 0x70
	// PCLKB/1 clock
	IIC1_ICMR1_CKS_000 = 0x0
	// PCLKB/2 clock
	IIC1_ICMR1_CKS_001 = 0x1
	// PCLKB/4 clock
	IIC1_ICMR1_CKS_010 = 0x2
	// PCLKB/8 clock
	IIC1_ICMR1_CKS_011 = 0x3
	// PCLKB/16 clock
	IIC1_ICMR1_CKS_100 = 0x4
	// PCLKB/32 clock
	IIC1_ICMR1_CKS_101 = 0x5
	// PCLKB/64 clock
	IIC1_ICMR1_CKS_110 = 0x6
	// PCLKB/128 clock
	IIC1_ICMR1_CKS_111 = 0x7
	// Position of BCWP field.
	IIC1_ICMR1_BCWP_Pos = 0x3
	// Bit mask of BCWP field.
	IIC1_ICMR1_BCWP_Msk = 0x8
	// Bit BCWP.
	IIC1_ICMR1_BCWP = 0x8
	// Enables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_0 = 0x0
	// Disables a value to be written in the BC[2:0] bits.
	IIC1_ICMR1_BCWP_1 = 0x1
	// Position of BC field.
	IIC1_ICMR1_BC_Pos = 0x0
	// Bit mask of BC field.
	IIC1_ICMR1_BC_Msk = 0x7
	// 9 bits
	IIC1_ICMR1_BC_000 = 0x0
	// 2 bits
	IIC1_ICMR1_BC_001 = 0x1
	// 3 bits
	IIC1_ICMR1_BC_010 = 0x2
	// 4 bits
	IIC1_ICMR1_BC_011 = 0x3
	// 5 bits
	IIC1_ICMR1_BC_100 = 0x4
	// 6 bits
	IIC1_ICMR1_BC_101 = 0x5
	// 7 bits
	IIC1_ICMR1_BC_110 = 0x6
	// 8 bits
	IIC1_ICMR1_BC_111 = 0x7

	// ICMR2: I2C Bus Mode Register 2
	// Position of DLCS field.
	IIC1_ICMR2_DLCS_Pos = 0x7
	// Bit mask of DLCS field.
	IIC1_ICMR2_DLCS_Msk = 0x80
	// Bit DLCS.
	IIC1_ICMR2_DLCS = 0x80
	// The internal reference clock (fIIC) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_0 = 0x0
	// The internal reference clock divided by 2 (fIIC/2) is selected as the clock source of the SDA output delay counter.
	IIC1_ICMR2_DLCS_1 = 0x1
	// Position of SDDL field.
	IIC1_ICMR2_SDDL_Pos = 0x4
	// Bit mask of SDDL field.
	IIC1_ICMR2_SDDL_Msk = 0x70
	// No output delay
	IIC1_ICMR2_SDDL_000 = 0x0
	// 1 fIIC cycle (ICMR2.DLCS=0) / 1 or 2 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_001 = 0x1
	// 2 fIIC cycles (ICMR2.DLCS=0) / 3 or 4 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_010 = 0x2
	// 3 fIIC cycles (ICMR2.DLCS=0) / 5 or 6 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_011 = 0x3
	// 4 fIIC cycles (ICMR2.DLCS=0) / 7 or 8 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_100 = 0x4
	// 5 fIIC cycles (ICMR2.DLCS=0) / 9 or 10 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_101 = 0x5
	// 6 fIIC cycles (ICMR2.DLCS=0) / 11 or 12 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_110 = 0x6
	// 7 fIIC cycles (ICMR2.DLCS=0) / 13 or 14 fIIC cycles (ICMR2.DLCS=1)
	IIC1_ICMR2_SDDL_111 = 0x7
	// Position of Reserved field.
	IIC1_ICMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC1_ICMR2_Reserved_Msk = 0x8
	// Bit Reserved.
	IIC1_ICMR2_Reserved = 0x8
	// Position of TMOH field.
	IIC1_ICMR2_TMOH_Pos = 0x2
	// Bit mask of TMOH field.
	IIC1_ICMR2_TMOH_Msk = 0x4
	// Bit TMOH.
	IIC1_ICMR2_TMOH = 0x4
	// Count is disabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_0 = 0x0
	// Count is enabled while the SCLn line is at a high level.
	IIC1_ICMR2_TMOH_1 = 0x1
	// Position of TMOL field.
	IIC1_ICMR2_TMOL_Pos = 0x1
	// Bit mask of TMOL field.
	IIC1_ICMR2_TMOL_Msk = 0x2
	// Bit TMOL.
	IIC1_ICMR2_TMOL = 0x2
	// Count is disabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_0 = 0x0
	// Count is enabled while the SCLn line is at a low level.
	IIC1_ICMR2_TMOL_1 = 0x1
	// Position of TMOS field.
	IIC1_ICMR2_TMOS_Pos = 0x0
	// Bit mask of TMOS field.
	IIC1_ICMR2_TMOS_Msk = 0x1
	// Bit TMOS.
	IIC1_ICMR2_TMOS = 0x1
	// Long mode is selected.
	IIC1_ICMR2_TMOS_0 = 0x0
	// Short mode is selected.
	IIC1_ICMR2_TMOS_1 = 0x1

	// ICMR3: I2C Bus Mode Register 3
	// Position of SMBE field.
	IIC1_ICMR3_SMBE_Pos = 0x7
	// Bit mask of SMBE field.
	IIC1_ICMR3_SMBE_Msk = 0x80
	// Bit SMBE.
	IIC1_ICMR3_SMBE = 0x80
	// The I2C bus is selected.
	IIC1_ICMR3_SMBE_0 = 0x0
	// The SMBus is selected.
	IIC1_ICMR3_SMBE_1 = 0x1
	// Position of WAIT field.
	IIC1_ICMR3_WAIT_Pos = 0x6
	// Bit mask of WAIT field.
	IIC1_ICMR3_WAIT_Msk = 0x40
	// Bit WAIT.
	IIC1_ICMR3_WAIT = 0x40
	// No WAIT (The period between ninth clock cycle and first clock cycle is not held low.)
	IIC1_ICMR3_WAIT_0 = 0x0
	// WAIT (The period between ninth clock cycle and first clock cycle is held low.)
	IIC1_ICMR3_WAIT_1 = 0x1
	// Position of RDRFS field.
	IIC1_ICMR3_RDRFS_Pos = 0x5
	// Bit mask of RDRFS field.
	IIC1_ICMR3_RDRFS_Msk = 0x20
	// Bit RDRFS.
	IIC1_ICMR3_RDRFS = 0x20
	// The RDRF flag is set at the rising edge of the ninth SCL clock cycle. (The SCLn line is not held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_0 = 0x0
	// The RDRF flag is set at the rising edge of the eighth SCL clock cycle. (The SCLn line is held low at the falling edge of the eighth clock cycle.)
	IIC1_ICMR3_RDRFS_1 = 0x1
	// Position of ACKWP field.
	IIC1_ICMR3_ACKWP_Pos = 0x4
	// Bit mask of ACKWP field.
	IIC1_ICMR3_ACKWP_Msk = 0x10
	// Bit ACKWP.
	IIC1_ICMR3_ACKWP = 0x10
	// Modification of the ACKBT bit is disabled.
	IIC1_ICMR3_ACKWP_0 = 0x0
	// Modification of the ACKBT bit is enabled.
	IIC1_ICMR3_ACKWP_1 = 0x1
	// Position of ACKBT field.
	IIC1_ICMR3_ACKBT_Pos = 0x3
	// Bit mask of ACKBT field.
	IIC1_ICMR3_ACKBT_Msk = 0x8
	// Bit ACKBT.
	IIC1_ICMR3_ACKBT = 0x8
	// A 0 is sent as the acknowledge bit (ACK transmission).
	IIC1_ICMR3_ACKBT_0 = 0x0
	// A 1 is sent as the acknowledge bit (NACK transmission).
	IIC1_ICMR3_ACKBT_1 = 0x1
	// Position of ACKBR field.
	IIC1_ICMR3_ACKBR_Pos = 0x2
	// Bit mask of ACKBR field.
	IIC1_ICMR3_ACKBR_Msk = 0x4
	// Bit ACKBR.
	IIC1_ICMR3_ACKBR = 0x4
	// A 0 is received as the acknowledge bit (ACK reception).
	IIC1_ICMR3_ACKBR_0 = 0x0
	// A 1 is received as the acknowledge bit (NACK reception).
	IIC1_ICMR3_ACKBR_1 = 0x1
	// Position of NF field.
	IIC1_ICMR3_NF_Pos = 0x0
	// Bit mask of NF field.
	IIC1_ICMR3_NF_Msk = 0x3
	// Noise of up to one IIC cycle is filtered out (single-stage filter).
	IIC1_ICMR3_NF_00 = 0x0
	// Noise of up to two IIC cycles is filtered out (2-stage filter).
	IIC1_ICMR3_NF_01 = 0x1
	// Noise of up to three IIC cycles is filtered out (3-stage filter).
	IIC1_ICMR3_NF_10 = 0x2
	// Noise of up to four IIC cycles is filtered out (4-stage filter)
	IIC1_ICMR3_NF_11 = 0x3

	// ICFER: I2C Bus Function Enable Register
	// Position of Reserved field.
	IIC1_ICFER_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	IIC1_ICFER_Reserved_Msk = 0x80
	// Bit Reserved.
	IIC1_ICFER_Reserved = 0x80
	// Position of SCLE field.
	IIC1_ICFER_SCLE_Pos = 0x6
	// Bit mask of SCLE field.
	IIC1_ICFER_SCLE_Msk = 0x40
	// Bit SCLE.
	IIC1_ICFER_SCLE = 0x40
	// No SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_0 = 0x0
	// An SCL synchronous circuit is used.
	IIC1_ICFER_SCLE_1 = 0x1
	// Position of NFE field.
	IIC1_ICFER_NFE_Pos = 0x5
	// Bit mask of NFE field.
	IIC1_ICFER_NFE_Msk = 0x20
	// Bit NFE.
	IIC1_ICFER_NFE = 0x20
	// No digital noise filter circuit is used.
	IIC1_ICFER_NFE_0 = 0x0
	// A digital noise filter circuit is used.
	IIC1_ICFER_NFE_1 = 0x1
	// Position of NACKE field.
	IIC1_ICFER_NACKE_Pos = 0x4
	// Bit mask of NACKE field.
	IIC1_ICFER_NACKE_Msk = 0x10
	// Bit NACKE.
	IIC1_ICFER_NACKE = 0x10
	// Transfer operation is not suspended during NACK reception (transfer suspension disabled).
	IIC1_ICFER_NACKE_0 = 0x0
	// Transfer operation is suspended during NACK reception (transfer suspension enabled).
	IIC1_ICFER_NACKE_1 = 0x1
	// Position of SALE field.
	IIC1_ICFER_SALE_Pos = 0x3
	// Bit mask of SALE field.
	IIC1_ICFER_SALE_Msk = 0x8
	// Bit SALE.
	IIC1_ICFER_SALE = 0x8
	// Slave arbitration-lost detection is disabled.
	IIC1_ICFER_SALE_0 = 0x0
	// Slave arbitration-lost detection is enabled.
	IIC1_ICFER_SALE_1 = 0x1
	// Position of NALE field.
	IIC1_ICFER_NALE_Pos = 0x2
	// Bit mask of NALE field.
	IIC1_ICFER_NALE_Msk = 0x4
	// Bit NALE.
	IIC1_ICFER_NALE = 0x4
	// NACK transmission arbitration-lost detection is disabled.
	IIC1_ICFER_NALE_0 = 0x0
	// NACK transmission arbitration-lost detection is enabled.
	IIC1_ICFER_NALE_1 = 0x1
	// Position of MALE field.
	IIC1_ICFER_MALE_Pos = 0x1
	// Bit mask of MALE field.
	IIC1_ICFER_MALE_Msk = 0x2
	// Bit MALE.
	IIC1_ICFER_MALE = 0x2
	// Master arbitration-lost detection is disabled.
	IIC1_ICFER_MALE_0 = 0x0
	// Master arbitration-lost detection is enabled.
	IIC1_ICFER_MALE_1 = 0x1
	// Position of TMOE field.
	IIC1_ICFER_TMOE_Pos = 0x0
	// Bit mask of TMOE field.
	IIC1_ICFER_TMOE_Msk = 0x1
	// Bit TMOE.
	IIC1_ICFER_TMOE = 0x1
	// The timeout function is disabled.
	IIC1_ICFER_TMOE_0 = 0x0
	// The timeout function is enabled.
	IIC1_ICFER_TMOE_1 = 0x1

	// ICSER: I2C Bus Status Enable Register
	// Position of HOAE field.
	IIC1_ICSER_HOAE_Pos = 0x7
	// Bit mask of HOAE field.
	IIC1_ICSER_HOAE_Msk = 0x80
	// Bit HOAE.
	IIC1_ICSER_HOAE = 0x80
	// Host address detection is disabled.
	IIC1_ICSER_HOAE_0 = 0x0
	// Host address detection is enabled.
	IIC1_ICSER_HOAE_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSER_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC1_ICSER_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC1_ICSER_Reserved = 0x40
	// Position of DIDE field.
	IIC1_ICSER_DIDE_Pos = 0x5
	// Bit mask of DIDE field.
	IIC1_ICSER_DIDE_Msk = 0x20
	// Bit DIDE.
	IIC1_ICSER_DIDE = 0x20
	// Device-ID address detection is disabled.
	IIC1_ICSER_DIDE_0 = 0x0
	// Device-ID address detection is enabled.
	IIC1_ICSER_DIDE_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICSER_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICSER_Reserved = 0x10
	// Position of GCAE field.
	IIC1_ICSER_GCAE_Pos = 0x3
	// Bit mask of GCAE field.
	IIC1_ICSER_GCAE_Msk = 0x8
	// Bit GCAE.
	IIC1_ICSER_GCAE = 0x8
	// General call address detection is disabled.
	IIC1_ICSER_GCAE_0 = 0x0
	// General call address detection is enabled.
	IIC1_ICSER_GCAE_1 = 0x1
	// Position of SAR2E field.
	IIC1_ICSER_SAR2E_Pos = 0x2
	// Bit mask of SAR2E field.
	IIC1_ICSER_SAR2E_Msk = 0x4
	// Bit SAR2E.
	IIC1_ICSER_SAR2E = 0x4
	// Slave address in SARL2 and SARU2 is disabled.
	IIC1_ICSER_SAR2E_0 = 0x0
	// Slave address in SARL2 and SARU2 is enabled
	IIC1_ICSER_SAR2E_1 = 0x1
	// Position of SAR1E field.
	IIC1_ICSER_SAR1E_Pos = 0x1
	// Bit mask of SAR1E field.
	IIC1_ICSER_SAR1E_Msk = 0x2
	// Bit SAR1E.
	IIC1_ICSER_SAR1E = 0x2
	// Slave address in SARL1 and SARU1 is disabled.
	IIC1_ICSER_SAR1E_0 = 0x0
	// Slave address in SARL1 and SARU1 is enabled.
	IIC1_ICSER_SAR1E_1 = 0x1
	// Position of SAR0E field.
	IIC1_ICSER_SAR0E_Pos = 0x0
	// Bit mask of SAR0E field.
	IIC1_ICSER_SAR0E_Msk = 0x1
	// Bit SAR0E.
	IIC1_ICSER_SAR0E = 0x1
	// Slave address in SARL0 and SARU0 is disabled.
	IIC1_ICSER_SAR0E_0 = 0x0
	// Slave address in SARL0 and SARU0 is enabled.
	IIC1_ICSER_SAR0E_1 = 0x1

	// ICIER: I2C Bus Interrupt Enable Register
	// Position of TIE field.
	IIC1_ICIER_TIE_Pos = 0x7
	// Bit mask of TIE field.
	IIC1_ICIER_TIE_Msk = 0x80
	// Bit TIE.
	IIC1_ICIER_TIE = 0x80
	// Transmit data empty interrupt request (IICn_TXI) is disabled.
	IIC1_ICIER_TIE_0 = 0x0
	// Transmit data empty interrupt request (IICn_TXI) is enabled.
	IIC1_ICIER_TIE_1 = 0x1
	// Position of TEIE field.
	IIC1_ICIER_TEIE_Pos = 0x6
	// Bit mask of TEIE field.
	IIC1_ICIER_TEIE_Msk = 0x40
	// Bit TEIE.
	IIC1_ICIER_TEIE = 0x40
	// Transmit end interrupt request (IICn_TEI) is disabled.
	IIC1_ICIER_TEIE_0 = 0x0
	// Transmit end interrupt request (IICn_TEI) is enabled.
	IIC1_ICIER_TEIE_1 = 0x1
	// Position of RIE field.
	IIC1_ICIER_RIE_Pos = 0x5
	// Bit mask of RIE field.
	IIC1_ICIER_RIE_Msk = 0x20
	// Bit RIE.
	IIC1_ICIER_RIE = 0x20
	// Receive data full interrupt request (IICn_RXI) is disabled.
	IIC1_ICIER_RIE_0 = 0x0
	// Receive data full interrupt request (IICn_RXI) is enabled.
	IIC1_ICIER_RIE_1 = 0x1
	// Position of NAKIE field.
	IIC1_ICIER_NAKIE_Pos = 0x4
	// Bit mask of NAKIE field.
	IIC1_ICIER_NAKIE_Msk = 0x10
	// Bit NAKIE.
	IIC1_ICIER_NAKIE = 0x10
	// NACK reception interrupt request (NAKI) is disabled.
	IIC1_ICIER_NAKIE_0 = 0x0
	// NACK reception interrupt request (NAKI) is enabled.
	IIC1_ICIER_NAKIE_1 = 0x1
	// Position of SPIE field.
	IIC1_ICIER_SPIE_Pos = 0x3
	// Bit mask of SPIE field.
	IIC1_ICIER_SPIE_Msk = 0x8
	// Bit SPIE.
	IIC1_ICIER_SPIE = 0x8
	// Stop condition detection interrupt request (SPI) is disabled.
	IIC1_ICIER_SPIE_0 = 0x0
	// Stop condition detection interrupt request (SPI) is enabled.
	IIC1_ICIER_SPIE_1 = 0x1
	// Position of STIE field.
	IIC1_ICIER_STIE_Pos = 0x2
	// Bit mask of STIE field.
	IIC1_ICIER_STIE_Msk = 0x4
	// Bit STIE.
	IIC1_ICIER_STIE = 0x4
	// Start condition detection interrupt request (STI) is disabled.
	IIC1_ICIER_STIE_0 = 0x0
	// Start condition detection interrupt request (STI) is enabled.
	IIC1_ICIER_STIE_1 = 0x1
	// Position of ALIE field.
	IIC1_ICIER_ALIE_Pos = 0x1
	// Bit mask of ALIE field.
	IIC1_ICIER_ALIE_Msk = 0x2
	// Bit ALIE.
	IIC1_ICIER_ALIE = 0x2
	// Arbitration-lost interrupt request (ALI) is disabled.
	IIC1_ICIER_ALIE_0 = 0x0
	// Arbitration-lost interrupt request (ALI) is enabled.
	IIC1_ICIER_ALIE_1 = 0x1
	// Position of TMOIE field.
	IIC1_ICIER_TMOIE_Pos = 0x0
	// Bit mask of TMOIE field.
	IIC1_ICIER_TMOIE_Msk = 0x1
	// Bit TMOIE.
	IIC1_ICIER_TMOIE = 0x1
	// Timeout interrupt request (TMOI) is disabled.
	IIC1_ICIER_TMOIE_0 = 0x0
	// Timeout interrupt request (TMOI) is enabled.
	IIC1_ICIER_TMOIE_1 = 0x1

	// ICSR1: I2C Bus Status Register 1
	// Position of HOA field.
	IIC1_ICSR1_HOA_Pos = 0x7
	// Bit mask of HOA field.
	IIC1_ICSR1_HOA_Msk = 0x80
	// Bit HOA.
	IIC1_ICSR1_HOA = 0x80
	// Host address is not detected.
	IIC1_ICSR1_HOA_0 = 0x0
	// Host address is detected.
	IIC1_ICSR1_HOA_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSR1_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	IIC1_ICSR1_Reserved_Msk = 0x40
	// Bit Reserved.
	IIC1_ICSR1_Reserved = 0x40
	// Position of DID field.
	IIC1_ICSR1_DID_Pos = 0x5
	// Bit mask of DID field.
	IIC1_ICSR1_DID_Msk = 0x20
	// Bit DID.
	IIC1_ICSR1_DID = 0x20
	// Device-ID command is not detected.
	IIC1_ICSR1_DID_0 = 0x0
	// Device-ID command is detected.
	IIC1_ICSR1_DID_1 = 0x1
	// Position of Reserved field.
	IIC1_ICSR1_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	IIC1_ICSR1_Reserved_Msk = 0x10
	// Bit Reserved.
	IIC1_ICSR1_Reserved = 0x10
	// Position of GCA field.
	IIC1_ICSR1_GCA_Pos = 0x3
	// Bit mask of GCA field.
	IIC1_ICSR1_GCA_Msk = 0x8
	// Bit GCA.
	IIC1_ICSR1_GCA = 0x8
	// General call address is not detected.
	IIC1_ICSR1_GCA_0 = 0x0
	// General call address is detected.
	IIC1_ICSR1_GCA_1 = 0x1
	// Position of AAS2 field.
	IIC1_ICSR1_AAS2_Pos = 0x2
	// Bit mask of AAS2 field.
	IIC1_ICSR1_AAS2_Msk = 0x4
	// Bit AAS2.
	IIC1_ICSR1_AAS2 = 0x4
	// Slave address 2 is not detected.
	IIC1_ICSR1_AAS2_0 = 0x0
	// Slave address 2 is detected
	IIC1_ICSR1_AAS2_1 = 0x1
	// Position of AAS1 field.
	IIC1_ICSR1_AAS1_Pos = 0x1
	// Bit mask of AAS1 field.
	IIC1_ICSR1_AAS1_Msk = 0x2
	// Bit AAS1.
	IIC1_ICSR1_AAS1 = 0x2
	// Slave address 1 is not detected.
	IIC1_ICSR1_AAS1_0 = 0x0
	// Slave address 1 is detected.
	IIC1_ICSR1_AAS1_1 = 0x1
	// Position of AAS0 field.
	IIC1_ICSR1_AAS0_Pos = 0x0
	// Bit mask of AAS0 field.
	IIC1_ICSR1_AAS0_Msk = 0x1
	// Bit AAS0.
	IIC1_ICSR1_AAS0 = 0x1
	// Slave address 0 is not detected.
	IIC1_ICSR1_AAS0_0 = 0x0
	// Slave address 0 is detected.
	IIC1_ICSR1_AAS0_1 = 0x1

	// ICSR2: I2C Bus Status Register 2
	// Position of TDRE field.
	IIC1_ICSR2_TDRE_Pos = 0x7
	// Bit mask of TDRE field.
	IIC1_ICSR2_TDRE_Msk = 0x80
	// Bit TDRE.
	IIC1_ICSR2_TDRE = 0x80
	// ICDRT contains transmit data.
	IIC1_ICSR2_TDRE_0 = 0x0
	// ICDRT contains no transmit data.
	IIC1_ICSR2_TDRE_1 = 0x1
	// Position of TEND field.
	IIC1_ICSR2_TEND_Pos = 0x6
	// Bit mask of TEND field.
	IIC1_ICSR2_TEND_Msk = 0x40
	// Bit TEND.
	IIC1_ICSR2_TEND = 0x40
	// Data is being transmitted.
	IIC1_ICSR2_TEND_0 = 0x0
	// Data has been transmitted.
	IIC1_ICSR2_TEND_1 = 0x1
	// Position of RDRF field.
	IIC1_ICSR2_RDRF_Pos = 0x5
	// Bit mask of RDRF field.
	IIC1_ICSR2_RDRF_Msk = 0x20
	// Bit RDRF.
	IIC1_ICSR2_RDRF = 0x20
	// ICDRR contains no receive data.
	IIC1_ICSR2_RDRF_0 = 0x0
	// ICDRR contains receive data.
	IIC1_ICSR2_RDRF_1 = 0x1
	// Position of NACKF field.
	IIC1_ICSR2_NACKF_Pos = 0x4
	// Bit mask of NACKF field.
	IIC1_ICSR2_NACKF_Msk = 0x10
	// Bit NACKF.
	IIC1_ICSR2_NACKF = 0x10
	// NACK is not detected.
	IIC1_ICSR2_NACKF_0 = 0x0
	// NACK is detected.
	IIC1_ICSR2_NACKF_1 = 0x1
	// Position of STOP field.
	IIC1_ICSR2_STOP_Pos = 0x3
	// Bit mask of STOP field.
	IIC1_ICSR2_STOP_Msk = 0x8
	// Bit STOP.
	IIC1_ICSR2_STOP = 0x8
	// Stop condition is not detected.
	IIC1_ICSR2_STOP_0 = 0x0
	// Stop condition is detected.
	IIC1_ICSR2_STOP_1 = 0x1
	// Position of START field.
	IIC1_ICSR2_START_Pos = 0x2
	// Bit mask of START field.
	IIC1_ICSR2_START_Msk = 0x4
	// Bit START.
	IIC1_ICSR2_START = 0x4
	// Start condition is not detected.
	IIC1_ICSR2_START_0 = 0x0
	// Start condition is detected.
	IIC1_ICSR2_START_1 = 0x1
	// Position of AL field.
	IIC1_ICSR2_AL_Pos = 0x1
	// Bit mask of AL field.
	IIC1_ICSR2_AL_Msk = 0x2
	// Bit AL.
	IIC1_ICSR2_AL = 0x2
	// Arbitration is not lost.
	IIC1_ICSR2_AL_0 = 0x0
	// Arbitration is lost.
	IIC1_ICSR2_AL_1 = 0x1
	// Position of TMOF field.
	IIC1_ICSR2_TMOF_Pos = 0x0
	// Bit mask of TMOF field.
	IIC1_ICSR2_TMOF_Msk = 0x1
	// Bit TMOF.
	IIC1_ICSR2_TMOF = 0x1
	// Timeout is not detected.
	IIC1_ICSR2_TMOF_0 = 0x0
	// Timeout is detected.
	IIC1_ICSR2_TMOF_1 = 0x1

	// SARL0: Slave Address Register L%s
	// Position of SVA field.
	IIC1_SARL_SVA_Pos = 0x0
	// Bit mask of SVA field.
	IIC1_SARL_SVA_Msk = 0xff

	// SARU0: Slave Address Register U%s
	// Position of Reserved field.
	IIC1_SARU_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	IIC1_SARU_Reserved_Msk = 0xf8
	// Position of SVA9 field.
	IIC1_SARU_SVA9_Pos = 0x2
	// Bit mask of SVA9 field.
	IIC1_SARU_SVA9_Msk = 0x4
	// Bit SVA9.
	IIC1_SARU_SVA9 = 0x4
	// Position of SVA8 field.
	IIC1_SARU_SVA8_Pos = 0x1
	// Bit mask of SVA8 field.
	IIC1_SARU_SVA8_Msk = 0x2
	// Bit SVA8.
	IIC1_SARU_SVA8 = 0x2
	// Position of FS field.
	IIC1_SARU_FS_Pos = 0x0
	// Bit mask of FS field.
	IIC1_SARU_FS_Msk = 0x1
	// Bit FS.
	IIC1_SARU_FS = 0x1
	// The 7-bit address format is selected.
	IIC1_SARU_FS_0 = 0x0
	// The 10-bit address format is selected.
	IIC1_SARU_FS_1 = 0x1

	// ICBRL: I2C Bus Bit Rate Low-Level Register
	// Position of Reserved field.
	IIC1_ICBRL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC1_ICBRL_Reserved_Msk = 0xe0
	// Position of BRL field.
	IIC1_ICBRL_BRL_Pos = 0x0
	// Bit mask of BRL field.
	IIC1_ICBRL_BRL_Msk = 0x1f

	// ICBRH: I2C Bus Bit Rate High-Level Register
	// Position of Reserved field.
	IIC1_ICBRH_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	IIC1_ICBRH_Reserved_Msk = 0xe0
	// Position of BRH field.
	IIC1_ICBRH_BRH_Pos = 0x0
	// Bit mask of BRH field.
	IIC1_ICBRH_BRH_Msk = 0x1f

	// ICDRT: I2C Bus Transmit Data Register
	// Position of ICDRT field.
	IIC1_ICDRT_ICDRT_Pos = 0x0
	// Bit mask of ICDRT field.
	IIC1_ICDRT_ICDRT_Msk = 0xff

	// ICDRR: I2C Bus Receive Data Register
	// Position of ICDRR field.
	IIC1_ICDRR_ICDRR_Pos = 0x0
	// Bit mask of ICDRR field.
	IIC1_ICDRR_ICDRR_Msk = 0xff
)

// Constants for MMF: Memory Mirror Function
const (
	// MMSFR: MemMirror Special Function Register
	// Position of KEY field.
	MMF_MMSFR_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMSFR_KEY_Msk = 0xff000000
	// Writing to the MEMMIRADDR bits are valid, when the KEY bits are written 0xDB.
	MMF_MMSFR_KEY_0xDB = 0xdb
	// Position of Reserved field.
	MMF_MMSFR_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	MMF_MMSFR_Reserved_Msk = 0x800000
	// Bit Reserved.
	MMF_MMSFR_Reserved = 0x800000
	// Position of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Pos = 0x7
	// Bit mask of MEMMIRADDR field.
	MMF_MMSFR_MEMMIRADDR_Msk = 0x7fff80
	// Position of Reserved field.
	MMF_MMSFR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MMF_MMSFR_Reserved_Msk = 0x7f

	// MMEN: MemMirror Enable Register
	// Position of KEY field.
	MMF_MMEN_KEY_Pos = 0x18
	// Bit mask of KEY field.
	MMF_MMEN_KEY_Msk = 0xff000000
	// Writing to the EN bit is valid, when the KEY bits are written 0xDB.
	MMF_MMEN_KEY_0xDB = 0xdb
	// Position of Reserved field.
	MMF_MMEN_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	MMF_MMEN_Reserved_Msk = 0xfffffe
	// Position of EN field.
	MMF_MMEN_EN_Pos = 0x0
	// Bit mask of EN field.
	MMF_MMEN_EN_Msk = 0x1
	// Bit EN.
	MMF_MMEN_EN = 0x1
	// Memory Mirror Function is enabled.
	MMF_MMEN_EN_1 = 0x1
	// Memory Mirror Function is disabled.
	MMF_MMEN_EN_0 = 0x0
)

// Constants for MMPU: Bus Master MPU
const (
	// MMPUCTLA: Bus Master MPU Control Register
	// Position of KEY field.
	MMPU_MMPUCTLA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUCTLA_KEY_Msk = 0xff00
	// Writing to the OAD and ENABLE bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUCTLA_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	MMPU_MMPUCTLA_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	MMPU_MMPUCTLA_Reserved_Msk = 0xfc
	// Position of OAD field.
	MMPU_MMPUCTLA_OAD_Pos = 0x1
	// Bit mask of OAD field.
	MMPU_MMPUCTLA_OAD_Msk = 0x2
	// Bit OAD.
	MMPU_MMPUCTLA_OAD = 0x2
	// Non-maskable interrupt.
	MMPU_MMPUCTLA_OAD_0 = 0x0
	// Internal reset.
	MMPU_MMPUCTLA_OAD_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUCTLA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUCTLA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUCTLA_ENABLE = 0x1
	// Master Group A disabled. Permission of all regions.
	MMPU_MMPUCTLA_ENABLE_0 = 0x0
	// Master Group A enabled. Protection of all regions.
	MMPU_MMPUCTLA_ENABLE_1 = 0x1

	// MMPUPTA: Group A Protection of Register
	// Position of KEY field.
	MMPU_MMPUPTA_KEY_Pos = 0x8
	// Bit mask of KEY field.
	MMPU_MMPUPTA_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	MMPU_MMPUPTA_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	MMPU_MMPUPTA_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	MMPU_MMPUPTA_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	MMPU_MMPUPTA_PROTECT_Msk = 0x1
	// Bit PROTECT.
	MMPU_MMPUPTA_PROTECT = 0x1
	// All Bus Master MPU Group A register writing is possible.
	MMPU_MMPUPTA_PROTECT_0 = 0x0
	// All Bus Master MPU Group A register writing is protected. Read is possible.
	MMPU_MMPUPTA_PROTECT_1 = 0x1

	// MMPUACA0: Group A Region %s Access Control Register
	// Position of Reserved field.
	MMPU_MMPUACA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	MMPU_MMPUACA_Reserved_Msk = 0xfff8
	// Position of WP field.
	MMPU_MMPUACA_WP_Pos = 0x2
	// Bit mask of WP field.
	MMPU_MMPUACA_WP_Msk = 0x4
	// Bit WP.
	MMPU_MMPUACA_WP = 0x4
	// Write permission
	MMPU_MMPUACA_WP_0 = 0x0
	// Write protection
	MMPU_MMPUACA_WP_1 = 0x1
	// Position of RP field.
	MMPU_MMPUACA_RP_Pos = 0x1
	// Bit mask of RP field.
	MMPU_MMPUACA_RP_Msk = 0x2
	// Bit RP.
	MMPU_MMPUACA_RP = 0x2
	// Read permission
	MMPU_MMPUACA_RP_0 = 0x0
	// Read protection
	MMPU_MMPUACA_RP_1 = 0x1
	// Position of ENABLE field.
	MMPU_MMPUACA_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	MMPU_MMPUACA_ENABLE_Msk = 0x1
	// Bit ENABLE.
	MMPU_MMPUACA_ENABLE = 0x1
	// Group m Region n unit is disabled
	MMPU_MMPUACA_ENABLE_0 = 0x0
	// Group m Region n unit is enabled
	MMPU_MMPUACA_ENABLE_1 = 0x1

	// MMPUSA0: Group A Region %s Start Address Register
	// Position of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Pos = 0x0
	// Bit mask of MMPUSA field.
	MMPU_MMPUSA_MMPUSA_Msk = 0xffffffff
	// Position of Reserved field.
	MMPU_MMPUSA_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MMPU_MMPUSA_Reserved_Msk = 0x3

	// MMPUEA0: Group A Region %s End Address Register
	// Position of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Pos = 0x0
	// Bit mask of MMPUEA field.
	MMPU_MMPUEA_MMPUEA_Msk = 0xffffffff
	// Position of Reserved field.
	MMPU_MMPUEA_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MMPU_MMPUEA_Reserved_Msk = 0x3
)

// Constants for SMPU: Bus Slave MPU
const (
	// SMPUCTL: Slave MPU Control Register
	// Position of KEY field.
	SMPU_SMPUCTL_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SMPU_SMPUCTL_KEY_Msk = 0xff00
	// Writing to the PROTECT and OAD bit is valid, when the KEY bits are written 0xA5.
	SMPU_SMPUCTL_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SMPU_SMPUCTL_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SMPU_SMPUCTL_Reserved_Msk = 0xfc
	// Position of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Pos = 0x1
	// Bit mask of PROTECT field.
	SMPU_SMPUCTL_PROTECT_Msk = 0x2
	// Bit PROTECT.
	SMPU_SMPUCTL_PROTECT = 0x2
	// All Bus Slave register writing is possible.
	SMPU_SMPUCTL_PROTECT_0 = 0x0
	// All Bus Slave register writing is protected. Read is possible.
	SMPU_SMPUCTL_PROTECT_1 = 0x1
	// Position of OAD field.
	SMPU_SMPUCTL_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SMPU_SMPUCTL_OAD_Msk = 0x1
	// Bit OAD.
	SMPU_SMPUCTL_OAD = 0x1
	// Non-maskable interrupt.
	SMPU_SMPUCTL_OAD_0 = 0x0
	// Reset
	SMPU_SMPUCTL_OAD_1 = 0x1

	// SMPUMBIU: Access Control Register for MBIU
	// Position of Reserved field.
	SMPU_SMPUMBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUMBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUMBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUMBIU_WPGRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUMBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUMBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUMBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUMBIU_RPGRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUMBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUMBIU_RPGRPA_1 = 0x1
	// Position of Reserved field.
	SMPU_SMPUMBIU_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SMPU_SMPUMBIU_Reserved_Msk = 0x3

	// SMPUFBIU: Access Control Register for FBIU
	// Position of Reserved field.
	SMPU_SMPUFBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUFBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUFBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUFBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUFBIU_WPGRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUFBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUFBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUFBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUFBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUFBIU_RPGRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUFBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUFBIU_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUFBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUFBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUFBIU_WPCPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUFBIU_WPCPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUFBIU_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUFBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUFBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUFBIU_RPCPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUFBIU_RPCPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUFBIU_RPCPU_1 = 0x1

	// SMPUSRAM0: Access Control Register for SRAM
	// Position of Reserved field.
	SMPU_SMPUSRAM0_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUSRAM0_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUSRAM0_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUSRAM0_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUSRAM0_WPGRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUSRAM0_WPGRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUSRAM0_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUSRAM0_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUSRAM0_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUSRAM0_RPGRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUSRAM0_RPGRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUSRAM0_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUSRAM0_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUSRAM0_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUSRAM0_WPCPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUSRAM0_WPCPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUSRAM0_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUSRAM0_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUSRAM0_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUSRAM0_RPCPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUSRAM0_RPCPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUSRAM0_RPCPU_1 = 0x1

	// SMPUP0BIU: Access Control Register for P%sBIU
	// Position of Reserved field.
	SMPU_SMPUPBIU_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SMPU_SMPUPBIU_Reserved_Msk = 0xfff0
	// Position of WPGRPA field.
	SMPU_SMPUPBIU_WPGRPA_Pos = 0x3
	// Bit mask of WPGRPA field.
	SMPU_SMPUPBIU_WPGRPA_Msk = 0x8
	// Bit WPGRPA.
	SMPU_SMPUPBIU_WPGRPA = 0x8
	// Master group A write of memory protection is disabled.
	SMPU_SMPUPBIU_WPGRPA_0 = 0x0
	// Master group A write of memory protection is enabled.
	SMPU_SMPUPBIU_WPGRPA_1 = 0x1
	// Position of RPGRPA field.
	SMPU_SMPUPBIU_RPGRPA_Pos = 0x2
	// Bit mask of RPGRPA field.
	SMPU_SMPUPBIU_RPGRPA_Msk = 0x4
	// Bit RPGRPA.
	SMPU_SMPUPBIU_RPGRPA = 0x4
	// Master group A read of memory protection is disabled.
	SMPU_SMPUPBIU_RPGRPA_0 = 0x0
	// Master group A read of memory protection is enabled.
	SMPU_SMPUPBIU_RPGRPA_1 = 0x1
	// Position of WPCPU field.
	SMPU_SMPUPBIU_WPCPU_Pos = 0x1
	// Bit mask of WPCPU field.
	SMPU_SMPUPBIU_WPCPU_Msk = 0x2
	// Bit WPCPU.
	SMPU_SMPUPBIU_WPCPU = 0x2
	// CPU write of memory protection is disabled.
	SMPU_SMPUPBIU_WPCPU_0 = 0x0
	// CPU write of memory protection is enabled.
	SMPU_SMPUPBIU_WPCPU_1 = 0x1
	// Position of RPCPU field.
	SMPU_SMPUPBIU_RPCPU_Pos = 0x0
	// Bit mask of RPCPU field.
	SMPU_SMPUPBIU_RPCPU_Msk = 0x1
	// Bit RPCPU.
	SMPU_SMPUPBIU_RPCPU = 0x1
	// CPU read of memory protection is disabled.
	SMPU_SMPUPBIU_RPCPU_0 = 0x0
	// CPU read of memory protection is enabled.
	SMPU_SMPUPBIU_RPCPU_1 = 0x1
)

// Constants for SPMON: CPU Stack Pointer Monitor
const (
	// MSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_MSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_MSPMPUOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SPMON_MSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_MSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_MSPMPUOAD_OAD = 0x1
	// Internal reset.
	SPMON_MSPMPUOAD_OAD_1 = 0x1
	// Non-maskable interrupt.
	SPMON_MSPMPUOAD_OAD_0 = 0x0

	// MSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Msk = 0xfe00
	// Position of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_MSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_MSPMPUCTL_ERROR = 0x100
	// SP_main has not overflowed or underflowed.
	SPMON_MSPMPUCTL_ERROR_0 = 0x0
	// SP_main has overflowed or underflowed.
	SPMON_MSPMPUCTL_ERROR_1 = 0x1
	// Position of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUCTL_Reserved_Msk = 0xfe
	// Position of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_MSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_MSPMPUCTL_ENABLE = 0x1
	// SP_main monitor is disabled.
	SPMON_MSPMPUCTL_ENABLE_0 = 0x0
	// SP_main monitor is enabled.
	SPMON_MSPMPUCTL_ENABLE_1 = 0x1

	// MSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_MSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_MSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_MSPMPUPT_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_MSPMPUPT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_MSPMPUPT_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_MSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_MSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_MSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_MSPMPUPT_PROTECT_1 = 0x1

	// MSPMPUSA: Main Stack Pointer Monitor Start Address Register
	// Position of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Pos = 0x0
	// Bit mask of MSPMPUSA field.
	SPMON_MSPMPUSA_MSPMPUSA_Msk = 0xffffffff

	// MSPMPUEA: Main Stack Pointer Monitor End Address Register
	// Position of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Pos = 0x0
	// Bit mask of MSPMPUEA field.
	SPMON_MSPMPUEA_MSPMPUEA_Msk = 0xffffffff

	// PSPMPUOAD: Stack Pointer Monitor Operation After Detection Register
	// Position of KEY field.
	SPMON_PSPMPUOAD_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUOAD_KEY_Msk = 0xff00
	// Writing to the OAD bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUOAD_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_PSPMPUOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SPMON_PSPMPUOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SPMON_PSPMPUOAD_OAD_Msk = 0x1
	// Bit OAD.
	SPMON_PSPMPUOAD_OAD = 0x1
	// Internal reset.
	SPMON_PSPMPUOAD_OAD_1 = 0x1
	// Non-maskable interrupt.
	SPMON_PSPMPUOAD_OAD_0 = 0x0

	// PSPMPUCTL: Stack Pointer Monitor Access Control Register
	// Position of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Msk = 0xfe00
	// Position of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Pos = 0x8
	// Bit mask of ERROR field.
	SPMON_PSPMPUCTL_ERROR_Msk = 0x100
	// Bit ERROR.
	SPMON_PSPMPUCTL_ERROR = 0x100
	// SP_process has not overflowed or underflowed.
	SPMON_PSPMPUCTL_ERROR_0 = 0x0
	// SP_process has overflowed or underflowed.
	SPMON_PSPMPUCTL_ERROR_1 = 0x1
	// Position of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUCTL_Reserved_Msk = 0xfe
	// Position of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Pos = 0x0
	// Bit mask of ENABLE field.
	SPMON_PSPMPUCTL_ENABLE_Msk = 0x1
	// Bit ENABLE.
	SPMON_PSPMPUCTL_ENABLE = 0x1
	// SP_process monitor is disabled.
	SPMON_PSPMPUCTL_ENABLE_0 = 0x0
	// SP_process monitor is enabled.
	SPMON_PSPMPUCTL_ENABLE_1 = 0x1

	// PSPMPUPT: Stack Pointer Monitor Protection Register
	// Position of KEY field.
	SPMON_PSPMPUPT_KEY_Pos = 0x8
	// Bit mask of KEY field.
	SPMON_PSPMPUPT_KEY_Msk = 0xff00
	// Writing to the PROTECT bit is valid, when the KEY bits are written 0xA5.
	SPMON_PSPMPUPT_KEY_0xA5 = 0xa5
	// Position of Reserved field.
	SPMON_PSPMPUPT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SPMON_PSPMPUPT_Reserved_Msk = 0xfe
	// Position of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Pos = 0x0
	// Bit mask of PROTECT field.
	SPMON_PSPMPUPT_PROTECT_Msk = 0x1
	// Bit PROTECT.
	SPMON_PSPMPUPT_PROTECT = 0x1
	// Stack Pointer Monitor register writing is possible.
	SPMON_PSPMPUPT_PROTECT_0 = 0x0
	// Stack Pointer Monitor register writing is protected.
	SPMON_PSPMPUPT_PROTECT_1 = 0x1

	// PSPMPUSA: Process Stack Pointer Monitor Start Address Register
	// Position of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Pos = 0x0
	// Bit mask of PSPMPUSA field.
	SPMON_PSPMPUSA_PSPMPUSA_Msk = 0xffffffff

	// PSPMPUEA: Process Stack Pointer Monitor End Address Register
	// Position of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Pos = 0x0
	// Bit mask of PSPMPUEA field.
	SPMON_PSPMPUEA_PSPMPUEA_Msk = 0xffffffff
)

// Constants for SRAM: SRAM Control
const (
	// PARIOAD: SRAM Parity Error Operation After Detection Register
	// Position of Reserved field.
	SRAM_PARIOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_PARIOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SRAM_PARIOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_PARIOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_PARIOAD_OAD = 0x1
	// Reset.
	SRAM_PARIOAD_OAD_1 = 0x1
	// Non maskable interrupt.
	SRAM_PARIOAD_OAD_0 = 0x0

	// SRAMPRCR: SRAM Protection Register
	// Position of KW field.
	SRAM_SRAMPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_SRAMPRCR_KW_Msk = 0xfe
	// Writing to the RAMPRCR bit is valid, when the KEY bits are written 1111000b.
	SRAM_SRAMPRCR_KW_1111000 = 0x78
	// Position of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Pos = 0x0
	// Bit mask of SRAMPRCR field.
	SRAM_SRAMPRCR_SRAMPRCR_Msk = 0x1
	// Bit SRAMPRCR.
	SRAM_SRAMPRCR_SRAMPRCR = 0x1
	// Writing to the protected register is disabled.
	SRAM_SRAMPRCR_SRAMPRCR_0 = 0x0
	// Writing to the protected register is enabled.
	SRAM_SRAMPRCR_SRAMPRCR_1 = 0x1

	// ECCMODE: ECC Operating Mode Control Register
	// Position of Reserved field.
	SRAM_ECCMODE_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SRAM_ECCMODE_Reserved_Msk = 0xfc
	// Position of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Pos = 0x0
	// Bit mask of ECCMOD field.
	SRAM_ECCMODE_ECCMOD_Msk = 0x3
	// ECC is disabled
	SRAM_ECCMODE_ECCMOD_00 = 0x0
	// Setting prohibited
	SRAM_ECCMODE_ECCMOD_01 = 0x1
	// ECC is enabled without error checking.
	SRAM_ECCMODE_ECCMOD_10 = 0x2
	// ECC is enabled with error checking.
	SRAM_ECCMODE_ECCMOD_11 = 0x3

	// ECC2STS: ECC 2-Bit Error Status Register
	// Position of Reserved field.
	SRAM_ECC2STS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC2STS_Reserved_Msk = 0xfe
	// Position of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Pos = 0x0
	// Bit mask of ECC2ERR field.
	SRAM_ECC2STS_ECC2ERR_Msk = 0x1
	// Bit ECC2ERR.
	SRAM_ECC2STS_ECC2ERR = 0x1
	// A 2-bit ECC error has not occurred.
	SRAM_ECC2STS_ECC2ERR_0 = 0x0
	// A 2-bit ECC error has occurred.
	SRAM_ECC2STS_ECC2ERR_1 = 0x1

	// ECC1STSEN: ECC 1-Bit Error Information Update Enable Register
	// Position of Reserved field.
	SRAM_ECC1STSEN_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC1STSEN_Reserved_Msk = 0xfe
	// Position of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Pos = 0x0
	// Bit mask of E1STSEN field.
	SRAM_ECC1STSEN_E1STSEN_Msk = 0x1
	// Bit E1STSEN.
	SRAM_ECC1STSEN_E1STSEN = 0x1
	// Disables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_0 = 0x0
	// Enables updating of the 1-bit ECC error information.
	SRAM_ECC1STSEN_E1STSEN_1 = 0x1

	// ECC1STS: ECC 1-Bit Error Status Register
	// Position of Reserved field.
	SRAM_ECC1STS_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECC1STS_Reserved_Msk = 0xfe
	// Position of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Pos = 0x0
	// Bit mask of ECC1ERR field.
	SRAM_ECC1STS_ECC1ERR_Msk = 0x1
	// Bit ECC1ERR.
	SRAM_ECC1STS_ECC1ERR = 0x1
	// A 1-bit ECC error has not occurred.
	SRAM_ECC1STS_ECC1ERR_0 = 0x0
	// A 1-bit ECC error has occurred.
	SRAM_ECC1STS_ECC1ERR_1 = 0x1

	// ECCPRCR: ECC Protection Register
	// Position of KW field.
	SRAM_ECCPRCR_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_ECCPRCR_KW_Msk = 0xfe
	// Writing to the ECCPRCR bit is valid, when the KW bits are written 1111000b.
	SRAM_ECCPRCR_KW_1111000 = 0x78
	// Position of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Pos = 0x0
	// Bit mask of ECCPRCR field.
	SRAM_ECCPRCR_ECCPRCR_Msk = 0x1
	// Bit ECCPRCR.
	SRAM_ECCPRCR_ECCPRCR = 0x1
	// Writing to the protect register is disabled.
	SRAM_ECCPRCR_ECCPRCR_0 = 0x0
	// Writing to the protect register is enabled.
	SRAM_ECCPRCR_ECCPRCR_1 = 0x1

	// ECCPRCR2: ECC Protection Register 2
	// Position of KW field.
	SRAM_ECCPRCR2_KW_Pos = 0x1
	// Bit mask of KW field.
	SRAM_ECCPRCR2_KW_Msk = 0xfe
	// Writing to the ECCPRCR2 bit is valid, when the KEY bits are written 1111000b.
	SRAM_ECCPRCR2_KW_1111000 = 0x78
	// Position of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Pos = 0x0
	// Bit mask of ECCPRCR2 field.
	SRAM_ECCPRCR2_ECCPRCR2_Msk = 0x1
	// Bit ECCPRCR2.
	SRAM_ECCPRCR2_ECCPRCR2 = 0x1
	// Writing to the protect register is disabled.
	SRAM_ECCPRCR2_ECCPRCR2_0 = 0x0
	// Writing to the protect register is enabled.
	SRAM_ECCPRCR2_ECCPRCR2_1 = 0x1

	// ECCETST: ECC Test Control Register
	// Position of Reserved field.
	SRAM_ECCETST_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECCETST_Reserved_Msk = 0xfe
	// Position of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Pos = 0x0
	// Bit mask of TSTBYP field.
	SRAM_ECCETST_TSTBYP_Msk = 0x1
	// Bit TSTBYP.
	SRAM_ECCETST_TSTBYP = 0x1
	// ECC bypass is disabled.
	SRAM_ECCETST_TSTBYP_0 = 0x0
	// ECC bypass is enabled.
	SRAM_ECCETST_TSTBYP_1 = 0x1

	// ECCOAD: SRAM ECC Error Operation After Detection Register
	// Position of Reserved field.
	SRAM_ECCOAD_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SRAM_ECCOAD_Reserved_Msk = 0xfe
	// Position of OAD field.
	SRAM_ECCOAD_OAD_Pos = 0x0
	// Bit mask of OAD field.
	SRAM_ECCOAD_OAD_Msk = 0x1
	// Bit OAD.
	SRAM_ECCOAD_OAD = 0x1
	// Non maskable interrupt.
	SRAM_ECCOAD_OAD_0 = 0x0
	// Internal reset.
	SRAM_ECCOAD_OAD_1 = 0x1
)

// Constants for BUS: BUS Control
const (
	// BUSMCNTSYS: Master Bus Control Register SYS
	// Position of IERES field.
	BUS_BUSMCNTSYS_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTSYS_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTSYS_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNTSYS_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNTSYS_IERES_1 = 0x1
	// Position of Reserved field.
	BUS_BUSMCNTSYS_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSMCNTSYS_Reserved_Msk = 0x7fff

	// BUSMCNTDMA: Master Bus Control Register DMA
	// Position of IERES field.
	BUS_BUSMCNTDMA_IERES_Pos = 0xf
	// Bit mask of IERES field.
	BUS_BUSMCNTDMA_IERES_Msk = 0x8000
	// Bit IERES.
	BUS_BUSMCNTDMA_IERES = 0x8000
	// Bus error will be reported.
	BUS_BUSMCNTDMA_IERES_0 = 0x0
	// Bus error will not be reported.
	BUS_BUSMCNTDMA_IERES_1 = 0x1
	// Position of Reserved field.
	BUS_BUSMCNTDMA_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSMCNTDMA_Reserved_Msk = 0x7fff

	// BUSSCNTFLI: Slave Bus Control Register FLI
	// Position of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTFLI_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTFLI_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTFLI_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTFLI_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTFLI_Reserved_Msk = 0xf

	// BUSSCNTRAM0: Slave Bus Control Register RAM0
	// Position of Reserved field.
	BUS_BUSSCNTRAM0_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTRAM0_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTRAM0_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTRAM0_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTRAM0_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTRAM0_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTRAM0_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTRAM0_Reserved_Msk = 0xf

	// BUSSCNTP0B: Slave Bus Control Register %s
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNT_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNT_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNT_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNT_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNT_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNT_Reserved_Msk = 0xf

	// BUSSCNTP4B: Slave Bus Control Register P4B
	// Position of Reserved field.
	BUS_BUSSCNTP4B_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTP4B_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTP4B_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTP4B_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTP4B_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTP4B_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTP4B_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTP4B_Reserved_Msk = 0xf

	// BUSSCNTP6B: Slave Bus Control Register P6B
	// Position of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTP6B_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTP6B_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTP6B_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTP6B_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTP6B_Reserved_Msk = 0xf

	// BUSSCNTFBU: Slave Bus Control Register FBU
	// Position of Reserved field.
	BUS_BUSSCNTFBU_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	BUS_BUSSCNTFBU_Reserved_Msk = 0xffc0
	// Position of ARBMET field.
	BUS_BUSSCNTFBU_ARBMET_Pos = 0x4
	// Bit mask of ARBMET field.
	BUS_BUSSCNTFBU_ARBMET_Msk = 0x30
	// fixed priority
	BUS_BUSSCNTFBU_ARBMET_00 = 0x0
	// round-robin
	BUS_BUSSCNTFBU_ARBMET_01 = 0x1
	// Position of Reserved field.
	BUS_BUSSCNTFBU_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	BUS_BUSSCNTFBU_Reserved_Msk = 0xf

	// BUS3ERRADD: Bus Error Address Register %s
	// Position of BERAD field.
	BUS_BUSERRADD_BERAD_Pos = 0x0
	// Bit mask of BERAD field.
	BUS_BUSERRADD_BERAD_Msk = 0xffffffff

	// BUS3ERRSTAT: Bus Error Status Register %s
	// Position of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Pos = 0x7
	// Bit mask of ERRSTAT field.
	BUS_BUSERRSTAT_ERRSTAT_Msk = 0x80
	// Bit ERRSTAT.
	BUS_BUSERRSTAT_ERRSTAT = 0x80
	// No bus error occurred
	BUS_BUSERRSTAT_ERRSTAT_0 = 0x0
	// Bus error occurred
	BUS_BUSERRSTAT_ERRSTAT_1 = 0x1
	// Position of Reserved field.
	BUS_BUSERRSTAT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	BUS_BUSERRSTAT_Reserved_Msk = 0x7e
	// Position of ACCSTAT field.
	BUS_BUSERRSTAT_ACCSTAT_Pos = 0x0
	// Bit mask of ACCSTAT field.
	BUS_BUSERRSTAT_ACCSTAT_Msk = 0x1
	// Bit ACCSTAT.
	BUS_BUSERRSTAT_ACCSTAT = 0x1
	// Read access
	BUS_BUSERRSTAT_ACCSTAT_0 = 0x0
	// Write Access
	BUS_BUSERRSTAT_ACCSTAT_1 = 0x1
)

// Constants for DBG: Debug Function
const (
	// DBGSTR: Debug Status Register
	// Position of Reserved field.
	DBG_DBGSTR_Reserved_Pos = 0x1e
	// Bit mask of Reserved field.
	DBG_DBGSTR_Reserved_Msk = 0xc0000000
	// Position of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Pos = 0x1d
	// Bit mask of CDBGPWRUPACK field.
	DBG_DBGSTR_CDBGPWRUPACK_Msk = 0x20000000
	// Bit CDBGPWRUPACK.
	DBG_DBGSTR_CDBGPWRUPACK = 0x20000000
	// Debug power-up request is not acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_0 = 0x0
	// Debug power-up request is acknowledged
	DBG_DBGSTR_CDBGPWRUPACK_1 = 0x1
	// Position of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Pos = 0x1c
	// Bit mask of CDBGPWRUPREQ field.
	DBG_DBGSTR_CDBGPWRUPREQ_Msk = 0x10000000
	// Bit CDBGPWRUPREQ.
	DBG_DBGSTR_CDBGPWRUPREQ = 0x10000000
	// OCD is not requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_0 = 0x0
	// OCD is requesting debug power-up
	DBG_DBGSTR_CDBGPWRUPREQ_1 = 0x1
	// Position of Reserved field.
	DBG_DBGSTR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DBG_DBGSTR_Reserved_Msk = 0xfffffff

	// DBGSTOPCR: Debug Stop Control Register
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xfc000000
	// Position of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Pos = 0x19
	// Bit mask of DBGSTOP_RECCR field.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_Msk = 0x2000000
	// Bit DBGSTOP_RECCR.
	DBG_DBGSTOPCR_DBGSTOP_RECCR = 0x2000000
	// Enable SRAM ECC error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RECCR_0 = 0x0
	// Mask SRAM ECC error reset/interrupt.
	DBG_DBGSTOPCR_DBGSTOP_RECCR_1 = 0x1
	// Position of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Pos = 0x18
	// Bit mask of DBGSTOP_RPER field.
	DBG_DBGSTOPCR_DBGSTOP_RPER_Msk = 0x1000000
	// Bit DBGSTOP_RPER.
	DBG_DBGSTOPCR_DBGSTOP_RPER = 0x1000000
	// Enable RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_0 = 0x0
	// Mask RAM parity error reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_RPER_1 = 0x1
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xf80000
	// Position of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Pos = 0x10
	// Bit mask of DBGSTOP_LVD field.
	DBG_DBGSTOPCR_DBGSTOP_LVD_Msk = 0x70000
	// Position of Reserved field.
	DBG_DBGSTOPCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	DBG_DBGSTOPCR_Reserved_Msk = 0xfffc
	// Position of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Pos = 0x1
	// Bit mask of DBGSTOP_WDT field.
	DBG_DBGSTOPCR_DBGSTOP_WDT_Msk = 0x2
	// Bit DBGSTOP_WDT.
	DBG_DBGSTOPCR_DBGSTOP_WDT = 0x2
	// Mask WDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_WDT_0 = 0x0
	// Enable WDT reset
	DBG_DBGSTOPCR_DBGSTOP_WDT_1 = 0x1
	// Position of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Pos = 0x0
	// Bit mask of DBGSTOP_IWDT field.
	DBG_DBGSTOPCR_DBGSTOP_IWDT_Msk = 0x1
	// Bit DBGSTOP_IWDT.
	DBG_DBGSTOPCR_DBGSTOP_IWDT = 0x1
	// Mask IWDT reset/interrupt
	DBG_DBGSTOPCR_DBGSTOP_IWDT_0 = 0x0
	// Enable IWDT reset
	DBG_DBGSTOPCR_DBGSTOP_IWDT_1 = 0x1
)

// Constants for DTC: Data Transfer Controller
const (
	// DTCCR: DTC Control Register
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0xe0
	// Position of RRS field.
	DTC_DTCCR_RRS_Pos = 0x4
	// Bit mask of RRS field.
	DTC_DTCCR_RRS_Msk = 0x10
	// Bit RRS.
	DTC_DTCCR_RRS = 0x10
	// Do not skip transfer information read
	DTC_DTCCR_RRS_0 = 0x0
	// Skip transfer information read when vector numbers match
	DTC_DTCCR_RRS_1 = 0x1
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0x8
	// Bit Reserved.
	DTC_DTCCR_Reserved = 0x8
	// Position of Reserved field.
	DTC_DTCCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	DTC_DTCCR_Reserved_Msk = 0x7

	// DTCVBR: DTC Vector Base Register
	// Position of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Pos = 0x0
	// Bit mask of DTCVBR field.
	DTC_DTCVBR_DTCVBR_Msk = 0xffffffff

	// DTCST: DTC Module Start Register
	// Position of Reserved field.
	DTC_DTCST_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	DTC_DTCST_Reserved_Msk = 0xfe
	// Position of DTCST field.
	DTC_DTCST_DTCST_Pos = 0x0
	// Bit mask of DTCST field.
	DTC_DTCST_DTCST_Msk = 0x1
	// Bit DTCST.
	DTC_DTCST_DTCST = 0x1
	// DTC module stop
	DTC_DTCST_DTCST_0 = 0x0
	// DTC module start
	DTC_DTCST_DTCST_1 = 0x1

	// DTCSTS: DTC Status Register
	// Position of ACT field.
	DTC_DTCSTS_ACT_Pos = 0xf
	// Bit mask of ACT field.
	DTC_DTCSTS_ACT_Msk = 0x8000
	// Bit ACT.
	DTC_DTCSTS_ACT = 0x8000
	// DTC transfer operation is not in progress.
	DTC_DTCSTS_ACT_0 = 0x0
	// DTC transfer operation is in progress.
	DTC_DTCSTS_ACT_1 = 0x1
	// Position of Reserved field.
	DTC_DTCSTS_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	DTC_DTCSTS_Reserved_Msk = 0x7f00
	// Position of VECN field.
	DTC_DTCSTS_VECN_Pos = 0x0
	// Bit mask of VECN field.
	DTC_DTCSTS_VECN_Msk = 0xff
)

// Constants for ICU: Interrupt Controller
const (
	// IRQCR0: IRQ Control Register %s
	// Position of FLTEN field.
	ICU_IRQCR_FLTEN_Pos = 0x7
	// Bit mask of FLTEN field.
	ICU_IRQCR_FLTEN_Msk = 0x80
	// Bit FLTEN.
	ICU_IRQCR_FLTEN = 0x80
	// Digital filter is disabled.
	ICU_IRQCR_FLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_IRQCR_FLTEN_1 = 0x1
	// Position of Reserved field.
	ICU_IRQCR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ICU_IRQCR_Reserved_Msk = 0x40
	// Bit Reserved.
	ICU_IRQCR_Reserved = 0x40
	// Position of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Pos = 0x4
	// Bit mask of FCLKSEL field.
	ICU_IRQCR_FCLKSEL_Msk = 0x30
	// PCLKB
	ICU_IRQCR_FCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_IRQCR_FCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_IRQCR_FCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_IRQCR_FCLKSEL_11 = 0x3
	// Position of Reserved field.
	ICU_IRQCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	ICU_IRQCR_Reserved_Msk = 0xc
	// Position of IRQMD field.
	ICU_IRQCR_IRQMD_Pos = 0x0
	// Bit mask of IRQMD field.
	ICU_IRQCR_IRQMD_Msk = 0x3
	// Falling edge
	ICU_IRQCR_IRQMD_00 = 0x0
	// Rising edge
	ICU_IRQCR_IRQMD_01 = 0x1
	// Rising and falling edges
	ICU_IRQCR_IRQMD_10 = 0x2
	// Low level
	ICU_IRQCR_IRQMD_11 = 0x3

	// NMICR: NMI Pin Interrupt Control Register
	// Position of NFLTEN field.
	ICU_NMICR_NFLTEN_Pos = 0x7
	// Bit mask of NFLTEN field.
	ICU_NMICR_NFLTEN_Msk = 0x80
	// Bit NFLTEN.
	ICU_NMICR_NFLTEN = 0x80
	// Digital filter is disabled.
	ICU_NMICR_NFLTEN_0 = 0x0
	// Digital filter is enabled.
	ICU_NMICR_NFLTEN_1 = 0x1
	// Position of Reserved field.
	ICU_NMICR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	ICU_NMICR_Reserved_Msk = 0x40
	// Bit Reserved.
	ICU_NMICR_Reserved = 0x40
	// Position of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Pos = 0x4
	// Bit mask of NFCLKSEL field.
	ICU_NMICR_NFCLKSEL_Msk = 0x30
	// PCLKB
	ICU_NMICR_NFCLKSEL_00 = 0x0
	// PCLKB/8
	ICU_NMICR_NFCLKSEL_01 = 0x1
	// PCLKB/32
	ICU_NMICR_NFCLKSEL_10 = 0x2
	// PCLKB/64
	ICU_NMICR_NFCLKSEL_11 = 0x3
	// Position of Reserved field.
	ICU_NMICR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	ICU_NMICR_Reserved_Msk = 0xe
	// Position of NMIMD field.
	ICU_NMICR_NMIMD_Pos = 0x0
	// Bit mask of NMIMD field.
	ICU_NMICR_NMIMD_Msk = 0x1
	// Bit NMIMD.
	ICU_NMICR_NMIMD = 0x1
	// Falling edge
	ICU_NMICR_NMIMD_0 = 0x0
	// Rising edge
	ICU_NMICR_NMIMD_1 = 0x1

	// NMIER: Non-Maskable Interrupt Enable Register
	// Position of Reserved field.
	ICU_NMIER_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMIER_Reserved_Msk = 0xe000
	// Position of SPEEN field.
	ICU_NMIER_SPEEN_Pos = 0xc
	// Bit mask of SPEEN field.
	ICU_NMIER_SPEEN_Msk = 0x1000
	// Bit SPEEN.
	ICU_NMIER_SPEEN = 0x1000
	// CPU Stack Pointer Monitor interrupt is disabled.
	ICU_NMIER_SPEEN_0 = 0x0
	// CPU Stack Pointer Monitor interrupt is enabled.
	ICU_NMIER_SPEEN_1 = 0x1
	// Position of BUSMEN field.
	ICU_NMIER_BUSMEN_Pos = 0xb
	// Bit mask of BUSMEN field.
	ICU_NMIER_BUSMEN_Msk = 0x800
	// Bit BUSMEN.
	ICU_NMIER_BUSMEN = 0x800
	// MPU Bus Master Error interrupt is disabled.
	ICU_NMIER_BUSMEN_0 = 0x0
	// MPU Bus Master Error interrupt is enabled.
	ICU_NMIER_BUSMEN_1 = 0x1
	// Position of BUSSEN field.
	ICU_NMIER_BUSSEN_Pos = 0xa
	// Bit mask of BUSSEN field.
	ICU_NMIER_BUSSEN_Msk = 0x400
	// Bit BUSSEN.
	ICU_NMIER_BUSSEN = 0x400
	// MPU Bus Slave Error interrupt is disabled.
	ICU_NMIER_BUSSEN_0 = 0x0
	// MPU Bus Slave Error interrupt is enabled.
	ICU_NMIER_BUSSEN_1 = 0x1
	// Position of RECCEN field.
	ICU_NMIER_RECCEN_Pos = 0x9
	// Bit mask of RECCEN field.
	ICU_NMIER_RECCEN_Msk = 0x200
	// Bit RECCEN.
	ICU_NMIER_RECCEN = 0x200
	// SRAM ECC Error interrupt is disabled.
	ICU_NMIER_RECCEN_0 = 0x0
	// SRAM ECC Error interrupt is enabled.
	ICU_NMIER_RECCEN_1 = 0x1
	// Position of RPEEN field.
	ICU_NMIER_RPEEN_Pos = 0x8
	// Bit mask of RPEEN field.
	ICU_NMIER_RPEEN_Msk = 0x100
	// Bit RPEEN.
	ICU_NMIER_RPEEN = 0x100
	// SRAM Parity Error interrupt is disabled.
	ICU_NMIER_RPEEN_0 = 0x0
	// SRAM Parity Error interrupt is enabled.
	ICU_NMIER_RPEEN_1 = 0x1
	// Position of NMIEN field.
	ICU_NMIER_NMIEN_Pos = 0x7
	// Bit mask of NMIEN field.
	ICU_NMIER_NMIEN_Msk = 0x80
	// Bit NMIEN.
	ICU_NMIER_NMIEN = 0x80
	// NMI pin interrupt is disabled.
	ICU_NMIER_NMIEN_0 = 0x0
	// NMI pin interrupt is enabled.
	ICU_NMIER_NMIEN_1 = 0x1
	// Position of OSTEN field.
	ICU_NMIER_OSTEN_Pos = 0x6
	// Bit mask of OSTEN field.
	ICU_NMIER_OSTEN_Msk = 0x40
	// Bit OSTEN.
	ICU_NMIER_OSTEN = 0x40
	// Main Oscillation stop detection interrupt is disabled.
	ICU_NMIER_OSTEN_0 = 0x0
	// Main Oscillation stop detection interrupt is enabled.
	ICU_NMIER_OSTEN_1 = 0x1
	// Position of Reserved field.
	ICU_NMIER_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	ICU_NMIER_Reserved_Msk = 0x30
	// Position of LVD2EN field.
	ICU_NMIER_LVD2EN_Pos = 0x3
	// Bit mask of LVD2EN field.
	ICU_NMIER_LVD2EN_Msk = 0x8
	// Bit LVD2EN.
	ICU_NMIER_LVD2EN = 0x8
	// Voltage-monitoring 2 interrupt is disabled.
	ICU_NMIER_LVD2EN_0 = 0x0
	// Voltage-monitoring 2 interrupt is enabled.
	ICU_NMIER_LVD2EN_1 = 0x1
	// Position of LVD1EN field.
	ICU_NMIER_LVD1EN_Pos = 0x2
	// Bit mask of LVD1EN field.
	ICU_NMIER_LVD1EN_Msk = 0x4
	// Bit LVD1EN.
	ICU_NMIER_LVD1EN = 0x4
	// Voltage-monitoring 1 interrupt is disabled.
	ICU_NMIER_LVD1EN_0 = 0x0
	// Voltage-monitoring 1 interrupt is enabled.
	ICU_NMIER_LVD1EN_1 = 0x1
	// Position of WDTEN field.
	ICU_NMIER_WDTEN_Pos = 0x1
	// Bit mask of WDTEN field.
	ICU_NMIER_WDTEN_Msk = 0x2
	// Bit WDTEN.
	ICU_NMIER_WDTEN = 0x2
	// WDT underflow/refresh error interrupt is disabled.
	ICU_NMIER_WDTEN_0 = 0x0
	// WDT underflow/refresh error interrupt is enabled.
	ICU_NMIER_WDTEN_1 = 0x1
	// Position of IWDTEN field.
	ICU_NMIER_IWDTEN_Pos = 0x0
	// Bit mask of IWDTEN field.
	ICU_NMIER_IWDTEN_Msk = 0x1
	// Bit IWDTEN.
	ICU_NMIER_IWDTEN = 0x1
	// IWDT underflow/refresh error interrupt is disabled.
	ICU_NMIER_IWDTEN_0 = 0x0
	// IWDT underflow/refresh error interrupt is enabled.
	ICU_NMIER_IWDTEN_1 = 0x1

	// NMICLR: Non-Maskable Interrupt Status Clear Register
	// Position of Reserved field.
	ICU_NMICLR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMICLR_Reserved_Msk = 0xe000
	// Position of SPECLR field.
	ICU_NMICLR_SPECLR_Pos = 0xc
	// Bit mask of SPECLR field.
	ICU_NMICLR_SPECLR_Msk = 0x1000
	// Bit SPECLR.
	ICU_NMICLR_SPECLR = 0x1000
	// No effect.
	ICU_NMICLR_SPECLR_0 = 0x0
	// Clear the NMISR.SPEST flag.
	ICU_NMICLR_SPECLR_1 = 0x1
	// Position of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Pos = 0xb
	// Bit mask of BUSMCLR field.
	ICU_NMICLR_BUSMCLR_Msk = 0x800
	// Bit BUSMCLR.
	ICU_NMICLR_BUSMCLR = 0x800
	// No effect.
	ICU_NMICLR_BUSMCLR_0 = 0x0
	// Clear the NMISR.BUSMST flag.
	ICU_NMICLR_BUSMCLR_1 = 0x1
	// Position of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Pos = 0xa
	// Bit mask of BUSSCLR field.
	ICU_NMICLR_BUSSCLR_Msk = 0x400
	// Bit BUSSCLR.
	ICU_NMICLR_BUSSCLR = 0x400
	// No effect.
	ICU_NMICLR_BUSSCLR_0 = 0x0
	// Clear the NMISR.BUSSST flag.
	ICU_NMICLR_BUSSCLR_1 = 0x1
	// Position of RECCCLR field.
	ICU_NMICLR_RECCCLR_Pos = 0x9
	// Bit mask of RECCCLR field.
	ICU_NMICLR_RECCCLR_Msk = 0x200
	// Bit RECCCLR.
	ICU_NMICLR_RECCCLR = 0x200
	// No effect.
	ICU_NMICLR_RECCCLR_0 = 0x0
	// Clear the NMISR.RECCST flag.
	ICU_NMICLR_RECCCLR_1 = 0x1
	// Position of RPECLR field.
	ICU_NMICLR_RPECLR_Pos = 0x8
	// Bit mask of RPECLR field.
	ICU_NMICLR_RPECLR_Msk = 0x100
	// Bit RPECLR.
	ICU_NMICLR_RPECLR = 0x100
	// No effect.
	ICU_NMICLR_RPECLR_0 = 0x0
	// Clear the NMISR.RPEST flag.
	ICU_NMICLR_RPECLR_1 = 0x1
	// Position of NMICLR field.
	ICU_NMICLR_NMICLR_Pos = 0x7
	// Bit mask of NMICLR field.
	ICU_NMICLR_NMICLR_Msk = 0x80
	// Bit NMICLR.
	ICU_NMICLR_NMICLR = 0x80
	// No effect.
	ICU_NMICLR_NMICLR_0 = 0x0
	// Clear the NMISR.NMIST flag.
	ICU_NMICLR_NMICLR_1 = 0x1
	// Position of OSTCLR field.
	ICU_NMICLR_OSTCLR_Pos = 0x6
	// Bit mask of OSTCLR field.
	ICU_NMICLR_OSTCLR_Msk = 0x40
	// Bit OSTCLR.
	ICU_NMICLR_OSTCLR = 0x40
	// No effect.
	ICU_NMICLR_OSTCLR_0 = 0x0
	// Clear the NMISR.OSTST flag.
	ICU_NMICLR_OSTCLR_1 = 0x1
	// Position of Reserved field.
	ICU_NMICLR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	ICU_NMICLR_Reserved_Msk = 0x30
	// Position of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Pos = 0x3
	// Bit mask of LVD2CLR field.
	ICU_NMICLR_LVD2CLR_Msk = 0x8
	// Bit LVD2CLR.
	ICU_NMICLR_LVD2CLR = 0x8
	// No effect.
	ICU_NMICLR_LVD2CLR_0 = 0x0
	// Clear the NMISR.LVD2ST flag.
	ICU_NMICLR_LVD2CLR_1 = 0x1
	// Position of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Pos = 0x2
	// Bit mask of LVD1CLR field.
	ICU_NMICLR_LVD1CLR_Msk = 0x4
	// Bit LVD1CLR.
	ICU_NMICLR_LVD1CLR = 0x4
	// No effect.
	ICU_NMICLR_LVD1CLR_0 = 0x0
	// Clear the NMISR.LVD1ST flag.
	ICU_NMICLR_LVD1CLR_1 = 0x1
	// Position of WDTCLR field.
	ICU_NMICLR_WDTCLR_Pos = 0x1
	// Bit mask of WDTCLR field.
	ICU_NMICLR_WDTCLR_Msk = 0x2
	// Bit WDTCLR.
	ICU_NMICLR_WDTCLR = 0x2
	// No effect.
	ICU_NMICLR_WDTCLR_0 = 0x0
	// Clear the NMISR.WDTST flag.
	ICU_NMICLR_WDTCLR_1 = 0x1
	// Position of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Pos = 0x0
	// Bit mask of IWDTCLR field.
	ICU_NMICLR_IWDTCLR_Msk = 0x1
	// Bit IWDTCLR.
	ICU_NMICLR_IWDTCLR = 0x1
	// No effect.
	ICU_NMICLR_IWDTCLR_0 = 0x0
	// Clear the NMISR.IWDTST flag.
	ICU_NMICLR_IWDTCLR_1 = 0x1

	// NMISR: Non-Maskable Interrupt Status Register
	// Position of Reserved field.
	ICU_NMISR_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	ICU_NMISR_Reserved_Msk = 0xe000
	// Position of SPEST field.
	ICU_NMISR_SPEST_Pos = 0xc
	// Bit mask of SPEST field.
	ICU_NMISR_SPEST_Msk = 0x1000
	// Bit SPEST.
	ICU_NMISR_SPEST = 0x1000
	// Interrupt not requested
	ICU_NMISR_SPEST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_SPEST_1 = 0x1
	// Position of BUSMST field.
	ICU_NMISR_BUSMST_Pos = 0xb
	// Bit mask of BUSMST field.
	ICU_NMISR_BUSMST_Msk = 0x800
	// Bit BUSMST.
	ICU_NMISR_BUSMST = 0x800
	// Interrupt not requested
	ICU_NMISR_BUSMST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_BUSMST_1 = 0x1
	// Position of BUSSST field.
	ICU_NMISR_BUSSST_Pos = 0xa
	// Bit mask of BUSSST field.
	ICU_NMISR_BUSSST_Msk = 0x400
	// Bit BUSSST.
	ICU_NMISR_BUSSST = 0x400
	// Interrupt not requested
	ICU_NMISR_BUSSST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_BUSSST_1 = 0x1
	// Position of RECCST field.
	ICU_NMISR_RECCST_Pos = 0x9
	// Bit mask of RECCST field.
	ICU_NMISR_RECCST_Msk = 0x200
	// Bit RECCST.
	ICU_NMISR_RECCST = 0x200
	// Interrupt not requested
	ICU_NMISR_RECCST_0 = 0x0
	// Interrupt requested.
	ICU_NMISR_RECCST_1 = 0x1
	// Position of RPEST field.
	ICU_NMISR_RPEST_Pos = 0x8
	// Bit mask of RPEST field.
	ICU_NMISR_RPEST_Msk = 0x100
	// Bit RPEST.
	ICU_NMISR_RPEST = 0x100
	// RAM Parity Error interrupt is not requested.
	ICU_NMISR_RPEST_0 = 0x0
	// RAM Parity Error interrupt is requested.
	ICU_NMISR_RPEST_1 = 0x1
	// Position of NMIST field.
	ICU_NMISR_NMIST_Pos = 0x7
	// Bit mask of NMIST field.
	ICU_NMISR_NMIST_Msk = 0x80
	// Bit NMIST.
	ICU_NMISR_NMIST = 0x80
	// NMI pin interrupt is not requested.
	ICU_NMISR_NMIST_0 = 0x0
	// NMI pin interrupt is requested.
	ICU_NMISR_NMIST_1 = 0x1
	// Position of OSTST field.
	ICU_NMISR_OSTST_Pos = 0x6
	// Bit mask of OSTST field.
	ICU_NMISR_OSTST_Msk = 0x40
	// Bit OSTST.
	ICU_NMISR_OSTST = 0x40
	// Main Oscillation stop detection interrupt is not requested.
	ICU_NMISR_OSTST_0 = 0x0
	// Main Oscillation stop detection interrupt is requested.
	ICU_NMISR_OSTST_1 = 0x1
	// Position of Reserved field.
	ICU_NMISR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	ICU_NMISR_Reserved_Msk = 0x30
	// Position of LVD2ST field.
	ICU_NMISR_LVD2ST_Pos = 0x3
	// Bit mask of LVD2ST field.
	ICU_NMISR_LVD2ST_Msk = 0x8
	// Bit LVD2ST.
	ICU_NMISR_LVD2ST = 0x8
	// Voltage-monitoring 2 interrupt is not requested.
	ICU_NMISR_LVD2ST_0 = 0x0
	// Voltage-monitoring 2 interrupt is requested.
	ICU_NMISR_LVD2ST_1 = 0x1
	// Position of LVD1ST field.
	ICU_NMISR_LVD1ST_Pos = 0x2
	// Bit mask of LVD1ST field.
	ICU_NMISR_LVD1ST_Msk = 0x4
	// Bit LVD1ST.
	ICU_NMISR_LVD1ST = 0x4
	// Voltage-monitoring 1 interrupt is not requested.
	ICU_NMISR_LVD1ST_0 = 0x0
	// Voltage-monitoring 1 interrupt is requested.
	ICU_NMISR_LVD1ST_1 = 0x1
	// Position of WDTST field.
	ICU_NMISR_WDTST_Pos = 0x1
	// Bit mask of WDTST field.
	ICU_NMISR_WDTST_Msk = 0x2
	// Bit WDTST.
	ICU_NMISR_WDTST = 0x2
	// WDT underflow/refresh error interrupt is not requested.
	ICU_NMISR_WDTST_0 = 0x0
	// WDT underflow/refresh error interrupt is requested.
	ICU_NMISR_WDTST_1 = 0x1
	// Position of IWDTST field.
	ICU_NMISR_IWDTST_Pos = 0x0
	// Bit mask of IWDTST field.
	ICU_NMISR_IWDTST_Msk = 0x1
	// Bit IWDTST.
	ICU_NMISR_IWDTST = 0x1
	// IWDT underflow/refresh error interrupt is not requested.
	ICU_NMISR_IWDTST_0 = 0x0
	// IWDT underflow/refresh error interrupt is requested.
	ICU_NMISR_IWDTST_1 = 0x1

	// WUPEN: Wake Up Interrupt Enable Register
	// Position of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Pos = 0x1f
	// Bit mask of IIC0WUPEN field.
	ICU_WUPEN_IIC0WUPEN_Msk = 0x80000000
	// Bit IIC0WUPEN.
	ICU_WUPEN_IIC0WUPEN = 0x80000000
	// S/W standby returns by IIC0 address match interrupt is disabled
	ICU_WUPEN_IIC0WUPEN_0 = 0x0
	// S/W standby returns by IIC0 address match interrupt is enabled
	ICU_WUPEN_IIC0WUPEN_1 = 0x1
	// Position of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Pos = 0x1e
	// Bit mask of AGT1CBWUPEN field.
	ICU_WUPEN_AGT1CBWUPEN_Msk = 0x40000000
	// Bit AGT1CBWUPEN.
	ICU_WUPEN_AGT1CBWUPEN = 0x40000000
	// S/W standby returns by AGT1 compare match B interrupt is disabled
	ICU_WUPEN_AGT1CBWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match B interrupt is enabled
	ICU_WUPEN_AGT1CBWUPEN_1 = 0x1
	// Position of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Pos = 0x1d
	// Bit mask of AGT1CAWUPEN field.
	ICU_WUPEN_AGT1CAWUPEN_Msk = 0x20000000
	// Bit AGT1CAWUPEN.
	ICU_WUPEN_AGT1CAWUPEN = 0x20000000
	// S/W standby returns by AGT1 compare match A interrupt is disabled
	ICU_WUPEN_AGT1CAWUPEN_0 = 0x0
	// S/W standby returns by AGT1 compare match A interrupt is enabled
	ICU_WUPEN_AGT1CAWUPEN_1 = 0x1
	// Position of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Pos = 0x1c
	// Bit mask of AGT1UDWUPEN field.
	ICU_WUPEN_AGT1UDWUPEN_Msk = 0x10000000
	// Bit AGT1UDWUPEN.
	ICU_WUPEN_AGT1UDWUPEN = 0x10000000
	// S/W standby returns by AGT1 underflow interrupt is disabled
	ICU_WUPEN_AGT1UDWUPEN_0 = 0x0
	// S/W standby returns by AGT1 underflow interrupt is enabled
	ICU_WUPEN_AGT1UDWUPEN_1 = 0x1
	// Position of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Pos = 0x1b
	// Bit mask of USBFSWUPEN field.
	ICU_WUPEN_USBFSWUPEN_Msk = 0x8000000
	// Bit USBFSWUPEN.
	ICU_WUPEN_USBFSWUPEN = 0x8000000
	// S/W standby returns by USBFS interrupt is disabled
	ICU_WUPEN_USBFSWUPEN_0 = 0x0
	// S/W standby returns by USBFS interrupt is enabled
	ICU_WUPEN_USBFSWUPEN_1 = 0x1
	// Position of Reserved field.
	ICU_WUPEN_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	ICU_WUPEN_Reserved_Msk = 0x4000000
	// Bit Reserved.
	ICU_WUPEN_Reserved = 0x4000000
	// Position of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Pos = 0x19
	// Bit mask of RTCPRDWUPEN field.
	ICU_WUPEN_RTCPRDWUPEN_Msk = 0x2000000
	// Bit RTCPRDWUPEN.
	ICU_WUPEN_RTCPRDWUPEN = 0x2000000
	// S/W standby returns by RTC period interrupt is disabled
	ICU_WUPEN_RTCPRDWUPEN_0 = 0x0
	// S/W standby returns by RTC period interrupt is enabled
	ICU_WUPEN_RTCPRDWUPEN_1 = 0x1
	// Position of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Pos = 0x18
	// Bit mask of RTCALMWUPEN field.
	ICU_WUPEN_RTCALMWUPEN_Msk = 0x1000000
	// Bit RTCALMWUPEN.
	ICU_WUPEN_RTCALMWUPEN = 0x1000000
	// S/W standby returns by RTC alarm interrupt is disabled
	ICU_WUPEN_RTCALMWUPEN_0 = 0x0
	// S/W standby returns by RTC alarm interrupt is enabled
	ICU_WUPEN_RTCALMWUPEN_1 = 0x1
	// Position of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Pos = 0x17
	// Bit mask of ACMPLP0WUPEN field.
	ICU_WUPEN_ACMPLP0WUPEN_Msk = 0x800000
	// Bit ACMPLP0WUPEN.
	ICU_WUPEN_ACMPLP0WUPEN = 0x800000
	// S/W standby returns by ACMPLP0 interrupt is disabled
	ICU_WUPEN_ACMPLP0WUPEN_0 = 0x0
	// S/W standby returns by ACMPLP0 interrupt is enabled
	ICU_WUPEN_ACMPLP0WUPEN_1 = 0x1
	// Position of Reserved field.
	ICU_WUPEN_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	ICU_WUPEN_Reserved_Msk = 0x700000
	// Position of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Pos = 0x13
	// Bit mask of LVD2WUPEN field.
	ICU_WUPEN_LVD2WUPEN_Msk = 0x80000
	// Bit LVD2WUPEN.
	ICU_WUPEN_LVD2WUPEN = 0x80000
	// S/W standby returns by LVD2 interrupt is disabled
	ICU_WUPEN_LVD2WUPEN_0 = 0x0
	// S/W standby returns by LVD2 interrupt is enabled
	ICU_WUPEN_LVD2WUPEN_1 = 0x1
	// Position of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Pos = 0x12
	// Bit mask of LVD1WUPEN field.
	ICU_WUPEN_LVD1WUPEN_Msk = 0x40000
	// Bit LVD1WUPEN.
	ICU_WUPEN_LVD1WUPEN = 0x40000
	// S/W standby returns by LVD1 interrupt is disabled
	ICU_WUPEN_LVD1WUPEN_0 = 0x0
	// S/W standby returns by LVD1 interrupt is enabled
	ICU_WUPEN_LVD1WUPEN_1 = 0x1
	// Position of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Pos = 0x11
	// Bit mask of KEYWUPEN field.
	ICU_WUPEN_KEYWUPEN_Msk = 0x20000
	// Bit KEYWUPEN.
	ICU_WUPEN_KEYWUPEN = 0x20000
	// S/W standby returns by KEY interrupt is disabled
	ICU_WUPEN_KEYWUPEN_0 = 0x0
	// S/W standby returns by KEY interrupt is enabled
	ICU_WUPEN_KEYWUPEN_1 = 0x1
	// Position of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Pos = 0x10
	// Bit mask of IWDTWUPEN field.
	ICU_WUPEN_IWDTWUPEN_Msk = 0x10000
	// Bit IWDTWUPEN.
	ICU_WUPEN_IWDTWUPEN = 0x10000
	// S/W standby returns by IWDT interrupt is disabled
	ICU_WUPEN_IWDTWUPEN_0 = 0x0
	// S/W standby returns by IWDT interrupt is enabled
	ICU_WUPEN_IWDTWUPEN_1 = 0x1
	// Position of Reserved field.
	ICU_WUPEN_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_WUPEN_Reserved_Msk = 0xff00
	// Position of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Pos = 0x7
	// Bit mask of IRQWUPEN7 field.
	ICU_WUPEN_IRQWUPEN7_Msk = 0x80
	// Bit IRQWUPEN7.
	ICU_WUPEN_IRQWUPEN7 = 0x80
	// S/W standby returns by IRQ7 interrupt is disabled
	ICU_WUPEN_IRQWUPEN7_0 = 0x0
	// S/W standby returns by IRQ7 interrupt is enabled
	ICU_WUPEN_IRQWUPEN7_1 = 0x1
	// Position of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Pos = 0x6
	// Bit mask of IRQWUPEN6 field.
	ICU_WUPEN_IRQWUPEN6_Msk = 0x40
	// Bit IRQWUPEN6.
	ICU_WUPEN_IRQWUPEN6 = 0x40
	// S/W standby returns by IRQ6 interrupt is disabled
	ICU_WUPEN_IRQWUPEN6_0 = 0x0
	// S/W standby returns by IRQ6 interrupt is enabled
	ICU_WUPEN_IRQWUPEN6_1 = 0x1
	// Position of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Pos = 0x5
	// Bit mask of IRQWUPEN5 field.
	ICU_WUPEN_IRQWUPEN5_Msk = 0x20
	// Bit IRQWUPEN5.
	ICU_WUPEN_IRQWUPEN5 = 0x20
	// S/W standby returns by IRQ5 interrupt is disabled
	ICU_WUPEN_IRQWUPEN5_0 = 0x0
	// S/W standby returns by IRQ5 interrupt is enabled
	ICU_WUPEN_IRQWUPEN5_1 = 0x1
	// Position of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Pos = 0x4
	// Bit mask of IRQWUPEN4 field.
	ICU_WUPEN_IRQWUPEN4_Msk = 0x10
	// Bit IRQWUPEN4.
	ICU_WUPEN_IRQWUPEN4 = 0x10
	// S/W standby returns by IRQ4 interrupt is disabled
	ICU_WUPEN_IRQWUPEN4_0 = 0x0
	// S/W standby returns by IRQ4 interrupt is enabled
	ICU_WUPEN_IRQWUPEN4_1 = 0x1
	// Position of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Pos = 0x3
	// Bit mask of IRQWUPEN3 field.
	ICU_WUPEN_IRQWUPEN3_Msk = 0x8
	// Bit IRQWUPEN3.
	ICU_WUPEN_IRQWUPEN3 = 0x8
	// S/W standby returns by IRQ3 interrupt is disabled
	ICU_WUPEN_IRQWUPEN3_0 = 0x0
	// S/W standby returns by IRQ3 interrupt is enabled
	ICU_WUPEN_IRQWUPEN3_1 = 0x1
	// Position of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Pos = 0x2
	// Bit mask of IRQWUPEN2 field.
	ICU_WUPEN_IRQWUPEN2_Msk = 0x4
	// Bit IRQWUPEN2.
	ICU_WUPEN_IRQWUPEN2 = 0x4
	// S/W standby returns by IRQ2 interrupt is disabled
	ICU_WUPEN_IRQWUPEN2_0 = 0x0
	// S/W standby returns by IRQ2 interrupt is enabled
	ICU_WUPEN_IRQWUPEN2_1 = 0x1
	// Position of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Pos = 0x1
	// Bit mask of IRQWUPEN1 field.
	ICU_WUPEN_IRQWUPEN1_Msk = 0x2
	// Bit IRQWUPEN1.
	ICU_WUPEN_IRQWUPEN1 = 0x2
	// S/W standby returns by IRQ1 interrupt is disabled
	ICU_WUPEN_IRQWUPEN1_0 = 0x0
	// S/W standby returns by IRQ1 interrupt is enabled
	ICU_WUPEN_IRQWUPEN1_1 = 0x1
	// Position of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Pos = 0x0
	// Bit mask of IRQWUPEN0 field.
	ICU_WUPEN_IRQWUPEN0_Msk = 0x1
	// Bit IRQWUPEN0.
	ICU_WUPEN_IRQWUPEN0 = 0x1
	// S/W standby returns by IRQ0 interrupt is disabled
	ICU_WUPEN_IRQWUPEN0_0 = 0x0
	// S/W standby returns by IRQ0 interrupt is enabled
	ICU_WUPEN_IRQWUPEN0_1 = 0x1

	// SELSR0: SYS Event Link Setting Register
	// Position of Reserved field.
	ICU_SELSR0_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_SELSR0_Reserved_Msk = 0xff00
	// Position of SELS field.
	ICU_SELSR0_SELS_Pos = 0x0
	// Bit mask of SELS field.
	ICU_SELSR0_SELS_Msk = 0xff
	// Disable event output to the associated low-power mode module
	ICU_SELSR0_SELS_0x00 = 0x0

	// IELSR0: ICU Event Link Setting Register %s
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xfe000000
	// Position of DTCE field.
	ICU_IELSR_DTCE_Pos = 0x18
	// Bit mask of DTCE field.
	ICU_IELSR_DTCE_Msk = 0x1000000
	// Bit DTCE.
	ICU_IELSR_DTCE = 0x1000000
	// DTC activation is disabled
	ICU_IELSR_DTCE_0 = 0x0
	// DTC activation is enabled
	ICU_IELSR_DTCE_1 = 0x1
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xfe0000
	// Position of IR field.
	ICU_IELSR_IR_Pos = 0x10
	// Bit mask of IR field.
	ICU_IELSR_IR_Msk = 0x10000
	// Bit IR.
	ICU_IELSR_IR = 0x10000
	// No interrupt request is generated
	ICU_IELSR_IR_0 = 0x0
	// An interrupt request is generated ( "1" write to the IR bit is prohibited. )
	ICU_IELSR_IR_1 = 0x1
	// Position of Reserved field.
	ICU_IELSR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	ICU_IELSR_Reserved_Msk = 0xff00
	// Position of IELS field.
	ICU_IELSR_IELS_Pos = 0x0
	// Bit mask of IELS field.
	ICU_IELSR_IELS_Msk = 0xff
	// Nothing is selected
	ICU_IELSR_IELS_0x000 = 0x0
)

// Constants for SYSTEM: System Control
const (
	// SBYCR: Standby Control Register
	// Position of SSBY field.
	SYSTEM_SBYCR_SSBY_Pos = 0xf
	// Bit mask of SSBY field.
	SYSTEM_SBYCR_SSBY_Msk = 0x8000
	// Bit SSBY.
	SYSTEM_SBYCR_SSBY = 0x8000
	// Sleep Mode
	SYSTEM_SBYCR_SSBY_0 = 0x0
	// Software Standby Mode
	SYSTEM_SBYCR_SSBY_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SBYCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_SBYCR_Reserved_Msk = 0x7fff

	// MSTPCRA: Module Stop Control Register A
	// Position of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Msk = 0xff800000
	// Position of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Pos = 0x16
	// Bit mask of MSTPA22 field.
	SYSTEM_MSTPCRA_MSTPA22_Msk = 0x400000
	// Bit MSTPA22.
	SYSTEM_MSTPCRA_MSTPA22 = 0x400000
	// Cancel the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_0 = 0x0
	// Enter the module-stop state
	SYSTEM_MSTPCRA_MSTPA22_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_MSTPCRA_Reserved_Msk = 0x3fffff

	// SCKDIVCR: System Clock Division Control Register
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x1f
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0x80000000
	// Bit Reserved.
	SYSTEM_SCKDIVCR_Reserved = 0x80000000
	// Position of FCK field.
	SYSTEM_SCKDIVCR_FCK_Pos = 0x1c
	// Bit mask of FCK field.
	SYSTEM_SCKDIVCR_FCK_Msk = 0x70000000
	// /1
	SYSTEM_SCKDIVCR_FCK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_FCK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_FCK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_FCK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_FCK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_FCK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_FCK_110 = 0x6
	// Position of ICK field.
	SYSTEM_SCKDIVCR_ICK_Pos = 0x18
	// Bit mask of ICK field.
	SYSTEM_SCKDIVCR_ICK_Msk = 0x7000000
	// /1
	SYSTEM_SCKDIVCR_ICK_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_ICK_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_ICK_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_ICK_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_ICK_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_ICK_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_ICK_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0xfff800
	// Position of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Pos = 0x8
	// Bit mask of PCKB field.
	SYSTEM_SCKDIVCR_PCKB_Msk = 0x700
	// /1
	SYSTEM_SCKDIVCR_PCKB_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKB_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKB_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKB_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKB_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKB_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKB_110 = 0x6
	// Position of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_SCKDIVCR_Reserved_Msk = 0xf8
	// Position of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Pos = 0x0
	// Bit mask of PCKD field.
	SYSTEM_SCKDIVCR_PCKD_Msk = 0x7
	// /1
	SYSTEM_SCKDIVCR_PCKD_000 = 0x0
	// /2
	SYSTEM_SCKDIVCR_PCKD_001 = 0x1
	// /4
	SYSTEM_SCKDIVCR_PCKD_010 = 0x2
	// /8
	SYSTEM_SCKDIVCR_PCKD_011 = 0x3
	// /16
	SYSTEM_SCKDIVCR_PCKD_100 = 0x4
	// /32
	SYSTEM_SCKDIVCR_PCKD_101 = 0x5
	// /64
	SYSTEM_SCKDIVCR_PCKD_110 = 0x6

	// SCKSCR: System Clock Source Control Register
	// Position of Reserved field.
	SYSTEM_SCKSCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_SCKSCR_Reserved_Msk = 0xf8
	// Position of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Pos = 0x0
	// Bit mask of CKSEL field.
	SYSTEM_SCKSCR_CKSEL_Msk = 0x7
	// HOCO
	SYSTEM_SCKSCR_CKSEL_000 = 0x0
	// MOCO
	SYSTEM_SCKSCR_CKSEL_001 = 0x1
	// LOCO
	SYSTEM_SCKSCR_CKSEL_010 = 0x2
	// Main clock oscillator
	SYSTEM_SCKSCR_CKSEL_011 = 0x3
	// Sub-clock oscillator
	SYSTEM_SCKSCR_CKSEL_100 = 0x4

	// MEMWAIT: Memory Wait Cycle Control Register
	// Position of Reserved field.
	SYSTEM_MEMWAIT_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MEMWAIT_Reserved_Msk = 0xfe
	// Position of MEMWAIT field.
	SYSTEM_MEMWAIT_MEMWAIT_Pos = 0x0
	// Bit mask of MEMWAIT field.
	SYSTEM_MEMWAIT_MEMWAIT_Msk = 0x1
	// Bit MEMWAIT.
	SYSTEM_MEMWAIT_MEMWAIT = 0x1
	// No wait
	SYSTEM_MEMWAIT_MEMWAIT_0 = 0x0
	// Wait
	SYSTEM_MEMWAIT_MEMWAIT_1 = 0x1

	// MOSCCR: Main Clock Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_MOSCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MOSCCR_Reserved_Msk = 0xfe
	// Position of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Pos = 0x0
	// Bit mask of MOSTP field.
	SYSTEM_MOSCCR_MOSTP_Msk = 0x1
	// Bit MOSTP.
	SYSTEM_MOSCCR_MOSTP = 0x1
	// Main clock oscillator is operating.
	SYSTEM_MOSCCR_MOSTP_0 = 0x0
	// Main clock oscillator is stopped.
	SYSTEM_MOSCCR_MOSTP_1 = 0x1

	// HOCOCR: High-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_HOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_HOCOCR_Reserved_Msk = 0xfe
	// Position of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Pos = 0x0
	// Bit mask of HCSTP field.
	SYSTEM_HOCOCR_HCSTP_Msk = 0x1
	// Bit HCSTP.
	SYSTEM_HOCOCR_HCSTP = 0x1
	// HOCO is operating.
	SYSTEM_HOCOCR_HCSTP_0 = 0x0
	// HOCO is stopped.
	SYSTEM_HOCOCR_HCSTP_1 = 0x1

	// MOCOCR: Middle-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_MOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_MOCOCR_Reserved_Msk = 0xfe
	// Position of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Pos = 0x0
	// Bit mask of MCSTP field.
	SYSTEM_MOCOCR_MCSTP_Msk = 0x1
	// Bit MCSTP.
	SYSTEM_MOCOCR_MCSTP = 0x1
	// MOCO is operating.
	SYSTEM_MOCOCR_MCSTP_0 = 0x0
	// MOCO is stopped.
	SYSTEM_MOCOCR_MCSTP_1 = 0x1

	// OSCSF: Oscillation Stabilization Flag Register
	// Position of Reserved field.
	SYSTEM_OSCSF_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_OSCSF_Reserved_Msk = 0xf0
	// Position of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Pos = 0x3
	// Bit mask of MOSCSF field.
	SYSTEM_OSCSF_MOSCSF_Msk = 0x8
	// Bit MOSCSF.
	SYSTEM_OSCSF_MOSCSF = 0x8
	// MOSTP = 1 (stopping the main clock oscillator) or oscillation of the main clock has not yet become stable.
	SYSTEM_OSCSF_MOSCSF_0 = 0x0
	// Oscillation of the main clock is stable so the clock is available for use as the system clock.
	SYSTEM_OSCSF_MOSCSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OSCSF_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSCSF_Reserved_Msk = 0x6
	// Position of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Pos = 0x0
	// Bit mask of HOCOSF field.
	SYSTEM_OSCSF_HOCOSF_Msk = 0x1
	// Bit HOCOSF.
	SYSTEM_OSCSF_HOCOSF = 0x1
	// The HOCO clock is stopped or oscillation of the HOCO clock has not yet become stable.
	SYSTEM_OSCSF_HOCOSF_0 = 0x0
	// Oscillation of the HOCO clock is stable so the clock is available for use as the system clock.
	SYSTEM_OSCSF_HOCOSF_1 = 0x1

	// CKOCR: Clock Out Control Register
	// Position of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Pos = 0x7
	// Bit mask of CKOEN field.
	SYSTEM_CKOCR_CKOEN_Msk = 0x80
	// Bit CKOEN.
	SYSTEM_CKOCR_CKOEN = 0x80
	// Clock Out disable
	SYSTEM_CKOCR_CKOEN_0 = 0x0
	// Clock Out enable
	SYSTEM_CKOCR_CKOEN_1 = 0x1
	// Position of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Pos = 0x4
	// Bit mask of CKODIV field.
	SYSTEM_CKOCR_CKODIV_Msk = 0x70
	// /1
	SYSTEM_CKOCR_CKODIV_000 = 0x0
	// /2
	SYSTEM_CKOCR_CKODIV_001 = 0x1
	// /4
	SYSTEM_CKOCR_CKODIV_010 = 0x2
	// /8
	SYSTEM_CKOCR_CKODIV_011 = 0x3
	// /16
	SYSTEM_CKOCR_CKODIV_100 = 0x4
	// /32
	SYSTEM_CKOCR_CKODIV_101 = 0x5
	// /64
	SYSTEM_CKOCR_CKODIV_110 = 0x6
	// /128
	SYSTEM_CKOCR_CKODIV_111 = 0x7
	// Position of Reserved field.
	SYSTEM_CKOCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_CKOCR_Reserved_Msk = 0x8
	// Bit Reserved.
	SYSTEM_CKOCR_Reserved = 0x8
	// Position of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Pos = 0x0
	// Bit mask of CKOSEL field.
	SYSTEM_CKOCR_CKOSEL_Msk = 0x7
	// HOCO
	SYSTEM_CKOCR_CKOSEL_000 = 0x0
	// MOCO
	SYSTEM_CKOCR_CKOSEL_001 = 0x1
	// LOCO
	SYSTEM_CKOCR_CKOSEL_010 = 0x2
	// MOSC
	SYSTEM_CKOCR_CKOSEL_011 = 0x3
	// SOSC
	SYSTEM_CKOCR_CKOSEL_100 = 0x4

	// OSTDCR: Oscillation Stop Detection Control Register
	// Position of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Pos = 0x7
	// Bit mask of OSTDE field.
	SYSTEM_OSTDCR_OSTDE_Msk = 0x80
	// Bit OSTDE.
	SYSTEM_OSTDCR_OSTDE = 0x80
	// Oscillation stop detection function is disabled.
	SYSTEM_OSTDCR_OSTDE_0 = 0x0
	// Oscillation stop detection function is enabled.
	SYSTEM_OSTDCR_OSTDE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OSTDCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSTDCR_Reserved_Msk = 0x7e
	// Position of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Pos = 0x0
	// Bit mask of OSTDIE field.
	SYSTEM_OSTDCR_OSTDIE_Msk = 0x1
	// Bit OSTDIE.
	SYSTEM_OSTDCR_OSTDIE = 0x1
	// The oscillation stop detection interrupt is disabled. Oscillation stop detection is not notified to the POEG.
	SYSTEM_OSTDCR_OSTDIE_0 = 0x0
	// The oscillation stop detection interrupt is enabled. Oscillation stop detection is notified to the POEG.
	SYSTEM_OSTDCR_OSTDIE_1 = 0x1

	// OSTDSR: Oscillation Stop Detection Status Register
	// Position of Reserved field.
	SYSTEM_OSTDSR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_OSTDSR_Reserved_Msk = 0xfe
	// Position of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Pos = 0x0
	// Bit mask of OSTDF field.
	SYSTEM_OSTDSR_OSTDF_Msk = 0x1
	// Bit OSTDF.
	SYSTEM_OSTDSR_OSTDF = 0x1
	// The main clock oscillation stop has not been detected.
	SYSTEM_OSTDSR_OSTDF_0 = 0x0
	// The main clock oscillation stop has been detected.
	SYSTEM_OSTDSR_OSTDF_1 = 0x1

	// MOCOUTCR: MOCO User Trimming Control Register
	// Position of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Pos = 0x0
	// Bit mask of MOCOUTRM field.
	SYSTEM_MOCOUTCR_MOCOUTRM_Msk = 0xff

	// HOCOUTCR: HOCO User Trimming Control Register
	// Position of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Pos = 0x0
	// Bit mask of HOCOUTRM field.
	SYSTEM_HOCOUTCR_HOCOUTRM_Msk = 0xff

	// SNZCR: Snooze Control Register
	// Position of SNZE field.
	SYSTEM_SNZCR_SNZE_Pos = 0x7
	// Bit mask of SNZE field.
	SYSTEM_SNZCR_SNZE_Msk = 0x80
	// Bit SNZE.
	SYSTEM_SNZCR_SNZE = 0x80
	// Disable Snooze Mode
	SYSTEM_SNZCR_SNZE_0 = 0x0
	// Enable Snooze Mode
	SYSTEM_SNZCR_SNZE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_SNZCR_Reserved_Msk = 0x7c
	// Position of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Pos = 0x1
	// Bit mask of SNZDTCEN field.
	SYSTEM_SNZCR_SNZDTCEN_Msk = 0x2
	// Bit SNZDTCEN.
	SYSTEM_SNZCR_SNZDTCEN = 0x2
	// Disable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_0 = 0x0
	// Enable DTC operation
	SYSTEM_SNZCR_SNZDTCEN_1 = 0x1
	// Position of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Pos = 0x0
	// Bit mask of RXDREQEN field.
	SYSTEM_SNZCR_RXDREQEN_Msk = 0x1
	// Bit RXDREQEN.
	SYSTEM_SNZCR_RXDREQEN = 0x1
	// Ignore RXD0 falling edge in Standby mode.
	SYSTEM_SNZCR_RXDREQEN_0 = 0x0
	// Accept RXD0 falling edge in Standby mode as a request to transit to Snooze mode.
	SYSTEM_SNZCR_RXDREQEN_1 = 0x1

	// SNZEDCR: Snooze End Control Register
	// Position of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Pos = 0x7
	// Bit mask of SCI0UMTED field.
	SYSTEM_SNZEDCR_SCI0UMTED_Msk = 0x80
	// Bit SCI0UMTED.
	SYSTEM_SNZEDCR_SCI0UMTED = 0x80
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_SCI0UMTED_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZEDCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_SNZEDCR_Reserved_Msk = 0x60
	// Position of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Pos = 0x4
	// Bit mask of AD0UMTED field.
	SYSTEM_SNZEDCR_AD0UMTED_Msk = 0x10
	// Bit AD0UMTED.
	SYSTEM_SNZEDCR_AD0UMTED = 0x10
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0UMTED_1 = 0x1
	// Position of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Pos = 0x3
	// Bit mask of AD0MATED field.
	SYSTEM_SNZEDCR_AD0MATED_Msk = 0x8
	// Bit AD0MATED.
	SYSTEM_SNZEDCR_AD0MATED = 0x8
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AD0MATED_1 = 0x1
	// Position of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Pos = 0x2
	// Bit mask of DTCNZRED field.
	SYSTEM_SNZEDCR_DTCNZRED_Msk = 0x4
	// Bit DTCNZRED.
	SYSTEM_SNZEDCR_DTCNZRED = 0x4
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCNZRED_1 = 0x1
	// Position of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Pos = 0x1
	// Bit mask of DTCZRED field.
	SYSTEM_SNZEDCR_DTCZRED_Msk = 0x2
	// Bit DTCZRED.
	SYSTEM_SNZEDCR_DTCZRED = 0x2
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_DTCZRED_1 = 0x1
	// Position of AGTUNFED field.
	SYSTEM_SNZEDCR_AGTUNFED_Pos = 0x0
	// Bit mask of AGTUNFED field.
	SYSTEM_SNZEDCR_AGTUNFED_Msk = 0x1
	// Bit AGTUNFED.
	SYSTEM_SNZEDCR_AGTUNFED = 0x1
	// Disable the Snooze End request
	SYSTEM_SNZEDCR_AGTUNFED_0 = 0x0
	// Enable the Snooze End request
	SYSTEM_SNZEDCR_AGTUNFED_1 = 0x1

	// SNZREQCR: Snooze Request Control Register
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x1f
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x80000000
	// Bit Reserved.
	SYSTEM_SNZREQCR_Reserved = 0x80000000
	// Position of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Pos = 0x1e
	// Bit mask of SNZREQEN30 field.
	SYSTEM_SNZREQCR_SNZREQEN30_Msk = 0x40000000
	// Bit SNZREQEN30.
	SYSTEM_SNZREQCR_SNZREQEN30 = 0x40000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN30_1 = 0x1
	// Position of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Pos = 0x1d
	// Bit mask of SNZREQEN29 field.
	SYSTEM_SNZREQCR_SNZREQEN29_Msk = 0x20000000
	// Bit SNZREQEN29.
	SYSTEM_SNZREQCR_SNZREQEN29 = 0x20000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN29_1 = 0x1
	// Position of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Pos = 0x1c
	// Bit mask of SNZREQEN28 field.
	SYSTEM_SNZREQCR_SNZREQEN28_Msk = 0x10000000
	// Bit SNZREQEN28.
	SYSTEM_SNZREQCR_SNZREQEN28 = 0x10000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN28_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0xc000000
	// Position of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Pos = 0x19
	// Bit mask of SNZREQEN25 field.
	SYSTEM_SNZREQCR_SNZREQEN25_Msk = 0x2000000
	// Bit SNZREQEN25.
	SYSTEM_SNZREQCR_SNZREQEN25 = 0x2000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN25_1 = 0x1
	// Position of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Pos = 0x18
	// Bit mask of SNZREQEN24 field.
	SYSTEM_SNZREQCR_SNZREQEN24_Msk = 0x1000000
	// Bit SNZREQEN24.
	SYSTEM_SNZREQCR_SNZREQEN24 = 0x1000000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN24_1 = 0x1
	// Position of SNZREQEN23 field.
	SYSTEM_SNZREQCR_SNZREQEN23_Pos = 0x17
	// Bit mask of SNZREQEN23 field.
	SYSTEM_SNZREQCR_SNZREQEN23_Msk = 0x800000
	// Bit SNZREQEN23.
	SYSTEM_SNZREQCR_SNZREQEN23 = 0x800000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN23_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN23_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x12
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x7c0000
	// Position of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Pos = 0x11
	// Bit mask of SNZREQEN17 field.
	SYSTEM_SNZREQCR_SNZREQEN17_Msk = 0x20000
	// Bit SNZREQEN17.
	SYSTEM_SNZREQCR_SNZREQEN17 = 0x20000
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN17_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	SYSTEM_SNZREQCR_Reserved_Msk = 0x1ff00
	// Position of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Pos = 0x7
	// Bit mask of SNZREQEN7 field.
	SYSTEM_SNZREQCR_SNZREQEN7_Msk = 0x80
	// Bit SNZREQEN7.
	SYSTEM_SNZREQCR_SNZREQEN7 = 0x80
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN7_1 = 0x1
	// Position of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Pos = 0x6
	// Bit mask of SNZREQEN6 field.
	SYSTEM_SNZREQCR_SNZREQEN6_Msk = 0x40
	// Bit SNZREQEN6.
	SYSTEM_SNZREQCR_SNZREQEN6 = 0x40
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN6_1 = 0x1
	// Position of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Pos = 0x5
	// Bit mask of SNZREQEN5 field.
	SYSTEM_SNZREQCR_SNZREQEN5_Msk = 0x20
	// Bit SNZREQEN5.
	SYSTEM_SNZREQCR_SNZREQEN5 = 0x20
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN5_1 = 0x1
	// Position of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Pos = 0x4
	// Bit mask of SNZREQEN4 field.
	SYSTEM_SNZREQCR_SNZREQEN4_Msk = 0x10
	// Bit SNZREQEN4.
	SYSTEM_SNZREQCR_SNZREQEN4 = 0x10
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN4_1 = 0x1
	// Position of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Pos = 0x3
	// Bit mask of SNZREQEN3 field.
	SYSTEM_SNZREQCR_SNZREQEN3_Msk = 0x8
	// Bit SNZREQEN3.
	SYSTEM_SNZREQCR_SNZREQEN3 = 0x8
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN3_1 = 0x1
	// Position of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Pos = 0x2
	// Bit mask of SNZREQEN2 field.
	SYSTEM_SNZREQCR_SNZREQEN2_Msk = 0x4
	// Bit SNZREQEN2.
	SYSTEM_SNZREQCR_SNZREQEN2 = 0x4
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN2_1 = 0x1
	// Position of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Pos = 0x1
	// Bit mask of SNZREQEN1 field.
	SYSTEM_SNZREQCR_SNZREQEN1_Msk = 0x2
	// Bit SNZREQEN1.
	SYSTEM_SNZREQCR_SNZREQEN1 = 0x2
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN1_1 = 0x1
	// Position of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Pos = 0x0
	// Bit mask of SNZREQEN0 field.
	SYSTEM_SNZREQCR_SNZREQEN0_Msk = 0x1
	// Bit SNZREQEN0.
	SYSTEM_SNZREQCR_SNZREQEN0 = 0x1
	// Disable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_0 = 0x0
	// Enable snooze request
	SYSTEM_SNZREQCR_SNZREQEN0_1 = 0x1

	// FLSTOP: Flash Operation Control Register
	// Position of Reserved field.
	SYSTEM_FLSTOP_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_FLSTOP_Reserved_Msk = 0xe0
	// Position of FLSTPF field.
	SYSTEM_FLSTOP_FLSTPF_Pos = 0x4
	// Bit mask of FLSTPF field.
	SYSTEM_FLSTOP_FLSTPF_Msk = 0x10
	// Bit FLSTPF.
	SYSTEM_FLSTOP_FLSTPF = 0x10
	// Transition completed
	SYSTEM_FLSTOP_FLSTPF_0 = 0x0
	// During transition (from the flash-stop-status to flashoperating- status or vice versa)
	SYSTEM_FLSTOP_FLSTPF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_FLSTOP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_FLSTOP_Reserved_Msk = 0xe
	// Position of FLSTOP field.
	SYSTEM_FLSTOP_FLSTOP_Pos = 0x0
	// Bit mask of FLSTOP field.
	SYSTEM_FLSTOP_FLSTOP_Msk = 0x1
	// Bit FLSTOP.
	SYSTEM_FLSTOP_FLSTOP = 0x1
	// Code flash memory operates. Data flash memory operation depends on DFLCTL.DFLEN bit
	SYSTEM_FLSTOP_FLSTOP_0 = 0x0
	// Code flash/Data flash memory stops
	SYSTEM_FLSTOP_FLSTOP_1 = 0x1

	// OPCCR: Operating Power Control Register
	// Position of Reserved field.
	SYSTEM_OPCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_OPCCR_Reserved_Msk = 0xe0
	// Position of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Pos = 0x4
	// Bit mask of OPCMTSF field.
	SYSTEM_OPCCR_OPCMTSF_Msk = 0x10
	// Bit OPCMTSF.
	SYSTEM_OPCCR_OPCMTSF = 0x10
	// Transition completed
	SYSTEM_OPCCR_OPCMTSF_0 = 0x0
	// During transition
	SYSTEM_OPCCR_OPCMTSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_OPCCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_OPCCR_Reserved_Msk = 0xc
	// Position of OPCM field.
	SYSTEM_OPCCR_OPCM_Pos = 0x0
	// Bit mask of OPCM field.
	SYSTEM_OPCCR_OPCM_Msk = 0x3
	// High-speed mode
	SYSTEM_OPCCR_OPCM_00 = 0x0
	// Prohibited
	SYSTEM_OPCCR_OPCM_01 = 0x1
	// Prohibited
	SYSTEM_OPCCR_OPCM_10 = 0x2
	// Low-speed mode
	SYSTEM_OPCCR_OPCM_11 = 0x3

	// MOSCWTCR: Main Clock Oscillator Wait Control Register
	// Position of Reserved field.
	SYSTEM_MOSCWTCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_MOSCWTCR_Reserved_Msk = 0xf0
	// Position of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Pos = 0x0
	// Bit mask of MSTS field.
	SYSTEM_MOSCWTCR_MSTS_Msk = 0xf
	// Wait time= 3 cycles (11.4us : calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0000 = 0x0
	// Wait time= 35 cycles (133.5us : calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0001 = 0x1
	// Wait time= 67 cycles (255.6us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0010 = 0x2
	// Wait time= 131 cycles (499.7us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0011 = 0x3
	// Wait time= 259 cycles (988.0us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0100 = 0x4
	// Wait time= 547 cycles (2086.6us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0101 = 0x5
	// Wait time= 1059 cycles (4039.8us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0110 = 0x6
	// Wait time= 2147 cycles (8190.2us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_0111 = 0x7
	// Wait time= 4291 cycles (16368.9us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_1000 = 0x8
	// Wait time= 8163 cycles (31139.4us: calculated at LOCO=262.144KHz (3.81us TYP.))
	SYSTEM_MOSCWTCR_MSTS_1001 = 0x9

	// HOCOWTCR: High-Speed On-Chip Oscillator Wait Control Register
	// Position of Reserved field.
	SYSTEM_HOCOWTCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_HOCOWTCR_Reserved_Msk = 0xf8
	// Position of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Pos = 0x0
	// Bit mask of HSTS field.
	SYSTEM_HOCOWTCR_HSTS_Msk = 0x7
	// If HOCO frequency is other than 64MHz, should set the value to 101b.
	SYSTEM_HOCOWTCR_HSTS_101 = 0x5
	// If HOCO frequency = 64MHz, should set the value to 110b.
	SYSTEM_HOCOWTCR_HSTS_110 = 0x6

	// SOPCCR: Sub Operating Power Control Register
	// Position of Reserved field.
	SYSTEM_SOPCCR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	SYSTEM_SOPCCR_Reserved_Msk = 0xe0
	// Position of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Pos = 0x4
	// Bit mask of SOPCMTSF field.
	SYSTEM_SOPCCR_SOPCMTSF_Msk = 0x10
	// Bit SOPCMTSF.
	SYSTEM_SOPCCR_SOPCMTSF = 0x10
	// Transition completed
	SYSTEM_SOPCCR_SOPCMTSF_0 = 0x0
	// During transition
	SYSTEM_SOPCCR_SOPCMTSF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SOPCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_SOPCCR_Reserved_Msk = 0xe
	// Position of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Pos = 0x0
	// Bit mask of SOPCM field.
	SYSTEM_SOPCCR_SOPCM_Msk = 0x1
	// Bit SOPCM.
	SYSTEM_SOPCCR_SOPCM = 0x1
	// Other than Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_0 = 0x0
	// Subosc-speed mode
	SYSTEM_SOPCCR_SOPCM_1 = 0x1

	// RSTSR1: Reset Status Register 1
	// Position of Reserved field.
	SYSTEM_RSTSR1_Reserved_Pos = 0xd
	// Bit mask of Reserved field.
	SYSTEM_RSTSR1_Reserved_Msk = 0xe000
	// Position of SPERF field.
	SYSTEM_RSTSR1_SPERF_Pos = 0xc
	// Bit mask of SPERF field.
	SYSTEM_RSTSR1_SPERF_Msk = 0x1000
	// Bit SPERF.
	SYSTEM_RSTSR1_SPERF = 0x1000
	// SP error reset not detected.
	SYSTEM_RSTSR1_SPERF_0 = 0x0
	// SP error reset detected.
	SYSTEM_RSTSR1_SPERF_1 = 0x1
	// Position of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Pos = 0xb
	// Bit mask of BUSMRF field.
	SYSTEM_RSTSR1_BUSMRF_Msk = 0x800
	// Bit BUSMRF.
	SYSTEM_RSTSR1_BUSMRF = 0x800
	// Bus Master MPU reset not detected.
	SYSTEM_RSTSR1_BUSMRF_0 = 0x0
	// Bus Master MPU reset detected.
	SYSTEM_RSTSR1_BUSMRF_1 = 0x1
	// Position of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Pos = 0xa
	// Bit mask of BUSSRF field.
	SYSTEM_RSTSR1_BUSSRF_Msk = 0x400
	// Bit BUSSRF.
	SYSTEM_RSTSR1_BUSSRF = 0x400
	// Bus Slave MPU reset not detected.
	SYSTEM_RSTSR1_BUSSRF_0 = 0x0
	// Bus Slave MPU reset detected.
	SYSTEM_RSTSR1_BUSSRF_1 = 0x1
	// Position of REERF field.
	SYSTEM_RSTSR1_REERF_Pos = 0x9
	// Bit mask of REERF field.
	SYSTEM_RSTSR1_REERF_Msk = 0x200
	// Bit REERF.
	SYSTEM_RSTSR1_REERF = 0x200
	// RAM ECC error reset not detected.
	SYSTEM_RSTSR1_REERF_0 = 0x0
	// RAM ECC error reset detected.
	SYSTEM_RSTSR1_REERF_1 = 0x1
	// Position of RPERF field.
	SYSTEM_RSTSR1_RPERF_Pos = 0x8
	// Bit mask of RPERF field.
	SYSTEM_RSTSR1_RPERF_Msk = 0x100
	// Bit RPERF.
	SYSTEM_RSTSR1_RPERF = 0x100
	// RAM parity error reset not detected.
	SYSTEM_RSTSR1_RPERF_0 = 0x0
	// RAM parity error reset detected.
	SYSTEM_RSTSR1_RPERF_1 = 0x1
	// Position of Reserved field.
	SYSTEM_RSTSR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_RSTSR1_Reserved_Msk = 0xf8
	// Position of SWRF field.
	SYSTEM_RSTSR1_SWRF_Pos = 0x2
	// Bit mask of SWRF field.
	SYSTEM_RSTSR1_SWRF_Msk = 0x4
	// Bit SWRF.
	SYSTEM_RSTSR1_SWRF = 0x4
	// Software reset not detected.
	SYSTEM_RSTSR1_SWRF_0 = 0x0
	// Software reset detected.
	SYSTEM_RSTSR1_SWRF_1 = 0x1
	// Position of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Pos = 0x1
	// Bit mask of WDTRF field.
	SYSTEM_RSTSR1_WDTRF_Msk = 0x2
	// Bit WDTRF.
	SYSTEM_RSTSR1_WDTRF = 0x2
	// Watchdog timer reset not detected.
	SYSTEM_RSTSR1_WDTRF_0 = 0x0
	// Watchdog timer reset detected.
	SYSTEM_RSTSR1_WDTRF_1 = 0x1
	// Position of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Pos = 0x0
	// Bit mask of IWDTRF field.
	SYSTEM_RSTSR1_IWDTRF_Msk = 0x1
	// Bit IWDTRF.
	SYSTEM_RSTSR1_IWDTRF = 0x1
	// Independent watchdog timer reset not detected.
	SYSTEM_RSTSR1_IWDTRF_0 = 0x0
	// Independent watchdog timer reset detected.
	SYSTEM_RSTSR1_IWDTRF_1 = 0x1

	// SDADCCKCR: 24-bit Sigma-Delta A/D Converter Clock Control Register
	// Position of SDADCCKEN field.
	SYSTEM_SDADCCKCR_SDADCCKEN_Pos = 0x7
	// Bit mask of SDADCCKEN field.
	SYSTEM_SDADCCKCR_SDADCCKEN_Msk = 0x80
	// Bit SDADCCKEN.
	SYSTEM_SDADCCKCR_SDADCCKEN = 0x80
	// MOSC is chosen by a source clock of 24-bit Sigma-Delta A/D Converter Clock
	SYSTEM_SDADCCKCR_SDADCCKEN_0 = 0x0
	// HOCO is chosen by a source clock of 24-bit Sigma-Delta A/D Converter Clock
	SYSTEM_SDADCCKCR_SDADCCKEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SDADCCKCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_SDADCCKCR_Reserved_Msk = 0x7e
	// Position of SDADCCKSEL field.
	SYSTEM_SDADCCKCR_SDADCCKSEL_Pos = 0x0
	// Bit mask of SDADCCKSEL field.
	SYSTEM_SDADCCKCR_SDADCCKSEL_Msk = 0x1
	// Bit SDADCCKSEL.
	SYSTEM_SDADCCKCR_SDADCCKSEL = 0x1
	// 24-bit Sigma-Delta A/D Converter Clock is disabled
	SYSTEM_SDADCCKCR_SDADCCKSEL_0 = 0x0
	// 24-bit Sigma-Delta A/D Converter Clock is enabled
	SYSTEM_SDADCCKCR_SDADCCKSEL_1 = 0x1

	// LVD1CR1: Voltage Monitor 1 Circuit Control Register 1
	// Position of Reserved field.
	SYSTEM_LVD1CR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVD1CR1_Reserved_Msk = 0xf8
	// Position of IRQSEL field.
	SYSTEM_LVD1CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSTEM_LVD1CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSTEM_LVD1CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSTEM_LVD1CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSTEM_LVD1CR1_IRQSEL_1 = 0x1
	// Position of IDTSEL field.
	SYSTEM_LVD1CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSTEM_LVD1CR1_IDTSEL_Msk = 0x3
	// When VCC>=Vdet1 (rise) is detected
	SYSTEM_LVD1CR1_IDTSEL_00 = 0x0
	// When VCC<Vdet1 (drop) is detected
	SYSTEM_LVD1CR1_IDTSEL_01 = 0x1
	// When drop and rise are detected
	SYSTEM_LVD1CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSTEM_LVD1CR1_IDTSEL_11 = 0x3

	// LVD1SR: Voltage Monitor 1 Circuit Status Register
	// Position of Reserved field.
	SYSTEM_LVD1SR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_LVD1SR_Reserved_Msk = 0xfc
	// Position of MON field.
	SYSTEM_LVD1SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSTEM_LVD1SR_MON_Msk = 0x2
	// Bit MON.
	SYSTEM_LVD1SR_MON = 0x2
	// VCC < Vdet1
	SYSTEM_LVD1SR_MON_0 = 0x0
	// VCC >= Vdet1 or MON is disabled
	SYSTEM_LVD1SR_MON_1 = 0x1
	// Position of DET field.
	SYSTEM_LVD1SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSTEM_LVD1SR_DET_Msk = 0x1
	// Bit DET.
	SYSTEM_LVD1SR_DET = 0x1
	// Not detected
	SYSTEM_LVD1SR_DET_0 = 0x0
	// Vdet1 passage detection
	SYSTEM_LVD1SR_DET_1 = 0x1

	// LVD2CR1: Voltage Monitor 2 Circuit Control Register 1
	// Position of Reserved field.
	SYSTEM_LVD2CR1_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVD2CR1_Reserved_Msk = 0xf8
	// Position of IRQSEL field.
	SYSTEM_LVD2CR1_IRQSEL_Pos = 0x2
	// Bit mask of IRQSEL field.
	SYSTEM_LVD2CR1_IRQSEL_Msk = 0x4
	// Bit IRQSEL.
	SYSTEM_LVD2CR1_IRQSEL = 0x4
	// Non-maskable interrupt
	SYSTEM_LVD2CR1_IRQSEL_0 = 0x0
	// Maskable interrupt
	SYSTEM_LVD2CR1_IRQSEL_1 = 0x1
	// Position of IDTSEL field.
	SYSTEM_LVD2CR1_IDTSEL_Pos = 0x0
	// Bit mask of IDTSEL field.
	SYSTEM_LVD2CR1_IDTSEL_Msk = 0x3
	// When VCC>=Vdet2 (rise) is detected
	SYSTEM_LVD2CR1_IDTSEL_00 = 0x0
	// When VCC<Vdet2 (drop) is detected
	SYSTEM_LVD2CR1_IDTSEL_01 = 0x1
	// When drop and rise are detected
	SYSTEM_LVD2CR1_IDTSEL_10 = 0x2
	// Settings prohibited
	SYSTEM_LVD2CR1_IDTSEL_11 = 0x3

	// LVD2SR: Voltage Monitor 2 Circuit Status Register
	// Position of Reserved field.
	SYSTEM_LVD2SR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_LVD2SR_Reserved_Msk = 0xfc
	// Position of MON field.
	SYSTEM_LVD2SR_MON_Pos = 0x1
	// Bit mask of MON field.
	SYSTEM_LVD2SR_MON_Msk = 0x2
	// Bit MON.
	SYSTEM_LVD2SR_MON = 0x2
	// VCC < Vdet2
	SYSTEM_LVD2SR_MON_0 = 0x0
	// VCC >= Vdet2 or MON is disabled
	SYSTEM_LVD2SR_MON_1 = 0x1
	// Position of DET field.
	SYSTEM_LVD2SR_DET_Pos = 0x0
	// Bit mask of DET field.
	SYSTEM_LVD2SR_DET_Msk = 0x1
	// Bit DET.
	SYSTEM_LVD2SR_DET = 0x1
	// Not detected
	SYSTEM_LVD2SR_DET_0 = 0x0
	// Vdet2 passage detection
	SYSTEM_LVD2SR_DET_1 = 0x1

	// PRCR: Protect Register
	// Position of PRKEY field.
	SYSTEM_PRCR_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	SYSTEM_PRCR_PRKEY_Msk = 0xff00
	// Enables writing to the PRCR register.
	SYSTEM_PRCR_PRKEY_0x5A = 0x5a
	// Position of Reserved field.
	SYSTEM_PRCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_PRCR_Reserved_Msk = 0xf0
	// Position of PRC3 field.
	SYSTEM_PRCR_PRC3_Pos = 0x3
	// Bit mask of PRC3 field.
	SYSTEM_PRCR_PRC3_Msk = 0x8
	// Bit PRC3.
	SYSTEM_PRCR_PRC3 = 0x8
	// Writes protected.
	SYSTEM_PRCR_PRC3_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC3_1 = 0x1
	// Position of Reserved field.
	SYSTEM_PRCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_PRCR_Reserved_Msk = 0x4
	// Bit Reserved.
	SYSTEM_PRCR_Reserved = 0x4
	// Position of PRC1 field.
	SYSTEM_PRCR_PRC1_Pos = 0x1
	// Bit mask of PRC1 field.
	SYSTEM_PRCR_PRC1_Msk = 0x2
	// Bit PRC1.
	SYSTEM_PRCR_PRC1 = 0x2
	// Writes protected.
	SYSTEM_PRCR_PRC1_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC1_1 = 0x1
	// Position of PRC0 field.
	SYSTEM_PRCR_PRC0_Pos = 0x0
	// Bit mask of PRC0 field.
	SYSTEM_PRCR_PRC0_Msk = 0x1
	// Bit PRC0.
	SYSTEM_PRCR_PRC0 = 0x1
	// Writes protected.
	SYSTEM_PRCR_PRC0_0 = 0x0
	// Writes not protected.
	SYSTEM_PRCR_PRC0_1 = 0x1

	// SYOCDCR: System Control OCD Control Register
	// Position of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Pos = 0x7
	// Bit mask of DBGEN field.
	SYSTEM_SYOCDCR_DBGEN_Msk = 0x80
	// Bit DBGEN.
	SYSTEM_SYOCDCR_DBGEN = 0x80
	// On-chip debugger is disabled
	SYSTEM_SYOCDCR_DBGEN_0 = 0x0
	// On-chip debugger is enabled
	SYSTEM_SYOCDCR_DBGEN_1 = 0x1
	// Position of Reserved field.
	SYSTEM_SYOCDCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_SYOCDCR_Reserved_Msk = 0x7f

	// RSTSR0: Reset Status Register 0
	// Position of Reserved field.
	SYSTEM_RSTSR0_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_RSTSR0_Reserved_Msk = 0xf0
	// Position of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Pos = 0x3
	// Bit mask of LVD2RF field.
	SYSTEM_RSTSR0_LVD2RF_Msk = 0x8
	// Bit LVD2RF.
	SYSTEM_RSTSR0_LVD2RF = 0x8
	// Voltage Monitor 2 reset not detected.
	SYSTEM_RSTSR0_LVD2RF_0 = 0x0
	// Voltage Monitor 2 reset detected.
	SYSTEM_RSTSR0_LVD2RF_1 = 0x1
	// Position of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Pos = 0x2
	// Bit mask of LVD1RF field.
	SYSTEM_RSTSR0_LVD1RF_Msk = 0x4
	// Bit LVD1RF.
	SYSTEM_RSTSR0_LVD1RF = 0x4
	// Voltage Monitor 1 reset not detected.
	SYSTEM_RSTSR0_LVD1RF_0 = 0x0
	// Voltage Monitor 1 reset detected.
	SYSTEM_RSTSR0_LVD1RF_1 = 0x1
	// Position of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Pos = 0x1
	// Bit mask of LVD0RF field.
	SYSTEM_RSTSR0_LVD0RF_Msk = 0x2
	// Bit LVD0RF.
	SYSTEM_RSTSR0_LVD0RF = 0x2
	// Voltage Monitor 0 reset not detected.
	SYSTEM_RSTSR0_LVD0RF_0 = 0x0
	// Voltage Monitor 0 reset detected.
	SYSTEM_RSTSR0_LVD0RF_1 = 0x1
	// Position of PORF field.
	SYSTEM_RSTSR0_PORF_Pos = 0x0
	// Bit mask of PORF field.
	SYSTEM_RSTSR0_PORF_Msk = 0x1
	// Bit PORF.
	SYSTEM_RSTSR0_PORF = 0x1
	// Power-on reset not detected.
	SYSTEM_RSTSR0_PORF_0 = 0x0
	// Power-on reset detected.
	SYSTEM_RSTSR0_PORF_1 = 0x1

	// RSTSR2: Reset Status Register 2
	// Position of Reserved field.
	SYSTEM_RSTSR2_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_RSTSR2_Reserved_Msk = 0xfe
	// Position of CWSF field.
	SYSTEM_RSTSR2_CWSF_Pos = 0x0
	// Bit mask of CWSF field.
	SYSTEM_RSTSR2_CWSF_Msk = 0x1
	// Bit CWSF.
	SYSTEM_RSTSR2_CWSF = 0x1
	// Cold start
	SYSTEM_RSTSR2_CWSF_0 = 0x0
	// Warm start
	SYSTEM_RSTSR2_CWSF_1 = 0x1

	// MOMCR: Main Clock Oscillator Mode Oscillation Control Register
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x80
	// Bit Reserved.
	SYSTEM_MOMCR_Reserved = 0x80
	// Position of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Pos = 0x6
	// Bit mask of MOSEL field.
	SYSTEM_MOMCR_MOSEL_Msk = 0x40
	// Bit MOSEL.
	SYSTEM_MOMCR_MOSEL = 0x40
	// Resonator
	SYSTEM_MOMCR_MOSEL_0 = 0x0
	// External clock input
	SYSTEM_MOMCR_MOSEL_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x30
	// Position of MODRV1 field.
	SYSTEM_MOMCR_MODRV1_Pos = 0x3
	// Bit mask of MODRV1 field.
	SYSTEM_MOMCR_MODRV1_Msk = 0x8
	// Bit MODRV1.
	SYSTEM_MOMCR_MODRV1 = 0x8
	// 10 MHz to 20 MHz
	SYSTEM_MOMCR_MODRV1_0 = 0x0
	// 1 MHz to 10 MHz
	SYSTEM_MOMCR_MODRV1_1 = 0x1
	// Position of Reserved field.
	SYSTEM_MOMCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_MOMCR_Reserved_Msk = 0x7

	// LVCMPCR: Voltage Monitor Circuit Control Register
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0x80
	// Bit Reserved.
	SYSTEM_LVCMPCR_Reserved = 0x80
	// Position of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Pos = 0x6
	// Bit mask of LVD2E field.
	SYSTEM_LVCMPCR_LVD2E_Msk = 0x40
	// Bit LVD2E.
	SYSTEM_LVCMPCR_LVD2E = 0x40
	// Voltage detection 2 circuit disabled
	SYSTEM_LVCMPCR_LVD2E_0 = 0x0
	// Voltage detection 2 circuit enabled
	SYSTEM_LVCMPCR_LVD2E_1 = 0x1
	// Position of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Pos = 0x5
	// Bit mask of LVD1E field.
	SYSTEM_LVCMPCR_LVD1E_Msk = 0x20
	// Bit LVD1E.
	SYSTEM_LVCMPCR_LVD1E = 0x20
	// Voltage detection 1 circuit disabled
	SYSTEM_LVCMPCR_LVD1E_0 = 0x0
	// Voltage detection 1 circuit enabled
	SYSTEM_LVCMPCR_LVD1E_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	SYSTEM_LVCMPCR_Reserved_Msk = 0x1f

	// LVDLVLR: Voltage Detection Level Select Register
	// Position of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Pos = 0x5
	// Bit mask of LVD2LVL field.
	SYSTEM_LVDLVLR_LVD2LVL_Msk = 0xe0
	// 4.29V(Vdet2_0)
	SYSTEM_LVDLVLR_LVD2LVL_000 = 0x0
	// 4.14V(Vdet2_1)
	SYSTEM_LVDLVLR_LVD2LVL_001 = 0x1
	// 4.02V(Vdet2_2)
	SYSTEM_LVDLVLR_LVD2LVL_010 = 0x2
	// 3.84V(Vdet2_3)
	SYSTEM_LVDLVLR_LVD2LVL_011 = 0x3
	// Position of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Pos = 0x0
	// Bit mask of LVD1LVL field.
	SYSTEM_LVDLVLR_LVD1LVL_Msk = 0x1f
	// 4.29V(Vdet1_0)
	SYSTEM_LVDLVLR_LVD1LVL_00000 = 0x0
	// 4.14V(Vdet1_1)
	SYSTEM_LVDLVLR_LVD1LVL_00001 = 0x1
	// 4.02V(Vdet1_2)
	SYSTEM_LVDLVLR_LVD1LVL_00010 = 0x2
	// 3.84V(Vdet1_3)
	SYSTEM_LVDLVLR_LVD1LVL_00011 = 0x3
	// 3.10V(Vdet1_4)
	SYSTEM_LVDLVLR_LVD1LVL_00100 = 0x4
	// 3.00V(Vdet1_5)
	SYSTEM_LVDLVLR_LVD1LVL_00101 = 0x5
	// 2.90V(Vdet1_6)
	SYSTEM_LVDLVLR_LVD1LVL_00110 = 0x6
	// 2.79V(Vdet1_7)
	SYSTEM_LVDLVLR_LVD1LVL_00111 = 0x7
	// 2.68V(Vdet1_8)
	SYSTEM_LVDLVLR_LVD1LVL_01000 = 0x8
	// 2.58V(Vdet1_9)
	SYSTEM_LVDLVLR_LVD1LVL_01001 = 0x9
	// 2.48V(Vdet1_A)
	SYSTEM_LVDLVLR_LVD1LVL_01010 = 0xa
	// 2.20V(Vdet1_B)
	SYSTEM_LVDLVLR_LVD1LVL_01011 = 0xb
	// 1.96V(Vdet1_C)
	SYSTEM_LVDLVLR_LVD1LVL_01100 = 0xc
	// 1.86V(Vdet1_D)
	SYSTEM_LVDLVLR_LVD1LVL_01101 = 0xd
	// 1.75V(Vdet1_E)
	SYSTEM_LVDLVLR_LVD1LVL_01110 = 0xe
	// 1.65V(Vdet1_F)
	SYSTEM_LVDLVLR_LVD1LVL_01111 = 0xf

	// LVD1CR0: Voltage Monitor 1 Circuit Control Register 0
	// Position of RN field.
	SYSTEM_LVD1CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSTEM_LVD1CR0_RN_Msk = 0x80
	// Bit RN.
	SYSTEM_LVD1CR0_RN = 0x80
	// Negation follows a stabilization time (tLVD1) after VCC > Vdet1 is detected.
	SYSTEM_LVD1CR0_RN_0 = 0x0
	// Negation follows a stabilization time (tLVD1) after assertion of the LVD1 reset.
	SYSTEM_LVD1CR0_RN_1 = 0x1
	// Position of RI field.
	SYSTEM_LVD1CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSTEM_LVD1CR0_RI_Msk = 0x40
	// Bit RI.
	SYSTEM_LVD1CR0_RI = 0x40
	// Voltage monitor 1 interrupt during Vdet1 passage
	SYSTEM_LVD1CR0_RI_0 = 0x0
	// Voltage monitor 1 reset enabled when the voltage falls to and below Vdet1
	SYSTEM_LVD1CR0_RI_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVD1CR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVD1CR0_Reserved_Msk = 0x38
	// Position of CMPE field.
	SYSTEM_LVD1CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSTEM_LVD1CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSTEM_LVD1CR0_CMPE = 0x4
	// Voltage monitor 1 circuit comparison result output disabled.
	SYSTEM_LVD1CR0_CMPE_0 = 0x0
	// Voltage monitor 1 circuit comparison result output enabled.
	SYSTEM_LVD1CR0_CMPE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVD1CR0_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_LVD1CR0_Reserved_Msk = 0x2
	// Bit Reserved.
	SYSTEM_LVD1CR0_Reserved = 0x2
	// Position of RIE field.
	SYSTEM_LVD1CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSTEM_LVD1CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSTEM_LVD1CR0_RIE = 0x1
	// Disabled
	SYSTEM_LVD1CR0_RIE_0 = 0x0
	// Enabled
	SYSTEM_LVD1CR0_RIE_1 = 0x1

	// LVD2CR0: Voltage Monitor 2 Circuit Control Register 0
	// Position of RN field.
	SYSTEM_LVD2CR0_RN_Pos = 0x7
	// Bit mask of RN field.
	SYSTEM_LVD2CR0_RN_Msk = 0x80
	// Bit RN.
	SYSTEM_LVD2CR0_RN = 0x80
	// Negation follows a stabilization time (tLVD2) after VCC > Vdet2 is detected.
	SYSTEM_LVD2CR0_RN_0 = 0x0
	// Negation follows a stabilization time (tLVD2) after assertion of the LVD2 reset.
	SYSTEM_LVD2CR0_RN_1 = 0x1
	// Position of RI field.
	SYSTEM_LVD2CR0_RI_Pos = 0x6
	// Bit mask of RI field.
	SYSTEM_LVD2CR0_RI_Msk = 0x40
	// Bit RI.
	SYSTEM_LVD2CR0_RI = 0x40
	// Voltage monitor 2 interrupt during Vdet2 passage
	SYSTEM_LVD2CR0_RI_0 = 0x0
	// Voltage monitor 2 reset enabled when the voltage falls to and below Vdet2
	SYSTEM_LVD2CR0_RI_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVD2CR0_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	SYSTEM_LVD2CR0_Reserved_Msk = 0x38
	// Position of CMPE field.
	SYSTEM_LVD2CR0_CMPE_Pos = 0x2
	// Bit mask of CMPE field.
	SYSTEM_LVD2CR0_CMPE_Msk = 0x4
	// Bit CMPE.
	SYSTEM_LVD2CR0_CMPE = 0x4
	// Voltage monitor 2 circuit comparison result output disabled.
	SYSTEM_LVD2CR0_CMPE_0 = 0x0
	// Voltage monitor 2 circuit comparison result output enabled.
	SYSTEM_LVD2CR0_CMPE_1 = 0x1
	// Position of Reserved field.
	SYSTEM_LVD2CR0_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_LVD2CR0_Reserved_Msk = 0x2
	// Bit Reserved.
	SYSTEM_LVD2CR0_Reserved = 0x2
	// Position of RIE field.
	SYSTEM_LVD2CR0_RIE_Pos = 0x0
	// Bit mask of RIE field.
	SYSTEM_LVD2CR0_RIE_Msk = 0x1
	// Bit RIE.
	SYSTEM_LVD2CR0_RIE = 0x1
	// Disabled
	SYSTEM_LVD2CR0_RIE_0 = 0x0
	// Enabled
	SYSTEM_LVD2CR0_RIE_1 = 0x1

	// SOSCCR: Sub-clock Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_SOSCCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_SOSCCR_Reserved_Msk = 0xfe
	// Position of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Pos = 0x0
	// Bit mask of SOSTP field.
	SYSTEM_SOSCCR_SOSTP_Msk = 0x1
	// Bit SOSTP.
	SYSTEM_SOSCCR_SOSTP = 0x1
	// Sub-clock oscillator is operating.
	SYSTEM_SOSCCR_SOSTP_0 = 0x0
	// Sub-clock oscillator is stopped.
	SYSTEM_SOSCCR_SOSTP_1 = 0x1

	// SOMCR: Sub-clock Oscillator Mode Control Register
	// Position of Reserved field.
	SYSTEM_SOMCR_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	SYSTEM_SOMCR_Reserved_Msk = 0xfc
	// Position of SODRV field.
	SYSTEM_SOMCR_SODRV_Pos = 0x0
	// Bit mask of SODRV field.
	SYSTEM_SOMCR_SODRV_Msk = 0x3
	// Normal Mode
	SYSTEM_SOMCR_SODRV_00 = 0x0
	// Low power mode 1
	SYSTEM_SOMCR_SODRV_01 = 0x1
	// Low power mode 2
	SYSTEM_SOMCR_SODRV_10 = 0x2
	// Low power mode 3
	SYSTEM_SOMCR_SODRV_11 = 0x3

	// LOCOCR: Low-Speed On-Chip Oscillator Control Register
	// Position of Reserved field.
	SYSTEM_LOCOCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	SYSTEM_LOCOCR_Reserved_Msk = 0xfe
	// Position of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Pos = 0x0
	// Bit mask of LCSTP field.
	SYSTEM_LOCOCR_LCSTP_Msk = 0x1
	// Bit LCSTP.
	SYSTEM_LOCOCR_LCSTP = 0x1
	// LOCO is operating.
	SYSTEM_LOCOCR_LCSTP_0 = 0x0
	// LOCO is stopped.
	SYSTEM_LOCOCR_LCSTP_1 = 0x1

	// LOCOUTCR: LOCO User Trimming Control Register
	// Position of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Pos = 0x0
	// Bit mask of LOCOUTRM field.
	SYSTEM_LOCOUTCR_LOCOUTRM_Msk = 0xff
)

// Constants for MSTP: Module Stop Control B,C,D
const (
	// MSTPCRB: Module Stop Control Register B
	// Position of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Pos = 0x1f
	// Bit mask of MSTPB31 field.
	MSTP_MSTPCRB_MSTPB31_Msk = 0x80000000
	// Bit MSTPB31.
	MSTP_MSTPCRB_MSTPB31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB31_1 = 0x1
	// Position of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Pos = 0x1e
	// Bit mask of MSTPB30 field.
	MSTP_MSTPCRB_MSTPB30_Msk = 0x40000000
	// Bit MSTPB30.
	MSTP_MSTPCRB_MSTPB30 = 0x40000000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB30_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB30_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x17
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x3f800000
	// Position of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Pos = 0x16
	// Bit mask of MSTPB22 field.
	MSTP_MSTPCRB_MSTPB22_Msk = 0x400000
	// Bit MSTPB22.
	MSTP_MSTPCRB_MSTPB22 = 0x400000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB22_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB22_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x300000
	// Position of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Pos = 0x13
	// Bit mask of MSTPB19 field.
	MSTP_MSTPCRB_MSTPB19_Msk = 0x80000
	// Bit MSTPB19.
	MSTP_MSTPCRB_MSTPB19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB19_1 = 0x1
	// Position of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Pos = 0x12
	// Bit mask of MSTPB18 field.
	MSTP_MSTPCRB_MSTPB18_Msk = 0x40000
	// Bit MSTPB18.
	MSTP_MSTPCRB_MSTPB18 = 0x40000
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB18_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB18_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x3f000
	// Position of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Pos = 0xb
	// Bit mask of MSTPB11 field.
	MSTP_MSTPCRB_MSTPB11_Msk = 0x800
	// Bit MSTPB11.
	MSTP_MSTPCRB_MSTPB11 = 0x800
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB11_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB11_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0xa
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x400
	// Bit Reserved.
	MSTP_MSTPCRB_Reserved = 0x400
	// Position of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Pos = 0x9
	// Bit mask of MSTPB9 field.
	MSTP_MSTPCRB_MSTPB9_Msk = 0x200
	// Bit MSTPB9.
	MSTP_MSTPCRB_MSTPB9 = 0x200
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB9_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB9_1 = 0x1
	// Position of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Pos = 0x8
	// Bit mask of MSTPB8 field.
	MSTP_MSTPCRB_MSTPB8_Msk = 0x100
	// Bit MSTPB8.
	MSTP_MSTPCRB_MSTPB8 = 0x100
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB8_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB8_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0xf8
	// Position of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Pos = 0x2
	// Bit mask of MSTPB2 field.
	MSTP_MSTPCRB_MSTPB2_Msk = 0x4
	// Bit MSTPB2.
	MSTP_MSTPCRB_MSTPB2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRB_MSTPB2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRB_MSTPB2_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRB_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MSTP_MSTPCRB_Reserved_Msk = 0x3

	// MSTPCRC: Module Stop Control Register C
	// Position of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Pos = 0x1f
	// Bit mask of MSTPC31 field.
	MSTP_MSTPCRC_MSTPC31_Msk = 0x80000000
	// Bit MSTPC31.
	MSTP_MSTPCRC_MSTPC31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC31_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0x60000000
	// Position of MSTPC28 field.
	MSTP_MSTPCRC_MSTPC28_Pos = 0x1c
	// Bit mask of MSTPC28 field.
	MSTP_MSTPCRC_MSTPC28_Msk = 0x10000000
	// Bit MSTPC28.
	MSTP_MSTPCRC_MSTPC28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC28_0 = 0x0
	// Enter the module-stop state.
	MSTP_MSTPCRC_MSTPC28_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0xfff8000
	// Position of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Pos = 0xe
	// Bit mask of MSTPC14 field.
	MSTP_MSTPCRC_MSTPC14_Msk = 0x4000
	// Bit MSTPC14.
	MSTP_MSTPCRC_MSTPC14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC14_1 = 0x1
	// Position of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Pos = 0xd
	// Bit mask of MSTPC13 field.
	MSTP_MSTPCRC_MSTPC13_Msk = 0x2000
	// Bit MSTPC13.
	MSTP_MSTPCRC_MSTPC13 = 0x2000
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC13_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC13_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0x1ff0
	// Position of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Pos = 0x3
	// Bit mask of MSTPC3 field.
	MSTP_MSTPCRC_MSTPC3_Msk = 0x8
	// Bit MSTPC3.
	MSTP_MSTPCRC_MSTPC3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC3_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRC_Reserved_Pos = 0x2
	// Bit mask of Reserved field.
	MSTP_MSTPCRC_Reserved_Msk = 0x4
	// Bit Reserved.
	MSTP_MSTPCRC_Reserved = 0x4
	// Position of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Pos = 0x1
	// Bit mask of MSTPC1 field.
	MSTP_MSTPCRC_MSTPC1_Msk = 0x2
	// Bit MSTPC1.
	MSTP_MSTPCRC_MSTPC1 = 0x2
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC1_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC1_1 = 0x1
	// Position of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Pos = 0x0
	// Bit mask of MSTPC0 field.
	MSTP_MSTPCRC_MSTPC0_Msk = 0x1
	// Bit MSTPC0.
	MSTP_MSTPCRC_MSTPC0 = 0x1
	// Cancel the module-stop state
	MSTP_MSTPCRC_MSTPC0_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRC_MSTPC0_1 = 0x1

	// MSTPCRD: Module Stop Control Register D
	// Position of MSTPD31 field.
	MSTP_MSTPCRD_MSTPD31_Pos = 0x1f
	// Bit mask of MSTPD31 field.
	MSTP_MSTPCRD_MSTPD31_Msk = 0x80000000
	// Bit MSTPD31.
	MSTP_MSTPCRD_MSTPD31 = 0x80000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD31_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD31_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x1e
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x40000000
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x40000000
	// Position of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Pos = 0x1d
	// Bit mask of MSTPD29 field.
	MSTP_MSTPCRD_MSTPD29_Msk = 0x20000000
	// Bit MSTPD29.
	MSTP_MSTPCRD_MSTPD29 = 0x20000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD29_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD29_1 = 0x1
	// Position of MSTPD28 field.
	MSTP_MSTPCRD_MSTPD28_Pos = 0x1c
	// Bit mask of MSTPD28 field.
	MSTP_MSTPCRD_MSTPD28_Msk = 0x10000000
	// Bit MSTPD28.
	MSTP_MSTPCRD_MSTPD28 = 0x10000000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD28_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD28_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0xfe00000
	// Position of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Pos = 0x14
	// Bit mask of MSTPD20 field.
	MSTP_MSTPCRD_MSTPD20_Msk = 0x100000
	// Bit MSTPD20.
	MSTP_MSTPCRD_MSTPD20 = 0x100000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD20_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD20_1 = 0x1
	// Position of MSTPD19 field.
	MSTP_MSTPCRD_MSTPD19_Pos = 0x13
	// Bit mask of MSTPD19 field.
	MSTP_MSTPCRD_MSTPD19_Msk = 0x80000
	// Bit MSTPD19.
	MSTP_MSTPCRD_MSTPD19 = 0x80000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD19_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD19_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x12
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x40000
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x40000
	// Position of MSTPD17 field.
	MSTP_MSTPCRD_MSTPD17_Pos = 0x11
	// Bit mask of MSTPD17 field.
	MSTP_MSTPCRD_MSTPD17_Msk = 0x20000
	// Bit MSTPD17.
	MSTP_MSTPCRD_MSTPD17 = 0x20000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD17_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD17_1 = 0x1
	// Position of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Pos = 0x10
	// Bit mask of MSTPD16 field.
	MSTP_MSTPCRD_MSTPD16_Msk = 0x10000
	// Bit MSTPD16.
	MSTP_MSTPCRD_MSTPD16 = 0x10000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD16_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD16_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0xf
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x8000
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x8000
	// Position of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Pos = 0xe
	// Bit mask of MSTPD14 field.
	MSTP_MSTPCRD_MSTPD14_Msk = 0x4000
	// Bit MSTPD14.
	MSTP_MSTPCRD_MSTPD14 = 0x4000
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD14_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD14_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x3f80
	// Position of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Pos = 0x6
	// Bit mask of MSTPD6 field.
	MSTP_MSTPCRD_MSTPD6_Msk = 0x40
	// Bit MSTPD6.
	MSTP_MSTPCRD_MSTPD6 = 0x40
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD6_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD6_1 = 0x1
	// Position of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Pos = 0x5
	// Bit mask of MSTPD5 field.
	MSTP_MSTPCRD_MSTPD5_Msk = 0x20
	// Bit MSTPD5.
	MSTP_MSTPCRD_MSTPD5 = 0x20
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD5_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD5_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x10
	// Bit Reserved.
	MSTP_MSTPCRD_Reserved = 0x10
	// Position of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Pos = 0x3
	// Bit mask of MSTPD3 field.
	MSTP_MSTPCRD_MSTPD3_Msk = 0x8
	// Bit MSTPD3.
	MSTP_MSTPCRD_MSTPD3 = 0x8
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD3_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD3_1 = 0x1
	// Position of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Pos = 0x2
	// Bit mask of MSTPD2 field.
	MSTP_MSTPCRD_MSTPD2_Msk = 0x4
	// Bit MSTPD2.
	MSTP_MSTPCRD_MSTPD2 = 0x4
	// Cancel the module-stop state
	MSTP_MSTPCRD_MSTPD2_0 = 0x0
	// Enter the module-stop state
	MSTP_MSTPCRD_MSTPD2_1 = 0x1
	// Position of Reserved field.
	MSTP_MSTPCRD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	MSTP_MSTPCRD_Reserved_Msk = 0x3
)

// Constants for AGT0: Asynchronous General purpose Timer 0
const (
	// AGT: AGT Counter Register
	// Position of AGT field.
	AGT0_AGT_AGT_Pos = 0x0
	// Bit mask of AGT field.
	AGT0_AGT_AGT_Msk = 0xffff

	// AGTCMA: AGT Compare Match A Register
	// Position of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Pos = 0x0
	// Bit mask of AGTCMA field.
	AGT0_AGTCMA_AGTCMA_Msk = 0xffff

	// AGTCMB: AGT Compare Match B Register
	// Position of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Pos = 0x0
	// Bit mask of AGTCMB field.
	AGT0_AGTCMB_AGTCMB_Msk = 0xffff

	// AGTCR: AGT Control Register
	// Position of TCMBF field.
	AGT0_AGTCR_TCMBF_Pos = 0x7
	// Bit mask of TCMBF field.
	AGT0_AGTCR_TCMBF_Msk = 0x80
	// Bit TCMBF.
	AGT0_AGTCR_TCMBF = 0x80
	// No Match
	AGT0_AGTCR_TCMBF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMBF_1 = 0x1
	// Position of TCMAF field.
	AGT0_AGTCR_TCMAF_Pos = 0x6
	// Bit mask of TCMAF field.
	AGT0_AGTCR_TCMAF_Msk = 0x40
	// Bit TCMAF.
	AGT0_AGTCR_TCMAF = 0x40
	// No Match
	AGT0_AGTCR_TCMAF_0 = 0x0
	// Match
	AGT0_AGTCR_TCMAF_1 = 0x1
	// Position of TUNDF field.
	AGT0_AGTCR_TUNDF_Pos = 0x5
	// Bit mask of TUNDF field.
	AGT0_AGTCR_TUNDF_Msk = 0x20
	// Bit TUNDF.
	AGT0_AGTCR_TUNDF = 0x20
	// No underflow
	AGT0_AGTCR_TUNDF_0 = 0x0
	// Underflow
	AGT0_AGTCR_TUNDF_1 = 0x1
	// Position of TEDGF field.
	AGT0_AGTCR_TEDGF_Pos = 0x4
	// Bit mask of TEDGF field.
	AGT0_AGTCR_TEDGF_Msk = 0x10
	// Bit TEDGF.
	AGT0_AGTCR_TEDGF = 0x10
	// No active edge received
	AGT0_AGTCR_TEDGF_0 = 0x0
	// Active edge received
	AGT0_AGTCR_TEDGF_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTCR_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTCR_Reserved = 0x8
	// Position of TSTOP field.
	AGT0_AGTCR_TSTOP_Pos = 0x2
	// Bit mask of TSTOP field.
	AGT0_AGTCR_TSTOP_Msk = 0x4
	// Bit TSTOP.
	AGT0_AGTCR_TSTOP = 0x4
	// no effect
	AGT0_AGTCR_TSTOP_0 = 0x0
	// The count is forcibly stopped.
	AGT0_AGTCR_TSTOP_1 = 0x1
	// Position of TCSTF field.
	AGT0_AGTCR_TCSTF_Pos = 0x1
	// Bit mask of TCSTF field.
	AGT0_AGTCR_TCSTF_Msk = 0x2
	// Bit TCSTF.
	AGT0_AGTCR_TCSTF = 0x2
	// Count stops
	AGT0_AGTCR_TCSTF_0 = 0x0
	// Count starts
	AGT0_AGTCR_TCSTF_1 = 0x1
	// Position of TSTART field.
	AGT0_AGTCR_TSTART_Pos = 0x0
	// Bit mask of TSTART field.
	AGT0_AGTCR_TSTART_Msk = 0x1
	// Bit TSTART.
	AGT0_AGTCR_TSTART = 0x1
	// Count stops
	AGT0_AGTCR_TSTART_0 = 0x0
	// Count starts
	AGT0_AGTCR_TSTART_1 = 0x1

	// AGTMR1: AGT Mode Register 1
	// Position of Reserved field.
	AGT0_AGTMR1_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	AGT0_AGTMR1_Reserved_Msk = 0x80
	// Bit Reserved.
	AGT0_AGTMR1_Reserved = 0x80
	// Position of TCK field.
	AGT0_AGTMR1_TCK_Pos = 0x4
	// Bit mask of TCK field.
	AGT0_AGTMR1_TCK_Msk = 0x70
	// PCLKB
	AGT0_AGTMR1_TCK_000 = 0x0
	// PCLKB/8
	AGT0_AGTMR1_TCK_001 = 0x1
	// PCLKB/2
	AGT0_AGTMR1_TCK_011 = 0x3
	// Divided clock LOCO specified by bits CKS[2:0] in the AGTMR2 register
	AGT0_AGTMR1_TCK_100 = 0x4
	// Underflow event signal from AGT0
	AGT0_AGTMR1_TCK_101 = 0x5
	// Divided clock fSUB specified by bits CKS[2:0] in the AGTMR2 register
	AGT0_AGTMR1_TCK_110 = 0x6
	// Position of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Pos = 0x3
	// Bit mask of TEDGPL field.
	AGT0_AGTMR1_TEDGPL_Msk = 0x8
	// Bit TEDGPL.
	AGT0_AGTMR1_TEDGPL = 0x8
	// Single-edge
	AGT0_AGTMR1_TEDGPL_0 = 0x0
	// Both-edge
	AGT0_AGTMR1_TEDGPL_1 = 0x1
	// Position of TMOD field.
	AGT0_AGTMR1_TMOD_Pos = 0x0
	// Bit mask of TMOD field.
	AGT0_AGTMR1_TMOD_Msk = 0x7
	// Timer mode
	AGT0_AGTMR1_TMOD_000 = 0x0
	// Pulse output mode
	AGT0_AGTMR1_TMOD_001 = 0x1
	// Event counter mode
	AGT0_AGTMR1_TMOD_010 = 0x2
	// Pulse width measurement mode
	AGT0_AGTMR1_TMOD_011 = 0x3
	// Pulse period measurement mode
	AGT0_AGTMR1_TMOD_100 = 0x4

	// AGTMR2: AGT Mode Register 2
	// Position of LPM field.
	AGT0_AGTMR2_LPM_Pos = 0x7
	// Bit mask of LPM field.
	AGT0_AGTMR2_LPM_Msk = 0x80
	// Bit LPM.
	AGT0_AGTMR2_LPM = 0x80
	// Normal mode
	AGT0_AGTMR2_LPM_0 = 0x0
	// Low Power mode
	AGT0_AGTMR2_LPM_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTMR2_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTMR2_Reserved_Msk = 0x78
	// Position of CKS field.
	AGT0_AGTMR2_CKS_Pos = 0x0
	// Bit mask of CKS field.
	AGT0_AGTMR2_CKS_Msk = 0x7
	// 1/1
	AGT0_AGTMR2_CKS_000 = 0x0
	// 1/2
	AGT0_AGTMR2_CKS_001 = 0x1
	// 1/4
	AGT0_AGTMR2_CKS_010 = 0x2
	// 1/8
	AGT0_AGTMR2_CKS_011 = 0x3
	// 1/16
	AGT0_AGTMR2_CKS_100 = 0x4
	// 1/32
	AGT0_AGTMR2_CKS_101 = 0x5
	// 1/64
	AGT0_AGTMR2_CKS_110 = 0x6
	// 1/128
	AGT0_AGTMR2_CKS_111 = 0x7

	// AGTIOC: AGT I/O Control Register
	// Position of TIOGT field.
	AGT0_AGTIOC_TIOGT_Pos = 0x6
	// Bit mask of TIOGT field.
	AGT0_AGTIOC_TIOGT_Msk = 0xc0
	// Event is always counted
	AGT0_AGTIOC_TIOGT_00 = 0x0
	// Event is counted during polarity period specified for AGTEE
	AGT0_AGTIOC_TIOGT_01 = 0x1
	// Position of TIPF field.
	AGT0_AGTIOC_TIPF_Pos = 0x4
	// Bit mask of TIPF field.
	AGT0_AGTIOC_TIPF_Msk = 0x30
	// No filter
	AGT0_AGTIOC_TIPF_00 = 0x0
	// Filter sampled at PCLKB
	AGT0_AGTIOC_TIPF_01 = 0x1
	// Filter sampled at PCLKB/8
	AGT0_AGTIOC_TIPF_10 = 0x2
	// Filter sampled at PCLKB/32
	AGT0_AGTIOC_TIPF_11 = 0x3
	// Position of Reserved field.
	AGT0_AGTIOC_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTIOC_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTIOC_Reserved = 0x8
	// Position of TOE field.
	AGT0_AGTIOC_TOE_Pos = 0x2
	// Bit mask of TOE field.
	AGT0_AGTIOC_TOE_Msk = 0x4
	// Bit TOE.
	AGT0_AGTIOC_TOE = 0x4
	// AGTO output disabled (port)
	AGT0_AGTIOC_TOE_0 = 0x0
	// AGTO output enabled
	AGT0_AGTIOC_TOE_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTIOC_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	AGT0_AGTIOC_Reserved_Msk = 0x2
	// Bit Reserved.
	AGT0_AGTIOC_Reserved = 0x2
	// Position of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Pos = 0x0
	// Bit mask of TEDGSEL field.
	AGT0_AGTIOC_TEDGSEL_Msk = 0x1
	// Bit TEDGSEL.
	AGT0_AGTIOC_TEDGSEL = 0x1

	// AGTISR: AGT Event Pin Select Register
	// Position of Reserved field.
	AGT0_AGTISR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTISR_Reserved_Msk = 0xf8
	// Position of EEPS field.
	AGT0_AGTISR_EEPS_Pos = 0x2
	// Bit mask of EEPS field.
	AGT0_AGTISR_EEPS_Msk = 0x4
	// Bit EEPS.
	AGT0_AGTISR_EEPS = 0x4
	// An event is counted during the low-level period
	AGT0_AGTISR_EEPS_0 = 0x0
	// An event is counted during the high-level period
	AGT0_AGTISR_EEPS_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTISR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	AGT0_AGTISR_Reserved_Msk = 0x3

	// AGTCMSR: AGT Compare Match Function Select Register
	// Position of Reserved field.
	AGT0_AGTCMSR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	AGT0_AGTCMSR_Reserved_Msk = 0x80
	// Bit Reserved.
	AGT0_AGTCMSR_Reserved = 0x80
	// Position of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Pos = 0x6
	// Bit mask of TOPOLB field.
	AGT0_AGTCMSR_TOPOLB_Msk = 0x40
	// Bit TOPOLB.
	AGT0_AGTCMSR_TOPOLB = 0x40
	// AGTOB Output is started at low
	AGT0_AGTCMSR_TOPOLB_0 = 0x0
	// AGTOB Output is started at high
	AGT0_AGTCMSR_TOPOLB_1 = 0x1
	// Position of TOEB field.
	AGT0_AGTCMSR_TOEB_Pos = 0x5
	// Bit mask of TOEB field.
	AGT0_AGTCMSR_TOEB_Msk = 0x20
	// Bit TOEB.
	AGT0_AGTCMSR_TOEB = 0x20
	// AGTOB output disabled (port)
	AGT0_AGTCMSR_TOEB_0 = 0x0
	// AGTOB output enabled
	AGT0_AGTCMSR_TOEB_1 = 0x1
	// Position of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Pos = 0x4
	// Bit mask of TCMEB field.
	AGT0_AGTCMSR_TCMEB_Msk = 0x10
	// Bit TCMEB.
	AGT0_AGTCMSR_TCMEB = 0x10
	// Disable compare match B register
	AGT0_AGTCMSR_TCMEB_0 = 0x0
	// Enable compare match B register
	AGT0_AGTCMSR_TCMEB_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTCMSR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	AGT0_AGTCMSR_Reserved_Msk = 0x8
	// Bit Reserved.
	AGT0_AGTCMSR_Reserved = 0x8
	// Position of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Pos = 0x2
	// Bit mask of TOPOLA field.
	AGT0_AGTCMSR_TOPOLA_Msk = 0x4
	// Bit TOPOLA.
	AGT0_AGTCMSR_TOPOLA = 0x4
	// AGTOA Output is started at low
	AGT0_AGTCMSR_TOPOLA_0 = 0x0
	// AGTOA Output is started at high
	AGT0_AGTCMSR_TOPOLA_1 = 0x1
	// Position of TOEA field.
	AGT0_AGTCMSR_TOEA_Pos = 0x1
	// Bit mask of TOEA field.
	AGT0_AGTCMSR_TOEA_Msk = 0x2
	// Bit TOEA.
	AGT0_AGTCMSR_TOEA = 0x2
	// AGTOA output disabled (port)
	AGT0_AGTCMSR_TOEA_0 = 0x0
	// AGTOA output enabled
	AGT0_AGTCMSR_TOEA_1 = 0x1
	// Position of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Pos = 0x0
	// Bit mask of TCMEA field.
	AGT0_AGTCMSR_TCMEA_Msk = 0x1
	// Bit TCMEA.
	AGT0_AGTCMSR_TCMEA = 0x1
	// Disable compare match A register
	AGT0_AGTCMSR_TCMEA_0 = 0x0
	// Enable compare match A register
	AGT0_AGTCMSR_TCMEA_1 = 0x1

	// AGTIOSEL: AGT Pin Select Register
	// Position of Reserved field.
	AGT0_AGTIOSEL_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	AGT0_AGTIOSEL_Reserved_Msk = 0xe0
	// Position of TIES field.
	AGT0_AGTIOSEL_TIES_Pos = 0x4
	// Bit mask of TIES field.
	AGT0_AGTIOSEL_TIES_Msk = 0x10
	// Bit TIES.
	AGT0_AGTIOSEL_TIES = 0x10
	// external event input disable during software standby mode
	AGT0_AGTIOSEL_TIES_0 = 0x0
	// external event input enable during software standby mode
	AGT0_AGTIOSEL_TIES_1 = 0x1
	// Position of Reserved field.
	AGT0_AGTIOSEL_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	AGT0_AGTIOSEL_Reserved_Msk = 0xf
)

// Constants for GPT320: General PWM Timer 0 (32-bit)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of Reserved field.
	GPT320_GTWP_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT320_GTWP_Reserved_Msk = 0xffff0000
	// Position of PRKEY field.
	GPT320_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT320_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT320_GTWP_PRKEY_0xA5 = 0xa5
	// Position of Reserved field.
	GPT320_GTWP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTWP_Reserved_Msk = 0xfe
	// Position of WP field.
	GPT320_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT320_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT320_GTWP_WP = 0x1
	// Write to the register is enabled
	GPT320_GTWP_WP_0 = 0x0
	// Write to the register is disabled
	GPT320_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of Reserved field.
	GPT320_GTSTR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT320_GTSTR_Reserved_Msk = 0xffffff80
	// Position of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT320_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT320_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT6_0 = 0x0
	// GPT166.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT320_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT320_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT5_0 = 0x0
	// GPT165.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT320_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT320_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT4_0 = 0x0
	// GPT164.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT320_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT320_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT3_0 = 0x0
	// GPT163.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT320_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT320_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT2_0 = 0x0
	// GPT162.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT320_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT320_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT1_0 = 0x0
	// GPT161.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT320_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT320_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT320_GTSTR_CSTRT0_0 = 0x0
	// GPT320.GTCNT counter starts (write) / Counter running (read)
	GPT320_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of Reserved field.
	GPT320_GTSTP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT320_GTSTP_Reserved_Msk = 0xffffff80
	// Position of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT320_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT320_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP6_0 = 0x0
	// GPT166.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT320_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT320_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP5_0 = 0x0
	// GPT165.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT320_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT320_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP4_0 = 0x0
	// GPT164.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT320_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT320_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP3_0 = 0x0
	// GPT163.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT320_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT320_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP2_0 = 0x0
	// GPT162.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT320_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT320_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP1_0 = 0x0
	// GPT161.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT320_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT320_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT320_GTSTP_CSTOP0_0 = 0x0
	// GPT320.GTCNT counter stops (write) / Counter stop (read)
	GPT320_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of Reserved field.
	GPT320_GTCLR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT320_GTCLR_Reserved_Msk = 0xffffff80
	// Position of CCLR6 field.
	GPT320_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT320_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT320_GTCLR_CCLR6 = 0x40
	// No effect
	GPT320_GTCLR_CCLR6_0 = 0x0
	// GPT166.GTCNT counter clears
	GPT320_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT320_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT320_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT320_GTCLR_CCLR5 = 0x20
	// No effect
	GPT320_GTCLR_CCLR5_0 = 0x0
	// GPT165.GTCNT counter clears
	GPT320_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT320_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT320_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT320_GTCLR_CCLR4 = 0x10
	// No effect
	GPT320_GTCLR_CCLR4_0 = 0x0
	// GPT164.GTCNT counter clears
	GPT320_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT320_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT320_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT320_GTCLR_CCLR3 = 0x8
	// No effect
	GPT320_GTCLR_CCLR3_0 = 0x0
	// GPT163.GTCNT counter clears
	GPT320_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT320_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT320_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT320_GTCLR_CCLR2 = 0x4
	// No effect
	GPT320_GTCLR_CCLR2_0 = 0x0
	// GPT162.GTCNT counter clears
	GPT320_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT320_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT320_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT320_GTCLR_CCLR1 = 0x2
	// No effect
	GPT320_GTCLR_CCLR1_0 = 0x0
	// GPT161.GTCNT counter clears
	GPT320_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT320_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT320_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT320_GTCLR_CCLR0 = 0x1
	// No effect
	GPT320_GTCLR_CCLR0_0 = 0x0
	// GPT320.GTCNT counter clears
	GPT320_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT320_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT320_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT320_GTSSR_CSTRT = 0x80000000
	// Counter start is disable by the GTSTR register
	GPT320_GTSSR_CSTRT_0 = 0x0
	// Counter start is enable by the GTSTR register
	GPT320_GTSSR_CSTRT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTSSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT320_GTSSR_Reserved_Msk = 0x7ff00000
	// Position of SSELCD field.
	GPT320_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT320_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT320_GTSSR_SSELCD = 0x80000
	// Counter start is disable at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_0 = 0x0
	// Counter start is enable at the ELC_GPTD input
	GPT320_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT320_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT320_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT320_GTSSR_SSELCC = 0x40000
	// Counter start is disable at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_0 = 0x0
	// Counter start is enable at the ELC_GPTC input
	GPT320_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT320_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT320_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT320_GTSSR_SSELCB = 0x20000
	// Counter start is disable at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_0 = 0x0
	// Counter start is enable at the ELC_GPTB input
	GPT320_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT320_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT320_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT320_GTSSR_SSELCA = 0x10000
	// Counter start is disable at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_0 = 0x0
	// Counter start is enable at the ELC_GPTA input
	GPT320_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT320_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT320_GTSSR_SSCBFAH = 0x8000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBFAH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT320_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT320_GTSSR_SSCBFAL = 0x4000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBFAL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT320_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT320_GTSSR_SSCBRAH = 0x2000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBRAH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT320_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT320_GTSSR_SSCBRAL = 0x1000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBRAL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT320_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT320_GTSSR_SSCAFBH = 0x800
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCAFBH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT320_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT320_GTSSR_SSCAFBL = 0x400
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCAFBL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT320_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT320_GTSSR_SSCARBH = 0x200
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCARBH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT320_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT320_GTSSR_SSCARBL = 0x100
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCARBL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTSSR_SSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTSSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTSSR_Reserved_Msk = 0xf0
	// Position of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT320_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT320_GTSSR_SSGTRGBF = 0x8
	// Counter start is disable at the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT320_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT320_GTSSR_SSGTRGBR = 0x4
	// Counter start is disable at the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGB input
	GPT320_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT320_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT320_GTSSR_SSGTRGAF = 0x2
	// Counter start is disable at the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT320_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT320_GTSSR_SSGTRGAR = 0x1
	// Counter start is disable at the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGA input
	GPT320_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT320_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT320_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT320_GTPSR_CSTOP = 0x80000000
	// Counter stop is disable by the GTSTP register
	GPT320_GTPSR_CSTOP_0 = 0x0
	// Counter stop is enable by the GTSTP register
	GPT320_GTPSR_CSTOP_1 = 0x1
	// Position of Reserved field.
	GPT320_GTPSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT320_GTPSR_Reserved_Msk = 0x7ff00000
	// Position of PSELCD field.
	GPT320_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT320_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT320_GTPSR_PSELCD = 0x80000
	// Counter stop is disable at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_0 = 0x0
	// Counter stop is enable at the ELC_GPTD input
	GPT320_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT320_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT320_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT320_GTPSR_PSELCC = 0x40000
	// Counter stop is disable at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_0 = 0x0
	// Counter stop is enable at the ELC_GPTC input
	GPT320_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT320_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT320_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT320_GTPSR_PSELCB = 0x20000
	// Counter stop is disable at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_0 = 0x0
	// Counter stop is enable at the ELC_GPTB input
	GPT320_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT320_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT320_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT320_GTPSR_PSELCA = 0x10000
	// Counter stop is disable at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_0 = 0x0
	// Counter stop is enable at the ELC_GPTA input
	GPT320_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT320_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT320_GTPSR_PSCBFAH = 0x8000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT320_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT320_GTPSR_PSCBFAL = 0x4000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT320_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT320_GTPSR_PSCBRAH = 0x2000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT320_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT320_GTPSR_PSCBRAL = 0x1000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT320_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT320_GTPSR_PSCAFBH = 0x800
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT320_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT320_GTPSR_PSCAFBL = 0x400
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT320_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT320_GTPSR_PSCARBH = 0x200
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCARBH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT320_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT320_GTPSR_PSCARBL = 0x100
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCARBL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTPSR_PSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTPSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTPSR_Reserved_Msk = 0xf0
	// Position of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT320_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT320_GTPSR_PSGTRGBF = 0x8
	// Counter stop is disable at the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT320_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT320_GTPSR_PSGTRGBR = 0x4
	// Counter stop is disable at the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGB input
	GPT320_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT320_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT320_GTPSR_PSGTRGAF = 0x2
	// Counter stop is disable at the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT320_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT320_GTPSR_PSGTRGAR = 0x1
	// Counter stop is disable at the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGA input
	GPT320_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT320_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT320_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT320_GTCSR_CCLR = 0x80000000
	// Counter clear is disable by the GTCLR register
	GPT320_GTCSR_CCLR_0 = 0x0
	// Counter clear is enable by the GTCLR register
	GPT320_GTCSR_CCLR_1 = 0x1
	// Position of Reserved field.
	GPT320_GTCSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT320_GTCSR_Reserved_Msk = 0x7ff00000
	// Position of CSELCD field.
	GPT320_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT320_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT320_GTCSR_CSELCD = 0x80000
	// Counter clear is disable at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_0 = 0x0
	// Counter clear is enable at the ELC_GPTD input
	GPT320_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT320_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT320_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT320_GTCSR_CSELCC = 0x40000
	// Counter clear is disable at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_0 = 0x0
	// Counter clear is enable at the ELC_GPTC input
	GPT320_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT320_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT320_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT320_GTCSR_CSELCB = 0x20000
	// Counter clear is disable at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_0 = 0x0
	// Counter clear is enable at the ELC_GPTB input
	GPT320_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT320_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT320_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT320_GTCSR_CSELCA = 0x10000
	// Counter clear is disable at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_0 = 0x0
	// Counter clear is enable at the ELC_GPTA input
	GPT320_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT320_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT320_GTCSR_CSCBFAH = 0x8000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT320_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT320_GTCSR_CSCBFAL = 0x4000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT320_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT320_GTCSR_CSCBRAH = 0x2000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT320_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT320_GTCSR_CSCBRAL = 0x1000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT320_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT320_GTCSR_CSCAFBH = 0x800
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT320_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT320_GTCSR_CSCAFBL = 0x400
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT320_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT320_GTCSR_CSCARBH = 0x200
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCARBH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT320_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT320_GTCSR_CSCARBL = 0x100
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCARBL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTCSR_CSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT320_GTCSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT320_GTCSR_Reserved_Msk = 0xf0
	// Position of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT320_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT320_GTCSR_CSGTRGBF = 0x8
	// Counter clear is disable at the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT320_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT320_GTCSR_CSGTRGBR = 0x4
	// Counter clear is disable at the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGB input
	GPT320_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT320_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT320_GTCSR_CSGTRGAF = 0x2
	// Counter clear is disable at the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT320_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT320_GTCSR_CSGTRGAR = 0x1
	// Counter clear is disable at the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGA input
	GPT320_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCD field.
	GPT320_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT320_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT320_GTUPSR_USELCD = 0x80000
	// Counter count up is disable at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_0 = 0x0
	// Counter count up is enable at the ELC_GPTD input
	GPT320_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT320_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT320_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT320_GTUPSR_USELCC = 0x40000
	// Counter count up is disable at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_0 = 0x0
	// Counter count up is enable at the ELC_GPTC input
	GPT320_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT320_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT320_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT320_GTUPSR_USELCB = 0x20000
	// Counter count up is disable at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_0 = 0x0
	// Counter count up is enable at the ELC_GPTB input
	GPT320_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT320_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT320_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT320_GTUPSR_USELCA = 0x10000
	// Counter count up is disable at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_0 = 0x0
	// Counter count up is enable at the ELC_GPTA input
	GPT320_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT320_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT320_GTUPSR_USCBFAH = 0x8000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT320_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT320_GTUPSR_USCBFAL = 0x4000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT320_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT320_GTUPSR_USCBRAH = 0x2000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT320_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT320_GTUPSR_USCBRAL = 0x1000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT320_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT320_GTUPSR_USCAFBH = 0x800
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT320_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT320_GTUPSR_USCAFBL = 0x400
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT320_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT320_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT320_GTUPSR_USCARBH = 0x200
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCARBH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT320_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT320_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT320_GTUPSR_USCARBL = 0x100
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCARBL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT320_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT320_GTUPSR_USGTRGBF = 0x8
	// Counter count up is disable at the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT320_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT320_GTUPSR_USGTRGBR = 0x4
	// Counter count up is disable at the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGB input
	GPT320_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT320_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT320_GTUPSR_USGTRGAF = 0x2
	// Counter count up is disable at the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT320_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT320_GTUPSR_USGTRGAR = 0x1
	// Counter count up is disable at the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGA input
	GPT320_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCD field.
	GPT320_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT320_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT320_GTDNSR_DSELCD = 0x80000
	// Counter count down is disable at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_0 = 0x0
	// Counter count down is enable at the ELC_GPTD input
	GPT320_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT320_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT320_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT320_GTDNSR_DSELCC = 0x40000
	// Counter count down is disable at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_0 = 0x0
	// Counter count down is enable at the ELC_GPTC input
	GPT320_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT320_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT320_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT320_GTDNSR_DSELCB = 0x20000
	// Counter count down is disable at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_0 = 0x0
	// Counter count down is enable at the ELC_GPTB input
	GPT320_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT320_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT320_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT320_GTDNSR_DSELCA = 0x10000
	// Counter count down is disable at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_0 = 0x0
	// Counter count down is enable at the ELC_GPTA input
	GPT320_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT320_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT320_GTDNSR_DSCBFAH = 0x8000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT320_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT320_GTDNSR_DSCBFAL = 0x4000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT320_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT320_GTDNSR_DSCBRAH = 0x2000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT320_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT320_GTDNSR_DSCBRAL = 0x1000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT320_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT320_GTDNSR_DSCAFBH = 0x800
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT320_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT320_GTDNSR_DSCAFBL = 0x400
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT320_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT320_GTDNSR_DSCARBH = 0x200
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT320_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT320_GTDNSR_DSCARBL = 0x100
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT320_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT320_GTDNSR_DSGTRGBF = 0x8
	// Counter count down is disable at the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT320_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT320_GTDNSR_DSGTRGBR = 0x4
	// Counter count down is disable at the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGB input
	GPT320_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT320_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT320_GTDNSR_DSGTRGAF = 0x2
	// Counter count down is disable at the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT320_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT320_GTDNSR_DSGTRGAR = 0x1
	// Counter count down is disable at the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGA input
	GPT320_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCD field.
	GPT320_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT320_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT320_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture is disable at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTD input
	GPT320_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT320_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT320_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT320_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture is disable at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTC input
	GPT320_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT320_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT320_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT320_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture is disable at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTB input
	GPT320_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT320_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT320_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT320_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture is disable at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTA input
	GPT320_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT320_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT320_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT320_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT320_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT320_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT320_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT320_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT320_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT320_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT320_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT320_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT320_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT320_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT320_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT320_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT320_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT320_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT320_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture is disable at the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT320_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT320_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture is disable at the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGB input
	GPT320_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT320_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT320_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture is disable at the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT320_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT320_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture is disable at the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGA input
	GPT320_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCD field.
	GPT320_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT320_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT320_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture is disable at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTD input
	GPT320_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT320_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT320_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT320_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture is disable at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTC input
	GPT320_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT320_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT320_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT320_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture is disable at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTB input
	GPT320_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT320_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT320_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT320_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture is disable at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTA input
	GPT320_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT320_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT320_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT320_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT320_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT320_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT320_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT320_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT320_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT320_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT320_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT320_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT320_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT320_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT320_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT320_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT320_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT320_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT320_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT320_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT320_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT320_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT320_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture is disable at the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT320_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT320_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture is disable at the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGB input
	GPT320_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT320_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT320_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture is disable at the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT320_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT320_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture is disable at the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGA input
	GPT320_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT320_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT320_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT320_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT320_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT320_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT320_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT320_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT320_GTCR_TPCS_101 = 0x5
	// Position of Reserved field.
	GPT320_GTCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	GPT320_GTCR_Reserved_Msk = 0xf80000
	// Position of MD field.
	GPT320_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT320_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT320_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT320_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT320_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT320_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	GPT320_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT320_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	GPT320_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT320_GTCR_MD_111 = 0x7
	// Position of Reserved field.
	GPT320_GTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTCR_Reserved_Msk = 0xfffe
	// Position of CST field.
	GPT320_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT320_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT320_GTCR_CST = 0x1
	// Count operation is stopped
	GPT320_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT320_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT320_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT320_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT320_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT320_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT320_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT320_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT320_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT320_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0 percent
	GPT320_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100 percent
	GPT320_GTUDDTYC_OBDTY_11 = 0x3
	// Position of Reserved field.
	GPT320_GTUDDTYC_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT320_GTUDDTYC_Reserved_Msk = 0xf00000
	// Position of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT320_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT320_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT320_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT320_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT320_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT320_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT320_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT320_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT320_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT320_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT320_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT320_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT320_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT320_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT320_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT320_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT320_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT320_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT320_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT320_GTUDDTYC_UD = 0x1
	// GTCNT counts down.
	GPT320_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up.
	GPT320_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT320_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT320_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT320_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT320_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT320_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT320_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT320_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT320_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT320_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCB pin is disabled.
	GPT320_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCB pin is enabled.
	GPT320_GTIOR_NFBEN_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x18000000
	// Position of OBDF field.
	GPT320_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT320_GTIOR_OBDF_Msk = 0x6000000
	// Output disable is prohibited.
	GPT320_GTIOR_OBDF_00 = 0x0
	// GTIOCB pin is set to Hi-Z when output disable is performed.
	GPT320_GTIOR_OBDF_01 = 0x1
	// GTIOCB pin is set to 0 when output disable is performed.
	GPT320_GTIOR_OBDF_10 = 0x2
	// GTIOCB pin is set to 1 when output disable is performed.
	GPT320_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT320_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT320_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT320_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT320_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT320_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT320_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT320_GTIOR_OBHLD = 0x800000
	// The GTIOCB pin output level at start/stop of counting depends on the register setting.
	GPT320_GTIOR_OBHLD_0 = 0x0
	// The GTIOCB pin output level is retained at start/stop of counting.
	GPT320_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT320_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT320_GTIOR_OBDFLT = 0x400000
	// The GTIOCB pin outputs low when counting is stopped.
	GPT320_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCB pin outputs high when counting is stopped.
	GPT320_GTIOR_OBDFLT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x200000
	// Bit Reserved.
	GPT320_GTIOR_Reserved = 0x200000
	// Position of GTIOB field.
	GPT320_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT320_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT320_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT320_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT320_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT320_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT320_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT320_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT320_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT320_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT320_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT320_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCA pin is disabled.
	GPT320_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCA pin is enabled.
	GPT320_GTIOR_NFAEN_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x1800
	// Position of OADF field.
	GPT320_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT320_GTIOR_OADF_Msk = 0x600
	// Output disable is prohibited.
	GPT320_GTIOR_OADF_00 = 0x0
	// GTIOCA pin is set to Hi-Z when output disable is performed.
	GPT320_GTIOR_OADF_01 = 0x1
	// GTIOCA pin is set to 0 when output disable is performed.
	GPT320_GTIOR_OADF_10 = 0x2
	// GTIOCA pin is set to 1 when output disable is performed.
	GPT320_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT320_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT320_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT320_GTIOR_OAE = 0x100
	// Output is disabled
	GPT320_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT320_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT320_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT320_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT320_GTIOR_OAHLD = 0x80
	// The GTIOCA pin output level at start/stop of counting depends on the register setting.
	GPT320_GTIOR_OAHLD_0 = 0x0
	// The GTIOCA pin output level is retained at start/stop of counting.
	GPT320_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT320_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT320_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT320_GTIOR_OADFLT = 0x40
	// The GTIOCA pin outputs low when counting is stopped.
	GPT320_GTIOR_OADFLT_0 = 0x0
	// The GTIOCA pin outputs high when counting is stopped.
	GPT320_GTIOR_OADFLT_1 = 0x1
	// Position of Reserved field.
	GPT320_GTIOR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT320_GTIOR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT320_GTIOR_Reserved = 0x20
	// Position of GTIOA field.
	GPT320_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT320_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT320_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT320_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT320_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT320_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request is disabled.
	GPT320_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request is enabled.
	GPT320_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT320_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT320_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT320_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request is disabled.
	GPT320_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request is enabled.
	GPT320_GTINTAD_GRPABH_1 = 0x1
	// Position of Reserved field.
	GPT320_GTINTAD_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	GPT320_GTINTAD_Reserved_Msk = 0x1c000000
	// Position of GRP field.
	GPT320_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT320_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request
	GPT320_GTINTAD_GRP_00 = 0x0
	// Group B output disable request
	GPT320_GTINTAD_GRP_01 = 0x1
	// Position of Reserved field.
	GPT320_GTINTAD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	GPT320_GTINTAD_Reserved_Msk = 0xffffff

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT320_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT320_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT320_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT320_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT320_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT320_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT320_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT320_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT320_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT320_GTST_OABHF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0x1e000000
	// Position of ODF field.
	GPT320_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT320_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT320_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT320_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT320_GTST_ODF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0xff0000
	// Position of GTCF field.
	GPT320_GTST_GTCF_Pos = 0xf
	// Bit mask of GTCF field.
	GPT320_GTST_GTCF_Msk = 0x8000
	// Bit GTCF.
	GPT320_GTST_GTCF = 0x8000
	// The GTCNT counter counts downward.
	GPT320_GTST_GTCF_0 = 0x0
	// The GTCNT counter counts upward.
	GPT320_GTST_GTCF_1 = 0x1
	// Position of Reserved field.
	GPT320_GTST_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT320_GTST_Reserved_Msk = 0x7f00
	// Position of TCFPU field.
	GPT320_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT320_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT320_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT320_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT320_GTST_TCFPU_1 = 0x1
	// Position of TCPFO field.
	GPT320_GTST_TCPFO_Pos = 0x6
	// Bit mask of TCPFO field.
	GPT320_GTST_TCPFO_Msk = 0x40
	// Bit TCPFO.
	GPT320_GTST_TCPFO = 0x40
	// No overflow (crest) has occurred.
	GPT320_GTST_TCPFO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT320_GTST_TCPFO_1 = 0x1
	// Position of TCFF field.
	GPT320_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT320_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT320_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT320_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT320_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT320_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT320_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT320_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT320_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT320_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT320_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT320_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT320_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT320_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT320_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT320_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT320_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT320_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT320_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT320_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT320_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT320_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT320_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT320_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT320_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT320_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT320_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT320_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT320_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT320_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of CCRSWT field.
	GPT320_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT320_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT320_GTBER_CCRSWT = 0x400000
	// no effect
	GPT320_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT320_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT320_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT320_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT320_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT320_GTBER_PR_01 = 0x1
	// Position of CCRB field.
	GPT320_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT320_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT320_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT320_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT320_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT320_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT320_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT320_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT320_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT320_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT320_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT320_GTBER_CCRA_11 = 0x3
	// Position of BD field.
	GPT320_GTBER_BD_Pos = 0x0
	// Bit mask of BD field.
	GPT320_GTBER_BD_Msk = 0x3
	// Buffer operation is enabled
	GPT320_GTBER_BD_0 = 0x0
	// Buffer operation is disabled
	GPT320_GTBER_BD_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT320_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT320_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of GTCCRA field.
	GPT320_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT320_GTCCRA_GTCCRA_Msk = 0xffffffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of GTCCRB field.
	GPT320_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT320_GTCCRB_GTCCRB_Msk = 0xffffffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of GTCCRC field.
	GPT320_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT320_GTCCRC_GTCCRC_Msk = 0xffffffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of GTCCRE field.
	GPT320_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT320_GTCCRE_GTCCRE_Msk = 0xffffffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of GTCCRD field.
	GPT320_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT320_GTCCRD_GTCCRD_Msk = 0xffffffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of GTCCRF field.
	GPT320_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT320_GTCCRF_GTCCRF_Msk = 0xffffffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of GTPR field.
	GPT320_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT320_GTPR_GTPR_Msk = 0xffffffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of GTPBR field.
	GPT320_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT320_GTPBR_GTPBR_Msk = 0xffffffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of Reserved field.
	GPT320_GTDTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT320_GTDTCR_Reserved_Msk = 0xfffffffe
	// Position of TDE field.
	GPT320_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT320_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT320_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU and GTDVD.
	GPT320_GTDTCR_TDE_0 = 0x0
	// GTDVU and GTDVD are used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB.
	GPT320_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of GTDVU field.
	GPT320_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT320_GTDVU_GTDVU_Msk = 0xffffffff
)

// Constants for GPT_OPS: Output Phase Switching Controller
const (
	// OPSCR: Output Phase Switching Control Register
	// Position of NFCS field.
	GPT_OPS_OPSCR_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	GPT_OPS_OPSCR_NFCS_Msk = 0xc0000000
	// PCLK/1
	GPT_OPS_OPSCR_NFCS_00 = 0x0
	// PCLK/4
	GPT_OPS_OPSCR_NFCS_01 = 0x1
	// PCLK/16
	GPT_OPS_OPSCR_NFCS_10 = 0x2
	// PCLK/64
	GPT_OPS_OPSCR_NFCS_11 = 0x3
	// Position of NFEN field.
	GPT_OPS_OPSCR_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	GPT_OPS_OPSCR_NFEN_Msk = 0x20000000
	// Bit NFEN.
	GPT_OPS_OPSCR_NFEN = 0x20000000
	// Do not use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_0 = 0x0
	// Use a noise filter to the external input.
	GPT_OPS_OPSCR_NFEN_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x1c
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x10000000
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x10000000
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x8000000
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x8000000
	// Position of GODF field.
	GPT_OPS_OPSCR_GODF_Pos = 0x1a
	// Bit mask of GODF field.
	GPT_OPS_OPSCR_GODF_Msk = 0x4000000
	// Bit GODF.
	GPT_OPS_OPSCR_GODF = 0x4000000
	// This bit function is ignored.
	GPT_OPS_OPSCR_GODF_0 = 0x0
	// Group disable will clear OPSCR.EN Bit.
	GPT_OPS_OPSCR_GODF_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x2000000
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x2000000
	// Position of GRP field.
	GPT_OPS_OPSCR_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT_OPS_OPSCR_GRP_Msk = 0x1000000
	// Bit GRP.
	GPT_OPS_OPSCR_GRP = 0x1000000
	// Select Group A output disable source
	GPT_OPS_OPSCR_GRP_0 = 0x0
	// Select Group B output disable source.
	GPT_OPS_OPSCR_GRP_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x16
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0xc00000
	// Position of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Pos = 0x15
	// Bit mask of ALIGN field.
	GPT_OPS_OPSCR_ALIGN_Msk = 0x200000
	// Bit ALIGN.
	GPT_OPS_OPSCR_ALIGN = 0x200000
	// Input phase is aligned to PCLK.
	GPT_OPS_OPSCR_ALIGN_0 = 0x0
	// Input phase is aligned PWM.
	GPT_OPS_OPSCR_ALIGN_1 = 0x1
	// Position of RV field.
	GPT_OPS_OPSCR_RV_Pos = 0x14
	// Bit mask of RV field.
	GPT_OPS_OPSCR_RV_Msk = 0x100000
	// Bit RV.
	GPT_OPS_OPSCR_RV = 0x100000
	// U/V/W-Phase output
	GPT_OPS_OPSCR_RV_0 = 0x0
	// Output to reverse the V / W-phase
	GPT_OPS_OPSCR_RV_1 = 0x1
	// Position of INV field.
	GPT_OPS_OPSCR_INV_Pos = 0x13
	// Bit mask of INV field.
	GPT_OPS_OPSCR_INV_Msk = 0x80000
	// Bit INV.
	GPT_OPS_OPSCR_INV = 0x80000
	// Positive Logic (Active High)output
	GPT_OPS_OPSCR_INV_0 = 0x0
	// Negative Logic (Active Low)output
	GPT_OPS_OPSCR_INV_1 = 0x1
	// Position of N field.
	GPT_OPS_OPSCR_N_Pos = 0x12
	// Bit mask of N field.
	GPT_OPS_OPSCR_N_Msk = 0x40000
	// Bit N.
	GPT_OPS_OPSCR_N = 0x40000
	// Level signal output
	GPT_OPS_OPSCR_N_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_N_1 = 0x1
	// Position of P field.
	GPT_OPS_OPSCR_P_Pos = 0x11
	// Bit mask of P field.
	GPT_OPS_OPSCR_P_Msk = 0x20000
	// Bit P.
	GPT_OPS_OPSCR_P = 0x20000
	// Level signal output
	GPT_OPS_OPSCR_P_0 = 0x0
	// PWM signal output (PWM of GPT0)
	GPT_OPS_OPSCR_P_1 = 0x1
	// Position of FB field.
	GPT_OPS_OPSCR_FB_Pos = 0x10
	// Bit mask of FB field.
	GPT_OPS_OPSCR_FB_Msk = 0x10000
	// Bit FB.
	GPT_OPS_OPSCR_FB = 0x10000
	// Select the external input.
	GPT_OPS_OPSCR_FB_0 = 0x0
	// Select the soft setting(OPSCR.UF, VF, WF).
	GPT_OPS_OPSCR_FB_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0xfe00
	// Position of EN field.
	GPT_OPS_OPSCR_EN_Pos = 0x8
	// Bit mask of EN field.
	GPT_OPS_OPSCR_EN_Msk = 0x100
	// Bit EN.
	GPT_OPS_OPSCR_EN = 0x100
	// Not Output(Hi-Z external terminals).
	GPT_OPS_OPSCR_EN_0 = 0x0
	// Output
	GPT_OPS_OPSCR_EN_1 = 0x1
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x80
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x80
	// Position of W field.
	GPT_OPS_OPSCR_W_Pos = 0x6
	// Bit mask of W field.
	GPT_OPS_OPSCR_W_Msk = 0x40
	// Bit W.
	GPT_OPS_OPSCR_W = 0x40
	// Position of V field.
	GPT_OPS_OPSCR_V_Pos = 0x5
	// Bit mask of V field.
	GPT_OPS_OPSCR_V_Msk = 0x20
	// Bit V.
	GPT_OPS_OPSCR_V = 0x20
	// Position of U field.
	GPT_OPS_OPSCR_U_Pos = 0x4
	// Bit mask of U field.
	GPT_OPS_OPSCR_U_Msk = 0x10
	// Bit U.
	GPT_OPS_OPSCR_U = 0x10
	// Position of Reserved field.
	GPT_OPS_OPSCR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	GPT_OPS_OPSCR_Reserved_Msk = 0x8
	// Bit Reserved.
	GPT_OPS_OPSCR_Reserved = 0x8
	// Position of WF field.
	GPT_OPS_OPSCR_WF_Pos = 0x2
	// Bit mask of WF field.
	GPT_OPS_OPSCR_WF_Msk = 0x4
	// Bit WF.
	GPT_OPS_OPSCR_WF = 0x4
	// Position of VF field.
	GPT_OPS_OPSCR_VF_Pos = 0x1
	// Bit mask of VF field.
	GPT_OPS_OPSCR_VF_Msk = 0x2
	// Bit VF.
	GPT_OPS_OPSCR_VF = 0x2
	// Position of UF field.
	GPT_OPS_OPSCR_UF_Pos = 0x0
	// Bit mask of UF field.
	GPT_OPS_OPSCR_UF_Msk = 0x1
	// Bit UF.
	GPT_OPS_OPSCR_UF = 0x1
)

// Constants for GPT161: General PWM Timer 1 (16-bit)
const (
	// GTWP: General PWM Timer Write-Protection Register
	// Position of Reserved field.
	GPT161_GTWP_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTWP_Reserved_Msk = 0xffff0000
	// Position of PRKEY field.
	GPT161_GTWP_PRKEY_Pos = 0x8
	// Bit mask of PRKEY field.
	GPT161_GTWP_PRKEY_Msk = 0xff00
	// Written to these bits, the WP bits write is permitted.
	GPT161_GTWP_PRKEY_0xA5 = 0xa5
	// Position of Reserved field.
	GPT161_GTWP_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT161_GTWP_Reserved_Msk = 0xfe
	// Position of WP field.
	GPT161_GTWP_WP_Pos = 0x0
	// Bit mask of WP field.
	GPT161_GTWP_WP_Msk = 0x1
	// Bit WP.
	GPT161_GTWP_WP = 0x1
	// Write to the register is enabled
	GPT161_GTWP_WP_0 = 0x0
	// Write to the register is disabled
	GPT161_GTWP_WP_1 = 0x1

	// GTSTR: General PWM Timer Software Start Register
	// Position of Reserved field.
	GPT161_GTSTR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT161_GTSTR_Reserved_Msk = 0xffffff80
	// Position of CSTRT6 field.
	GPT161_GTSTR_CSTRT6_Pos = 0x6
	// Bit mask of CSTRT6 field.
	GPT161_GTSTR_CSTRT6_Msk = 0x40
	// Bit CSTRT6.
	GPT161_GTSTR_CSTRT6 = 0x40
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT6_0 = 0x0
	// GPT166.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT6_1 = 0x1
	// Position of CSTRT5 field.
	GPT161_GTSTR_CSTRT5_Pos = 0x5
	// Bit mask of CSTRT5 field.
	GPT161_GTSTR_CSTRT5_Msk = 0x20
	// Bit CSTRT5.
	GPT161_GTSTR_CSTRT5 = 0x20
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT5_0 = 0x0
	// GPT165.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT5_1 = 0x1
	// Position of CSTRT4 field.
	GPT161_GTSTR_CSTRT4_Pos = 0x4
	// Bit mask of CSTRT4 field.
	GPT161_GTSTR_CSTRT4_Msk = 0x10
	// Bit CSTRT4.
	GPT161_GTSTR_CSTRT4 = 0x10
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT4_0 = 0x0
	// GPT164.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT4_1 = 0x1
	// Position of CSTRT3 field.
	GPT161_GTSTR_CSTRT3_Pos = 0x3
	// Bit mask of CSTRT3 field.
	GPT161_GTSTR_CSTRT3_Msk = 0x8
	// Bit CSTRT3.
	GPT161_GTSTR_CSTRT3 = 0x8
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT3_0 = 0x0
	// GPT163.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT3_1 = 0x1
	// Position of CSTRT2 field.
	GPT161_GTSTR_CSTRT2_Pos = 0x2
	// Bit mask of CSTRT2 field.
	GPT161_GTSTR_CSTRT2_Msk = 0x4
	// Bit CSTRT2.
	GPT161_GTSTR_CSTRT2 = 0x4
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT2_0 = 0x0
	// GPT162.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT2_1 = 0x1
	// Position of CSTRT1 field.
	GPT161_GTSTR_CSTRT1_Pos = 0x1
	// Bit mask of CSTRT1 field.
	GPT161_GTSTR_CSTRT1_Msk = 0x2
	// Bit CSTRT1.
	GPT161_GTSTR_CSTRT1 = 0x2
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT1_0 = 0x0
	// GPT161.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT1_1 = 0x1
	// Position of CSTRT0 field.
	GPT161_GTSTR_CSTRT0_Pos = 0x0
	// Bit mask of CSTRT0 field.
	GPT161_GTSTR_CSTRT0_Msk = 0x1
	// Bit CSTRT0.
	GPT161_GTSTR_CSTRT0 = 0x1
	// No effect (write) / counter stop (read)
	GPT161_GTSTR_CSTRT0_0 = 0x0
	// GPT320.GTCNT counter starts (write) / Counter running (read)
	GPT161_GTSTR_CSTRT0_1 = 0x1

	// GTSTP: General PWM Timer Software Stop Register
	// Position of Reserved field.
	GPT161_GTSTP_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT161_GTSTP_Reserved_Msk = 0xffffff80
	// Position of CSTOP6 field.
	GPT161_GTSTP_CSTOP6_Pos = 0x6
	// Bit mask of CSTOP6 field.
	GPT161_GTSTP_CSTOP6_Msk = 0x40
	// Bit CSTOP6.
	GPT161_GTSTP_CSTOP6 = 0x40
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP6_0 = 0x0
	// GPT166.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP6_1 = 0x1
	// Position of CSTOP5 field.
	GPT161_GTSTP_CSTOP5_Pos = 0x5
	// Bit mask of CSTOP5 field.
	GPT161_GTSTP_CSTOP5_Msk = 0x20
	// Bit CSTOP5.
	GPT161_GTSTP_CSTOP5 = 0x20
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP5_0 = 0x0
	// GPT165.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP5_1 = 0x1
	// Position of CSTOP4 field.
	GPT161_GTSTP_CSTOP4_Pos = 0x4
	// Bit mask of CSTOP4 field.
	GPT161_GTSTP_CSTOP4_Msk = 0x10
	// Bit CSTOP4.
	GPT161_GTSTP_CSTOP4 = 0x10
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP4_0 = 0x0
	// GPT164.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP4_1 = 0x1
	// Position of CSTOP3 field.
	GPT161_GTSTP_CSTOP3_Pos = 0x3
	// Bit mask of CSTOP3 field.
	GPT161_GTSTP_CSTOP3_Msk = 0x8
	// Bit CSTOP3.
	GPT161_GTSTP_CSTOP3 = 0x8
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP3_0 = 0x0
	// GPT163.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP3_1 = 0x1
	// Position of CSTOP2 field.
	GPT161_GTSTP_CSTOP2_Pos = 0x2
	// Bit mask of CSTOP2 field.
	GPT161_GTSTP_CSTOP2_Msk = 0x4
	// Bit CSTOP2.
	GPT161_GTSTP_CSTOP2 = 0x4
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP2_0 = 0x0
	// GPT162.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP2_1 = 0x1
	// Position of CSTOP1 field.
	GPT161_GTSTP_CSTOP1_Pos = 0x1
	// Bit mask of CSTOP1 field.
	GPT161_GTSTP_CSTOP1_Msk = 0x2
	// Bit CSTOP1.
	GPT161_GTSTP_CSTOP1 = 0x2
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP1_0 = 0x0
	// GPT161.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP1_1 = 0x1
	// Position of CSTOP0 field.
	GPT161_GTSTP_CSTOP0_Pos = 0x0
	// Bit mask of CSTOP0 field.
	GPT161_GTSTP_CSTOP0_Msk = 0x1
	// Bit CSTOP0.
	GPT161_GTSTP_CSTOP0 = 0x1
	// No effect (write) / counter running (read)
	GPT161_GTSTP_CSTOP0_0 = 0x0
	// GPT320.GTCNT counter stops (write) / Counter stop (read)
	GPT161_GTSTP_CSTOP0_1 = 0x1

	// GTCLR: General PWM Timer Software Clear Register
	// Position of Reserved field.
	GPT161_GTCLR_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	GPT161_GTCLR_Reserved_Msk = 0xffffff80
	// Position of CCLR6 field.
	GPT161_GTCLR_CCLR6_Pos = 0x6
	// Bit mask of CCLR6 field.
	GPT161_GTCLR_CCLR6_Msk = 0x40
	// Bit CCLR6.
	GPT161_GTCLR_CCLR6 = 0x40
	// No effect
	GPT161_GTCLR_CCLR6_0 = 0x0
	// GPT166.GTCNT counter clears
	GPT161_GTCLR_CCLR6_1 = 0x1
	// Position of CCLR5 field.
	GPT161_GTCLR_CCLR5_Pos = 0x5
	// Bit mask of CCLR5 field.
	GPT161_GTCLR_CCLR5_Msk = 0x20
	// Bit CCLR5.
	GPT161_GTCLR_CCLR5 = 0x20
	// No effect
	GPT161_GTCLR_CCLR5_0 = 0x0
	// GPT165.GTCNT counter clears
	GPT161_GTCLR_CCLR5_1 = 0x1
	// Position of CCLR4 field.
	GPT161_GTCLR_CCLR4_Pos = 0x4
	// Bit mask of CCLR4 field.
	GPT161_GTCLR_CCLR4_Msk = 0x10
	// Bit CCLR4.
	GPT161_GTCLR_CCLR4 = 0x10
	// No effect
	GPT161_GTCLR_CCLR4_0 = 0x0
	// GPT164.GTCNT counter clears
	GPT161_GTCLR_CCLR4_1 = 0x1
	// Position of CCLR3 field.
	GPT161_GTCLR_CCLR3_Pos = 0x3
	// Bit mask of CCLR3 field.
	GPT161_GTCLR_CCLR3_Msk = 0x8
	// Bit CCLR3.
	GPT161_GTCLR_CCLR3 = 0x8
	// No effect
	GPT161_GTCLR_CCLR3_0 = 0x0
	// GPT163.GTCNT counter clears
	GPT161_GTCLR_CCLR3_1 = 0x1
	// Position of CCLR2 field.
	GPT161_GTCLR_CCLR2_Pos = 0x2
	// Bit mask of CCLR2 field.
	GPT161_GTCLR_CCLR2_Msk = 0x4
	// Bit CCLR2.
	GPT161_GTCLR_CCLR2 = 0x4
	// No effect
	GPT161_GTCLR_CCLR2_0 = 0x0
	// GPT162.GTCNT counter clears
	GPT161_GTCLR_CCLR2_1 = 0x1
	// Position of CCLR1 field.
	GPT161_GTCLR_CCLR1_Pos = 0x1
	// Bit mask of CCLR1 field.
	GPT161_GTCLR_CCLR1_Msk = 0x2
	// Bit CCLR1.
	GPT161_GTCLR_CCLR1 = 0x2
	// No effect
	GPT161_GTCLR_CCLR1_0 = 0x0
	// GPT161.GTCNT counter clears
	GPT161_GTCLR_CCLR1_1 = 0x1
	// Position of CCLR0 field.
	GPT161_GTCLR_CCLR0_Pos = 0x0
	// Bit mask of CCLR0 field.
	GPT161_GTCLR_CCLR0_Msk = 0x1
	// Bit CCLR0.
	GPT161_GTCLR_CCLR0 = 0x1
	// No effect
	GPT161_GTCLR_CCLR0_0 = 0x0
	// GPT320.GTCNT counter clears
	GPT161_GTCLR_CCLR0_1 = 0x1

	// GTSSR: General PWM Timer Start Source Select Register
	// Position of CSTRT field.
	GPT161_GTSSR_CSTRT_Pos = 0x1f
	// Bit mask of CSTRT field.
	GPT161_GTSSR_CSTRT_Msk = 0x80000000
	// Bit CSTRT.
	GPT161_GTSSR_CSTRT = 0x80000000
	// Counter start is disable by the GTSTR register
	GPT161_GTSSR_CSTRT_0 = 0x0
	// Counter start is enable by the GTSTR register
	GPT161_GTSSR_CSTRT_1 = 0x1
	// Position of Reserved field.
	GPT161_GTSSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT161_GTSSR_Reserved_Msk = 0x7ff00000
	// Position of SSELCD field.
	GPT161_GTSSR_SSELCD_Pos = 0x13
	// Bit mask of SSELCD field.
	GPT161_GTSSR_SSELCD_Msk = 0x80000
	// Bit SSELCD.
	GPT161_GTSSR_SSELCD = 0x80000
	// Counter start is disable at the ELC_GPTD input
	GPT161_GTSSR_SSELCD_0 = 0x0
	// Counter start is enable at the ELC_GPTD input
	GPT161_GTSSR_SSELCD_1 = 0x1
	// Position of SSELCC field.
	GPT161_GTSSR_SSELCC_Pos = 0x12
	// Bit mask of SSELCC field.
	GPT161_GTSSR_SSELCC_Msk = 0x40000
	// Bit SSELCC.
	GPT161_GTSSR_SSELCC = 0x40000
	// Counter start is disable at the ELC_GPTC input
	GPT161_GTSSR_SSELCC_0 = 0x0
	// Counter start is enable at the ELC_GPTC input
	GPT161_GTSSR_SSELCC_1 = 0x1
	// Position of SSELCB field.
	GPT161_GTSSR_SSELCB_Pos = 0x11
	// Bit mask of SSELCB field.
	GPT161_GTSSR_SSELCB_Msk = 0x20000
	// Bit SSELCB.
	GPT161_GTSSR_SSELCB = 0x20000
	// Counter start is disable at the ELC_GPTB input
	GPT161_GTSSR_SSELCB_0 = 0x0
	// Counter start is enable at the ELC_GPTB input
	GPT161_GTSSR_SSELCB_1 = 0x1
	// Position of SSELCA field.
	GPT161_GTSSR_SSELCA_Pos = 0x10
	// Bit mask of SSELCA field.
	GPT161_GTSSR_SSELCA_Msk = 0x10000
	// Bit SSELCA.
	GPT161_GTSSR_SSELCA = 0x10000
	// Counter start is disable at the ELC_GPTA input
	GPT161_GTSSR_SSELCA_0 = 0x0
	// Counter start is enable at the ELC_GPTA input
	GPT161_GTSSR_SSELCA_1 = 0x1
	// Position of SSCBFAH field.
	GPT161_GTSSR_SSCBFAH_Pos = 0xf
	// Bit mask of SSCBFAH field.
	GPT161_GTSSR_SSCBFAH_Msk = 0x8000
	// Bit SSCBFAH.
	GPT161_GTSSR_SSCBFAH = 0x8000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTSSR_SSCBFAH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTSSR_SSCBFAH_1 = 0x1
	// Position of SSCBFAL field.
	GPT161_GTSSR_SSCBFAL_Pos = 0xe
	// Bit mask of SSCBFAL field.
	GPT161_GTSSR_SSCBFAL_Msk = 0x4000
	// Bit SSCBFAL.
	GPT161_GTSSR_SSCBFAL = 0x4000
	// Counter start is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTSSR_SSCBFAL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTSSR_SSCBFAL_1 = 0x1
	// Position of SSCBRAH field.
	GPT161_GTSSR_SSCBRAH_Pos = 0xd
	// Bit mask of SSCBRAH field.
	GPT161_GTSSR_SSCBRAH_Msk = 0x2000
	// Bit SSCBRAH.
	GPT161_GTSSR_SSCBRAH = 0x2000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTSSR_SSCBRAH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTSSR_SSCBRAH_1 = 0x1
	// Position of SSCBRAL field.
	GPT161_GTSSR_SSCBRAL_Pos = 0xc
	// Bit mask of SSCBRAL field.
	GPT161_GTSSR_SSCBRAL_Msk = 0x1000
	// Bit SSCBRAL.
	GPT161_GTSSR_SSCBRAL = 0x1000
	// Counter start is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTSSR_SSCBRAL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTSSR_SSCBRAL_1 = 0x1
	// Position of SSCAFBH field.
	GPT161_GTSSR_SSCAFBH_Pos = 0xb
	// Bit mask of SSCAFBH field.
	GPT161_GTSSR_SSCAFBH_Msk = 0x800
	// Bit SSCAFBH.
	GPT161_GTSSR_SSCAFBH = 0x800
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTSSR_SSCAFBH_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTSSR_SSCAFBH_1 = 0x1
	// Position of SSCAFBL field.
	GPT161_GTSSR_SSCAFBL_Pos = 0xa
	// Bit mask of SSCAFBL field.
	GPT161_GTSSR_SSCAFBL_Msk = 0x400
	// Bit SSCAFBL.
	GPT161_GTSSR_SSCAFBL = 0x400
	// Counter start is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTSSR_SSCAFBL_0 = 0x0
	// Counter start is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTSSR_SSCAFBL_1 = 0x1
	// Position of SSCARBH field.
	GPT161_GTSSR_SSCARBH_Pos = 0x9
	// Bit mask of SSCARBH field.
	GPT161_GTSSR_SSCARBH_Msk = 0x200
	// Bit SSCARBH.
	GPT161_GTSSR_SSCARBH = 0x200
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTSSR_SSCARBH_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTSSR_SSCARBH_1 = 0x1
	// Position of SSCARBL field.
	GPT161_GTSSR_SSCARBL_Pos = 0x8
	// Bit mask of SSCARBL field.
	GPT161_GTSSR_SSCARBL_Msk = 0x100
	// Bit SSCARBL.
	GPT161_GTSSR_SSCARBL = 0x100
	// Counter start is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTSSR_SSCARBL_0 = 0x0
	// Counter start is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTSSR_SSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT161_GTSSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT161_GTSSR_Reserved_Msk = 0xf0
	// Position of SSGTRGBF field.
	GPT161_GTSSR_SSGTRGBF_Pos = 0x3
	// Bit mask of SSGTRGBF field.
	GPT161_GTSSR_SSGTRGBF_Msk = 0x8
	// Bit SSGTRGBF.
	GPT161_GTSSR_SSGTRGBF = 0x8
	// Counter start is disable at the falling edge of GTETRGB input
	GPT161_GTSSR_SSGTRGBF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGB input
	GPT161_GTSSR_SSGTRGBF_1 = 0x1
	// Position of SSGTRGBR field.
	GPT161_GTSSR_SSGTRGBR_Pos = 0x2
	// Bit mask of SSGTRGBR field.
	GPT161_GTSSR_SSGTRGBR_Msk = 0x4
	// Bit SSGTRGBR.
	GPT161_GTSSR_SSGTRGBR = 0x4
	// Counter start is disable at the rising edge of GTETRGB input
	GPT161_GTSSR_SSGTRGBR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGB input
	GPT161_GTSSR_SSGTRGBR_1 = 0x1
	// Position of SSGTRGAF field.
	GPT161_GTSSR_SSGTRGAF_Pos = 0x1
	// Bit mask of SSGTRGAF field.
	GPT161_GTSSR_SSGTRGAF_Msk = 0x2
	// Bit SSGTRGAF.
	GPT161_GTSSR_SSGTRGAF = 0x2
	// Counter start is disable at the falling edge of GTETRGA input
	GPT161_GTSSR_SSGTRGAF_0 = 0x0
	// Counter start is enable at the falling edge of GTETRGA input
	GPT161_GTSSR_SSGTRGAF_1 = 0x1
	// Position of SSGTRGAR field.
	GPT161_GTSSR_SSGTRGAR_Pos = 0x0
	// Bit mask of SSGTRGAR field.
	GPT161_GTSSR_SSGTRGAR_Msk = 0x1
	// Bit SSGTRGAR.
	GPT161_GTSSR_SSGTRGAR = 0x1
	// Counter start is disable at the rising edge of GTETRGA input
	GPT161_GTSSR_SSGTRGAR_0 = 0x0
	// Counter start is enable at the rising edge of GTETRGA input
	GPT161_GTSSR_SSGTRGAR_1 = 0x1

	// GTPSR: General PWM Timer Stop Source Select Register
	// Position of CSTOP field.
	GPT161_GTPSR_CSTOP_Pos = 0x1f
	// Bit mask of CSTOP field.
	GPT161_GTPSR_CSTOP_Msk = 0x80000000
	// Bit CSTOP.
	GPT161_GTPSR_CSTOP = 0x80000000
	// Counter stop is disable by the GTSTP register
	GPT161_GTPSR_CSTOP_0 = 0x0
	// Counter stop is enable by the GTSTP register
	GPT161_GTPSR_CSTOP_1 = 0x1
	// Position of Reserved field.
	GPT161_GTPSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT161_GTPSR_Reserved_Msk = 0x7ff00000
	// Position of PSELCD field.
	GPT161_GTPSR_PSELCD_Pos = 0x13
	// Bit mask of PSELCD field.
	GPT161_GTPSR_PSELCD_Msk = 0x80000
	// Bit PSELCD.
	GPT161_GTPSR_PSELCD = 0x80000
	// Counter stop is disable at the ELC_GPTD input
	GPT161_GTPSR_PSELCD_0 = 0x0
	// Counter stop is enable at the ELC_GPTD input
	GPT161_GTPSR_PSELCD_1 = 0x1
	// Position of PSELCC field.
	GPT161_GTPSR_PSELCC_Pos = 0x12
	// Bit mask of PSELCC field.
	GPT161_GTPSR_PSELCC_Msk = 0x40000
	// Bit PSELCC.
	GPT161_GTPSR_PSELCC = 0x40000
	// Counter stop is disable at the ELC_GPTC input
	GPT161_GTPSR_PSELCC_0 = 0x0
	// Counter stop is enable at the ELC_GPTC input
	GPT161_GTPSR_PSELCC_1 = 0x1
	// Position of PSELCB field.
	GPT161_GTPSR_PSELCB_Pos = 0x11
	// Bit mask of PSELCB field.
	GPT161_GTPSR_PSELCB_Msk = 0x20000
	// Bit PSELCB.
	GPT161_GTPSR_PSELCB = 0x20000
	// Counter stop is disable at the ELC_GPTB input
	GPT161_GTPSR_PSELCB_0 = 0x0
	// Counter stop is enable at the ELC_GPTB input
	GPT161_GTPSR_PSELCB_1 = 0x1
	// Position of PSELCA field.
	GPT161_GTPSR_PSELCA_Pos = 0x10
	// Bit mask of PSELCA field.
	GPT161_GTPSR_PSELCA_Msk = 0x10000
	// Bit PSELCA.
	GPT161_GTPSR_PSELCA = 0x10000
	// Counter stop is disable at the ELC_GPTA input
	GPT161_GTPSR_PSELCA_0 = 0x0
	// Counter stop is enable at the ELC_GPTA input
	GPT161_GTPSR_PSELCA_1 = 0x1
	// Position of PSCBFAH field.
	GPT161_GTPSR_PSCBFAH_Pos = 0xf
	// Bit mask of PSCBFAH field.
	GPT161_GTPSR_PSCBFAH_Msk = 0x8000
	// Bit PSCBFAH.
	GPT161_GTPSR_PSCBFAH = 0x8000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTPSR_PSCBFAH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTPSR_PSCBFAH_1 = 0x1
	// Position of PSCBFAL field.
	GPT161_GTPSR_PSCBFAL_Pos = 0xe
	// Bit mask of PSCBFAL field.
	GPT161_GTPSR_PSCBFAL_Msk = 0x4000
	// Bit PSCBFAL.
	GPT161_GTPSR_PSCBFAL = 0x4000
	// Counter stop is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTPSR_PSCBFAL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTPSR_PSCBFAL_1 = 0x1
	// Position of PSCBRAH field.
	GPT161_GTPSR_PSCBRAH_Pos = 0xd
	// Bit mask of PSCBRAH field.
	GPT161_GTPSR_PSCBRAH_Msk = 0x2000
	// Bit PSCBRAH.
	GPT161_GTPSR_PSCBRAH = 0x2000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTPSR_PSCBRAH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTPSR_PSCBRAH_1 = 0x1
	// Position of PSCBRAL field.
	GPT161_GTPSR_PSCBRAL_Pos = 0xc
	// Bit mask of PSCBRAL field.
	GPT161_GTPSR_PSCBRAL_Msk = 0x1000
	// Bit PSCBRAL.
	GPT161_GTPSR_PSCBRAL = 0x1000
	// Counter stop is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTPSR_PSCBRAL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTPSR_PSCBRAL_1 = 0x1
	// Position of PSCAFBH field.
	GPT161_GTPSR_PSCAFBH_Pos = 0xb
	// Bit mask of PSCAFBH field.
	GPT161_GTPSR_PSCAFBH_Msk = 0x800
	// Bit PSCAFBH.
	GPT161_GTPSR_PSCAFBH = 0x800
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTPSR_PSCAFBH_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTPSR_PSCAFBH_1 = 0x1
	// Position of PSCAFBL field.
	GPT161_GTPSR_PSCAFBL_Pos = 0xa
	// Bit mask of PSCAFBL field.
	GPT161_GTPSR_PSCAFBL_Msk = 0x400
	// Bit PSCAFBL.
	GPT161_GTPSR_PSCAFBL = 0x400
	// Counter stop is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTPSR_PSCAFBL_0 = 0x0
	// Counter stop is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTPSR_PSCAFBL_1 = 0x1
	// Position of PSCARBH field.
	GPT161_GTPSR_PSCARBH_Pos = 0x9
	// Bit mask of PSCARBH field.
	GPT161_GTPSR_PSCARBH_Msk = 0x200
	// Bit PSCARBH.
	GPT161_GTPSR_PSCARBH = 0x200
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTPSR_PSCARBH_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTPSR_PSCARBH_1 = 0x1
	// Position of PSCARBL field.
	GPT161_GTPSR_PSCARBL_Pos = 0x8
	// Bit mask of PSCARBL field.
	GPT161_GTPSR_PSCARBL_Msk = 0x100
	// Bit PSCARBL.
	GPT161_GTPSR_PSCARBL = 0x100
	// Counter stop is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTPSR_PSCARBL_0 = 0x0
	// Counter stop is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTPSR_PSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT161_GTPSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT161_GTPSR_Reserved_Msk = 0xf0
	// Position of PSGTRGBF field.
	GPT161_GTPSR_PSGTRGBF_Pos = 0x3
	// Bit mask of PSGTRGBF field.
	GPT161_GTPSR_PSGTRGBF_Msk = 0x8
	// Bit PSGTRGBF.
	GPT161_GTPSR_PSGTRGBF = 0x8
	// Counter stop is disable at the falling edge of GTETRGB input
	GPT161_GTPSR_PSGTRGBF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGB input
	GPT161_GTPSR_PSGTRGBF_1 = 0x1
	// Position of PSGTRGBR field.
	GPT161_GTPSR_PSGTRGBR_Pos = 0x2
	// Bit mask of PSGTRGBR field.
	GPT161_GTPSR_PSGTRGBR_Msk = 0x4
	// Bit PSGTRGBR.
	GPT161_GTPSR_PSGTRGBR = 0x4
	// Counter stop is disable at the rising edge of GTETRGB input
	GPT161_GTPSR_PSGTRGBR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGB input
	GPT161_GTPSR_PSGTRGBR_1 = 0x1
	// Position of PSGTRGAF field.
	GPT161_GTPSR_PSGTRGAF_Pos = 0x1
	// Bit mask of PSGTRGAF field.
	GPT161_GTPSR_PSGTRGAF_Msk = 0x2
	// Bit PSGTRGAF.
	GPT161_GTPSR_PSGTRGAF = 0x2
	// Counter stop is disable at the falling edge of GTETRGA input
	GPT161_GTPSR_PSGTRGAF_0 = 0x0
	// Counter stop is enable at the falling edge of GTETRGA input
	GPT161_GTPSR_PSGTRGAF_1 = 0x1
	// Position of PSGTRGAR field.
	GPT161_GTPSR_PSGTRGAR_Pos = 0x0
	// Bit mask of PSGTRGAR field.
	GPT161_GTPSR_PSGTRGAR_Msk = 0x1
	// Bit PSGTRGAR.
	GPT161_GTPSR_PSGTRGAR = 0x1
	// Counter stop is disable at the rising edge of GTETRGA input
	GPT161_GTPSR_PSGTRGAR_0 = 0x0
	// Counter stop is enable at the rising edge of GTETRGA input
	GPT161_GTPSR_PSGTRGAR_1 = 0x1

	// GTCSR: General PWM Timer Clear Source Select Register
	// Position of CCLR field.
	GPT161_GTCSR_CCLR_Pos = 0x1f
	// Bit mask of CCLR field.
	GPT161_GTCSR_CCLR_Msk = 0x80000000
	// Bit CCLR.
	GPT161_GTCSR_CCLR = 0x80000000
	// Counter clear is disable by the GTCLR register
	GPT161_GTCSR_CCLR_0 = 0x0
	// Counter clear is enable by the GTCLR register
	GPT161_GTCSR_CCLR_1 = 0x1
	// Position of Reserved field.
	GPT161_GTCSR_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT161_GTCSR_Reserved_Msk = 0x7ff00000
	// Position of CSELCD field.
	GPT161_GTCSR_CSELCD_Pos = 0x13
	// Bit mask of CSELCD field.
	GPT161_GTCSR_CSELCD_Msk = 0x80000
	// Bit CSELCD.
	GPT161_GTCSR_CSELCD = 0x80000
	// Counter clear is disable at the ELC_GPTD input
	GPT161_GTCSR_CSELCD_0 = 0x0
	// Counter clear is enable at the ELC_GPTD input
	GPT161_GTCSR_CSELCD_1 = 0x1
	// Position of CSELCC field.
	GPT161_GTCSR_CSELCC_Pos = 0x12
	// Bit mask of CSELCC field.
	GPT161_GTCSR_CSELCC_Msk = 0x40000
	// Bit CSELCC.
	GPT161_GTCSR_CSELCC = 0x40000
	// Counter clear is disable at the ELC_GPTC input
	GPT161_GTCSR_CSELCC_0 = 0x0
	// Counter clear is enable at the ELC_GPTC input
	GPT161_GTCSR_CSELCC_1 = 0x1
	// Position of CSELCB field.
	GPT161_GTCSR_CSELCB_Pos = 0x11
	// Bit mask of CSELCB field.
	GPT161_GTCSR_CSELCB_Msk = 0x20000
	// Bit CSELCB.
	GPT161_GTCSR_CSELCB = 0x20000
	// Counter clear is disable at the ELC_GPTB input
	GPT161_GTCSR_CSELCB_0 = 0x0
	// Counter clear is enable at the ELC_GPTB input
	GPT161_GTCSR_CSELCB_1 = 0x1
	// Position of CSELCA field.
	GPT161_GTCSR_CSELCA_Pos = 0x10
	// Bit mask of CSELCA field.
	GPT161_GTCSR_CSELCA_Msk = 0x10000
	// Bit CSELCA.
	GPT161_GTCSR_CSELCA = 0x10000
	// Counter clear is disable at the ELC_GPTA input
	GPT161_GTCSR_CSELCA_0 = 0x0
	// Counter clear is enable at the ELC_GPTA input
	GPT161_GTCSR_CSELCA_1 = 0x1
	// Position of CSCBFAH field.
	GPT161_GTCSR_CSCBFAH_Pos = 0xf
	// Bit mask of CSCBFAH field.
	GPT161_GTCSR_CSCBFAH_Msk = 0x8000
	// Bit CSCBFAH.
	GPT161_GTCSR_CSCBFAH = 0x8000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTCSR_CSCBFAH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTCSR_CSCBFAH_1 = 0x1
	// Position of CSCBFAL field.
	GPT161_GTCSR_CSCBFAL_Pos = 0xe
	// Bit mask of CSCBFAL field.
	GPT161_GTCSR_CSCBFAL_Msk = 0x4000
	// Bit CSCBFAL.
	GPT161_GTCSR_CSCBFAL = 0x4000
	// Counter clear is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTCSR_CSCBFAL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTCSR_CSCBFAL_1 = 0x1
	// Position of CSCBRAH field.
	GPT161_GTCSR_CSCBRAH_Pos = 0xd
	// Bit mask of CSCBRAH field.
	GPT161_GTCSR_CSCBRAH_Msk = 0x2000
	// Bit CSCBRAH.
	GPT161_GTCSR_CSCBRAH = 0x2000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTCSR_CSCBRAH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTCSR_CSCBRAH_1 = 0x1
	// Position of CSCBRAL field.
	GPT161_GTCSR_CSCBRAL_Pos = 0xc
	// Bit mask of CSCBRAL field.
	GPT161_GTCSR_CSCBRAL_Msk = 0x1000
	// Bit CSCBRAL.
	GPT161_GTCSR_CSCBRAL = 0x1000
	// Counter clear is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTCSR_CSCBRAL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTCSR_CSCBRAL_1 = 0x1
	// Position of CSCAFBH field.
	GPT161_GTCSR_CSCAFBH_Pos = 0xb
	// Bit mask of CSCAFBH field.
	GPT161_GTCSR_CSCAFBH_Msk = 0x800
	// Bit CSCAFBH.
	GPT161_GTCSR_CSCAFBH = 0x800
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTCSR_CSCAFBH_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTCSR_CSCAFBH_1 = 0x1
	// Position of CSCAFBL field.
	GPT161_GTCSR_CSCAFBL_Pos = 0xa
	// Bit mask of CSCAFBL field.
	GPT161_GTCSR_CSCAFBL_Msk = 0x400
	// Bit CSCAFBL.
	GPT161_GTCSR_CSCAFBL = 0x400
	// Counter clear is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTCSR_CSCAFBL_0 = 0x0
	// Counter clear is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTCSR_CSCAFBL_1 = 0x1
	// Position of CSCARBH field.
	GPT161_GTCSR_CSCARBH_Pos = 0x9
	// Bit mask of CSCARBH field.
	GPT161_GTCSR_CSCARBH_Msk = 0x200
	// Bit CSCARBH.
	GPT161_GTCSR_CSCARBH = 0x200
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTCSR_CSCARBH_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTCSR_CSCARBH_1 = 0x1
	// Position of CSCARBL field.
	GPT161_GTCSR_CSCARBL_Pos = 0x8
	// Bit mask of CSCARBL field.
	GPT161_GTCSR_CSCARBL_Msk = 0x100
	// Bit CSCARBL.
	GPT161_GTCSR_CSCARBL = 0x100
	// Counter clear is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTCSR_CSCARBL_0 = 0x0
	// Counter clear is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTCSR_CSCARBL_1 = 0x1
	// Position of Reserved field.
	GPT161_GTCSR_Reserved_Pos = 0x4
	// Bit mask of Reserved field.
	GPT161_GTCSR_Reserved_Msk = 0xf0
	// Position of CSGTRGBF field.
	GPT161_GTCSR_CSGTRGBF_Pos = 0x3
	// Bit mask of CSGTRGBF field.
	GPT161_GTCSR_CSGTRGBF_Msk = 0x8
	// Bit CSGTRGBF.
	GPT161_GTCSR_CSGTRGBF = 0x8
	// Counter clear is disable at the falling edge of GTETRGB input
	GPT161_GTCSR_CSGTRGBF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGB input
	GPT161_GTCSR_CSGTRGBF_1 = 0x1
	// Position of CSGTRGBR field.
	GPT161_GTCSR_CSGTRGBR_Pos = 0x2
	// Bit mask of CSGTRGBR field.
	GPT161_GTCSR_CSGTRGBR_Msk = 0x4
	// Bit CSGTRGBR.
	GPT161_GTCSR_CSGTRGBR = 0x4
	// Counter clear is disable at the rising edge of GTETRGB input
	GPT161_GTCSR_CSGTRGBR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGB input
	GPT161_GTCSR_CSGTRGBR_1 = 0x1
	// Position of CSGTRGAF field.
	GPT161_GTCSR_CSGTRGAF_Pos = 0x1
	// Bit mask of CSGTRGAF field.
	GPT161_GTCSR_CSGTRGAF_Msk = 0x2
	// Bit CSGTRGAF.
	GPT161_GTCSR_CSGTRGAF = 0x2
	// Counter clear is disable at the falling edge of GTETRGA input
	GPT161_GTCSR_CSGTRGAF_0 = 0x0
	// Counter clear is enable at the falling edge of GTETRGA input
	GPT161_GTCSR_CSGTRGAF_1 = 0x1
	// Position of CSGTRGAR field.
	GPT161_GTCSR_CSGTRGAR_Pos = 0x0
	// Bit mask of CSGTRGAR field.
	GPT161_GTCSR_CSGTRGAR_Msk = 0x1
	// Bit CSGTRGAR.
	GPT161_GTCSR_CSGTRGAR = 0x1
	// Counter clear is disable at the rising edge of GTETRGA input
	GPT161_GTCSR_CSGTRGAR_0 = 0x0
	// Counter clear is enable at the rising edge of GTETRGA input
	GPT161_GTCSR_CSGTRGAR_1 = 0x1

	// GTUPSR: General PWM Timer Up Count Source Select Register
	// Position of USELCD field.
	GPT161_GTUPSR_USELCD_Pos = 0x13
	// Bit mask of USELCD field.
	GPT161_GTUPSR_USELCD_Msk = 0x80000
	// Bit USELCD.
	GPT161_GTUPSR_USELCD = 0x80000
	// Counter count up is disable at the ELC_GPTD input
	GPT161_GTUPSR_USELCD_0 = 0x0
	// Counter count up is enable at the ELC_GPTD input
	GPT161_GTUPSR_USELCD_1 = 0x1
	// Position of USELCC field.
	GPT161_GTUPSR_USELCC_Pos = 0x12
	// Bit mask of USELCC field.
	GPT161_GTUPSR_USELCC_Msk = 0x40000
	// Bit USELCC.
	GPT161_GTUPSR_USELCC = 0x40000
	// Counter count up is disable at the ELC_GPTC input
	GPT161_GTUPSR_USELCC_0 = 0x0
	// Counter count up is enable at the ELC_GPTC input
	GPT161_GTUPSR_USELCC_1 = 0x1
	// Position of USELCB field.
	GPT161_GTUPSR_USELCB_Pos = 0x11
	// Bit mask of USELCB field.
	GPT161_GTUPSR_USELCB_Msk = 0x20000
	// Bit USELCB.
	GPT161_GTUPSR_USELCB = 0x20000
	// Counter count up is disable at the ELC_GPTB input
	GPT161_GTUPSR_USELCB_0 = 0x0
	// Counter count up is enable at the ELC_GPTB input
	GPT161_GTUPSR_USELCB_1 = 0x1
	// Position of USELCA field.
	GPT161_GTUPSR_USELCA_Pos = 0x10
	// Bit mask of USELCA field.
	GPT161_GTUPSR_USELCA_Msk = 0x10000
	// Bit USELCA.
	GPT161_GTUPSR_USELCA = 0x10000
	// Counter count up is disable at the ELC_GPTA input
	GPT161_GTUPSR_USELCA_0 = 0x0
	// Counter count up is enable at the ELC_GPTA input
	GPT161_GTUPSR_USELCA_1 = 0x1
	// Position of USCBFAH field.
	GPT161_GTUPSR_USCBFAH_Pos = 0xf
	// Bit mask of USCBFAH field.
	GPT161_GTUPSR_USCBFAH_Msk = 0x8000
	// Bit USCBFAH.
	GPT161_GTUPSR_USCBFAH = 0x8000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTUPSR_USCBFAH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTUPSR_USCBFAH_1 = 0x1
	// Position of USCBFAL field.
	GPT161_GTUPSR_USCBFAL_Pos = 0xe
	// Bit mask of USCBFAL field.
	GPT161_GTUPSR_USCBFAL_Msk = 0x4000
	// Bit USCBFAL.
	GPT161_GTUPSR_USCBFAL = 0x4000
	// Counter count up is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTUPSR_USCBFAL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTUPSR_USCBFAL_1 = 0x1
	// Position of USCBRAH field.
	GPT161_GTUPSR_USCBRAH_Pos = 0xd
	// Bit mask of USCBRAH field.
	GPT161_GTUPSR_USCBRAH_Msk = 0x2000
	// Bit USCBRAH.
	GPT161_GTUPSR_USCBRAH = 0x2000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTUPSR_USCBRAH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTUPSR_USCBRAH_1 = 0x1
	// Position of USCBRAL field.
	GPT161_GTUPSR_USCBRAL_Pos = 0xc
	// Bit mask of USCBRAL field.
	GPT161_GTUPSR_USCBRAL_Msk = 0x1000
	// Bit USCBRAL.
	GPT161_GTUPSR_USCBRAL = 0x1000
	// Counter count up is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTUPSR_USCBRAL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTUPSR_USCBRAL_1 = 0x1
	// Position of USCAFBH field.
	GPT161_GTUPSR_USCAFBH_Pos = 0xb
	// Bit mask of USCAFBH field.
	GPT161_GTUPSR_USCAFBH_Msk = 0x800
	// Bit USCAFBH.
	GPT161_GTUPSR_USCAFBH = 0x800
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTUPSR_USCAFBH_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTUPSR_USCAFBH_1 = 0x1
	// Position of USCAFBL field.
	GPT161_GTUPSR_USCAFBL_Pos = 0xa
	// Bit mask of USCAFBL field.
	GPT161_GTUPSR_USCAFBL_Msk = 0x400
	// Bit USCAFBL.
	GPT161_GTUPSR_USCAFBL = 0x400
	// Counter count up is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTUPSR_USCAFBL_0 = 0x0
	// Counter count up is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTUPSR_USCAFBL_1 = 0x1
	// Position of USCARBH field.
	GPT161_GTUPSR_USCARBH_Pos = 0x9
	// Bit mask of USCARBH field.
	GPT161_GTUPSR_USCARBH_Msk = 0x200
	// Bit USCARBH.
	GPT161_GTUPSR_USCARBH = 0x200
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTUPSR_USCARBH_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTUPSR_USCARBH_1 = 0x1
	// Position of USCARBL field.
	GPT161_GTUPSR_USCARBL_Pos = 0x8
	// Bit mask of USCARBL field.
	GPT161_GTUPSR_USCARBL_Msk = 0x100
	// Bit USCARBL.
	GPT161_GTUPSR_USCARBL = 0x100
	// Counter count up is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTUPSR_USCARBL_0 = 0x0
	// Counter count up is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTUPSR_USCARBL_1 = 0x1
	// Position of USGTRGBF field.
	GPT161_GTUPSR_USGTRGBF_Pos = 0x3
	// Bit mask of USGTRGBF field.
	GPT161_GTUPSR_USGTRGBF_Msk = 0x8
	// Bit USGTRGBF.
	GPT161_GTUPSR_USGTRGBF = 0x8
	// Counter count up is disable at the falling edge of GTETRGB input
	GPT161_GTUPSR_USGTRGBF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGB input
	GPT161_GTUPSR_USGTRGBF_1 = 0x1
	// Position of USGTRGBR field.
	GPT161_GTUPSR_USGTRGBR_Pos = 0x2
	// Bit mask of USGTRGBR field.
	GPT161_GTUPSR_USGTRGBR_Msk = 0x4
	// Bit USGTRGBR.
	GPT161_GTUPSR_USGTRGBR = 0x4
	// Counter count up is disable at the rising edge of GTETRGB input
	GPT161_GTUPSR_USGTRGBR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGB input
	GPT161_GTUPSR_USGTRGBR_1 = 0x1
	// Position of USGTRGAF field.
	GPT161_GTUPSR_USGTRGAF_Pos = 0x1
	// Bit mask of USGTRGAF field.
	GPT161_GTUPSR_USGTRGAF_Msk = 0x2
	// Bit USGTRGAF.
	GPT161_GTUPSR_USGTRGAF = 0x2
	// Counter count up is disable at the falling edge of GTETRGA input
	GPT161_GTUPSR_USGTRGAF_0 = 0x0
	// Counter count up is enable at the falling edge of GTETRGA input
	GPT161_GTUPSR_USGTRGAF_1 = 0x1
	// Position of USGTRGAR field.
	GPT161_GTUPSR_USGTRGAR_Pos = 0x0
	// Bit mask of USGTRGAR field.
	GPT161_GTUPSR_USGTRGAR_Msk = 0x1
	// Bit USGTRGAR.
	GPT161_GTUPSR_USGTRGAR = 0x1
	// Counter count up is disable at the rising edge of GTETRGA input
	GPT161_GTUPSR_USGTRGAR_0 = 0x0
	// Counter count up is enable at the rising edge of GTETRGA input
	GPT161_GTUPSR_USGTRGAR_1 = 0x1

	// GTDNSR: General PWM Timer Down Count Source Select Register
	// Position of DSELCD field.
	GPT161_GTDNSR_DSELCD_Pos = 0x13
	// Bit mask of DSELCD field.
	GPT161_GTDNSR_DSELCD_Msk = 0x80000
	// Bit DSELCD.
	GPT161_GTDNSR_DSELCD = 0x80000
	// Counter count down is disable at the ELC_GPTD input
	GPT161_GTDNSR_DSELCD_0 = 0x0
	// Counter count down is enable at the ELC_GPTD input
	GPT161_GTDNSR_DSELCD_1 = 0x1
	// Position of DSELCC field.
	GPT161_GTDNSR_DSELCC_Pos = 0x12
	// Bit mask of DSELCC field.
	GPT161_GTDNSR_DSELCC_Msk = 0x40000
	// Bit DSELCC.
	GPT161_GTDNSR_DSELCC = 0x40000
	// Counter count down is disable at the ELC_GPTC input
	GPT161_GTDNSR_DSELCC_0 = 0x0
	// Counter count down is enable at the ELC_GPTC input
	GPT161_GTDNSR_DSELCC_1 = 0x1
	// Position of DSELCB field.
	GPT161_GTDNSR_DSELCB_Pos = 0x11
	// Bit mask of DSELCB field.
	GPT161_GTDNSR_DSELCB_Msk = 0x20000
	// Bit DSELCB.
	GPT161_GTDNSR_DSELCB = 0x20000
	// Counter count down is disable at the ELC_GPTB input
	GPT161_GTDNSR_DSELCB_0 = 0x0
	// Counter count down is enable at the ELC_GPTB input
	GPT161_GTDNSR_DSELCB_1 = 0x1
	// Position of DSELCA field.
	GPT161_GTDNSR_DSELCA_Pos = 0x10
	// Bit mask of DSELCA field.
	GPT161_GTDNSR_DSELCA_Msk = 0x10000
	// Bit DSELCA.
	GPT161_GTDNSR_DSELCA = 0x10000
	// Counter count down is disable at the ELC_GPTA input
	GPT161_GTDNSR_DSELCA_0 = 0x0
	// Counter count down is enable at the ELC_GPTA input
	GPT161_GTDNSR_DSELCA_1 = 0x1
	// Position of DSCBFAH field.
	GPT161_GTDNSR_DSCBFAH_Pos = 0xf
	// Bit mask of DSCBFAH field.
	GPT161_GTDNSR_DSCBFAH_Msk = 0x8000
	// Bit DSCBFAH.
	GPT161_GTDNSR_DSCBFAH = 0x8000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTDNSR_DSCBFAH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTDNSR_DSCBFAH_1 = 0x1
	// Position of DSCBFAL field.
	GPT161_GTDNSR_DSCBFAL_Pos = 0xe
	// Bit mask of DSCBFAL field.
	GPT161_GTDNSR_DSCBFAL_Msk = 0x4000
	// Bit DSCBFAL.
	GPT161_GTDNSR_DSCBFAL = 0x4000
	// Counter count down is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTDNSR_DSCBFAL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTDNSR_DSCBFAL_1 = 0x1
	// Position of DSCBRAH field.
	GPT161_GTDNSR_DSCBRAH_Pos = 0xd
	// Bit mask of DSCBRAH field.
	GPT161_GTDNSR_DSCBRAH_Msk = 0x2000
	// Bit DSCBRAH.
	GPT161_GTDNSR_DSCBRAH = 0x2000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTDNSR_DSCBRAH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTDNSR_DSCBRAH_1 = 0x1
	// Position of DSCBRAL field.
	GPT161_GTDNSR_DSCBRAL_Pos = 0xc
	// Bit mask of DSCBRAL field.
	GPT161_GTDNSR_DSCBRAL_Msk = 0x1000
	// Bit DSCBRAL.
	GPT161_GTDNSR_DSCBRAL = 0x1000
	// Counter count down is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTDNSR_DSCBRAL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTDNSR_DSCBRAL_1 = 0x1
	// Position of DSCAFBH field.
	GPT161_GTDNSR_DSCAFBH_Pos = 0xb
	// Bit mask of DSCAFBH field.
	GPT161_GTDNSR_DSCAFBH_Msk = 0x800
	// Bit DSCAFBH.
	GPT161_GTDNSR_DSCAFBH = 0x800
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTDNSR_DSCAFBH_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTDNSR_DSCAFBH_1 = 0x1
	// Position of DSCAFBL field.
	GPT161_GTDNSR_DSCAFBL_Pos = 0xa
	// Bit mask of DSCAFBL field.
	GPT161_GTDNSR_DSCAFBL_Msk = 0x400
	// Bit DSCAFBL.
	GPT161_GTDNSR_DSCAFBL = 0x400
	// Counter count down is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTDNSR_DSCAFBL_0 = 0x0
	// Counter count down is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTDNSR_DSCAFBL_1 = 0x1
	// Position of DSCARBH field.
	GPT161_GTDNSR_DSCARBH_Pos = 0x9
	// Bit mask of DSCARBH field.
	GPT161_GTDNSR_DSCARBH_Msk = 0x200
	// Bit DSCARBH.
	GPT161_GTDNSR_DSCARBH = 0x200
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTDNSR_DSCARBH_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTDNSR_DSCARBH_1 = 0x1
	// Position of DSCARBL field.
	GPT161_GTDNSR_DSCARBL_Pos = 0x8
	// Bit mask of DSCARBL field.
	GPT161_GTDNSR_DSCARBL_Msk = 0x100
	// Bit DSCARBL.
	GPT161_GTDNSR_DSCARBL = 0x100
	// Counter count down is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTDNSR_DSCARBL_0 = 0x0
	// Counter count down is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTDNSR_DSCARBL_1 = 0x1
	// Position of DSGTRGBF field.
	GPT161_GTDNSR_DSGTRGBF_Pos = 0x3
	// Bit mask of DSGTRGBF field.
	GPT161_GTDNSR_DSGTRGBF_Msk = 0x8
	// Bit DSGTRGBF.
	GPT161_GTDNSR_DSGTRGBF = 0x8
	// Counter count down is disable at the falling edge of GTETRGB input
	GPT161_GTDNSR_DSGTRGBF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGB input
	GPT161_GTDNSR_DSGTRGBF_1 = 0x1
	// Position of DSGTRGBR field.
	GPT161_GTDNSR_DSGTRGBR_Pos = 0x2
	// Bit mask of DSGTRGBR field.
	GPT161_GTDNSR_DSGTRGBR_Msk = 0x4
	// Bit DSGTRGBR.
	GPT161_GTDNSR_DSGTRGBR = 0x4
	// Counter count down is disable at the rising edge of GTETRGB input
	GPT161_GTDNSR_DSGTRGBR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGB input
	GPT161_GTDNSR_DSGTRGBR_1 = 0x1
	// Position of DSGTRGAF field.
	GPT161_GTDNSR_DSGTRGAF_Pos = 0x1
	// Bit mask of DSGTRGAF field.
	GPT161_GTDNSR_DSGTRGAF_Msk = 0x2
	// Bit DSGTRGAF.
	GPT161_GTDNSR_DSGTRGAF = 0x2
	// Counter count down is disable at the falling edge of GTETRGA input
	GPT161_GTDNSR_DSGTRGAF_0 = 0x0
	// Counter count down is enable at the falling edge of GTETRGA input
	GPT161_GTDNSR_DSGTRGAF_1 = 0x1
	// Position of DSGTRGAR field.
	GPT161_GTDNSR_DSGTRGAR_Pos = 0x0
	// Bit mask of DSGTRGAR field.
	GPT161_GTDNSR_DSGTRGAR_Msk = 0x1
	// Bit DSGTRGAR.
	GPT161_GTDNSR_DSGTRGAR = 0x1
	// Counter count down is disable at the rising edge of GTETRGA input
	GPT161_GTDNSR_DSGTRGAR_0 = 0x0
	// Counter count down is enable at the rising edge of GTETRGA input
	GPT161_GTDNSR_DSGTRGAR_1 = 0x1

	// GTICASR: General PWM Timer Input Capture Source Select Register A
	// Position of ASELCD field.
	GPT161_GTICASR_ASELCD_Pos = 0x13
	// Bit mask of ASELCD field.
	GPT161_GTICASR_ASELCD_Msk = 0x80000
	// Bit ASELCD.
	GPT161_GTICASR_ASELCD = 0x80000
	// GTCCRA input capture is disable at the ELC_GPTD input
	GPT161_GTICASR_ASELCD_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTD input
	GPT161_GTICASR_ASELCD_1 = 0x1
	// Position of ASELCC field.
	GPT161_GTICASR_ASELCC_Pos = 0x12
	// Bit mask of ASELCC field.
	GPT161_GTICASR_ASELCC_Msk = 0x40000
	// Bit ASELCC.
	GPT161_GTICASR_ASELCC = 0x40000
	// GTCCRA input capture is disable at the ELC_GPTC input
	GPT161_GTICASR_ASELCC_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTC input
	GPT161_GTICASR_ASELCC_1 = 0x1
	// Position of ASELCB field.
	GPT161_GTICASR_ASELCB_Pos = 0x11
	// Bit mask of ASELCB field.
	GPT161_GTICASR_ASELCB_Msk = 0x20000
	// Bit ASELCB.
	GPT161_GTICASR_ASELCB = 0x20000
	// GTCCRA input capture is disable at the ELC_GPTB input
	GPT161_GTICASR_ASELCB_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTB input
	GPT161_GTICASR_ASELCB_1 = 0x1
	// Position of ASELCA field.
	GPT161_GTICASR_ASELCA_Pos = 0x10
	// Bit mask of ASELCA field.
	GPT161_GTICASR_ASELCA_Msk = 0x10000
	// Bit ASELCA.
	GPT161_GTICASR_ASELCA = 0x10000
	// GTCCRA input capture is disable at the ELC_GPTA input
	GPT161_GTICASR_ASELCA_0 = 0x0
	// GTCCRA input capture is enable at the ELC_GPTA input
	GPT161_GTICASR_ASELCA_1 = 0x1
	// Position of ASCBFAH field.
	GPT161_GTICASR_ASCBFAH_Pos = 0xf
	// Bit mask of ASCBFAH field.
	GPT161_GTICASR_ASCBFAH_Msk = 0x8000
	// Bit ASCBFAH.
	GPT161_GTICASR_ASCBFAH = 0x8000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICASR_ASCBFAH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICASR_ASCBFAH_1 = 0x1
	// Position of ASCBFAL field.
	GPT161_GTICASR_ASCBFAL_Pos = 0xe
	// Bit mask of ASCBFAL field.
	GPT161_GTICASR_ASCBFAL_Msk = 0x4000
	// Bit ASCBFAL.
	GPT161_GTICASR_ASCBFAL = 0x4000
	// GTCCRA input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICASR_ASCBFAL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICASR_ASCBFAL_1 = 0x1
	// Position of ASCBRAH field.
	GPT161_GTICASR_ASCBRAH_Pos = 0xd
	// Bit mask of ASCBRAH field.
	GPT161_GTICASR_ASCBRAH_Msk = 0x2000
	// Bit ASCBRAH.
	GPT161_GTICASR_ASCBRAH = 0x2000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICASR_ASCBRAH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICASR_ASCBRAH_1 = 0x1
	// Position of ASCBRAL field.
	GPT161_GTICASR_ASCBRAL_Pos = 0xc
	// Bit mask of ASCBRAL field.
	GPT161_GTICASR_ASCBRAL_Msk = 0x1000
	// Bit ASCBRAL.
	GPT161_GTICASR_ASCBRAL = 0x1000
	// GTCCRA input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICASR_ASCBRAL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICASR_ASCBRAL_1 = 0x1
	// Position of ASCAFBH field.
	GPT161_GTICASR_ASCAFBH_Pos = 0xb
	// Bit mask of ASCAFBH field.
	GPT161_GTICASR_ASCAFBH_Msk = 0x800
	// Bit ASCAFBH.
	GPT161_GTICASR_ASCAFBH = 0x800
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICASR_ASCAFBH_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICASR_ASCAFBH_1 = 0x1
	// Position of ASCAFBL field.
	GPT161_GTICASR_ASCAFBL_Pos = 0xa
	// Bit mask of ASCAFBL field.
	GPT161_GTICASR_ASCAFBL_Msk = 0x400
	// Bit ASCAFBL.
	GPT161_GTICASR_ASCAFBL = 0x400
	// GTCCRA input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICASR_ASCAFBL_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICASR_ASCAFBL_1 = 0x1
	// Position of ASCARBH field.
	GPT161_GTICASR_ASCARBH_Pos = 0x9
	// Bit mask of ASCARBH field.
	GPT161_GTICASR_ASCARBH_Msk = 0x200
	// Bit ASCARBH.
	GPT161_GTICASR_ASCARBH = 0x200
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICASR_ASCARBH_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICASR_ASCARBH_1 = 0x1
	// Position of ASCARBL field.
	GPT161_GTICASR_ASCARBL_Pos = 0x8
	// Bit mask of ASCARBL field.
	GPT161_GTICASR_ASCARBL_Msk = 0x100
	// Bit ASCARBL.
	GPT161_GTICASR_ASCARBL = 0x100
	// GTCCRA input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICASR_ASCARBL_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICASR_ASCARBL_1 = 0x1
	// Position of ASGTRGBF field.
	GPT161_GTICASR_ASGTRGBF_Pos = 0x3
	// Bit mask of ASGTRGBF field.
	GPT161_GTICASR_ASGTRGBF_Msk = 0x8
	// Bit ASGTRGBF.
	GPT161_GTICASR_ASGTRGBF = 0x8
	// GTCCRA input capture is disable at the falling edge of GTETRGB input
	GPT161_GTICASR_ASGTRGBF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGB input
	GPT161_GTICASR_ASGTRGBF_1 = 0x1
	// Position of ASGTRGBR field.
	GPT161_GTICASR_ASGTRGBR_Pos = 0x2
	// Bit mask of ASGTRGBR field.
	GPT161_GTICASR_ASGTRGBR_Msk = 0x4
	// Bit ASGTRGBR.
	GPT161_GTICASR_ASGTRGBR = 0x4
	// GTCCRA input capture is disable at the rising edge of GTETRGB input
	GPT161_GTICASR_ASGTRGBR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGB input
	GPT161_GTICASR_ASGTRGBR_1 = 0x1
	// Position of ASGTRGAF field.
	GPT161_GTICASR_ASGTRGAF_Pos = 0x1
	// Bit mask of ASGTRGAF field.
	GPT161_GTICASR_ASGTRGAF_Msk = 0x2
	// Bit ASGTRGAF.
	GPT161_GTICASR_ASGTRGAF = 0x2
	// GTCCRA input capture is disable at the falling edge of GTETRGA input
	GPT161_GTICASR_ASGTRGAF_0 = 0x0
	// GTCCRA input capture is enable at the falling edge of GTETRGA input
	GPT161_GTICASR_ASGTRGAF_1 = 0x1
	// Position of ASGTRGAR field.
	GPT161_GTICASR_ASGTRGAR_Pos = 0x0
	// Bit mask of ASGTRGAR field.
	GPT161_GTICASR_ASGTRGAR_Msk = 0x1
	// Bit ASGTRGAR.
	GPT161_GTICASR_ASGTRGAR = 0x1
	// GTCCRA input capture is disable at the rising edge of GTETRGA input
	GPT161_GTICASR_ASGTRGAR_0 = 0x0
	// GTCCRA input capture is enable at the rising edge of GTETRGA input
	GPT161_GTICASR_ASGTRGAR_1 = 0x1

	// GTICBSR: General PWM Timer Input Capture Source Select Register B
	// Position of BSELCD field.
	GPT161_GTICBSR_BSELCD_Pos = 0x13
	// Bit mask of BSELCD field.
	GPT161_GTICBSR_BSELCD_Msk = 0x80000
	// Bit BSELCD.
	GPT161_GTICBSR_BSELCD = 0x80000
	// GTCCRB input capture is disable at the ELC_GPTD input
	GPT161_GTICBSR_BSELCD_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTD input
	GPT161_GTICBSR_BSELCD_1 = 0x1
	// Position of BSELCC field.
	GPT161_GTICBSR_BSELCC_Pos = 0x12
	// Bit mask of BSELCC field.
	GPT161_GTICBSR_BSELCC_Msk = 0x40000
	// Bit BSELCC.
	GPT161_GTICBSR_BSELCC = 0x40000
	// GTCCRB input capture is disable at the ELC_GPTC input
	GPT161_GTICBSR_BSELCC_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTC input
	GPT161_GTICBSR_BSELCC_1 = 0x1
	// Position of BSELCB field.
	GPT161_GTICBSR_BSELCB_Pos = 0x11
	// Bit mask of BSELCB field.
	GPT161_GTICBSR_BSELCB_Msk = 0x20000
	// Bit BSELCB.
	GPT161_GTICBSR_BSELCB = 0x20000
	// GTCCRB input capture is disable at the ELC_GPTB input
	GPT161_GTICBSR_BSELCB_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTB input
	GPT161_GTICBSR_BSELCB_1 = 0x1
	// Position of BSELCA field.
	GPT161_GTICBSR_BSELCA_Pos = 0x10
	// Bit mask of BSELCA field.
	GPT161_GTICBSR_BSELCA_Msk = 0x10000
	// Bit BSELCA.
	GPT161_GTICBSR_BSELCA = 0x10000
	// GTCCRB input capture is disable at the ELC_GPTA input
	GPT161_GTICBSR_BSELCA_0 = 0x0
	// GTCCRB input capture is enable at the ELC_GPTA input
	GPT161_GTICBSR_BSELCA_1 = 0x1
	// Position of BSCBFAH field.
	GPT161_GTICBSR_BSCBFAH_Pos = 0xf
	// Bit mask of BSCBFAH field.
	GPT161_GTICBSR_BSCBFAH_Msk = 0x8000
	// Bit BSCBFAH.
	GPT161_GTICBSR_BSCBFAH = 0x8000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICBSR_BSCBFAH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICBSR_BSCBFAH_1 = 0x1
	// Position of BSCBFAL field.
	GPT161_GTICBSR_BSCBFAL_Pos = 0xe
	// Bit mask of BSCBFAL field.
	GPT161_GTICBSR_BSCBFAL_Msk = 0x4000
	// Bit BSCBFAL.
	GPT161_GTICBSR_BSCBFAL = 0x4000
	// GTCCRB input capture is disable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICBSR_BSCBFAL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICBSR_BSCBFAL_1 = 0x1
	// Position of BSCBRAH field.
	GPT161_GTICBSR_BSCBRAH_Pos = 0xd
	// Bit mask of BSCBRAH field.
	GPT161_GTICBSR_BSCBRAH_Msk = 0x2000
	// Bit BSCBRAH.
	GPT161_GTICBSR_BSCBRAH = 0x2000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICBSR_BSCBRAH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 1
	GPT161_GTICBSR_BSCBRAH_1 = 0x1
	// Position of BSCBRAL field.
	GPT161_GTICBSR_BSCBRAL_Pos = 0xc
	// Bit mask of BSCBRAL field.
	GPT161_GTICBSR_BSCBRAL_Msk = 0x1000
	// Bit BSCBRAL.
	GPT161_GTICBSR_BSCBRAL = 0x1000
	// GTCCRB input capture is disable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICBSR_BSCBRAL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCB input when GTIOCA input is 0
	GPT161_GTICBSR_BSCBRAL_1 = 0x1
	// Position of BSCAFBH field.
	GPT161_GTICBSR_BSCAFBH_Pos = 0xb
	// Bit mask of BSCAFBH field.
	GPT161_GTICBSR_BSCAFBH_Msk = 0x800
	// Bit BSCAFBH.
	GPT161_GTICBSR_BSCAFBH = 0x800
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICBSR_BSCAFBH_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICBSR_BSCAFBH_1 = 0x1
	// Position of BSCAFBL field.
	GPT161_GTICBSR_BSCAFBL_Pos = 0xa
	// Bit mask of BSCAFBL field.
	GPT161_GTICBSR_BSCAFBL_Msk = 0x400
	// Bit BSCAFBL.
	GPT161_GTICBSR_BSCAFBL = 0x400
	// GTCCRB input capture is disable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICBSR_BSCAFBL_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICBSR_BSCAFBL_1 = 0x1
	// Position of BSCARBH field.
	GPT161_GTICBSR_BSCARBH_Pos = 0x9
	// Bit mask of BSCARBH field.
	GPT161_GTICBSR_BSCARBH_Msk = 0x200
	// Bit BSCARBH.
	GPT161_GTICBSR_BSCARBH = 0x200
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICBSR_BSCARBH_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 1
	GPT161_GTICBSR_BSCARBH_1 = 0x1
	// Position of BSCARBL field.
	GPT161_GTICBSR_BSCARBL_Pos = 0x8
	// Bit mask of BSCARBL field.
	GPT161_GTICBSR_BSCARBL_Msk = 0x100
	// Bit BSCARBL.
	GPT161_GTICBSR_BSCARBL = 0x100
	// GTCCRB input capture is disable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICBSR_BSCARBL_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTIOCA input when GTIOCB input is 0
	GPT161_GTICBSR_BSCARBL_1 = 0x1
	// Position of BSGTRGBF field.
	GPT161_GTICBSR_BSGTRGBF_Pos = 0x3
	// Bit mask of BSGTRGBF field.
	GPT161_GTICBSR_BSGTRGBF_Msk = 0x8
	// Bit BSGTRGBF.
	GPT161_GTICBSR_BSGTRGBF = 0x8
	// GTCCRB input capture is disable at the falling edge of GTETRGB input
	GPT161_GTICBSR_BSGTRGBF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGB input
	GPT161_GTICBSR_BSGTRGBF_1 = 0x1
	// Position of BSGTRGBR field.
	GPT161_GTICBSR_BSGTRGBR_Pos = 0x2
	// Bit mask of BSGTRGBR field.
	GPT161_GTICBSR_BSGTRGBR_Msk = 0x4
	// Bit BSGTRGBR.
	GPT161_GTICBSR_BSGTRGBR = 0x4
	// GTCCRB input capture is disable at the rising edge of GTETRGB input
	GPT161_GTICBSR_BSGTRGBR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGB input
	GPT161_GTICBSR_BSGTRGBR_1 = 0x1
	// Position of BSGTRGAF field.
	GPT161_GTICBSR_BSGTRGAF_Pos = 0x1
	// Bit mask of BSGTRGAF field.
	GPT161_GTICBSR_BSGTRGAF_Msk = 0x2
	// Bit BSGTRGAF.
	GPT161_GTICBSR_BSGTRGAF = 0x2
	// GTCCRB input capture is disable at the falling edge of GTETRGA input
	GPT161_GTICBSR_BSGTRGAF_0 = 0x0
	// GTCCRB input capture is enable at the falling edge of GTETRGA input
	GPT161_GTICBSR_BSGTRGAF_1 = 0x1
	// Position of BSGTRGAR field.
	GPT161_GTICBSR_BSGTRGAR_Pos = 0x0
	// Bit mask of BSGTRGAR field.
	GPT161_GTICBSR_BSGTRGAR_Msk = 0x1
	// Bit BSGTRGAR.
	GPT161_GTICBSR_BSGTRGAR = 0x1
	// GTCCRB input capture is disable at the rising edge of GTETRGA input
	GPT161_GTICBSR_BSGTRGAR_0 = 0x0
	// GTCCRB input capture is enable at the rising edge of GTETRGA input
	GPT161_GTICBSR_BSGTRGAR_1 = 0x1

	// GTCR: General PWM Timer Control Register
	// Position of TPCS field.
	GPT161_GTCR_TPCS_Pos = 0x18
	// Bit mask of TPCS field.
	GPT161_GTCR_TPCS_Msk = 0x7000000
	// PCLK/1
	GPT161_GTCR_TPCS_000 = 0x0
	// PCLK/4
	GPT161_GTCR_TPCS_001 = 0x1
	// PCLK/16
	GPT161_GTCR_TPCS_010 = 0x2
	// PCLK/64
	GPT161_GTCR_TPCS_011 = 0x3
	// PCLK/256
	GPT161_GTCR_TPCS_100 = 0x4
	// PCLK/1024
	GPT161_GTCR_TPCS_101 = 0x5
	// Position of Reserved field.
	GPT161_GTCR_Reserved_Pos = 0x13
	// Bit mask of Reserved field.
	GPT161_GTCR_Reserved_Msk = 0xf80000
	// Position of MD field.
	GPT161_GTCR_MD_Pos = 0x10
	// Bit mask of MD field.
	GPT161_GTCR_MD_Msk = 0x70000
	// Saw-wave PWM mode (single buffer or double buffer possible)
	GPT161_GTCR_MD_000 = 0x0
	// Saw-wave one-shot pulse mode (fixed buffer operation)
	GPT161_GTCR_MD_001 = 0x1
	// Setting prohibited
	GPT161_GTCR_MD_010 = 0x2
	// Setting prohibited
	GPT161_GTCR_MD_011 = 0x3
	// Triangle-wave PWM mode 1 (16-bit transfer at crest) (single buffer or double buffer possible)
	GPT161_GTCR_MD_100 = 0x4
	// Triangle-wave PWM mode 2 (16-bit transfer at crest and trough) (single buffer or double buffer possible)
	GPT161_GTCR_MD_101 = 0x5
	// Triangle-wave PWM mode 3 (32-bit transfer at trough) fixed buffer operation)
	GPT161_GTCR_MD_110 = 0x6
	// Setting prohibited
	GPT161_GTCR_MD_111 = 0x7
	// Position of Reserved field.
	GPT161_GTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT161_GTCR_Reserved_Msk = 0xfffe
	// Position of CST field.
	GPT161_GTCR_CST_Pos = 0x0
	// Bit mask of CST field.
	GPT161_GTCR_CST_Msk = 0x1
	// Bit CST.
	GPT161_GTCR_CST = 0x1
	// Count operation is stopped
	GPT161_GTCR_CST_0 = 0x0
	// Count operation is performed
	GPT161_GTCR_CST_1 = 0x1

	// GTUDDTYC: General PWM Timer Count Direction and Duty Setting Register
	// Position of OBDTYR field.
	GPT161_GTUDDTYC_OBDTYR_Pos = 0x1b
	// Bit mask of OBDTYR field.
	GPT161_GTUDDTYC_OBDTYR_Msk = 0x8000000
	// Bit OBDTYR.
	GPT161_GTUDDTYC_OBDTYR = 0x8000000
	// Apply output value set in 0 percent/100 percent duty to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT161_GTUDDTYC_OBDTYR_0 = 0x0
	// Apply masked compare match output value to GTIOB[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT161_GTUDDTYC_OBDTYR_1 = 0x1
	// Position of OBDTYF field.
	GPT161_GTUDDTYC_OBDTYF_Pos = 0x1a
	// Bit mask of OBDTYF field.
	GPT161_GTUDDTYC_OBDTYF_Msk = 0x4000000
	// Bit OBDTYF.
	GPT161_GTUDDTYC_OBDTYF = 0x4000000
	// Not forcibly set
	GPT161_GTUDDTYC_OBDTYF_0 = 0x0
	// Forcibly set
	GPT161_GTUDDTYC_OBDTYF_1 = 0x1
	// Position of OBDTY field.
	GPT161_GTUDDTYC_OBDTY_Pos = 0x18
	// Bit mask of OBDTY field.
	GPT161_GTUDDTYC_OBDTY_Msk = 0x3000000
	// GTIOCB pin duty is depend on compare match
	GPT161_GTUDDTYC_OBDTY_00 = 0x0
	// GTIOCB pin duty is depend on compare match
	GPT161_GTUDDTYC_OBDTY_01 = 0x1
	// GTIOCB pin duty 0 percent
	GPT161_GTUDDTYC_OBDTY_10 = 0x2
	// GTIOCB pin duty 100 percent
	GPT161_GTUDDTYC_OBDTY_11 = 0x3
	// Position of Reserved field.
	GPT161_GTUDDTYC_Reserved_Pos = 0x14
	// Bit mask of Reserved field.
	GPT161_GTUDDTYC_Reserved_Msk = 0xf00000
	// Position of OADTYR field.
	GPT161_GTUDDTYC_OADTYR_Pos = 0x13
	// Bit mask of OADTYR field.
	GPT161_GTUDDTYC_OADTYR_Msk = 0x80000
	// Bit OADTYR.
	GPT161_GTUDDTYC_OADTYR = 0x80000
	// Apply output value set in 0 percent/100 percent duty to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT161_GTUDDTYC_OADTYR_0 = 0x0
	// Apply masked compare match output value to GTIOA[3:2] function after releasing 0 percent/100 percent duty setting.
	GPT161_GTUDDTYC_OADTYR_1 = 0x1
	// Position of OADTYF field.
	GPT161_GTUDDTYC_OADTYF_Pos = 0x12
	// Bit mask of OADTYF field.
	GPT161_GTUDDTYC_OADTYF_Msk = 0x40000
	// Bit OADTYF.
	GPT161_GTUDDTYC_OADTYF = 0x40000
	// Not forcibly set
	GPT161_GTUDDTYC_OADTYF_0 = 0x0
	// Forcibly set
	GPT161_GTUDDTYC_OADTYF_1 = 0x1
	// Position of OADTY field.
	GPT161_GTUDDTYC_OADTY_Pos = 0x10
	// Bit mask of OADTY field.
	GPT161_GTUDDTYC_OADTY_Msk = 0x30000
	// GTIOCA pin duty is depend on compare match
	GPT161_GTUDDTYC_OADTY_00 = 0x0
	// GTIOCA pin duty is depend on compare match
	GPT161_GTUDDTYC_OADTY_01 = 0x1
	// GTIOCA pin duty 0 percent
	GPT161_GTUDDTYC_OADTY_10 = 0x2
	// GTIOCA pin duty 100 percent
	GPT161_GTUDDTYC_OADTY_11 = 0x3
	// Position of UDF field.
	GPT161_GTUDDTYC_UDF_Pos = 0x1
	// Bit mask of UDF field.
	GPT161_GTUDDTYC_UDF_Msk = 0x2
	// Bit UDF.
	GPT161_GTUDDTYC_UDF = 0x2
	// Not forcibly set
	GPT161_GTUDDTYC_UDF_0 = 0x0
	// Forcibly set
	GPT161_GTUDDTYC_UDF_1 = 0x1
	// Position of UD field.
	GPT161_GTUDDTYC_UD_Pos = 0x0
	// Bit mask of UD field.
	GPT161_GTUDDTYC_UD_Msk = 0x1
	// Bit UD.
	GPT161_GTUDDTYC_UD = 0x1
	// GTCNT counts down.
	GPT161_GTUDDTYC_UD_0 = 0x0
	// GTCNT counts up.
	GPT161_GTUDDTYC_UD_1 = 0x1

	// GTIOR: General PWM Timer I/O Control Register
	// Position of NFCSB field.
	GPT161_GTIOR_NFCSB_Pos = 0x1e
	// Bit mask of NFCSB field.
	GPT161_GTIOR_NFCSB_Msk = 0xc0000000
	// PCLK/1
	GPT161_GTIOR_NFCSB_00 = 0x0
	// PCLK/4
	GPT161_GTIOR_NFCSB_01 = 0x1
	// PCLK/16
	GPT161_GTIOR_NFCSB_10 = 0x2
	// PCLK/64
	GPT161_GTIOR_NFCSB_11 = 0x3
	// Position of NFBEN field.
	GPT161_GTIOR_NFBEN_Pos = 0x1d
	// Bit mask of NFBEN field.
	GPT161_GTIOR_NFBEN_Msk = 0x20000000
	// Bit NFBEN.
	GPT161_GTIOR_NFBEN = 0x20000000
	// The noise filter for the GTIOCB pin is disabled.
	GPT161_GTIOR_NFBEN_0 = 0x0
	// The noise filter for the GTIOCB pin is enabled.
	GPT161_GTIOR_NFBEN_1 = 0x1
	// Position of Reserved field.
	GPT161_GTIOR_Reserved_Pos = 0x1b
	// Bit mask of Reserved field.
	GPT161_GTIOR_Reserved_Msk = 0x18000000
	// Position of OBDF field.
	GPT161_GTIOR_OBDF_Pos = 0x19
	// Bit mask of OBDF field.
	GPT161_GTIOR_OBDF_Msk = 0x6000000
	// Output disable is prohibited.
	GPT161_GTIOR_OBDF_00 = 0x0
	// GTIOCB pin is set to Hi-Z when output disable is performed.
	GPT161_GTIOR_OBDF_01 = 0x1
	// GTIOCB pin is set to 0 when output disable is performed.
	GPT161_GTIOR_OBDF_10 = 0x2
	// GTIOCB pin is set to 1 when output disable is performed.
	GPT161_GTIOR_OBDF_11 = 0x3
	// Position of OBE field.
	GPT161_GTIOR_OBE_Pos = 0x18
	// Bit mask of OBE field.
	GPT161_GTIOR_OBE_Msk = 0x1000000
	// Bit OBE.
	GPT161_GTIOR_OBE = 0x1000000
	// Output is disabled
	GPT161_GTIOR_OBE_0 = 0x0
	// Output is enabled
	GPT161_GTIOR_OBE_1 = 0x1
	// Position of OBHLD field.
	GPT161_GTIOR_OBHLD_Pos = 0x17
	// Bit mask of OBHLD field.
	GPT161_GTIOR_OBHLD_Msk = 0x800000
	// Bit OBHLD.
	GPT161_GTIOR_OBHLD = 0x800000
	// The GTIOCB pin output level at start/stop of counting depends on the register setting.
	GPT161_GTIOR_OBHLD_0 = 0x0
	// The GTIOCB pin output level is retained at start/stop of counting.
	GPT161_GTIOR_OBHLD_1 = 0x1
	// Position of OBDFLT field.
	GPT161_GTIOR_OBDFLT_Pos = 0x16
	// Bit mask of OBDFLT field.
	GPT161_GTIOR_OBDFLT_Msk = 0x400000
	// Bit OBDFLT.
	GPT161_GTIOR_OBDFLT = 0x400000
	// The GTIOCB pin outputs low when counting is stopped.
	GPT161_GTIOR_OBDFLT_0 = 0x0
	// The GTIOCB pin outputs high when counting is stopped.
	GPT161_GTIOR_OBDFLT_1 = 0x1
	// Position of Reserved field.
	GPT161_GTIOR_Reserved_Pos = 0x15
	// Bit mask of Reserved field.
	GPT161_GTIOR_Reserved_Msk = 0x200000
	// Bit Reserved.
	GPT161_GTIOR_Reserved = 0x200000
	// Position of GTIOB field.
	GPT161_GTIOR_GTIOB_Pos = 0x10
	// Bit mask of GTIOB field.
	GPT161_GTIOR_GTIOB_Msk = 0x1f0000
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRB compare match.
	GPT161_GTIOR_GTIOB_11111 = 0x1f
	// Position of NFCSA field.
	GPT161_GTIOR_NFCSA_Pos = 0xe
	// Bit mask of NFCSA field.
	GPT161_GTIOR_NFCSA_Msk = 0xc000
	// PCLK/1
	GPT161_GTIOR_NFCSA_00 = 0x0
	// PCLK/4
	GPT161_GTIOR_NFCSA_01 = 0x1
	// PCLK/16
	GPT161_GTIOR_NFCSA_10 = 0x2
	// PCLK/64
	GPT161_GTIOR_NFCSA_11 = 0x3
	// Position of NFAEN field.
	GPT161_GTIOR_NFAEN_Pos = 0xd
	// Bit mask of NFAEN field.
	GPT161_GTIOR_NFAEN_Msk = 0x2000
	// Bit NFAEN.
	GPT161_GTIOR_NFAEN = 0x2000
	// The noise filter for the GTIOCA pin is disabled.
	GPT161_GTIOR_NFAEN_0 = 0x0
	// The noise filter for the GTIOCA pin is enabled.
	GPT161_GTIOR_NFAEN_1 = 0x1
	// Position of Reserved field.
	GPT161_GTIOR_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	GPT161_GTIOR_Reserved_Msk = 0x1800
	// Position of OADF field.
	GPT161_GTIOR_OADF_Pos = 0x9
	// Bit mask of OADF field.
	GPT161_GTIOR_OADF_Msk = 0x600
	// Output disable is prohibited.
	GPT161_GTIOR_OADF_00 = 0x0
	// GTIOCA pin is set to Hi-Z when output disable is performed.
	GPT161_GTIOR_OADF_01 = 0x1
	// GTIOCA pin is set to 0 when output disable is performed.
	GPT161_GTIOR_OADF_10 = 0x2
	// GTIOCA pin is set to 1 when output disable is performed.
	GPT161_GTIOR_OADF_11 = 0x3
	// Position of OAE field.
	GPT161_GTIOR_OAE_Pos = 0x8
	// Bit mask of OAE field.
	GPT161_GTIOR_OAE_Msk = 0x100
	// Bit OAE.
	GPT161_GTIOR_OAE = 0x100
	// Output is disabled
	GPT161_GTIOR_OAE_0 = 0x0
	// Output is enabled
	GPT161_GTIOR_OAE_1 = 0x1
	// Position of OAHLD field.
	GPT161_GTIOR_OAHLD_Pos = 0x7
	// Bit mask of OAHLD field.
	GPT161_GTIOR_OAHLD_Msk = 0x80
	// Bit OAHLD.
	GPT161_GTIOR_OAHLD = 0x80
	// The GTIOCA pin output level at start/stop of counting depends on the register setting.
	GPT161_GTIOR_OAHLD_0 = 0x0
	// The GTIOCA pin output level is retained at start/stop of counting.
	GPT161_GTIOR_OAHLD_1 = 0x1
	// Position of OADFLT field.
	GPT161_GTIOR_OADFLT_Pos = 0x6
	// Bit mask of OADFLT field.
	GPT161_GTIOR_OADFLT_Msk = 0x40
	// Bit OADFLT.
	GPT161_GTIOR_OADFLT = 0x40
	// The GTIOCA pin outputs low when counting is stopped.
	GPT161_GTIOR_OADFLT_0 = 0x0
	// The GTIOCA pin outputs high when counting is stopped.
	GPT161_GTIOR_OADFLT_1 = 0x1
	// Position of Reserved field.
	GPT161_GTIOR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	GPT161_GTIOR_Reserved_Msk = 0x20
	// Bit Reserved.
	GPT161_GTIOR_Reserved = 0x20
	// Position of GTIOA field.
	GPT161_GTIOR_GTIOA_Pos = 0x0
	// Bit mask of GTIOA field.
	GPT161_GTIOR_GTIOA_Msk = 0x1f
	// Initial output is Low. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00000 = 0x0
	// Initial output is Low. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00001 = 0x1
	// Initial output is Low. Output retained at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00010 = 0x2
	// Initial output is Low. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00011 = 0x3
	// Initial output is Low. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00100 = 0x4
	// Initial output is Low. Low output at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00101 = 0x5
	// Initial output is Low. Low output at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00110 = 0x6
	// Initial output is Low. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_00111 = 0x7
	// Initial output is Low. High output at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01000 = 0x8
	// Initial output is Low. High output at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01001 = 0x9
	// Initial output is Low. High output at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01010 = 0xa
	// Initial output is Low. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01011 = 0xb
	// Initial output is Low. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01100 = 0xc
	// Initial output is Low. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01101 = 0xd
	// Initial output is Low. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01110 = 0xe
	// Initial output is Low. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_01111 = 0xf
	// Initial output is High. Output retained at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10000 = 0x10
	// Initial output is High. Output retained at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10001 = 0x11
	// Initial output is High. Output retained at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10010 = 0x12
	// Initial output is High. Output retained at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10011 = 0x13
	// Initial output is High. Low output at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10100 = 0x14
	// Initial output is High. Low output at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10101 = 0x15
	// Initial output is High. Low output at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10110 = 0x16
	// Initial output is High. Low output at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_10111 = 0x17
	// Initial output is High. High output at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11000 = 0x18
	// Initial output is High. High output at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11001 = 0x19
	// Initial output is High. High output at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11010 = 0x1a
	// Initial output is High. High output at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11011 = 0x1b
	// Initial output is High. Output toggled at cycle end. Output retained at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11100 = 0x1c
	// Initial output is High. Output toggled at cycle end. Low output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11101 = 0x1d
	// Initial output is High. Output toggled at cycle end. High output at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11110 = 0x1e
	// Initial output is High. Output toggled at cycle end. Output toggled at GTCCRA compare match.
	GPT161_GTIOR_GTIOA_11111 = 0x1f

	// GTINTAD: General PWM Timer Interrupt Output Setting Register
	// Position of GRPABL field.
	GPT161_GTINTAD_GRPABL_Pos = 0x1e
	// Bit mask of GRPABL field.
	GPT161_GTINTAD_GRPABL_Msk = 0x40000000
	// Bit GRPABL.
	GPT161_GTINTAD_GRPABL = 0x40000000
	// Same time output level low disable request is disabled.
	GPT161_GTINTAD_GRPABL_0 = 0x0
	// Same time output level low disable request is enabled.
	GPT161_GTINTAD_GRPABL_1 = 0x1
	// Position of GRPABH field.
	GPT161_GTINTAD_GRPABH_Pos = 0x1d
	// Bit mask of GRPABH field.
	GPT161_GTINTAD_GRPABH_Msk = 0x20000000
	// Bit GRPABH.
	GPT161_GTINTAD_GRPABH = 0x20000000
	// Same time output level high disable request is disabled.
	GPT161_GTINTAD_GRPABH_0 = 0x0
	// Same time output level high disable request is enabled.
	GPT161_GTINTAD_GRPABH_1 = 0x1
	// Position of Reserved field.
	GPT161_GTINTAD_Reserved_Pos = 0x1a
	// Bit mask of Reserved field.
	GPT161_GTINTAD_Reserved_Msk = 0x1c000000
	// Position of GRP field.
	GPT161_GTINTAD_GRP_Pos = 0x18
	// Bit mask of GRP field.
	GPT161_GTINTAD_GRP_Msk = 0x3000000
	// Group A output disable request
	GPT161_GTINTAD_GRP_00 = 0x0
	// Group B output disable request
	GPT161_GTINTAD_GRP_01 = 0x1
	// Position of Reserved field.
	GPT161_GTINTAD_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	GPT161_GTINTAD_Reserved_Msk = 0xffffff

	// GTST: General PWM Timer Status Register
	// Position of OABLF field.
	GPT161_GTST_OABLF_Pos = 0x1e
	// Bit mask of OABLF field.
	GPT161_GTST_OABLF_Msk = 0x40000000
	// Bit OABLF.
	GPT161_GTST_OABLF = 0x40000000
	// GTIOCA pin and GTIOCB pin don't output 0 at the same time.
	GPT161_GTST_OABLF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 0 at the same time.
	GPT161_GTST_OABLF_1 = 0x1
	// Position of OABHF field.
	GPT161_GTST_OABHF_Pos = 0x1d
	// Bit mask of OABHF field.
	GPT161_GTST_OABHF_Msk = 0x20000000
	// Bit OABHF.
	GPT161_GTST_OABHF = 0x20000000
	// GTIOCA pin and GTIOCB pin don't output 1 at the same time.
	GPT161_GTST_OABHF_0 = 0x0
	// GTIOCA pin and GTIOCB pin output 1 at the same time.
	GPT161_GTST_OABHF_1 = 0x1
	// Position of Reserved field.
	GPT161_GTST_Reserved_Pos = 0x19
	// Bit mask of Reserved field.
	GPT161_GTST_Reserved_Msk = 0x1e000000
	// Position of ODF field.
	GPT161_GTST_ODF_Pos = 0x18
	// Bit mask of ODF field.
	GPT161_GTST_ODF_Msk = 0x1000000
	// Bit ODF.
	GPT161_GTST_ODF = 0x1000000
	// No output disable request is generated.
	GPT161_GTST_ODF_0 = 0x0
	// An output disable request is generated.
	GPT161_GTST_ODF_1 = 0x1
	// Position of Reserved field.
	GPT161_GTST_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTST_Reserved_Msk = 0xff0000
	// Position of GTCF field.
	GPT161_GTST_GTCF_Pos = 0xf
	// Bit mask of GTCF field.
	GPT161_GTST_GTCF_Msk = 0x8000
	// Bit GTCF.
	GPT161_GTST_GTCF = 0x8000
	// The GTCNT counter counts downward.
	GPT161_GTST_GTCF_0 = 0x0
	// The GTCNT counter counts upward.
	GPT161_GTST_GTCF_1 = 0x1
	// Position of Reserved field.
	GPT161_GTST_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	GPT161_GTST_Reserved_Msk = 0x7f00
	// Position of TCFPU field.
	GPT161_GTST_TCFPU_Pos = 0x7
	// Bit mask of TCFPU field.
	GPT161_GTST_TCFPU_Msk = 0x80
	// Bit TCFPU.
	GPT161_GTST_TCFPU = 0x80
	// No underflow (trough) has occurred.
	GPT161_GTST_TCFPU_0 = 0x0
	// An underflow (trough) has occurred.
	GPT161_GTST_TCFPU_1 = 0x1
	// Position of TCPFO field.
	GPT161_GTST_TCPFO_Pos = 0x6
	// Bit mask of TCPFO field.
	GPT161_GTST_TCPFO_Msk = 0x40
	// Bit TCPFO.
	GPT161_GTST_TCPFO = 0x40
	// No overflow (crest) has occurred.
	GPT161_GTST_TCPFO_0 = 0x0
	// An overflow (crest) has occurred.
	GPT161_GTST_TCPFO_1 = 0x1
	// Position of TCFF field.
	GPT161_GTST_TCFF_Pos = 0x5
	// Bit mask of TCFF field.
	GPT161_GTST_TCFF_Msk = 0x20
	// Bit TCFF.
	GPT161_GTST_TCFF = 0x20
	// No compare match of GTCCRF is generated
	GPT161_GTST_TCFF_0 = 0x0
	// A compare match of GTCCRF is generated.
	GPT161_GTST_TCFF_1 = 0x1
	// Position of TCFE field.
	GPT161_GTST_TCFE_Pos = 0x4
	// Bit mask of TCFE field.
	GPT161_GTST_TCFE_Msk = 0x10
	// Bit TCFE.
	GPT161_GTST_TCFE = 0x10
	// No compare match of GTCCRE is generated
	GPT161_GTST_TCFE_0 = 0x0
	// A compare match of GTCCRE is generated.
	GPT161_GTST_TCFE_1 = 0x1
	// Position of TCFD field.
	GPT161_GTST_TCFD_Pos = 0x3
	// Bit mask of TCFD field.
	GPT161_GTST_TCFD_Msk = 0x8
	// Bit TCFD.
	GPT161_GTST_TCFD = 0x8
	// No compare match of GTCCRD is generated.
	GPT161_GTST_TCFD_0 = 0x0
	// A compare match of GTCCRD is generated.
	GPT161_GTST_TCFD_1 = 0x1
	// Position of TCFC field.
	GPT161_GTST_TCFC_Pos = 0x2
	// Bit mask of TCFC field.
	GPT161_GTST_TCFC_Msk = 0x4
	// Bit TCFC.
	GPT161_GTST_TCFC = 0x4
	// No compare match of GTCCRC is generated.
	GPT161_GTST_TCFC_0 = 0x0
	// A compare match of GTCCRC is generated.
	GPT161_GTST_TCFC_1 = 0x1
	// Position of TCFB field.
	GPT161_GTST_TCFB_Pos = 0x1
	// Bit mask of TCFB field.
	GPT161_GTST_TCFB_Msk = 0x2
	// Bit TCFB.
	GPT161_GTST_TCFB = 0x2
	// No input capture/compare match of GTCCRB is generated.
	GPT161_GTST_TCFB_0 = 0x0
	// An input capture/compare match of GTCCRB is generated.
	GPT161_GTST_TCFB_1 = 0x1
	// Position of TCFA field.
	GPT161_GTST_TCFA_Pos = 0x0
	// Bit mask of TCFA field.
	GPT161_GTST_TCFA_Msk = 0x1
	// Bit TCFA.
	GPT161_GTST_TCFA = 0x1
	// No input capture/compare match of GTCCRA is generated.
	GPT161_GTST_TCFA_0 = 0x0
	// An input capture/compare match of GTCCRA is generated.
	GPT161_GTST_TCFA_1 = 0x1

	// GTBER: General PWM Timer Buffer Enable Register
	// Position of CCRSWT field.
	GPT161_GTBER_CCRSWT_Pos = 0x16
	// Bit mask of CCRSWT field.
	GPT161_GTBER_CCRSWT_Msk = 0x400000
	// Bit CCRSWT.
	GPT161_GTBER_CCRSWT = 0x400000
	// no effect
	GPT161_GTBER_CCRSWT_0 = 0x0
	// Forcibly performs buffer transfer of GTCCRA and GTCCRB. This bit automatically returns to 0 after the writing of 1.
	GPT161_GTBER_CCRSWT_1 = 0x1
	// Position of PR field.
	GPT161_GTBER_PR_Pos = 0x14
	// Bit mask of PR field.
	GPT161_GTBER_PR_Msk = 0x300000
	// Buffer operation is not performed
	GPT161_GTBER_PR_00 = 0x0
	// Single buffer operation (GTPBR --> GTPR)
	GPT161_GTBER_PR_01 = 0x1
	// Position of CCRB field.
	GPT161_GTBER_CCRB_Pos = 0x12
	// Bit mask of CCRB field.
	GPT161_GTBER_CCRB_Msk = 0xc0000
	// Buffer operation is not performed
	GPT161_GTBER_CCRB_00 = 0x0
	// Single buffer operation (GTCCRB <--> GTCCRE)
	GPT161_GTBER_CCRB_01 = 0x1
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT161_GTBER_CCRB_10 = 0x2
	// Double buffer operation (GTCCRB <--> GTCCRE <--> GTCCRF)
	GPT161_GTBER_CCRB_11 = 0x3
	// Position of CCRA field.
	GPT161_GTBER_CCRA_Pos = 0x10
	// Bit mask of CCRA field.
	GPT161_GTBER_CCRA_Msk = 0x30000
	// Buffer operation is not performed
	GPT161_GTBER_CCRA_00 = 0x0
	// Single buffer operation (GTCCRA <--> GTCCRC)
	GPT161_GTBER_CCRA_01 = 0x1
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT161_GTBER_CCRA_10 = 0x2
	// Double buffer operation (GTCCRA <--> GTCCRC <--> GTCCRD)
	GPT161_GTBER_CCRA_11 = 0x3
	// Position of BD field.
	GPT161_GTBER_BD_Pos = 0x0
	// Bit mask of BD field.
	GPT161_GTBER_BD_Msk = 0x3
	// Buffer operation is enabled
	GPT161_GTBER_BD_0 = 0x0
	// Buffer operation is disabled
	GPT161_GTBER_BD_1 = 0x1

	// GTCNT: General PWM Timer Counter
	// Position of GTCNT field.
	GPT161_GTCNT_GTCNT_Pos = 0x0
	// Bit mask of GTCNT field.
	GPT161_GTCNT_GTCNT_Msk = 0xffffffff

	// GTCCRA: General PWM Timer Compare Capture Register A
	// Position of Reserved field.
	GPT161_GTCCRA_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRA_Reserved_Msk = 0xffff0000
	// Position of GTCCRA field.
	GPT161_GTCCRA_GTCCRA_Pos = 0x0
	// Bit mask of GTCCRA field.
	GPT161_GTCCRA_GTCCRA_Msk = 0xffff

	// GTCCRB: General PWM Timer Compare Capture Register B
	// Position of Reserved field.
	GPT161_GTCCRB_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRB_Reserved_Msk = 0xffff0000
	// Position of GTCCRB field.
	GPT161_GTCCRB_GTCCRB_Pos = 0x0
	// Bit mask of GTCCRB field.
	GPT161_GTCCRB_GTCCRB_Msk = 0xffff

	// GTCCRC: General PWM Timer Compare Capture Register C
	// Position of Reserved field.
	GPT161_GTCCRC_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRC_Reserved_Msk = 0xffff0000
	// Position of GTCCRC field.
	GPT161_GTCCRC_GTCCRC_Pos = 0x0
	// Bit mask of GTCCRC field.
	GPT161_GTCCRC_GTCCRC_Msk = 0xffff

	// GTCCRE: General PWM Timer Compare Capture Register E
	// Position of Reserved field.
	GPT161_GTCCRE_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRE_Reserved_Msk = 0xffff0000
	// Position of GTCCRE field.
	GPT161_GTCCRE_GTCCRE_Pos = 0x0
	// Bit mask of GTCCRE field.
	GPT161_GTCCRE_GTCCRE_Msk = 0xffff

	// GTCCRD: General PWM Timer Compare Capture Register D
	// Position of Reserved field.
	GPT161_GTCCRD_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRD_Reserved_Msk = 0xffff0000
	// Position of GTCCRD field.
	GPT161_GTCCRD_GTCCRD_Pos = 0x0
	// Bit mask of GTCCRD field.
	GPT161_GTCCRD_GTCCRD_Msk = 0xffff

	// GTCCRF: General PWM Timer Compare Capture Register F
	// Position of Reserved field.
	GPT161_GTCCRF_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTCCRF_Reserved_Msk = 0xffff0000
	// Position of GTCCRF field.
	GPT161_GTCCRF_GTCCRF_Pos = 0x0
	// Bit mask of GTCCRF field.
	GPT161_GTCCRF_GTCCRF_Msk = 0xffff

	// GTPR: General PWM Timer Cycle Setting Register
	// Position of Reserved field.
	GPT161_GTPR_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTPR_Reserved_Msk = 0xffff0000
	// Position of GTPR field.
	GPT161_GTPR_GTPR_Pos = 0x0
	// Bit mask of GTPR field.
	GPT161_GTPR_GTPR_Msk = 0xffff

	// GTPBR: General PWM Timer Cycle Setting Buffer Register
	// Position of Reserved field.
	GPT161_GTPBR_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTPBR_Reserved_Msk = 0xffff0000
	// Position of GTPBR field.
	GPT161_GTPBR_GTPBR_Pos = 0x0
	// Bit mask of GTPBR field.
	GPT161_GTPBR_GTPBR_Msk = 0xffff

	// GTDTCR: General PWM Timer Dead Time Control Register
	// Position of Reserved field.
	GPT161_GTDTCR_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	GPT161_GTDTCR_Reserved_Msk = 0xfffffffe
	// Position of TDE field.
	GPT161_GTDTCR_TDE_Pos = 0x0
	// Bit mask of TDE field.
	GPT161_GTDTCR_TDE_Msk = 0x1
	// Bit TDE.
	GPT161_GTDTCR_TDE = 0x1
	// GTCCRB is set without using GTDVU and GTDVD.
	GPT161_GTDTCR_TDE_0 = 0x0
	// GTDVU and GTDVD are used to set the compare match value for negative-phase waveform with dead time automatically in GTCCRB.
	GPT161_GTDTCR_TDE_1 = 0x1

	// GTDVU: General PWM Timer Dead Time Value Register U
	// Position of Reserved field.
	GPT161_GTDVU_Reserved_Pos = 0x10
	// Bit mask of Reserved field.
	GPT161_GTDVU_Reserved_Msk = 0xffff0000
	// Position of GTDVU field.
	GPT161_GTDVU_GTDVU_Pos = 0x0
	// Bit mask of GTDVU field.
	GPT161_GTDVU_GTDVU_Msk = 0xffff
)

// Constants for POEG: Port Output Enable Module for GPT
const (
	// POEGGA: POEG Group %s Setting Register
	// Position of NFCS field.
	POEG_POEGG_NFCS_Pos = 0x1e
	// Bit mask of NFCS field.
	POEG_POEGG_NFCS_Msk = 0xc0000000
	// Sampling GTETRG pin input level for three times in every PCLKB.
	POEG_POEGG_NFCS_00 = 0x0
	// Sampling GTETRG pin input level for three times in every PCLKB /8.
	POEG_POEGG_NFCS_01 = 0x1
	// Sampling GTETRG pin input level for three times in every PCLKB /32.
	POEG_POEGG_NFCS_10 = 0x2
	// Sampling GTETRG pin input level for three times in every PCLKB /128.
	POEG_POEGG_NFCS_11 = 0x3
	// Position of NFEN field.
	POEG_POEGG_NFEN_Pos = 0x1d
	// Bit mask of NFEN field.
	POEG_POEGG_NFEN_Msk = 0x20000000
	// Bit NFEN.
	POEG_POEGG_NFEN = 0x20000000
	// Filtering noise disabled
	POEG_POEGG_NFEN_0 = 0x0
	// Filtering noise enabled
	POEG_POEGG_NFEN_1 = 0x1
	// Position of INV field.
	POEG_POEGG_INV_Pos = 0x1c
	// Bit mask of INV field.
	POEG_POEGG_INV_Msk = 0x10000000
	// Bit INV.
	POEG_POEGG_INV = 0x10000000
	// GTETRG Input
	POEG_POEGG_INV_0 = 0x0
	// GTETRG Input Reversed.
	POEG_POEGG_INV_1 = 0x1
	// Position of Reserved field.
	POEG_POEGG_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	POEG_POEGG_Reserved_Msk = 0xffe0000
	// Position of ST field.
	POEG_POEGG_ST_Pos = 0x10
	// Bit mask of ST field.
	POEG_POEGG_ST_Msk = 0x10000
	// Bit ST.
	POEG_POEGG_ST = 0x10000
	// GTETRG input after filtering is 0.
	POEG_POEGG_ST_0 = 0x0
	// GTETRG input after filtering is 1.
	POEG_POEGG_ST_1 = 0x1
	// Position of Reserved field.
	POEG_POEGG_Reserved_Pos = 0xe
	// Bit mask of Reserved field.
	POEG_POEGG_Reserved_Msk = 0xc000
	// Position of CDRE5 field.
	POEG_POEGG_CDRE5_Pos = 0xd
	// Bit mask of CDRE5 field.
	POEG_POEGG_CDRE5_Msk = 0x2000
	// Bit CDRE5.
	POEG_POEGG_CDRE5 = 0x2000
	// Disable output-disable request from ACMPLP1.
	POEG_POEGG_CDRE5_0 = 0x0
	// Enable output-disable request from ACMPLP1.
	POEG_POEGG_CDRE5_1 = 0x1
	// Position of CDRE4 field.
	POEG_POEGG_CDRE4_Pos = 0xc
	// Bit mask of CDRE4 field.
	POEG_POEGG_CDRE4_Msk = 0x1000
	// Bit CDRE4.
	POEG_POEGG_CDRE4 = 0x1000
	// Disable output-disable request from ACMPLP0.
	POEG_POEGG_CDRE4_0 = 0x0
	// Enable output-disable request from ACMPLP0.
	POEG_POEGG_CDRE4_1 = 0x1
	// Position of Reserved field.
	POEG_POEGG_Reserved_Pos = 0x9
	// Bit mask of Reserved field.
	POEG_POEGG_Reserved_Msk = 0xe00
	// Position of CDRE0 field.
	POEG_POEGG_CDRE0_Pos = 0x8
	// Bit mask of CDRE0 field.
	POEG_POEGG_CDRE0_Msk = 0x100
	// Bit CDRE0.
	POEG_POEGG_CDRE0 = 0x100
	// Disable output-disable request from ACMPHS0.
	POEG_POEGG_CDRE0_0 = 0x0
	// Enable output-disable request from ACMPHS0.
	POEG_POEGG_CDRE0_1 = 0x1
	// Position of OSTPE field.
	POEG_POEGG_OSTPE_Pos = 0x6
	// Bit mask of OSTPE field.
	POEG_POEGG_OSTPE_Msk = 0x40
	// Bit OSTPE.
	POEG_POEGG_OSTPE = 0x40
	// A output-disable request from the oscillation stop detection disabled.
	POEG_POEGG_OSTPE_0 = 0x0
	// A output-disable request from the oscillation stop detection enabled.
	POEG_POEGG_OSTPE_1 = 0x1
	// Position of IOCE field.
	POEG_POEGG_IOCE_Pos = 0x5
	// Bit mask of IOCE field.
	POEG_POEGG_IOCE_Msk = 0x20
	// Bit IOCE.
	POEG_POEGG_IOCE = 0x20
	// A output-disable request from GPT disable request or comparator interrupt disabled.
	POEG_POEGG_IOCE_0 = 0x0
	// A output-disable request from GPT disable request or comparator interrupt enabled.
	POEG_POEGG_IOCE_1 = 0x1
	// Position of PIDE field.
	POEG_POEGG_PIDE_Pos = 0x4
	// Bit mask of PIDE field.
	POEG_POEGG_PIDE_Msk = 0x10
	// Bit PIDE.
	POEG_POEGG_PIDE = 0x10
	// A output-disable request from the GTETRG pins disabled.
	POEG_POEGG_PIDE_0 = 0x0
	// A output-disable request from the GTETRG pins enabled.
	POEG_POEGG_PIDE_1 = 0x1
	// Position of SSF field.
	POEG_POEGG_SSF_Pos = 0x3
	// Bit mask of SSF field.
	POEG_POEGG_SSF_Msk = 0x8
	// Bit SSF.
	POEG_POEGG_SSF = 0x8
	// A output-disable request from software has not been generated.
	POEG_POEGG_SSF_0 = 0x0
	// A output-disable request from software has been generated.
	POEG_POEGG_SSF_1 = 0x1
	// Position of OSTPF field.
	POEG_POEGG_OSTPF_Pos = 0x2
	// Bit mask of OSTPF field.
	POEG_POEGG_OSTPF_Msk = 0x4
	// Bit OSTPF.
	POEG_POEGG_OSTPF = 0x4
	// A output-disable request from the oscillation stop detection has not been generated.
	POEG_POEGG_OSTPF_0 = 0x0
	// A output-disable request from the oscillation stop detection has been generated.
	POEG_POEGG_OSTPF_1 = 0x1
	// Position of IOCF field.
	POEG_POEGG_IOCF_Pos = 0x1
	// Bit mask of IOCF field.
	POEG_POEGG_IOCF_Msk = 0x2
	// Bit IOCF.
	POEG_POEGG_IOCF = 0x2
	// No output-disable request from the GPT, the ACMPHS or the ACMPLP occurred.
	POEG_POEGG_IOCF_0 = 0x0
	// Output-disable request from the GPT, the ACMPHS or the ACMPLP occurred.
	POEG_POEGG_IOCF_1 = 0x1
	// Position of PIDF field.
	POEG_POEGG_PIDF_Pos = 0x0
	// Bit mask of PIDF field.
	POEG_POEGG_PIDF_Msk = 0x1
	// Bit PIDF.
	POEG_POEGG_PIDF = 0x1
	// A output-disable request from the GTETRG pin has not been generated.
	POEG_POEGG_PIDF_0 = 0x0
	// A output-disable request from the GTETRG pin has been generated.
	POEG_POEGG_PIDF_1 = 0x1
)

// Constants for RTC: Realtime Clock
const (
	// R64CNT: 64-Hz Counter
	// Position of F1HZ field.
	RTC_R64CNT_F1HZ_Pos = 0x6
	// Bit mask of F1HZ field.
	RTC_R64CNT_F1HZ_Msk = 0x40
	// Bit F1HZ.
	RTC_R64CNT_F1HZ = 0x40
	// Position of F2HZ field.
	RTC_R64CNT_F2HZ_Pos = 0x5
	// Bit mask of F2HZ field.
	RTC_R64CNT_F2HZ_Msk = 0x20
	// Bit F2HZ.
	RTC_R64CNT_F2HZ = 0x20
	// Position of F4HZ field.
	RTC_R64CNT_F4HZ_Pos = 0x4
	// Bit mask of F4HZ field.
	RTC_R64CNT_F4HZ_Msk = 0x10
	// Bit F4HZ.
	RTC_R64CNT_F4HZ = 0x10
	// Position of F8HZ field.
	RTC_R64CNT_F8HZ_Pos = 0x3
	// Bit mask of F8HZ field.
	RTC_R64CNT_F8HZ_Msk = 0x8
	// Bit F8HZ.
	RTC_R64CNT_F8HZ = 0x8
	// Position of F16HZ field.
	RTC_R64CNT_F16HZ_Pos = 0x2
	// Bit mask of F16HZ field.
	RTC_R64CNT_F16HZ_Msk = 0x4
	// Bit F16HZ.
	RTC_R64CNT_F16HZ = 0x4
	// Position of F32HZ field.
	RTC_R64CNT_F32HZ_Pos = 0x1
	// Bit mask of F32HZ field.
	RTC_R64CNT_F32HZ_Msk = 0x2
	// Bit F32HZ.
	RTC_R64CNT_F32HZ = 0x2
	// Position of F64HZ field.
	RTC_R64CNT_F64HZ_Pos = 0x0
	// Bit mask of F64HZ field.
	RTC_R64CNT_F64HZ_Msk = 0x1
	// Bit F64HZ.
	RTC_R64CNT_F64HZ = 0x1

	// RSECCNT: Second Counter
	// Position of SEC10 field.
	RTC_RSECCNT_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECCNT_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECCNT_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECCNT_SEC1_Msk = 0xf

	// BCNT0: Binary Counter 0
	// Position of BCNT0 field.
	RTC_BCNT0_BCNT0_Pos = 0x0
	// Bit mask of BCNT0 field.
	RTC_BCNT0_BCNT0_Msk = 0xff

	// RMINCNT: Minute Counter
	// Position of MIN10 field.
	RTC_RMINCNT_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINCNT_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINCNT_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINCNT_MIN1_Msk = 0xf

	// BCNT1: Binary Counter 1
	// Position of BCNT1 field.
	RTC_BCNT1_BCNT1_Pos = 0x0
	// Bit mask of BCNT1 field.
	RTC_BCNT1_BCNT1_Msk = 0xff

	// RHRCNT: Hour Counter
	// Position of PM field.
	RTC_RHRCNT_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRCNT_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRCNT_PM = 0x40
	// a.m.
	RTC_RHRCNT_PM_0 = 0x0
	// p.m.
	RTC_RHRCNT_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRCNT_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRCNT_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRCNT_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRCNT_HR1_Msk = 0xf

	// BCNT2: Binary Counter 2
	// Position of BCNT2 field.
	RTC_BCNT2_BCNT2_Pos = 0x0
	// Bit mask of BCNT2 field.
	RTC_BCNT2_BCNT2_Msk = 0xff

	// RWKCNT: Day-of-Week Counter
	// Position of DAYW field.
	RTC_RWKCNT_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKCNT_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKCNT_DAYW_000 = 0x0
	// Monday
	RTC_RWKCNT_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKCNT_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKCNT_DAYW_011 = 0x3
	// Thursday
	RTC_RWKCNT_DAYW_100 = 0x4
	// Friday
	RTC_RWKCNT_DAYW_101 = 0x5
	// Saturday
	RTC_RWKCNT_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKCNT_DAYW_111 = 0x7

	// BCNT3: Binary Counter 3
	// Position of BCNT3 field.
	RTC_BCNT3_BCNT3_Pos = 0x0
	// Bit mask of BCNT3 field.
	RTC_BCNT3_BCNT3_Msk = 0xff

	// RDAYCNT: Day Counter
	// Position of DATE10 field.
	RTC_RDAYCNT_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYCNT_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYCNT_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYCNT_DATE1_Msk = 0xf

	// RMONCNT: Month Counter
	// Position of Reserved field.
	RTC_RMONCNT_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	RTC_RMONCNT_Reserved_Msk = 0xe0
	// Position of MON10 field.
	RTC_RMONCNT_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONCNT_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONCNT_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONCNT_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONCNT_MON1_Msk = 0xf

	// RYRCNT: Year Counter
	// Position of Reserved field.
	RTC_RYRCNT_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_RYRCNT_Reserved_Msk = 0xff00
	// Position of YR10 field.
	RTC_RYRCNT_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRCNT_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRCNT_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRCNT_YR1_Msk = 0xf

	// RSECAR: Second Alarm Register
	// Position of ENB field.
	RTC_RSECAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RSECAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RSECAR_ENB = 0x80
	// The register value is not compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_0 = 0x0
	// The register value is compared with the RSECCNT counter value.
	RTC_RSECAR_ENB_1 = 0x1
	// Position of SEC10 field.
	RTC_RSECAR_SEC10_Pos = 0x4
	// Bit mask of SEC10 field.
	RTC_RSECAR_SEC10_Msk = 0x70
	// Position of SEC1 field.
	RTC_RSECAR_SEC1_Pos = 0x0
	// Bit mask of SEC1 field.
	RTC_RSECAR_SEC1_Msk = 0xf

	// BCNT0AR: Binary Counter 0 Alarm Register
	// Position of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Pos = 0x0
	// Bit mask of BCNT0AR field.
	RTC_BCNT0AR_BCNT0AR_Msk = 0xff

	// RMINAR: Minute Alarm Register
	// Position of ENB field.
	RTC_RMINAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMINAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMINAR_ENB = 0x80
	// The register value is not compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_0 = 0x0
	// The register value is compared with the RMINCNT counter value.
	RTC_RMINAR_ENB_1 = 0x1
	// Position of MIN10 field.
	RTC_RMINAR_MIN10_Pos = 0x4
	// Bit mask of MIN10 field.
	RTC_RMINAR_MIN10_Msk = 0x70
	// Position of MIN1 field.
	RTC_RMINAR_MIN1_Pos = 0x0
	// Bit mask of MIN1 field.
	RTC_RMINAR_MIN1_Msk = 0xf

	// BCNT1AR: Binary Counter 1 Alarm Register
	// Position of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Pos = 0x0
	// Bit mask of BCNT1AR field.
	RTC_BCNT1AR_BCNT1AR_Msk = 0xff

	// RHRAR: Hour Alarm Register
	// Position of ENB field.
	RTC_RHRAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RHRAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RHRAR_ENB = 0x80
	// The register value is not compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_0 = 0x0
	// The register value is compared with the RHRCNT counter value.
	RTC_RHRAR_ENB_1 = 0x1
	// Position of PM field.
	RTC_RHRAR_PM_Pos = 0x6
	// Bit mask of PM field.
	RTC_RHRAR_PM_Msk = 0x40
	// Bit PM.
	RTC_RHRAR_PM = 0x40
	// a.m.
	RTC_RHRAR_PM_0 = 0x0
	// p.m.
	RTC_RHRAR_PM_1 = 0x1
	// Position of HR10 field.
	RTC_RHRAR_HR10_Pos = 0x4
	// Bit mask of HR10 field.
	RTC_RHRAR_HR10_Msk = 0x30
	// Position of HR1 field.
	RTC_RHRAR_HR1_Pos = 0x0
	// Bit mask of HR1 field.
	RTC_RHRAR_HR1_Msk = 0xf

	// BCNT2AR: Binary Counter 2 Alarm Register
	// Position of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Pos = 0x0
	// Bit mask of BCNT2AR field.
	RTC_BCNT2AR_BCNT2AR_Msk = 0xff

	// RWKAR: Day-of-Week Alarm Register
	// Position of ENB field.
	RTC_RWKAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RWKAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RWKAR_ENB = 0x80
	// The register value is not compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_0 = 0x0
	// The register value is compared with the RWKCNT counter value.
	RTC_RWKAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RWKAR_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	RTC_RWKAR_Reserved_Msk = 0x78
	// Position of DAYW field.
	RTC_RWKAR_DAYW_Pos = 0x0
	// Bit mask of DAYW field.
	RTC_RWKAR_DAYW_Msk = 0x7
	// Sunday
	RTC_RWKAR_DAYW_000 = 0x0
	// Monday
	RTC_RWKAR_DAYW_001 = 0x1
	// Tuesday
	RTC_RWKAR_DAYW_010 = 0x2
	// Wednesday
	RTC_RWKAR_DAYW_011 = 0x3
	// Thursday
	RTC_RWKAR_DAYW_100 = 0x4
	// Friday
	RTC_RWKAR_DAYW_101 = 0x5
	// Saturday
	RTC_RWKAR_DAYW_110 = 0x6
	// Setting Prohibited
	RTC_RWKAR_DAYW_111 = 0x7

	// BCNT3AR: Binary Counter 3 Alarm Register
	// Position of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Pos = 0x0
	// Bit mask of BCNT3AR field.
	RTC_BCNT3AR_BCNT3AR_Msk = 0xff

	// RDAYAR: Date Alarm Register
	// Position of ENB field.
	RTC_RDAYAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RDAYAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RDAYAR_ENB = 0x80
	// The register value is not compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_0 = 0x0
	// The register value is compared with the RDAYCNT counter value.
	RTC_RDAYAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RDAYAR_Reserved_Pos = 0x6
	// Bit mask of Reserved field.
	RTC_RDAYAR_Reserved_Msk = 0x40
	// Bit Reserved.
	RTC_RDAYAR_Reserved = 0x40
	// Position of DATE10 field.
	RTC_RDAYAR_DATE10_Pos = 0x4
	// Bit mask of DATE10 field.
	RTC_RDAYAR_DATE10_Msk = 0x30
	// Position of DATE1 field.
	RTC_RDAYAR_DATE1_Pos = 0x0
	// Bit mask of DATE1 field.
	RTC_RDAYAR_DATE1_Msk = 0xf

	// BCNT0AER: Binary Counter 0 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT0AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT0AER_ENB_Msk = 0xff

	// RMONAR: Month Alarm Register
	// Position of ENB field.
	RTC_RMONAR_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RMONAR_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RMONAR_ENB = 0x80
	// The register value is not compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_0 = 0x0
	// The register value is compared with the RMONCNT counter value.
	RTC_RMONAR_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RMONAR_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	RTC_RMONAR_Reserved_Msk = 0x60
	// Position of MON10 field.
	RTC_RMONAR_MON10_Pos = 0x4
	// Bit mask of MON10 field.
	RTC_RMONAR_MON10_Msk = 0x10
	// Bit MON10.
	RTC_RMONAR_MON10 = 0x10
	// Position of MON1 field.
	RTC_RMONAR_MON1_Pos = 0x0
	// Bit mask of MON1 field.
	RTC_RMONAR_MON1_Msk = 0xf

	// BCNT1AER: Binary Counter 1 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT1AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT1AER_ENB_Msk = 0xff

	// RYRAR: Year Alarm Register
	// Position of Reserved field.
	RTC_RYRAR_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_RYRAR_Reserved_Msk = 0xff00
	// Position of YR10 field.
	RTC_RYRAR_YR10_Pos = 0x4
	// Bit mask of YR10 field.
	RTC_RYRAR_YR10_Msk = 0xf0
	// Position of YR1 field.
	RTC_RYRAR_YR1_Pos = 0x0
	// Bit mask of YR1 field.
	RTC_RYRAR_YR1_Msk = 0xf

	// BCNT2AER: Binary Counter 2 Alarm Enable Register
	// Position of Reserved field.
	RTC_BCNT2AER_Reserved_Pos = 0x8
	// Bit mask of Reserved field.
	RTC_BCNT2AER_Reserved_Msk = 0xff00
	// Position of ENB field.
	RTC_BCNT2AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT2AER_ENB_Msk = 0xff

	// RYRAREN: Year Alarm Enable Register
	// Position of ENB field.
	RTC_RYRAREN_ENB_Pos = 0x7
	// Bit mask of ENB field.
	RTC_RYRAREN_ENB_Msk = 0x80
	// Bit ENB.
	RTC_RYRAREN_ENB = 0x80
	// The register value is not compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_0 = 0x0
	// The register value is compared with the RYRCNT counter value.
	RTC_RYRAREN_ENB_1 = 0x1
	// Position of Reserved field.
	RTC_RYRAREN_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	RTC_RYRAREN_Reserved_Msk = 0x7f

	// BCNT3AER: Binary Counter 3 Alarm Enable Register
	// Position of ENB field.
	RTC_BCNT3AER_ENB_Pos = 0x0
	// Bit mask of ENB field.
	RTC_BCNT3AER_ENB_Msk = 0xff

	// RCR1: RTC Control Register 1
	// Position of PES field.
	RTC_RCR1_PES_Pos = 0x4
	// Bit mask of PES field.
	RTC_RCR1_PES_Msk = 0xf0
	// A periodic interrupt is generated every 1/256 second((RCR4.RCKSEL = 0)./A periodic interrupt is generated every 1/128 second((RCR4.RCKSEL = 1).
	RTC_RCR1_PES_0110 = 0x6
	// A periodic interrupt is generated every 1/128 second.
	RTC_RCR1_PES_0111 = 0x7
	// A periodic interrupt is generated every 1/64 second.
	RTC_RCR1_PES_1000 = 0x8
	// A periodic interrupt is generated every 1/32 second.
	RTC_RCR1_PES_1001 = 0x9
	// A periodic interrupt is generated every 1/16 second.
	RTC_RCR1_PES_1010 = 0xa
	// A periodic interrupt is generated every 1/8 second.
	RTC_RCR1_PES_1011 = 0xb
	// A periodic interrupt is generated every 1/4 second.
	RTC_RCR1_PES_1100 = 0xc
	// A periodic interrupt is generated every 1/2 second.
	RTC_RCR1_PES_1101 = 0xd
	// A periodic interrupt is generated every 1 second.
	RTC_RCR1_PES_1110 = 0xe
	// A periodic interrupt is generated every 2 seconds.
	RTC_RCR1_PES_1111 = 0xf
	// Position of RTCOS field.
	RTC_RCR1_RTCOS_Pos = 0x3
	// Bit mask of RTCOS field.
	RTC_RCR1_RTCOS_Msk = 0x8
	// Bit RTCOS.
	RTC_RCR1_RTCOS = 0x8
	// RTCOUT outputs 1 Hz.
	RTC_RCR1_RTCOS_0 = 0x0
	// RTCOUT outputs 64 Hz.
	RTC_RCR1_RTCOS_1 = 0x1
	// Position of PIE field.
	RTC_RCR1_PIE_Pos = 0x2
	// Bit mask of PIE field.
	RTC_RCR1_PIE_Msk = 0x4
	// Bit PIE.
	RTC_RCR1_PIE = 0x4
	// A periodic interrupt request is disabled.
	RTC_RCR1_PIE_0 = 0x0
	// A periodic interrupt request is enabled.
	RTC_RCR1_PIE_1 = 0x1
	// Position of CIE field.
	RTC_RCR1_CIE_Pos = 0x1
	// Bit mask of CIE field.
	RTC_RCR1_CIE_Msk = 0x2
	// Bit CIE.
	RTC_RCR1_CIE = 0x2
	// A carry interrupt request is disabled.
	RTC_RCR1_CIE_0 = 0x0
	// A carry interrupt request is enabled.
	RTC_RCR1_CIE_1 = 0x1
	// Position of AIE field.
	RTC_RCR1_AIE_Pos = 0x0
	// Bit mask of AIE field.
	RTC_RCR1_AIE_Msk = 0x1
	// Bit AIE.
	RTC_RCR1_AIE = 0x1
	// An alarm interrupt request is disabled.
	RTC_RCR1_AIE_0 = 0x0
	// An alarm interrupt request is enabled.
	RTC_RCR1_AIE_1 = 0x1

	// RCR2: RTC Control Register 2
	// Position of CNTMD field.
	RTC_RCR2_CNTMD_Pos = 0x7
	// Bit mask of CNTMD field.
	RTC_RCR2_CNTMD_Msk = 0x80
	// Bit CNTMD.
	RTC_RCR2_CNTMD = 0x80
	// The calendar count mode.
	RTC_RCR2_CNTMD_0 = 0x0
	// The binary count mode.
	RTC_RCR2_CNTMD_1 = 0x1
	// Position of HR24 field.
	RTC_RCR2_HR24_Pos = 0x6
	// Bit mask of HR24 field.
	RTC_RCR2_HR24_Msk = 0x40
	// Bit HR24.
	RTC_RCR2_HR24 = 0x40
	// The RTC operates in 12-hour mode.
	RTC_RCR2_HR24_0 = 0x0
	// The RTC operates in 24-hour mode.
	RTC_RCR2_HR24_1 = 0x1
	// Position of AADJP field.
	RTC_RCR2_AADJP_Pos = 0x5
	// Bit mask of AADJP field.
	RTC_RCR2_AADJP_Msk = 0x20
	// Bit AADJP.
	RTC_RCR2_AADJP = 0x20
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every minute.
	RTC_RCR2_AADJP_0 = 0x0
	// The RADJ.ADJ[5:0] setting value is adjusted from the count value of the prescaler every 10 seconds.
	RTC_RCR2_AADJP_1 = 0x1
	// Position of AADJE field.
	RTC_RCR2_AADJE_Pos = 0x4
	// Bit mask of AADJE field.
	RTC_RCR2_AADJE_Msk = 0x10
	// Bit AADJE.
	RTC_RCR2_AADJE = 0x10
	// Automatic adjustment is disabled.
	RTC_RCR2_AADJE_0 = 0x0
	// Automatic adjustment is enabled.
	RTC_RCR2_AADJE_1 = 0x1
	// Position of RTCOE field.
	RTC_RCR2_RTCOE_Pos = 0x3
	// Bit mask of RTCOE field.
	RTC_RCR2_RTCOE_Msk = 0x8
	// Bit RTCOE.
	RTC_RCR2_RTCOE = 0x8
	// RTCOUT output disabled.
	RTC_RCR2_RTCOE_0 = 0x0
	// RTCOUT output enabled.
	RTC_RCR2_RTCOE_1 = 0x1
	// Position of ADJ30 field.
	RTC_RCR2_ADJ30_Pos = 0x2
	// Bit mask of ADJ30 field.
	RTC_RCR2_ADJ30_Msk = 0x4
	// Bit ADJ30.
	RTC_RCR2_ADJ30 = 0x4
	// Writing is invalid.(write) / In normal time operation, or 30-second adjustment has completed.(read)
	RTC_RCR2_ADJ30_0 = 0x0
	// 30-second adjustment is executed.(write) / During 30-second adjustment.(read)
	RTC_RCR2_ADJ30_1 = 0x1
	// Position of RESET field.
	RTC_RCR2_RESET_Pos = 0x1
	// Bit mask of RESET field.
	RTC_RCR2_RESET_Msk = 0x2
	// Bit RESET.
	RTC_RCR2_RESET = 0x2
	// Writing is invalid.(write) / In normal time operation, or an RTC software reset has completed.(read)
	RTC_RCR2_RESET_0 = 0x0
	// The prescaler and the target registers for RTC software reset *1 are initialized.(write) / During an RTC software reset.(read)
	RTC_RCR2_RESET_1 = 0x1
	// Position of START field.
	RTC_RCR2_START_Pos = 0x0
	// Bit mask of START field.
	RTC_RCR2_START_Msk = 0x1
	// Bit START.
	RTC_RCR2_START = 0x1
	// Prescaler and time counter are stopped.
	RTC_RCR2_START_0 = 0x0
	// Prescaler and time counter operate normally.
	RTC_RCR2_START_1 = 0x1

	// RCR4: RTC Control Register 4
	// Position of Reserved field.
	RTC_RCR4_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	RTC_RCR4_Reserved_Msk = 0xfe
	// Position of RCKSEL field.
	RTC_RCR4_RCKSEL_Pos = 0x0
	// Bit mask of RCKSEL field.
	RTC_RCR4_RCKSEL_Msk = 0x1
	// Bit RCKSEL.
	RTC_RCR4_RCKSEL = 0x1
	// Sub-clock oscillator is selected.
	RTC_RCR4_RCKSEL_0 = 0x0
	// LOCO clock oscillator is selected.
	RTC_RCR4_RCKSEL_1 = 0x1

	// RFRH: Frequency Register H
	// Position of Reserved field.
	RTC_RFRH_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	RTC_RFRH_Reserved_Msk = 0xfffe
	// Position of RFC16 field.
	RTC_RFRH_RFC16_Pos = 0x0
	// Bit mask of RFC16 field.
	RTC_RFRH_RFC16_Msk = 0x1
	// Bit RFC16.
	RTC_RFRH_RFC16 = 0x1

	// RFRL: Frequency Register L
	// Position of RFC field.
	RTC_RFRL_RFC_Pos = 0x0
	// Bit mask of RFC field.
	RTC_RFRL_RFC_Msk = 0xffff

	// RADJ: Time Error Adjustment Register
	// Position of PMADJ field.
	RTC_RADJ_PMADJ_Pos = 0x6
	// Bit mask of PMADJ field.
	RTC_RADJ_PMADJ_Msk = 0xc0
	// Adjustment is not performed.
	RTC_RADJ_PMADJ_00 = 0x0
	// Adjustment is performed by the addition to the prescaler.
	RTC_RADJ_PMADJ_01 = 0x1
	// Adjustment is performed by the subtraction from the prescaler.
	RTC_RADJ_PMADJ_10 = 0x2
	// Setting prohibited
	RTC_RADJ_PMADJ_11 = 0x3
	// Position of ADJ field.
	RTC_RADJ_ADJ_Pos = 0x0
	// Bit mask of ADJ field.
	RTC_RADJ_ADJ_Msk = 0x3f
)

// Constants for FCACHE: Flash Cache
const (
	// FCACHEE: Flash Cache Enable Register
	// Position of Reserved field.
	FCACHE_FCACHEE_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	FCACHE_FCACHEE_Reserved_Msk = 0xfffe
	// Position of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Pos = 0x0
	// Bit mask of FCACHEEN field.
	FCACHE_FCACHEE_FCACHEEN_Msk = 0x1
	// Bit FCACHEEN.
	FCACHE_FCACHEE_FCACHEEN = 0x1
	// FCACHE is disabled
	FCACHE_FCACHEE_FCACHEEN_0 = 0x0
	// FCACHE is enabled
	FCACHE_FCACHEE_FCACHEEN_1 = 0x1

	// FCACHEIV: Flash Cache Invalidate Register
	// Position of Reserved field.
	FCACHE_FCACHEIV_Reserved_Pos = 0x1
	// Bit mask of Reserved field.
	FCACHE_FCACHEIV_Reserved_Msk = 0xfffe
	// Position of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Pos = 0x0
	// Bit mask of FCACHEIV field.
	FCACHE_FCACHEIV_FCACHEIV_Msk = 0x1
	// Bit FCACHEIV.
	FCACHE_FCACHEIV_FCACHEIV = 0x1
	// (Read)not in progress / (Write) no effect.
	FCACHE_FCACHEIV_FCACHEIV_0 = 0x0
	// (Read)in progress /(Write) Starting Cache Invalidation
	FCACHE_FCACHEIV_FCACHEIV_1 = 0x1
)

// Constants for PORT0: Port 0 Control Registers
const ()

// Constants for PORT1: Port 1 Control Registers
const ()

// Constants for PFS: Pmn Pin Function Control Register
const (
	// P000PFS: P000 Pin Function Control Register
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P000PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P000PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P000PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P000PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P000PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P000PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P000PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P000PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_ISEL_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x3800
	// Position of DSCR field.
	PFS_P000PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P000PFS_DSCR = 0x400
	// Low drive
	PFS_P000PFS_DSCR_0 = 0x0
	// High drive
	PFS_P000PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P000PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_PIDR = 0x2
	// Low input
	PFS_P000PFS_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_PODR = 0x1
	// Low output
	PFS_P000PFS_PODR_0 = 0x0
	// High output
	PFS_P000PFS_PODR_1 = 0x1

	// P000PFS_HA: P000 Pin Function Control Register
	// Position of ASEL field.
	PFS_P000PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P000PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P000PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P000PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P000PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P000PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P000PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P000PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P000PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P000PFS_HA_ISEL_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x3800
	// Position of DSCR field.
	PFS_P000PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P000PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P000PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P000PFS_HA_DSCR_0 = 0x0
	// High drive
	PFS_P000PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P000PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_HA_PIDR = 0x2
	// Low input
	PFS_P000PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_HA_PODR = 0x1
	// Low output
	PFS_P000PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P000PFS_HA_PODR_1 = 0x1

	// P000PFS_BY: P000 Pin Function Control Register
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P000PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P000PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P000PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P000PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P000PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P000PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P000PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P000PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P000PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P000PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P000PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P000PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P000PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P000PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P000PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P000PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P000PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P000PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P000PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P000PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P000PFS_BY_PIDR = 0x2
	// Low input
	PFS_P000PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P000PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P000PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P000PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P000PFS_BY_PODR = 0x1
	// Low output
	PFS_P000PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P000PFS_BY_PODR_1 = 0x1

	// P100PFS: P100 Pin Function Control Register
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P100PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P100PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P100PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P100PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P100PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P100PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P100PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P100PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P100PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P100PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P100PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P100PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P100PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P100PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P100PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P100PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P100PFS_ISEL_1 = 0x1
	// Position of EOFR field.
	PFS_P100PFS_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P100PFS_EOFR_Msk = 0x3000
	// Don't care
	PFS_P100PFS_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P100PFS_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P100PFS_EOFR_10 = 0x2
	// Detect both edge.
	PFS_P100PFS_EOFR_11 = 0x3
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P100PFS_Reserved = 0x800
	// Position of DSCR field.
	PFS_P100PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P100PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P100PFS_DSCR = 0x400
	// Low drive
	PFS_P100PFS_DSCR_0 = 0x0
	// High drive
	PFS_P100PFS_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P100PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P100PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P100PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P100PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P100PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P100PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_PIDR = 0x2
	// Low input
	PFS_P100PFS_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_PODR = 0x1
	// Low output
	PFS_P100PFS_PODR_0 = 0x0
	// High output
	PFS_P100PFS_PODR_1 = 0x1

	// P100PFS_HA: P100 Pin Function Control Register
	// Position of ASEL field.
	PFS_P100PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P100PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P100PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P100PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P100PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P100PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P100PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P100PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P100PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P100PFS_HA_ISEL_1 = 0x1
	// Position of EOFR field.
	PFS_P100PFS_HA_EOFR_Pos = 0xc
	// Bit mask of EOFR field.
	PFS_P100PFS_HA_EOFR_Msk = 0x3000
	// Don't care
	PFS_P100PFS_HA_EOFR_00 = 0x0
	// Detect rising edge
	PFS_P100PFS_HA_EOFR_01 = 0x1
	// Detect falling edge
	PFS_P100PFS_HA_EOFR_10 = 0x2
	// Detect both edge.
	PFS_P100PFS_HA_EOFR_11 = 0x3
	// Position of Reserved field.
	PFS_P100PFS_HA_Reserved_Pos = 0xb
	// Bit mask of Reserved field.
	PFS_P100PFS_HA_Reserved_Msk = 0x800
	// Bit Reserved.
	PFS_P100PFS_HA_Reserved = 0x800
	// Position of DSCR field.
	PFS_P100PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P100PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P100PFS_HA_DSCR = 0x400
	// Low drive
	PFS_P100PFS_HA_DSCR_0 = 0x0
	// High drive
	PFS_P100PFS_HA_DSCR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P100PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P100PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P100PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P100PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P100PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P100PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P100PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P100PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_HA_PIDR = 0x2
	// Low input
	PFS_P100PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_HA_PODR = 0x1
	// Low output
	PFS_P100PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P100PFS_HA_PODR_1 = 0x1

	// P100PFS_BY: P100 Pin Function Control Register
	// Position of Reserved field.
	PFS_P100PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P100PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P100PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P100PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P100PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P100PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P100PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P100PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P100PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P100PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P100PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P100PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P100PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P100PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P100PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P100PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P100PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P100PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P100PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P100PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P100PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P100PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P100PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P100PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P100PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P100PFS_BY_PIDR = 0x2
	// Low input
	PFS_P100PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P100PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P100PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P100PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P100PFS_BY_PODR = 0x1
	// Low output
	PFS_P100PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P100PFS_BY_PODR_1 = 0x1

	// P407PFS: P407 Pin Function Control Register
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0x1d
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0xe0000000
	// Position of PSEL field.
	PFS_P407PFS_PSEL_Pos = 0x18
	// Bit mask of PSEL field.
	PFS_P407PFS_PSEL_Msk = 0x1f000000
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0x11
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0xfe0000
	// Position of PMR field.
	PFS_P407PFS_PMR_Pos = 0x10
	// Bit mask of PMR field.
	PFS_P407PFS_PMR_Msk = 0x10000
	// Bit PMR.
	PFS_P407PFS_PMR = 0x10000
	// Uses the pin as a general I/O pin.
	PFS_P407PFS_PMR_0 = 0x0
	// Uses the pin as an I/O port for peripheral functions.
	PFS_P407PFS_PMR_1 = 0x1
	// Position of ASEL field.
	PFS_P407PFS_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P407PFS_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P407PFS_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P407PFS_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P407PFS_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P407PFS_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P407PFS_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P407PFS_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P407PFS_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P407PFS_ISEL_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0x3000
	// Position of DSCR1 field.
	PFS_P407PFS_DSCR1_Pos = 0xb
	// Bit mask of DSCR1 field.
	PFS_P407PFS_DSCR1_Msk = 0x800
	// Bit DSCR1.
	PFS_P407PFS_DSCR1 = 0x800
	// Low drive
	PFS_P407PFS_DSCR1_00 = 0x0
	// Middle drive
	PFS_P407PFS_DSCR1_01 = 0x1
	// Middle drive for IIC Fast-mode and SPI
	PFS_P407PFS_DSCR1_10 = 0x2
	// Setting prohibited.
	PFS_P407PFS_DSCR1_11 = 0x3
	// Position of DSCR field.
	PFS_P407PFS_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P407PFS_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P407PFS_DSCR = 0x400
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P407PFS_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P407PFS_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P407PFS_NCODR = 0x40
	// CMOS output
	PFS_P407PFS_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P407PFS_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P407PFS_Reserved = 0x20
	// Position of PCR field.
	PFS_P407PFS_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P407PFS_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P407PFS_PCR = 0x10
	// Disables an input pull-up.
	PFS_P407PFS_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P407PFS_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P407PFS_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P407PFS_Reserved = 0x8
	// Position of PDR field.
	PFS_P407PFS_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P407PFS_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P407PFS_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P407PFS_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P407PFS_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P407PFS_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P407PFS_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P407PFS_PIDR = 0x2
	// Low input
	PFS_P407PFS_PIDR_0 = 0x0
	// High input
	PFS_P407PFS_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P407PFS_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P407PFS_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P407PFS_PODR = 0x1
	// Low output
	PFS_P407PFS_PODR_0 = 0x0
	// High output
	PFS_P407PFS_PODR_1 = 0x1

	// P407PFS_HA: P407 Pin Function Control Register
	// Position of ASEL field.
	PFS_P407PFS_HA_ASEL_Pos = 0xf
	// Bit mask of ASEL field.
	PFS_P407PFS_HA_ASEL_Msk = 0x8000
	// Bit ASEL.
	PFS_P407PFS_HA_ASEL = 0x8000
	// Used other than as analog pin
	PFS_P407PFS_HA_ASEL_0 = 0x0
	// Used as analog pin
	PFS_P407PFS_HA_ASEL_1 = 0x1
	// Position of ISEL field.
	PFS_P407PFS_HA_ISEL_Pos = 0xe
	// Bit mask of ISEL field.
	PFS_P407PFS_HA_ISEL_Msk = 0x4000
	// Bit ISEL.
	PFS_P407PFS_HA_ISEL = 0x4000
	// Not used as IRQn input pin
	PFS_P407PFS_HA_ISEL_0 = 0x0
	// Used as IRQn input pin
	PFS_P407PFS_HA_ISEL_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_HA_Reserved_Pos = 0xc
	// Bit mask of Reserved field.
	PFS_P407PFS_HA_Reserved_Msk = 0x3000
	// Position of DSCR1 field.
	PFS_P407PFS_HA_DSCR1_Pos = 0xb
	// Bit mask of DSCR1 field.
	PFS_P407PFS_HA_DSCR1_Msk = 0x800
	// Bit DSCR1.
	PFS_P407PFS_HA_DSCR1 = 0x800
	// Low drive
	PFS_P407PFS_HA_DSCR1_00 = 0x0
	// Middle drive
	PFS_P407PFS_HA_DSCR1_01 = 0x1
	// Middle drive for IIC Fast-mode and SPI
	PFS_P407PFS_HA_DSCR1_10 = 0x2
	// Setting prohibited.
	PFS_P407PFS_HA_DSCR1_11 = 0x3
	// Position of DSCR field.
	PFS_P407PFS_HA_DSCR_Pos = 0xa
	// Bit mask of DSCR field.
	PFS_P407PFS_HA_DSCR_Msk = 0x400
	// Bit DSCR.
	PFS_P407PFS_HA_DSCR = 0x400
	// Position of Reserved field.
	PFS_P407PFS_HA_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P407PFS_HA_Reserved_Msk = 0x380
	// Position of NCODR field.
	PFS_P407PFS_HA_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P407PFS_HA_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P407PFS_HA_NCODR = 0x40
	// CMOS output
	PFS_P407PFS_HA_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P407PFS_HA_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_HA_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P407PFS_HA_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P407PFS_HA_Reserved = 0x20
	// Position of PCR field.
	PFS_P407PFS_HA_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P407PFS_HA_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P407PFS_HA_PCR = 0x10
	// Disables an input pull-up.
	PFS_P407PFS_HA_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P407PFS_HA_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_HA_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P407PFS_HA_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P407PFS_HA_Reserved = 0x8
	// Position of PDR field.
	PFS_P407PFS_HA_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P407PFS_HA_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P407PFS_HA_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P407PFS_HA_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P407PFS_HA_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P407PFS_HA_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P407PFS_HA_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P407PFS_HA_PIDR = 0x2
	// Low input
	PFS_P407PFS_HA_PIDR_0 = 0x0
	// High input
	PFS_P407PFS_HA_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P407PFS_HA_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P407PFS_HA_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P407PFS_HA_PODR = 0x1
	// Low output
	PFS_P407PFS_HA_PODR_0 = 0x0
	// High output
	PFS_P407PFS_HA_PODR_1 = 0x1

	// P407PFS_BY: P407 Pin Function Control Register
	// Position of Reserved field.
	PFS_P407PFS_BY_Reserved_Pos = 0x7
	// Bit mask of Reserved field.
	PFS_P407PFS_BY_Reserved_Msk = 0x80
	// Bit Reserved.
	PFS_P407PFS_BY_Reserved = 0x80
	// Position of NCODR field.
	PFS_P407PFS_BY_NCODR_Pos = 0x6
	// Bit mask of NCODR field.
	PFS_P407PFS_BY_NCODR_Msk = 0x40
	// Bit NCODR.
	PFS_P407PFS_BY_NCODR = 0x40
	// CMOS output
	PFS_P407PFS_BY_NCODR_0 = 0x0
	// NMOS open-drain output
	PFS_P407PFS_BY_NCODR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_BY_Reserved_Pos = 0x5
	// Bit mask of Reserved field.
	PFS_P407PFS_BY_Reserved_Msk = 0x20
	// Bit Reserved.
	PFS_P407PFS_BY_Reserved = 0x20
	// Position of PCR field.
	PFS_P407PFS_BY_PCR_Pos = 0x4
	// Bit mask of PCR field.
	PFS_P407PFS_BY_PCR_Msk = 0x10
	// Bit PCR.
	PFS_P407PFS_BY_PCR = 0x10
	// Disables an input pull-up.
	PFS_P407PFS_BY_PCR_0 = 0x0
	// Enables an input pull-up.
	PFS_P407PFS_BY_PCR_1 = 0x1
	// Position of Reserved field.
	PFS_P407PFS_BY_Reserved_Pos = 0x3
	// Bit mask of Reserved field.
	PFS_P407PFS_BY_Reserved_Msk = 0x8
	// Bit Reserved.
	PFS_P407PFS_BY_Reserved = 0x8
	// Position of PDR field.
	PFS_P407PFS_BY_PDR_Pos = 0x2
	// Bit mask of PDR field.
	PFS_P407PFS_BY_PDR_Msk = 0x4
	// Bit PDR.
	PFS_P407PFS_BY_PDR = 0x4
	// Input (Functions as an input pin.)
	PFS_P407PFS_BY_PDR_0 = 0x0
	// Output (Functions as an output pin.)
	PFS_P407PFS_BY_PDR_1 = 0x1
	// Position of PIDR field.
	PFS_P407PFS_BY_PIDR_Pos = 0x1
	// Bit mask of PIDR field.
	PFS_P407PFS_BY_PIDR_Msk = 0x2
	// Bit PIDR.
	PFS_P407PFS_BY_PIDR = 0x2
	// Low input
	PFS_P407PFS_BY_PIDR_0 = 0x0
	// High input
	PFS_P407PFS_BY_PIDR_1 = 0x1
	// Position of PODR field.
	PFS_P407PFS_BY_PODR_Pos = 0x0
	// Bit mask of PODR field.
	PFS_P407PFS_BY_PODR_Msk = 0x1
	// Bit PODR.
	PFS_P407PFS_BY_PODR = 0x1
	// Low output
	PFS_P407PFS_BY_PODR_0 = 0x0
	// High output
	PFS_P407PFS_BY_PODR_1 = 0x1
)

// Constants for PMISC: Miscellaneous Port Control Register
const (
	// PWPR: Write-Protect Register
	// Position of B0WI field.
	PMISC_PWPR_B0WI_Pos = 0x7
	// Bit mask of B0WI field.
	PMISC_PWPR_B0WI_Msk = 0x80
	// Bit B0WI.
	PMISC_PWPR_B0WI = 0x80
	// Writing to the PFSWE bit is enabled
	PMISC_PWPR_B0WI_0 = 0x0
	// Writing to the PFSWE bit is disabled
	PMISC_PWPR_B0WI_1 = 0x1
	// Position of PFSWE field.
	PMISC_PWPR_PFSWE_Pos = 0x6
	// Bit mask of PFSWE field.
	PMISC_PWPR_PFSWE_Msk = 0x40
	// Bit PFSWE.
	PMISC_PWPR_PFSWE = 0x40
	// Writing to the PFS register is disabled
	PMISC_PWPR_PFSWE_0 = 0x0
	// Writing to the PFS register is enabled
	PMISC_PWPR_PFSWE_1 = 0x1
	// Position of Reserved field.
	PMISC_PWPR_Reserved_Pos = 0x0
	// Bit mask of Reserved field.
	PMISC_PWPR_Reserved_Msk = 0x3f
)
